[
  {
    "_tag": "Constant",
    "module": {
      "name": "ChannelSchema.ts",
      "path": "src/ChannelSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "encodeUnknown",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const encodeUnknown: <A, I, R>(schema: Schema.Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel.Channel<Chunk.Chunk<unknown>, Chunk.Chunk<A>, IE | ParseError, IE, Done, Done, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChannelSchema.ts",
      "path": "src/ChannelSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "decodeUnknown",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const decodeUnknown: <A, I, R>(schema: Schema.Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<any>, ParseError | IE, IE, Done, Done, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChannelSchema.ts",
      "path": "src/ChannelSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "duplex",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const duplex: { <IA, II, IR, OA, OI, OR>(options: { readonly inputSchema: Schema.Schema<IA, II, IR>; readonly outputSchema: Schema.Schema<OA, OI, OR>; }): <R, InErr, OutErr, OutDone, InDone>(self: Channel.Channel<Chunk.Chunk<OI>, Chunk.Chunk<II>, OutErr, ParseError | InErr, OutDone, InDone, R>) => Channel.Channel<Chunk.Chunk<OA>, Chunk.Chunk<IA>, ParseError | OutErr, InErr, OutDone, InDone, R | IR | OR>; <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(self: Channel.Channel<Chunk.Chunk<OI>, Chunk.Chunk<II>, OutErr, ParseError | InErr, OutDone, InDone, R>, options: { readonly inputSchema: Schema.Schema<IA, II, IR>; readonly outputSchema: Schema.Schema<OA, OI, OR>; }): Channel.Channel<Chunk.Chunk<OA>, Chunk.Chunk<IA>, ParseError | OutErr, InErr, OutDone, InDone, R | IR | OR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChannelSchema.ts",
      "path": "src/ChannelSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "duplexUnknown",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const duplexUnknown: { <IA, II, IR, OA, OI, OR>(options: { readonly inputSchema: Schema.Schema<IA, II, IR>; readonly outputSchema: Schema.Schema<OA, OI, OR>; }): <R, InErr, OutErr, OutDone, InDone>(self: Channel.Channel<Chunk.Chunk<unknown>, Chunk.Chunk<any>, OutErr, ParseError | InErr, OutDone, InDone, R>) => Channel.Channel<Chunk.Chunk<OA>, Chunk.Chunk<IA>, ParseError | OutErr, InErr, OutDone, InDone, R | IR | OR>; <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(self: Channel.Channel<Chunk.Chunk<unknown>, Chunk.Chunk<any>, OutErr, ParseError | InErr, OutDone, InDone, R>, options: { readonly inputSchema: Schema.Schema<IA, II, IR>; readonly outputSchema: Schema.Schema<OA, OI, OR>; }): Channel.Channel<Chunk.Chunk<OA>, Chunk.Chunk<IA>, ParseError | OutErr, InErr, OutDone, InDone, R | IR | OR>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ChannelSchema.ts",
      "path": "src/ChannelSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "encode",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const encode: <A, I, R>(schema: Schema.Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel.Channel<Chunk.Chunk<I>, Chunk.Chunk<A>, IE | ParseError, IE, Done, Done, R>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ChannelSchema.ts",
      "path": "src/ChannelSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "decode",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const decode: <A, I, R>(schema: Schema.Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<I>, ParseError | IE, IE, Done, Done, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DevTools.ts",
      "path": "src/DevTools.ts"
    },
    "project": "@effect/experimental",
    "name": "layerSocket",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerSocket: Layer.Layer<never, never, Socket.Socket>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "DevTools.ts",
      "path": "src/DevTools.ts"
    },
    "project": "@effect/experimental",
    "name": "layerWebSocket",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerWebSocket: (url?: string) => Layer.Layer<never, never, Socket.WebSocketConstructor>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "DevTools.ts",
      "path": "src/DevTools.ts"
    },
    "project": "@effect/experimental",
    "name": "layer",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layer: (url?: string) => Layer.Layer<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Client.ts",
      "path": "src/DevTools/Client.ts"
    },
    "project": "@effect/experimental",
    "name": "Client",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "tags",
    "signature": "declare const Client: Context.Tag<Client, ClientImpl>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Client.ts",
      "path": "src/DevTools/Client.ts"
    },
    "project": "@effect/experimental",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: Effect.Effect<ClientImpl, never, Scope.Scope | Socket.Socket>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Client.ts",
      "path": "src/DevTools/Client.ts"
    },
    "project": "@effect/experimental",
    "name": "layer",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layer: Layer.Layer<Client, never, Socket.Socket>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Client.ts",
      "path": "src/DevTools/Client.ts"
    },
    "project": "@effect/experimental",
    "name": "makeTracer",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const makeTracer: Effect.Effect<Tracer.Tracer, never, Client>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Client.ts",
      "path": "src/DevTools/Client.ts"
    },
    "project": "@effect/experimental",
    "name": "layerTracer",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerTracer: Layer.Layer<never, never, Socket.Socket>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Client.ts",
      "path": "src/DevTools/Client.ts"
    },
    "project": "@effect/experimental",
    "name": "ClientImpl",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface ClientImpl {\n  readonly unsafeAddSpan: (_: Domain.Span | Domain.SpanEvent) => void\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Client.ts",
      "path": "src/DevTools/Client.ts"
    },
    "project": "@effect/experimental",
    "name": "Client",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Client {\n  readonly _: unique symbol\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "SpanStatusStarted",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const SpanStatusStarted: Schema.Struct<{ _tag: Schema.Literal<[\"Started\"]>; startTime: typeof Schema.BigInt; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "SpanStatusEnded",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const SpanStatusEnded: Schema.Struct<{ _tag: Schema.Literal<[\"Ended\"]>; startTime: typeof Schema.BigInt; endTime: typeof Schema.BigInt; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "SpanStatus",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const SpanStatus: Schema.Union<[Schema.Struct<{ _tag: Schema.Literal<[\"Started\"]>; startTime: typeof Schema.BigInt; }>, Schema.Struct<{ _tag: Schema.Literal<[\"Ended\"]>; startTime: typeof Schema.BigInt; endTime: typeof Schema.BigInt; }>]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "ExternalSpan",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const ExternalSpan: Schema.Struct<{ _tag: Schema.Literal<[\"ExternalSpan\"]>; spanId: typeof Schema.String; traceId: typeof Schema.String; sampled: typeof Schema.Boolean; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Span",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const Span: Schema.Schema<Span, SpanFrom, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "SpanEvent",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const SpanEvent: Schema.Schema<SpanEvent, { readonly _tag: \"SpanEvent\"; readonly spanId: string; readonly traceId: string; readonly name: string; readonly attributes: { readonly [x: string]: unknown; }; readonly startTime: string; }, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "ParentSpan",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const ParentSpan: Schema.Union<[Schema.Schema<Span, SpanFrom, never>, Schema.Struct<{ _tag: Schema.Literal<[\"ExternalSpan\"]>; spanId: typeof Schema.String; traceId: typeof Schema.String; sampled: typeof Schema.Boolean; }>]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Ping",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const Ping: Schema.Struct<{ _tag: Schema.Literal<[\"Ping\"]>; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Pong",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const Pong: Schema.Struct<{ _tag: Schema.Literal<[\"Pong\"]>; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "MetricsRequest",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const MetricsRequest: Schema.Struct<{ _tag: Schema.Literal<[\"MetricsRequest\"]>; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "MetricLabel",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const MetricLabel: Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Counter",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const Counter: Schema.Struct<{ _tag: Schema.Literal<[\"Counter\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly count: number | bigint; }, { readonly count: string | number; }, never>; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Frequency",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const Frequency: Schema.Struct<{ _tag: Schema.Literal<[\"Frequency\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly occurrences: { readonly [x: string]: number; }; }, { readonly occurrences: { readonly [x: string]: number; }; }, never>; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Gauge",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const Gauge: Schema.Struct<{ _tag: Schema.Literal<[\"Gauge\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly value: number | bigint; }, { readonly value: string | number; }, never>; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Histogram",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const Histogram: Schema.Struct<{ _tag: Schema.Literal<[\"Histogram\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly count: number; readonly buckets: ReadonlyArray<readonly [number, number]>; readonly min: number; readonly max: number; readonly sum: number; }, { readonly count: number; readonly buckets: ReadonlyArray<readonly [number | null, number]>; readonly min: number; readonly max: number; readonly sum: number; }, never>; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Summary",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const Summary: Schema.Struct<{ _tag: Schema.Literal<[\"Summary\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly error: number; readonly count: number; readonly min: number; readonly max: number; readonly sum: number; readonly quantiles: ReadonlyArray<readonly [number, Option<number>]>; }, { readonly error: number; readonly count: number; readonly min: number; readonly max: number; readonly sum: number; readonly quantiles: ReadonlyArray<readonly [number, { readonly _tag: \"None\"; } | { readonly value: number; readonly _tag: \"Some\"; }]>; }, never>; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Metric",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const Metric: Schema.Union<[Schema.Struct<{ _tag: Schema.Literal<[\"Counter\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly count: number | bigint; }, { readonly count: string | number; }, never>; }>, Schema.Struct<{ _tag: Schema.Literal<[\"Frequency\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly occurrences: { readonly [x: string]: number; }; }, { readonly occurrences: { readonly [x: string]: number; }; }, never>; }>, Schema.Struct<{ _tag: Schema.Literal<[\"Gauge\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly value: number | bigint; }, { readonly value: string | number; }, never>; }>, Schema.Struct<{ _tag: Schema.Literal<[\"Histogram\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly count: number; readonly buckets: ReadonlyArray<readonly [number, number]>; readonly min: number; readonly max: number; readonly sum: number; }, { readonly count: number; readonly buckets: ReadonlyArray<readonly [number | null, number]>; readonly min: number; readonly max: number; readonly sum: number; }, never>; }>, Schema.Struct<{ _tag: Schema.Literal<[\"Summary\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly error: number; readonly count: number; readonly min: number; readonly max: number; readonly sum: number; readonly quantiles: ReadonlyArray<readonly [number, Option<number>]>; }, { readonly error: number; readonly count: number; readonly min: number; readonly max: number; readonly sum: number; readonly quantiles: ReadonlyArray<readonly [number, { readonly _tag: \"None\"; } | { readonly value: number; readonly _tag: \"Some\"; }]>; }, never>; }>]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "MetricsSnapshot",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const MetricsSnapshot: Schema.Struct<{ _tag: Schema.Literal<[\"MetricsSnapshot\"]>; metrics: Schema.Array$<Schema.Union<[Schema.Struct<{ _tag: Schema.Literal<[\"Counter\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly count: number | bigint; }, { readonly count: string | number; }, never>; }>, Schema.Struct<{ _tag: Schema.Literal<[\"Frequency\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly occurrences: { readonly [x: string]: number; }; }, { readonly occurrences: { readonly [x: string]: number; }; }, never>; }>, Schema.Struct<{ _tag: Schema.Literal<[\"Gauge\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly value: number | bigint; }, { readonly value: string | number; }, never>; }>, Schema.Struct<{ _tag: Schema.Literal<[\"Histogram\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly count: number; readonly buckets: ReadonlyArray<readonly [number, number]>; readonly min: number; readonly max: number; readonly sum: number; }, { readonly count: number; readonly buckets: ReadonlyArray<readonly [number | null, number]>; readonly min: number; readonly max: number; readonly sum: number; }, never>; }>, Schema.Struct<{ _tag: Schema.Literal<[\"Summary\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly error: number; readonly count: number; readonly min: number; readonly max: number; readonly sum: number; readonly quantiles: ReadonlyArray<readonly [number, Option<number>]>; }, { readonly error: number; readonly count: number; readonly min: number; readonly max: number; readonly sum: number; readonly quantiles: ReadonlyArray<readonly [number, { readonly _tag: \"None\"; } | { readonly value: number; readonly _tag: \"Some\"; }]>; }, never>; }>]>>; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Request",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const Request: Schema.Union<[Schema.Struct<{ _tag: Schema.Literal<[\"Ping\"]>; }>, Schema.Schema<Span, SpanFrom, never>, Schema.Schema<SpanEvent, { readonly _tag: \"SpanEvent\"; readonly spanId: string; readonly traceId: string; readonly name: string; readonly attributes: { readonly [x: string]: unknown; }; readonly startTime: string; }, never>, Schema.Struct<{ _tag: Schema.Literal<[\"MetricsSnapshot\"]>; metrics: Schema.Array$<Schema.Union<[Schema.Struct<{ _tag: Schema.Literal<[\"Counter\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly count: number | bigint; }, { readonly count: string | number; }, never>; }>, Schema.Struct<{ _tag: Schema.Literal<[\"Frequency\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly occurrences: { readonly [x: string]: number; }; }, { readonly occurrences: { readonly [x: string]: number; }; }, never>; }>, Schema.Struct<{ _tag: Schema.Literal<[\"Gauge\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly value: number | bigint; }, { readonly value: string | number; }, never>; }>, Schema.Struct<{ _tag: Schema.Literal<[\"Histogram\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly count: number; readonly buckets: ReadonlyArray<readonly [number, number]>; readonly min: number; readonly max: number; readonly sum: number; }, { readonly count: number; readonly buckets: ReadonlyArray<readonly [number | null, number]>; readonly min: number; readonly max: number; readonly sum: number; }, never>; }>, Schema.Struct<{ _tag: Schema.Literal<[\"Summary\"]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<{ readonly error: number; readonly count: number; readonly min: number; readonly max: number; readonly sum: number; readonly quantiles: ReadonlyArray<readonly [number, Option<number>]>; }, { readonly error: number; readonly count: number; readonly min: number; readonly max: number; readonly sum: number; readonly quantiles: ReadonlyArray<readonly [number, { readonly _tag: \"None\"; } | { readonly value: number; readonly _tag: \"Some\"; }]>; }, never>; }>]>>; }>]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Response",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const Response: Schema.Union<[Schema.Struct<{ _tag: Schema.Literal<[\"Pong\"]>; }>, Schema.Struct<{ _tag: Schema.Literal<[\"MetricsRequest\"]>; }>]>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "metric",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const metric: <Tag extends string, S, IS, R>(tag: Tag, state: Schema.Schema<S, IS, R>) => Schema.Struct<{ _tag: Schema.Literal<[Tag]>; name: typeof Schema.String; description: Schema.optionalWith<typeof Schema.String, { as: \"Option\"; }>; tags: Schema.Array$<Schema.Struct<{ key: typeof Schema.String; value: typeof Schema.String; }>>; state: Schema.Schema<S, IS, R>; }>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "ExternalSpanFrom",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "export interface ExternalSpanFrom extends Schema.Schema.Encoded<typeof ExternalSpan> {}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "ExternalSpan",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "export interface ExternalSpan extends Schema.Schema.Type<typeof ExternalSpan> {}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "SpanFrom",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "export interface SpanFrom {\n  readonly _tag: \"Span\"\n  readonly spanId: string\n  readonly traceId: string\n  readonly name: string\n  readonly sampled: boolean\n  readonly attributes: ReadonlyArray<readonly [string, unknown]>\n  readonly parent: Schema.OptionEncoded<ParentSpanFrom>\n  readonly status: {\n    readonly _tag: \"Started\"\n    readonly startTime: string\n  } | {\n    readonly _tag: \"Ended\"\n    readonly startTime: string\n    readonly endTime: string\n  }\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Span",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "export interface Span {\n  readonly _tag: \"Span\"\n  readonly spanId: string\n  readonly traceId: string\n  readonly name: string\n  readonly sampled: boolean\n  readonly attributes: ReadonlyMap<string, unknown>\n  readonly parent: Option<ParentSpan>\n  readonly status: {\n    readonly _tag: \"Started\"\n    readonly startTime: bigint\n  } | {\n    readonly _tag: \"Ended\"\n    readonly startTime: bigint\n    readonly endTime: bigint\n  }\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "SpanEvent",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "export interface SpanEvent {\n  readonly _tag: \"SpanEvent\"\n  readonly spanId: string\n  readonly traceId: string\n  readonly name: string\n  readonly attributes: { readonly [x: string]: unknown }\n  readonly startTime: bigint\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "ParentSpanFrom",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "type ParentSpanFrom = SpanFrom | ExternalSpanFrom"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "ParentSpan",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "type ParentSpan = Span | ExternalSpan"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Metric",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "type Metric = Schema.Schema.Type<typeof Metric>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "MetricFrom",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "type MetricFrom = Schema.Schema.Encoded<typeof Metric>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "MetricsSnapshot",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "type MetricsSnapshot = Schema.Schema.Type<typeof MetricsSnapshot>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "MetricsSnapshotFrom",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "type MetricsSnapshotFrom = Schema.Schema.Encoded<typeof MetricsSnapshot>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Request",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "type Request = Schema.Schema.Type<typeof Request>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Response",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "type Response = Schema.Schema.Type<typeof Response>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Request.WithoutPing",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "type WithoutPing = Exclude<Request, { readonly _tag: \"Ping\" }>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Domain.ts",
      "path": "src/DevTools/Domain.ts"
    },
    "project": "@effect/experimental",
    "name": "Response.WithoutPong",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "type WithoutPong = Exclude<Response, { readonly _tag: \"Pong\" }>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Server.ts",
      "path": "src/DevTools/Server.ts"
    },
    "project": "@effect/experimental",
    "name": "run",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const run: <R, E, _>(handle: (client: Client) => Effect.Effect<_, E, R>) => Effect.Effect<never, SocketServer.SocketServerError, SocketServer.SocketServer | R>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Server.ts",
      "path": "src/DevTools/Server.ts"
    },
    "project": "@effect/experimental",
    "name": "Client",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Client {\n  readonly queue: Mailbox.ReadonlyMailbox<Domain.Request.WithoutPing>\n  readonly request: (_: Domain.Response.WithoutPong) => Effect.Effect<void>\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const TypeId: unique symbol"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "isEvent",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "guards",
    "signature": "declare const isEvent: (u: unknown) => u is Event<any, any, any, any>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: <Tag extends string, Payload extends Schema.Schema.Any = typeof Schema.Void, Success extends Schema.Schema.Any = typeof Schema.Void, Error extends Schema.Schema.All = typeof Schema.Never>(options: { readonly tag: Tag; readonly primaryKey: (payload: Schema.Schema.Type<Payload>) => string; readonly payload?: Payload; readonly success?: Success; readonly error?: Error; }) => Event<Tag, Payload, Success, Error>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event",
    "description": "Represents an event in an EventLog.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Event<\n  out Tag extends string,\n  in out Payload extends Schema.Schema.Any = typeof Schema.Void,\n  in out Success extends Schema.Schema.Any = typeof Schema.Void,\n  in out Error extends Schema.Schema.All = typeof Schema.Never\n> {\n  readonly [TypeId]: TypeId\n  readonly tag: Tag\n  readonly primaryKey: (payload: Schema.Schema.Type<Payload>) => string\n  readonly payload: Payload\n  readonly payloadMsgPack: MsgPack.schema<Payload>\n  readonly success: Success\n  readonly error: Error\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "EventHandler",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface EventHandler<in out Tag extends string> {\n  readonly _: unique symbol\n  readonly tag: Tag\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type TypeId = typeof TypeId"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.Any",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Any {\n    readonly [TypeId]: TypeId\n    readonly tag: string\n  }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.AnyWithProps",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface AnyWithProps extends Event<string, Schema.Schema.Any, Schema.Schema.Any, Schema.Schema.Any> {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.ToService",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type ToService<A> = A extends Event<\n    infer _Tag,\n    infer _Payload,\n    infer _Success,\n    infer _Error\n  > ? EventHandler<_Tag> :\n    never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.Tag",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Tag<A> = A extends Event<\n    infer _Tag,\n    infer _Payload,\n    infer _Success,\n    infer _Error\n  > ? _Tag :\n    never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.ErrorSchema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type ErrorSchema<A> = A extends Event<\n    infer _Tag,\n    infer _Payload,\n    infer _Success,\n    infer _Error\n  > ? _Error\n    : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.Error",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Error<A> = Schema.Schema.Type<ErrorSchema<A>>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.AddError",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type AddError<A, Error> = A extends Event<\n    infer _Tag,\n    infer _Payload,\n    infer _Success,\n    infer _Error\n  > ? Event<_Tag, _Payload, _Success, _Error | Error>\n    : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.PayloadSchema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type PayloadSchema<A> = A extends Event<\n    infer _Tag,\n    infer _Payload,\n    infer _Success,\n    infer _Error\n  > ? _Payload\n    : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.Payload",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Payload<A> = Schema.Schema.Type<PayloadSchema<A>>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.TaggedPayload",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type TaggedPayload<A> = A extends Event<\n    infer _Tag,\n    infer _Payload,\n    infer _Success,\n    infer _Error\n  > ? {\n      readonly _tag: _Tag\n      readonly payload: Schema.Schema.Type<_Payload>\n    }\n    : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.SuccessSchema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type SuccessSchema<A> = A extends Event<\n    infer _Tag,\n    infer _Payload,\n    infer _Success,\n    infer _Error\n  > ? _Success\n    : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.Success",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Success<A> = Schema.Schema.Type<SuccessSchema<A>>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.Context",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Context<A> = A extends Event<\n    infer _Name,\n    infer _Payload,\n    infer _Success,\n    infer _Error\n  > ? Schema.Schema.Context<_Payload> | Schema.Schema.Context<_Success> | Schema.Schema.Context<_Error>\n    : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.WithTag",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type WithTag<Events, Tag> = Extract<Events, { readonly tag: Tag }>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.ExcludeTag",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type ExcludeTag<Events, Tag> = Exclude<Events, { readonly tag: Tag }>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.PayloadWithTag",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type PayloadWithTag<Events, Tag> = Payload<WithTag<Events, Tag>>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.SuccessWithTag",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type SuccessWithTag<Events, Tag> = Success<WithTag<Events, Tag>>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.ErrorWithTag",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type ErrorWithTag<Events, Tag> = Error<WithTag<Events, Tag>>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Event.ts",
      "path": "src/Event.ts"
    },
    "project": "@effect/experimental",
    "name": "Event.ContextWithTag",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type ContextWithTag<Events, Tag> = Context<WithTag<Events, Tag>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventGroup.ts",
      "path": "src/EventGroup.ts"
    },
    "project": "@effect/experimental",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const TypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventGroup.ts",
      "path": "src/EventGroup.ts"
    },
    "project": "@effect/experimental",
    "name": "empty",
    "description": "An `EventGroup` is a collection of `Event`s. You can use an `EventGroup` to\nrepresent a portion of your domain.\n\nThe events can be implemented later using the `EventLog.group` api.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const empty: EventGroup<never>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventGroup.ts",
      "path": "src/EventGroup.ts"
    },
    "project": "@effect/experimental",
    "name": "isEventGroup",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "guards",
    "signature": "declare const isEventGroup: (u: unknown) => u is EventGroup.Any"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "EventGroup.ts",
      "path": "src/EventGroup.ts"
    },
    "project": "@effect/experimental",
    "name": "EventGroup",
    "description": "An `EventGroup` is a collection of `Event`s. You can use an `EventGroup` to\nrepresent a portion of your domain.\n\nThe events can be implemented later using the `EventLogBuilder.group` api.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface EventGroup<\n  out Events extends Event.Any = never\n> extends Pipeable {\n  new(_: never): {}\n\n  readonly [TypeId]: TypeId\n  readonly events: Record.ReadonlyRecord<string, Events>\n\n  /**\n   * Add an `Event` to the `EventGroup`.\n   */\n  add<\n    Tag extends string,\n    Payload extends Schema.Schema.Any = typeof Schema.Void,\n    Success extends Schema.Schema.Any = typeof Schema.Void,\n    Error extends Schema.Schema.All = typeof Schema.Never\n  >(options: {\n    readonly tag: Tag\n    readonly primaryKey: (payload: Schema.Schema.Type<Payload>) => string\n    readonly payload?: Payload\n    readonly success?: Success\n    readonly error?: Error\n  }): EventGroup<Events | Event<Tag, Payload, Success, Error>>\n\n  /**\n   * Add an error schema to all the events in the `EventGroup`.\n   */\n  addError<Error extends Schema.Schema.Any>(error: Error): EventGroup<Event.AddError<Events, Error>>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "EventGroup.ts",
      "path": "src/EventGroup.ts"
    },
    "project": "@effect/experimental",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type TypeId = typeof TypeId"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "EventGroup.ts",
      "path": "src/EventGroup.ts"
    },
    "project": "@effect/experimental",
    "name": "EventGroup.Any",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Any {\n    readonly [TypeId]: TypeId\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "EventGroup.ts",
      "path": "src/EventGroup.ts"
    },
    "project": "@effect/experimental",
    "name": "EventGroup.AnyWithProps",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type AnyWithProps = EventGroup<Event.AnyWithProps>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "EventGroup.ts",
      "path": "src/EventGroup.ts"
    },
    "project": "@effect/experimental",
    "name": "EventGroup.ToService",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type ToService<A> = A extends EventGroup<infer _Events> ? Event.ToService<_Events>\n    : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "EventGroup.ts",
      "path": "src/EventGroup.ts"
    },
    "project": "@effect/experimental",
    "name": "EventGroup.Events",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Events<Group> = Group extends EventGroup<infer _Events> ? _Events\n    : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "EventGroup.ts",
      "path": "src/EventGroup.ts"
    },
    "project": "@effect/experimental",
    "name": "EventGroup.Context",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Context<Group> = Event.Context<Events<Group>>"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "EventJournal",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "tags",
    "signature": "declare class EventJournal"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "EventJournalError",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "errors",
    "signature": "declare class EventJournalError"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "Entry",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "entry",
    "signature": "declare class Entry"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "RemoteEntry",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "entry",
    "signature": "declare class RemoteEntry"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "ErrorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "errors",
    "signature": "declare const ErrorTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "RemoteIdTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "remote",
    "signature": "declare const RemoteIdTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "RemoteId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "remote",
    "signature": "declare const RemoteId: Schema.brand<typeof Schema.Uint8ArrayFromSelf, unique symbol>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "EntryIdTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "entry",
    "signature": "declare const EntryIdTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "EntryId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "entry",
    "signature": "declare const EntryId: Schema.brand<typeof Schema.Uint8ArrayFromSelf, unique symbol>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "makeMemory",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "memory",
    "signature": "declare const makeMemory: Effect.Effect<{ readonly entries: Effect.Effect<ReadonlyArray<Entry>, EventJournalError>; readonly write: <A, E, R>(options: { readonly event: string; readonly primaryKey: string; readonly payload: Uint8Array; readonly effect: (entry: Entry) => Effect.Effect<A, E, R>; }) => Effect.Effect<A, EventJournalError | E, R>; readonly writeFromRemote: (options: { readonly remoteId: RemoteId; readonly entries: ReadonlyArray<RemoteEntry>; readonly compact?: ((uncommitted: ReadonlyArray<RemoteEntry>) => Effect.Effect<ReadonlyArray<[compacted: ReadonlyArray<Entry>, remoteEntries: ReadonlyArray<RemoteEntry>]>, EventJournalError>) | undefined; readonly effect: (options: { readonly entry: Entry; readonly conflicts: ReadonlyArray<Entry>; }) => Effect.Effect<void, EventJournalError>; }) => Effect.Effect<void, EventJournalError>; readonly withRemoteUncommited: <A, E, R>(remoteId: RemoteId, f: (entries: ReadonlyArray<Entry>) => Effect.Effect<A, E, R>) => Effect.Effect<A, EventJournalError | E, R>; readonly nextRemoteSequence: (remoteId: RemoteId) => Effect.Effect<number, EventJournalError>; readonly changes: Effect.Effect<Queue.Dequeue<Entry>, never, Scope>; readonly destroy: Effect.Effect<void, EventJournalError>; }, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "layerMemory",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "memory",
    "signature": "declare const layerMemory: Layer.Layer<EventJournal, never, never>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "makeRemoteId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "remote",
    "signature": "declare const makeRemoteId: () => RemoteId"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "makeEntryId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "entry",
    "signature": "declare const makeEntryId: (options?: { msecs?: number; }) => EntryId"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "entryIdMillis",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "entry",
    "signature": "declare const entryIdMillis: (entryId: EntryId) => number"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "makeIndexedDb",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "indexed db",
    "signature": "declare const makeIndexedDb: (options?: { readonly database?: string; }) => Effect.Effect<typeof EventJournal.Service, EventJournalError, Scope>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "layerIndexedDb",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "indexed db",
    "signature": "declare const layerIndexedDb: (options?: { readonly database?: string; }) => Layer.Layer<EventJournal, EventJournalError>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "ErrorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "errors",
    "signature": "type ErrorTypeId = typeof ErrorTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "RemoteId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "remote",
    "signature": "type RemoteId = typeof RemoteId.Type"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "EventJournal.ts",
      "path": "src/EventJournal.ts"
    },
    "project": "@effect/experimental",
    "name": "EntryId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "entry",
    "signature": "type EntryId = typeof EntryId.Type"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "Registry",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare class Registry"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "Identity",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "tags",
    "signature": "declare class Identity"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "EventLog",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "tags",
    "signature": "declare class EventLog"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "SchemaTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schema",
    "signature": "declare const SchemaTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "HandlersTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "handlers",
    "signature": "declare const HandlersTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "layerEventLog",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerEventLog: Layer.Layer<EventLog, never, Identity | EventJournal>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "isEventLogSchema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schema",
    "signature": "declare const isEventLogSchema: (u: unknown) => u is EventLogSchema<any>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "schema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schema",
    "signature": "declare const schema: <Groups extends ReadonlyArray<EventGroup.Any>>(...groups: Groups) => EventLogSchema<Groups[number]>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "group",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "handlers",
    "signature": "declare const group: <Events extends Event.Any, Return>(group: EventGroup<Events>, f: (handlers: Handlers<never, Events>) => Handlers.ValidateReturn<Return>) => Layer.Layer<Event.ToService<Events>, Handlers.Error<Return>, Exclude<Handlers.Context<Return>, Scope>>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "groupCompaction",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "compaction",
    "signature": "declare const groupCompaction: <Events extends Event.Any, R>(group: EventGroup<Events>, effect: (options: { readonly primaryKey: string; readonly entries: Array<Entry>; readonly events: Array<Event.TaggedPayload<Events>>; readonly write: <Tag extends Event.Tag<Events>>(tag: Tag, payload: Event.PayloadWithTag<Events, Tag>) => Effect.Effect<void>; }) => Effect.Effect<void, never, R>) => Layer.Layer<never, never, EventLog | R | Event.Context<Events>>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "groupReactivity",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "reactivity",
    "signature": "declare const groupReactivity: <Events extends Event.Any>(group: EventGroup<Events>, keys: { readonly [Tag in Event.Tag<Events>]?: ReadonlyArray<string>; } | ReadonlyArray<string>) => Layer.Layer<never, never, EventLog>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "layer",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layer: <Groups extends EventGroup.Any>(_schema: EventLogSchema<Groups>) => Layer.Layer<EventLog, never, EventGroup.ToService<Groups> | EventJournal | Identity>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "makeClient",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "client",
    "signature": "declare const makeClient: <Groups extends EventGroup.Any>(schema: EventLogSchema<Groups>) => Effect.Effect<(<Tag extends Event.Tag<EventGroup.Events<Groups>>>(event: Tag, payload: Event.PayloadWithTag<EventGroup.Events<Groups>, Tag>) => Effect.Effect<Event.SuccessWithTag<EventGroup.Events<Groups>, Tag>, Event.ErrorWithTag<EventGroup.Events<Groups>, Tag> | EventJournalError>), never, EventLog>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "EventLogSchema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schema",
    "signature": "export interface EventLogSchema<Groups extends EventGroup.Any> {\n  new(_: never): {}\n  readonly [SchemaTypeId]: SchemaTypeId\n  readonly groups: ReadonlyArray<Groups>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "Handlers",
    "description": "Represents a handled `EventGroup`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "handlers",
    "signature": "export interface Handlers<\n  R,\n  Events extends Event.Any = never\n> extends Pipeable {\n  readonly [HandlersTypeId]: {\n    _Endpoints: Covariant<Events>\n  }\n  readonly group: EventGroup.AnyWithProps\n  readonly handlers: Record.ReadonlyRecord<string, Handlers.Item<R>>\n  readonly context: Context.Context<any>\n\n  /**\n   * Add the implementation for an `Event` to a `Handlers` group.\n   */\n  handle<Tag extends Events[\"tag\"], R1>(\n    name: Tag,\n    handler: (\n      options: {\n        readonly payload: Event.PayloadWithTag<Events, Tag>\n        readonly entry: Entry\n        readonly conflicts: Array<{\n          readonly entry: Entry\n          readonly payload: Event.PayloadWithTag<Events, Tag>\n        }>\n      }\n    ) => Effect.Effect<Event.SuccessWithTag<Events, Tag>, Event.ErrorWithTag<Events, Tag>, R1>\n  ): Handlers<\n    R | R1,\n    Event.ExcludeTag<Events, Tag>\n  >\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "SchemaTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schema",
    "signature": "type SchemaTypeId = typeof SchemaTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "HandlersTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "handlers",
    "signature": "type HandlersTypeId = typeof HandlersTypeId"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "Handlers.Any",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "handlers",
    "signature": "export interface Any {\n    readonly [HandlersTypeId]: any\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "Handlers.Item",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "handlers",
    "signature": "type Item<R> = {\n    readonly event: Event.AnyWithProps\n    readonly context: Context.Context<any>\n    readonly handler: (options: {\n      readonly payload: any\n      readonly entry: Entry\n      readonly conflicts: Array<{\n        readonly entry: Entry\n        readonly payload: any\n      }>\n    }) => Effect.Effect<any, R>\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "Handlers.ValidateReturn",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "handlers",
    "signature": "type ValidateReturn<A> = A extends (\n    | Handlers<\n      infer _R,\n      infer _Events\n    >\n    | Effect.Effect<\n      Handlers<\n        infer _R,\n        infer _Events\n      >,\n      infer _EX,\n      infer _RX\n    >\n  ) ? [_Events] extends [never] ? A\n    : `Event not handled: ${Event.Tag<_Events>}` :\n    `Must return the implemented handlers`"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "Handlers.Error",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "handlers",
    "signature": "type Error<A> = A extends Effect.Effect<\n    Handlers<\n      infer _R,\n      infer _Events\n    >,\n    infer _EX,\n    infer _RX\n  > ? _EX :\n    never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "EventLog.ts",
      "path": "src/EventLog.ts"
    },
    "project": "@effect/experimental",
    "name": "Handlers.Context",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "handlers",
    "signature": "type Context<A> = A extends Handlers<\n    infer _R,\n    infer _Events\n  > ? _R | Event.Context<_Events> :\n    A extends Effect.Effect<\n      Handlers<\n        infer _R,\n        infer _Events\n      >,\n      infer _EX,\n      infer _RX\n    > ? _R | _RX | Event.Context<_Events> :\n    never"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLogEncryption.ts",
      "path": "src/EventLogEncryption.ts"
    },
    "project": "@effect/experimental",
    "name": "EventLogEncryption",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "encrytion",
    "signature": "declare class EventLogEncryption"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogEncryption.ts",
      "path": "src/EventLogEncryption.ts"
    },
    "project": "@effect/experimental",
    "name": "EncryptedEntry",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare const EncryptedEntry: Schema.Struct<{ entryId: Schema.brand<typeof Schema.Uint8ArrayFromSelf, unique symbol>; encryptedEntry: typeof Schema.Uint8ArrayFromSelf; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogEncryption.ts",
      "path": "src/EventLogEncryption.ts"
    },
    "project": "@effect/experimental",
    "name": "EncryptedRemoteEntry",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare const EncryptedRemoteEntry: Schema.Struct<{ sequence: typeof Schema.Number; iv: typeof Schema.Uint8ArrayFromSelf; entryId: Schema.brand<typeof Schema.Uint8ArrayFromSelf, unique symbol>; encryptedEntry: typeof Schema.Uint8ArrayFromSelf; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogEncryption.ts",
      "path": "src/EventLogEncryption.ts"
    },
    "project": "@effect/experimental",
    "name": "layerSubtle",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "encrytion",
    "signature": "declare const layerSubtle: Layer.Layer<EventLogEncryption, never, never>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventLogEncryption.ts",
      "path": "src/EventLogEncryption.ts"
    },
    "project": "@effect/experimental",
    "name": "makeEncryptionSubtle",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "encrytion",
    "signature": "declare const makeEncryptionSubtle: (crypto: Crypto) => Effect.Effect<typeof EventLogEncryption.Service>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "EventLogEncryption.ts",
      "path": "src/EventLogEncryption.ts"
    },
    "project": "@effect/experimental",
    "name": "EncryptedRemoteEntry",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface EncryptedRemoteEntry extends Schema.Schema.Type<typeof EncryptedRemoteEntry> {}"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "Hello",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare class Hello"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "ChunkedMessage",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare class ChunkedMessage"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "WriteEntries",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare class WriteEntries"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "Ack",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare class Ack"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "RequestChanges",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare class RequestChanges"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "Changes",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare class Changes"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "StopChanges",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare class StopChanges"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "Ping",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare class Ping"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "Pong",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare class Pong"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "RemoteAdditions",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "change",
    "signature": "declare class RemoteAdditions"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "ProtocolRequest",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare const ProtocolRequest: Schema.Union<[typeof WriteEntries, typeof RequestChanges, typeof StopChanges, typeof ChunkedMessage, typeof Ping]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "ProtocolRequestMsgPack",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare const ProtocolRequestMsgPack: MsgPack.schema<Schema.Union<[typeof WriteEntries, typeof RequestChanges, typeof StopChanges, typeof ChunkedMessage, typeof Ping]>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "decodeRequest",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare const decodeRequest: (i: Uint8Array<ArrayBufferLike>, overrideOptions?: ParseOptions) => ChunkedMessage | WriteEntries | RequestChanges | StopChanges | Ping"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "encodeRequest",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare const encodeRequest: (a: ChunkedMessage | WriteEntries | RequestChanges | StopChanges | Ping, overrideOptions?: ParseOptions) => Uint8Array<ArrayBufferLike>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "ProtocolResponse",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare const ProtocolResponse: Schema.Union<[typeof Hello, typeof Ack, typeof Changes, typeof ChunkedMessage, typeof Pong]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "ProtocolResponseMsgPack",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare const ProtocolResponseMsgPack: MsgPack.schema<Schema.Union<[typeof Hello, typeof Ack, typeof Changes, typeof ChunkedMessage, typeof Pong]>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "decodeResponse",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare const decodeResponse: (i: Uint8Array<ArrayBufferLike>, overrideOptions?: ParseOptions) => ChunkedMessage | Hello | Ack | Changes | Pong"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "encodeResponse",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "protocol",
    "signature": "declare const encodeResponse: (a: ChunkedMessage | Hello | Ack | Changes | Pong, overrideOptions?: ParseOptions) => Uint8Array<ArrayBufferLike>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "fromSocket",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "construtors",
    "signature": "declare const fromSocket: (options?: { readonly disablePing?: boolean; }) => Effect.Effect<void, never, Scope.Scope | EventLog | EventLogEncryption | Socket.Socket>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "fromWebSocket",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "construtors",
    "signature": "declare const fromWebSocket: (url: string, options?: { readonly disablePing?: boolean; }) => Effect.Effect<void, never, Scope.Scope | EventLogEncryption | EventLog | Socket.WebSocketConstructor>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "layerWebSocket",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerWebSocket: (url: string, options?: { readonly disablePing?: boolean; }) => Layer.Layer<never, never, Socket.WebSocketConstructor | EventLog | EventLogEncryption>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "layerWebSocketBrowser",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerWebSocketBrowser: (url: string, options?: { readonly disablePing?: boolean; }) => Layer.Layer<never, never, EventLog>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "EventLogRemote.ts",
      "path": "src/EventLogRemote.ts"
    },
    "project": "@effect/experimental",
    "name": "EventLogRemote",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface EventLogRemote {\n  readonly id: RemoteId\n  readonly changes: (\n    identity: typeof Identity.Service,\n    startSequence: number\n  ) => Effect.Effect<Mailbox.ReadonlyMailbox<RemoteEntry>, never, Scope.Scope>\n  readonly write: (identity: typeof Identity.Service, entries: ReadonlyArray<Entry>) => Effect.Effect<void>\n}"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Node.ts",
      "path": "src/EventLogRemote/Node.ts"
    },
    "project": "@effect/experimental",
    "name": "layerWebSocket",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerWebSocket: (url: string) => Layer.Layer<never, never, EventLog>"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLogServer.ts",
      "path": "src/EventLogServer.ts"
    },
    "project": "@effect/experimental",
    "name": "PersistedEntry",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "storage",
    "signature": "declare class PersistedEntry"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "EventLogServer.ts",
      "path": "src/EventLogServer.ts"
    },
    "project": "@effect/experimental",
    "name": "Storage",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "storage",
    "signature": "declare class Storage"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogServer.ts",
      "path": "src/EventLogServer.ts"
    },
    "project": "@effect/experimental",
    "name": "makeHandler",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const makeHandler: Effect.Effect<(socket: Socket.Socket) => Effect.Effect<void, Socket.SocketError, Scope.Scope>, never, Storage>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogServer.ts",
      "path": "src/EventLogServer.ts"
    },
    "project": "@effect/experimental",
    "name": "makeHandlerHttp",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "websockets",
    "signature": "declare const makeHandlerHttp: Effect.Effect<Effect.Effect<HttpServerResponse.HttpServerResponse, Socket.SocketError | HttpServerError.RequestError, Scope.Scope | HttpServerRequest.HttpServerRequest>, never, Storage>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogServer.ts",
      "path": "src/EventLogServer.ts"
    },
    "project": "@effect/experimental",
    "name": "makeStorageMemory",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "storage",
    "signature": "declare const makeStorageMemory: Effect.Effect<{ readonly getId: Effect.Effect<RemoteId>; readonly write: (publicKey: string, entries: ReadonlyArray<PersistedEntry>) => Effect.Effect<ReadonlyArray<EncryptedRemoteEntry>>; readonly entries: (publicKey: string, startSequence: number) => Effect.Effect<ReadonlyArray<EncryptedRemoteEntry>>; readonly changes: (publicKey: string, startSequence: number) => Effect.Effect<Mailbox.ReadonlyMailbox<EncryptedRemoteEntry>, never, Scope.Scope>; }, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "EventLogServer.ts",
      "path": "src/EventLogServer.ts"
    },
    "project": "@effect/experimental",
    "name": "layerStorageMemory",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "storage",
    "signature": "declare const layerStorageMemory: Layer.Layer<Storage, never, never>"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Cloudflare.ts",
      "path": "src/EventLogServer/Cloudflare.ts"
    },
    "project": "@effect/experimental",
    "name": "EventLogDurableObject",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "DurableObject",
    "signature": "declare class EventLogDurableObject { constructor(options: {\n    readonly ctx: DurableObjectState\n    readonly env: unknown\n    readonly storageLayer: Layer.Layer<EventLogServer.Storage>\n  }) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "MachineDefect",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "errors",
    "signature": "declare class MachineDefect"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "MachineContext",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "tags",
    "signature": "declare class MachineContext"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const TypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "SerializableTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const SerializableTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "ActorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const ActorTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "retry",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const retry: { <M extends Machine.Any, Out, In extends Machine.InitError<M> | MachineDefect, R>(policy: Schedule.Schedule<Out, In, R>): (self: M) => Machine.AddContext<M, R>; <M extends Machine.Any, Out, In extends Machine.InitError<M> | MachineDefect, R>(self: M, policy: Schedule.Schedule<Out, In, R>): Machine.AddContext<M, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "currentTracingEnabled",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "tracing",
    "signature": "declare const currentTracingEnabled: FiberRef.FiberRef<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "withTracingEnabled",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "tracing",
    "signature": "declare const withTracingEnabled: { (enabled: boolean): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, enabled: boolean): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: { <State, Public extends Procedure.TaggedRequest.Any, Private extends Procedure.TaggedRequest.Any, InitErr, R>(initialize: Effect.Effect<ProcedureList<State, Public, Private, R>, InitErr, R>): Machine<State, Public, Private, void, InitErr, Exclude<R, Scope.Scope | MachineContext>>; <State, Public extends Procedure.TaggedRequest.Any, Private extends Procedure.TaggedRequest.Any, Input, InitErr, R>(initialize: Machine.Initialize<Input, State, Public, Private, R, InitErr, R>): Machine<State, Public, Private, Input, InitErr, Exclude<R, Scope.Scope | MachineContext>>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "makeWith",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const makeWith: <State, Input = void>() => { <Public extends Procedure.TaggedRequest.Any, Private extends Procedure.TaggedRequest.Any, InitErr, R>(initialize: Effect.Effect<ProcedureList<State, Public, Private, R>, InitErr, R>): Machine<State, Public, Private, void, InitErr, Exclude<R, Scope.Scope | MachineContext>>; <Public extends Procedure.TaggedRequest.Any, Private extends Procedure.TaggedRequest.Any, InitErr, R>(initialize: Machine.Initialize<Input, State, Public, Private, R, InitErr, R>): Machine<State, Public, Private, Input, InitErr, Exclude<R, Scope.Scope | MachineContext>>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "makeSerializable",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const makeSerializable: { <State, IS, RS, Public extends Schema.TaggedRequest.All, Private extends Schema.TaggedRequest.All, InitErr, R>(options: { readonly state: Schema.Schema<State, IS, RS>; readonly input?: undefined; }, initialize: Effect.Effect<SerializableProcedureList<State, Public, Private, R>, InitErr, R> | Machine.InitializeSerializable<void, State, Public, Private, R, InitErr, R>): SerializableMachine<State, Public, Private, void, InitErr, Exclude<R, Scope.Scope | MachineContext>, RS>; <State, IS, RS, Input, II, RI, Public extends Schema.TaggedRequest.All, Private extends Schema.TaggedRequest.All, InitErr, R>(options: { readonly state: Schema.Schema<State, IS, RS>; readonly input: Schema.Schema<Input, II, RI>; }, initialize: Machine.InitializeSerializable<Input, State, Public, Private, R, InitErr, R>): SerializableMachine<State, Public, Private, Input, InitErr, Exclude<R, Scope.Scope | MachineContext>, RS | RI>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "boot",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "runtime",
    "signature": "declare const boot: <M extends Machine.Any>(self: M, ...[input, options]: [Machine.Input<M>] extends [void] ? [input?: Machine.Input<M>, options?: { readonly previousState?: Machine.State<M>; }] : [input: Machine.Input<M>, options?: { readonly previousState?: Machine.State<M>; }]) => Effect.Effect<M extends { readonly [SerializableTypeId]: SerializableTypeId; } ? SerializableActor<M> : Actor<M>, never, Machine.Context<M> | Scope.Scope>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "snapshot",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "runtime",
    "signature": "declare const snapshot: <State, Public extends Schema.TaggedRequest.All, Private extends Schema.TaggedRequest.All, Input, InitErr, R, SR>(self: Actor<SerializableMachine<State, Public, Private, Input, InitErr, R, SR>>) => Effect.Effect<[input: unknown, state: unknown], ParseResult.ParseError, SR>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "restore",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "runtime",
    "signature": "declare const restore: <State, Public extends Schema.TaggedRequest.All, Private extends Schema.TaggedRequest.All, Input, InitErr, R, SR>(self: SerializableMachine<State, Public, Private, Input, InitErr, R, SR>, snapshot: readonly [input: unknown, state: unknown]) => Effect.Effect<Actor<SerializableMachine<State, Public, Private, Input, InitErr, R, SR>>, ParseResult.ParseError, R | SR>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "Machine",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Machine<\n  State,\n  Public extends Procedure.TaggedRequest.Any,\n  Private extends Procedure.TaggedRequest.Any,\n  Input,\n  InitErr,\n  R\n> extends Pipeable {\n  readonly [TypeId]: TypeId\n  readonly initialize: Machine.Initialize<Input, State, Public, Private, InitErr, R, R>\n  readonly retryPolicy: Schedule.Schedule<unknown, InitErr | MachineDefect, R> | undefined\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "SerializableMachine",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface SerializableMachine<\n  State,\n  Public extends Schema.TaggedRequest.All,\n  Private extends Schema.TaggedRequest.All,\n  Input,\n  InitErr,\n  R,\n  SR\n> extends\n  Machine<\n    State,\n    Public,\n    Private,\n    Input,\n    InitErr,\n    R\n  >\n{\n  readonly [SerializableTypeId]: SerializableTypeId\n  readonly schemaInput: Schema.Schema<Input, unknown, SR>\n  readonly schemaState: Schema.Schema<State, unknown, SR>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "Actor",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Actor<M extends Machine.Any> extends Subscribable.Subscribable<Machine.State<M>> {\n  readonly [ActorTypeId]: ActorTypeId\n  readonly machine: M\n  readonly input: Machine.Input<M>\n  readonly send: <Req extends Machine.Public<M>>(request: Req) => Effect.Effect<\n    Request.Success<Req>,\n    Request.Error<Req>\n  >\n  readonly join: Effect.Effect<never, Machine.InitError<M> | MachineDefect>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "SerializableActor",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface SerializableActor<M extends Machine.Any> extends Actor<M> {\n  readonly sendUnknown: (request: unknown) => Effect.Effect<\n    Schema.ExitEncoded<unknown, unknown, unknown>,\n    ParseResult.ParseError\n  >\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type TypeId = typeof TypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "SerializableTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type SerializableTypeId = typeof SerializableTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "ActorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type ActorTypeId = typeof ActorTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "Machine.Any",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Any = | Machine<any, any, any, any, any, any>\n    | Machine<any, any, any, any, never, any>\n    | Machine<any, never, any, any, never, any>\n    | Machine<any, any, never, any, never, any>\n    | Machine<any, never, never, any, never, any>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "Machine.Initialize",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Initialize<Input, State, Public, Private, R, E, InitR> = (\n    input: Input,\n    previousState?: State | undefined\n  ) => Effect.Effect<ProcedureList<State, Public, Private, R>, E, InitR>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "Machine.InitializeSerializable",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type InitializeSerializable<Input, State, Public, Private, R, E, InitR> = (\n    input: Input,\n    previousState?: State | undefined\n  ) => Effect.Effect<SerializableProcedureList<State, Public, Private, R>, E, InitR>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "Machine.Public",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type Public<M> = M extends Machine<infer _S, infer Public, infer _Pr, infer _I, infer _IE, infer _R> ? Public\n    : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "Machine.Private",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type Private<M> = M extends Machine<infer _S, infer _Pu, infer Private, infer _I, infer _IE, infer _R> ?\n    Private\n    : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "Machine.State",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type State<M> = M extends Machine<infer State, infer _Pu, infer _Pr, infer _I, infer _IE, infer _R> ? State\n    : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "Machine.InitError",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type InitError<M> = M extends Machine<infer _S, infer _Pu, infer _Pr, infer _I, infer InitErr, infer _R> ?\n    InitErr\n    : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "Machine.Context",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type Context<M> = M extends Machine<infer _S, infer _Pu, infer _Pr, infer _I, infer _IE, infer R> ? R\n    : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "Machine.Input",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type Input<M> = M extends Machine<infer _S, infer _Pu, infer _Pr, infer Input, infer _IE, infer _R> ? Input\n    : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Machine.ts",
      "path": "src/Machine.ts"
    },
    "project": "@effect/experimental",
    "name": "Machine.AddContext",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type AddContext<M, R, E> = M extends SerializableMachine<\n    infer State,\n    infer Public,\n    infer Private,\n    infer Input,\n    infer InitErr,\n    infer R2,\n    infer SR\n  > ? SerializableMachine<\n      State,\n      Public,\n      Private,\n      Input,\n      InitErr | E,\n      R | R2,\n      SR\n    > :\n    M extends Machine<infer State, infer Public, infer Private, infer Input, infer InitErr, infer R2> ? Machine<\n        State,\n        Public,\n        Private,\n        Input,\n        InitErr | E,\n        R | R2\n      > :\n    never"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const TypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "SerializableTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const SerializableTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "NoReply",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const NoReply: unique symbol"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "isSerializable",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "refinements",
    "signature": "declare const isSerializable: (u: unknown) => u is SerializableProcedure<any, any, any>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: <Requests extends TaggedRequest.Any, State>() => <Req extends TaggedRequest.Any>() => <R>(tag: Req[\"_tag\"], handler: Handler<Req, State, Requests, R>) => Procedure<Req, State, R>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "makeSerializable",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const makeSerializable: <Requests extends TaggedRequest.Any, State>() => <Req extends Schema.TaggedRequest.All, IS, R, RS>(schema: Schema.Schema<Req, IS, RS> & { readonly _tag: Req[\"_tag\"]; }, handler: Handler<Req, State, Requests, R>) => SerializableProcedure<Req, State, R | Schema.SerializableWithResult.Context<Req>>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "TaggedRequest",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface TaggedRequest<Tag extends string, A, E> extends Request<A, E> {\n  readonly _tag: Tag\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "Procedure",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Procedure<Request extends TaggedRequest.Any, State, R> extends Pipeable {\n  readonly [TypeId]: TypeId\n  readonly tag: Request[\"_tag\"]\n  readonly handler: Handler<Request, State, any, R>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "SerializableProcedure",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface SerializableProcedure<Request extends Schema.TaggedRequest.All, State, R>\n  extends Procedure<Request, State, R>\n{\n  readonly [SerializableTypeId]: SerializableTypeId\n  readonly schema: Schema.Schema<Request, unknown>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type TypeId = typeof TypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "SerializableTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type SerializableTypeId = typeof SerializableTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "NoReply",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type NoReply = typeof NoReply"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "Handler",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Handler<Request, State, Requests, R> = (\n  context: Procedure.Context<Requests | Request, Request, State>\n) => Effect.Effect<\n  readonly [response: Request.Success<Request> | NoReply, state: State],\n  Request.Error<Request>,\n  R\n>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "TaggedRequest.Any",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Any = | TaggedRequest<string, any, any>\n    | TaggedRequest<string, any, never>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "Procedure.BaseContext",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface BaseContext {\n    readonly fork: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<void, never, R>\n    readonly forkOne: {\n      (id: string): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<void, never, R>\n      <A, E, R>(effect: Effect.Effect<A, E, R>, id: string): Effect.Effect<void, never, R>\n    }\n    readonly forkReplace: {\n      (id: string): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<void, never, R>\n      <A, E, R>(effect: Effect.Effect<A, E, R>, id: string): Effect.Effect<void, never, R>\n    }\n    readonly unsafeSend: <Req extends TaggedRequest.Any>(request: Req) => Effect.Effect<void>\n    readonly unsafeSendAwait: <Req extends TaggedRequest.Any>(request: Req) => Effect.Effect<\n      Request.Success<Req>,\n      Request.Error<Req>\n    >\n  }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "Procedure.ContextProto",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface ContextProto<Requests extends TaggedRequest.Any, State> extends BaseContext {\n    readonly send: <Req extends Requests>(request: Req) => Effect.Effect<void>\n    readonly sendAwait: <Req extends Requests>(request: Req) => Effect.Effect<\n      Request.Success<Req>,\n      Request.Error<Req>\n    >\n    readonly forkWith: {\n      (state: State): <A, E, R>(\n        effect: Effect.Effect<A, E, R>\n      ) => Effect.Effect<readonly [void, State], never, R>\n      <A, E, R>(\n        effect: Effect.Effect<A, E, R>,\n        state: State\n      ): Effect.Effect<readonly [void, State], never, R>\n    }\n    readonly forkOneWith: {\n      (\n        id: string,\n        state: State\n      ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<readonly [void, State], never, R>\n      <A, E, R>(\n        effect: Effect.Effect<A, E, R>,\n        id: string,\n        state: State\n      ): Effect.Effect<readonly [void, State], never, R>\n    }\n    readonly forkReplaceWith: {\n      (\n        id: string,\n        state: State\n      ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<readonly [void, State], never, R>\n      <A, E, R>(\n        effect: Effect.Effect<A, E, R>,\n        id: string,\n        state: State\n      ): Effect.Effect<readonly [void, State], never, R>\n    }\n  }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "Procedure.Context",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Context<Requests extends TaggedRequest.Any, Request extends TaggedRequest.Any, State>\n    extends ContextProto<Requests, State>\n  {\n    readonly request: Request\n    readonly state: State\n    readonly deferred: Deferred.Deferred<\n      Request.Success<Request>,\n      Request.Error<Request>\n    >\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "Procedure.InferRequest",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type InferRequest<P> = P extends Procedure<infer Req, infer _, infer _> ? Req : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Procedure.ts",
      "path": "src/Machine/Procedure.ts"
    },
    "project": "@effect/experimental",
    "name": "Procedure.InferContext",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type InferContext<P> = P extends Procedure<infer _, infer _, infer R> ? R : never"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ProcedureList.ts",
      "path": "src/Machine/ProcedureList.ts"
    },
    "project": "@effect/experimental",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const TypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ProcedureList.ts",
      "path": "src/Machine/ProcedureList.ts"
    },
    "project": "@effect/experimental",
    "name": "addProcedure",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const addProcedure: { <Req extends Procedure.TaggedRequest.Any, State, R2>(procedure: Procedure.Procedure<Req, State, R2>): <Public extends Procedure.TaggedRequest.Any, Private extends Procedure.TaggedRequest.Any, R>(self: ProcedureList<State, Public, Private, R>) => ProcedureList<State, Req | Public, Private, R | R2>; <State, Public extends Procedure.TaggedRequest.Any, Private extends Procedure.TaggedRequest.Any, R, Req extends Procedure.TaggedRequest.Any, R2>(self: ProcedureList<State, Public, Private, R>, procedure: Procedure.Procedure<Req, State, R2>): ProcedureList<State, Req | Public, Private, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ProcedureList.ts",
      "path": "src/Machine/ProcedureList.ts"
    },
    "project": "@effect/experimental",
    "name": "addProcedurePrivate",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const addProcedurePrivate: { <Req extends Procedure.TaggedRequest.Any, State, R2>(procedure: Procedure.Procedure<Req, State, R2>): <Public extends Procedure.TaggedRequest.Any, Private extends Procedure.TaggedRequest.Any, R>(self: ProcedureList<State, Public, Private, R>) => ProcedureList<State, Public, Private | Req, R | R2>; <State, Public extends Procedure.TaggedRequest.Any, Private extends Procedure.TaggedRequest.Any, R, Req extends Procedure.TaggedRequest.Any, R2>(self: ProcedureList<State, Public, Private, R>, procedure: Procedure.Procedure<Req, State, R2>): ProcedureList<State, Public, Private | Req, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ProcedureList.ts",
      "path": "src/Machine/ProcedureList.ts"
    },
    "project": "@effect/experimental",
    "name": "withInitialState",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const withInitialState: { <State>(initialState: Types.NoInfer<State>): <Public extends Procedure.TaggedRequest.Any, Private extends Procedure.TaggedRequest.Any, R>(self: ProcedureList<State, Public, Private, R>) => ProcedureList<State, Public, Private, R>; <State, Public extends Procedure.TaggedRequest.Any, Private extends Procedure.TaggedRequest.Any, R>(self: ProcedureList<State, Public, Private, R>, initialState: Types.NoInfer<State>): ProcedureList<State, Public, Private, R>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ProcedureList.ts",
      "path": "src/Machine/ProcedureList.ts"
    },
    "project": "@effect/experimental",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: <State>(initialState: State, options?: { readonly identifier?: string; }) => ProcedureList<State, never, never, never>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ProcedureList.ts",
      "path": "src/Machine/ProcedureList.ts"
    },
    "project": "@effect/experimental",
    "name": "add",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const add: <Req extends Procedure.TaggedRequest.Any>() => { <State, Public extends Procedure.TaggedRequest.Any, Private extends Procedure.TaggedRequest.Any, R2>(tag: Req[\"_tag\"], handler: Procedure.Handler<Req, Types.NoInfer<State>, Types.NoInfer<Public> | Types.NoInfer<Private>, R2>): <R>(self: ProcedureList<State, Public, Private, R>) => ProcedureList<State, Req | Public, Private, R | R2>; <State, Public extends Procedure.TaggedRequest.Any, Private extends Procedure.TaggedRequest.Any, R, R2>(self: ProcedureList<State, Public, Private, R>, tag: Req[\"_tag\"], handler: Procedure.Handler<Req, Types.NoInfer<State>, Types.NoInfer<Public> | Types.NoInfer<Private>, R2>): ProcedureList<State, Req | Public, Private, R | R2>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ProcedureList.ts",
      "path": "src/Machine/ProcedureList.ts"
    },
    "project": "@effect/experimental",
    "name": "addPrivate",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const addPrivate: <Req extends Procedure.TaggedRequest.Any>() => { <State, Public extends Procedure.TaggedRequest.Any, Private extends Procedure.TaggedRequest.Any, R2>(tag: Req[\"_tag\"], handler: Procedure.Handler<Req, Types.NoInfer<State>, Types.NoInfer<Public> | Types.NoInfer<Private>, R2>): <R>(self: ProcedureList<State, Public, Private, R>) => ProcedureList<State, Public, Private | Req, R | R2>; <State, Public extends Procedure.TaggedRequest.Any, Private extends Procedure.TaggedRequest.Any, R, R2>(self: ProcedureList<State, Public, Private, R>, tag: Req[\"_tag\"], handler: Procedure.Handler<Req, Types.NoInfer<State>, Types.NoInfer<Public> | Types.NoInfer<Private>, R2>): ProcedureList<State, Public, Private | Req, R | R2>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ProcedureList.ts",
      "path": "src/Machine/ProcedureList.ts"
    },
    "project": "@effect/experimental",
    "name": "ProcedureList",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface ProcedureList<\n  State,\n  Public extends Procedure.TaggedRequest.Any,\n  Private extends Procedure.TaggedRequest.Any,\n  R\n> extends Effect.Effect<ProcedureList<State, Public, Private, R>> {\n  readonly [TypeId]: TypeId\n  readonly initialState: State\n  readonly public: ReadonlyArray<Procedure.Procedure<Public, State, R>>\n  readonly private: ReadonlyArray<Procedure.Procedure<Private, State, R>>\n  readonly identifier: string\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ProcedureList.ts",
      "path": "src/Machine/ProcedureList.ts"
    },
    "project": "@effect/experimental",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SerializableProcedureList.ts",
      "path": "src/Machine/SerializableProcedureList.ts"
    },
    "project": "@effect/experimental",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: <State>(initialState: State, options?: { readonly identifier?: string; }) => SerializableProcedureList<State, never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SerializableProcedureList.ts",
      "path": "src/Machine/SerializableProcedureList.ts"
    },
    "project": "@effect/experimental",
    "name": "add",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const add: { <Req extends Schema.TaggedRequest.All, I, ReqR, State, Public extends Schema.TaggedRequest.All, Private extends Schema.TaggedRequest.All, R2>(schema: Schema.Schema<Req, I, ReqR> & { readonly _tag: Req[\"_tag\"]; }, handler: Procedure.Handler<Req, Types.NoInfer<State>, Types.NoInfer<Public> | Types.NoInfer<Private>, R2>): <R>(self: SerializableProcedureList<State, Public, Private, R>) => SerializableProcedureList<State, Req | Public, Private, R | R2 | Schema.SerializableWithResult.Context<Req>>; <State, Public extends Schema.TaggedRequest.All, Private extends Schema.TaggedRequest.All, R, Req extends Schema.TaggedRequest.All, I, ReqR, R2>(self: SerializableProcedureList<State, Public, Private, R>, schema: Schema.Schema<Req, I, ReqR> & { readonly _tag: Req[\"_tag\"]; }, handler: Procedure.Handler<Req, Types.NoInfer<State>, Types.NoInfer<Public> | Types.NoInfer<Private>, R2>): SerializableProcedureList<State, Req | Public, Private, R | R2 | Schema.SerializableWithResult.Context<Req>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SerializableProcedureList.ts",
      "path": "src/Machine/SerializableProcedureList.ts"
    },
    "project": "@effect/experimental",
    "name": "addPrivate",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const addPrivate: { <Req extends Schema.TaggedRequest.All, I, ReqR, State, Public extends Schema.TaggedRequest.All, Private extends Schema.TaggedRequest.All, R2>(schema: Schema.Schema<Req, I, ReqR> & { readonly _tag: Req[\"_tag\"]; }, handler: Procedure.Handler<Req, Types.NoInfer<State>, Types.NoInfer<Public> | Types.NoInfer<Private>, R2>): <R>(self: SerializableProcedureList<State, Public, Private, R>) => SerializableProcedureList<State, Public, Private | Req, R | R2 | Schema.SerializableWithResult.Context<Req>>; <State, Public extends Schema.TaggedRequest.All, Private extends Schema.TaggedRequest.All, R, Req extends Schema.TaggedRequest.All, I, ReqR, R2>(self: SerializableProcedureList<State, Public, Private, R>, schema: Schema.Schema<Req, I, ReqR> & { readonly _tag: Req[\"_tag\"]; }, handler: Procedure.Handler<Req, Types.NoInfer<State>, Types.NoInfer<Public> | Types.NoInfer<Private>, R2>): SerializableProcedureList<State, Public, Private | Req, R | R2 | Schema.SerializableWithResult.Context<Req>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SerializableProcedureList.ts",
      "path": "src/Machine/SerializableProcedureList.ts"
    },
    "project": "@effect/experimental",
    "name": "withInitialState",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const withInitialState: { <State>(initialState: Types.NoInfer<State>): <Public extends Schema.TaggedRequest.All, Private extends Schema.TaggedRequest.All, R>(self: SerializableProcedureList<State, Public, Private, R>) => SerializableProcedureList<State, Public, Private, R>; <State, Public extends Schema.TaggedRequest.All, Private extends Schema.TaggedRequest.All, R>(self: SerializableProcedureList<State, Public, Private, R>, initialState: Types.NoInfer<State>): SerializableProcedureList<State, Public, Private, R>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SerializableProcedureList.ts",
      "path": "src/Machine/SerializableProcedureList.ts"
    },
    "project": "@effect/experimental",
    "name": "SerializableProcedureList",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface SerializableProcedureList<\n  State,\n  Public extends Schema.TaggedRequest.All,\n  Private extends Schema.TaggedRequest.All,\n  R\n> extends Effect.Effect<SerializableProcedureList<State, Public, Private, R>> {\n  readonly [ProcedureList.TypeId]: ProcedureList.TypeId\n  readonly initialState: State\n  readonly public: ReadonlyArray<Procedure.SerializableProcedure<Public, State, R>>\n  readonly private: ReadonlyArray<Procedure.SerializableProcedure<Private, State, R>>\n  readonly identifier: string\n}"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "MsgPack.ts",
      "path": "src/MsgPack.ts"
    },
    "project": "@effect/experimental",
    "name": "MsgPackError",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "errors",
    "signature": "declare class MsgPackError"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MsgPack.ts",
      "path": "src/MsgPack.ts"
    },
    "project": "@effect/experimental",
    "name": "duplexSchema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const duplexSchema: { <IA, II, IR, OA, OI, OR>(options: { readonly inputSchema: Schema.Schema<IA, II, IR>; readonly outputSchema: Schema.Schema<OA, OI, OR>; }): <R, InErr, OutErr, OutDone, InDone>(self: Channel.Channel<Chunk.Chunk<Uint8Array>, Chunk.Chunk<Uint8Array>, OutErr, MsgPackError | ParseError | InErr, OutDone, InDone, R>) => Channel.Channel<Chunk.Chunk<OA>, Chunk.Chunk<IA>, MsgPackError | ParseError | OutErr, InErr, OutDone, InDone, IR | OR | R>; <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(self: Channel.Channel<Chunk.Chunk<Uint8Array>, Chunk.Chunk<Uint8Array>, OutErr, MsgPackError | ParseError | InErr, OutDone, InDone, R>, options: { readonly inputSchema: Schema.Schema<IA, II, IR>; readonly outputSchema: Schema.Schema<OA, OI, OR>; }): Channel.Channel<Chunk.Chunk<OA>, Chunk.Chunk<IA>, MsgPackError | ParseError | OutErr, InErr, OutDone, InDone, R | IR | OR>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MsgPack.ts",
      "path": "src/MsgPack.ts"
    },
    "project": "@effect/experimental",
    "name": "pack",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const pack: <IE = never, Done = unknown>() => Channel.Channel<Chunk.Chunk<Uint8Array>, Chunk.Chunk<unknown>, IE | MsgPackError, IE, Done, Done>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MsgPack.ts",
      "path": "src/MsgPack.ts"
    },
    "project": "@effect/experimental",
    "name": "packSchema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const packSchema: <A, I, R>(schema: Schema.Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel.Channel<Chunk.Chunk<Uint8Array>, Chunk.Chunk<A>, IE | MsgPackError | ParseError, IE, Done, Done, R>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MsgPack.ts",
      "path": "src/MsgPack.ts"
    },
    "project": "@effect/experimental",
    "name": "unpack",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const unpack: <IE = never, Done = unknown>() => Channel.Channel<Chunk.Chunk<unknown>, Chunk.Chunk<Uint8Array>, IE | MsgPackError, IE, Done, Done>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MsgPack.ts",
      "path": "src/MsgPack.ts"
    },
    "project": "@effect/experimental",
    "name": "unpackSchema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const unpackSchema: <A, I, R>(schema: Schema.Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<Uint8Array>, MsgPackError | ParseError | IE, IE, Done, Done, R>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MsgPack.ts",
      "path": "src/MsgPack.ts"
    },
    "project": "@effect/experimental",
    "name": "duplex",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const duplex: <R, IE, OE, OutDone, InDone>(self: Channel.Channel<Chunk.Chunk<Uint8Array>, Chunk.Chunk<Uint8Array>, OE, IE | MsgPackError, OutDone, InDone, R>) => Channel.Channel<Chunk.Chunk<unknown>, Chunk.Chunk<unknown>, MsgPackError | OE, IE, OutDone, InDone, R>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MsgPack.ts",
      "path": "src/MsgPack.ts"
    },
    "project": "@effect/experimental",
    "name": "schema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const schema: <S extends Schema.Schema.Any>(schema: S) => schema<S>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MsgPack.ts",
      "path": "src/MsgPack.ts"
    },
    "project": "@effect/experimental",
    "name": "schema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "export interface schema<S extends Schema.Schema.Any> extends Schema.transformOrFail<Schema.Schema<Uint8Array>, S> {}"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "NdjsonError",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "errors",
    "signature": "declare class NdjsonError"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "NdjsonErrorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const NdjsonErrorTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "duplex",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const duplex: { (options?: NdjsonOptions): <R, IE, OE, OutDone, InDone>(self: Channel.Channel<Chunk.Chunk<Uint8Array>, Chunk.Chunk<Uint8Array>, OE, IE | NdjsonError, OutDone, InDone, R>) => Channel.Channel<Chunk.Chunk<unknown>, Chunk.Chunk<unknown>, NdjsonError | OE, IE, OutDone, InDone, R>; <R, IE, OE, OutDone, InDone>(self: Channel.Channel<Chunk.Chunk<Uint8Array>, Chunk.Chunk<Uint8Array>, OE, IE | NdjsonError, OutDone, InDone, R>, options?: NdjsonOptions): Channel.Channel<Chunk.Chunk<unknown>, Chunk.Chunk<unknown>, NdjsonError | OE, IE, OutDone, InDone, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "duplexString",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const duplexString: { (options?: NdjsonOptions): <R, IE, OE, OutDone, InDone>(self: Channel.Channel<Chunk.Chunk<string>, Chunk.Chunk<string>, OE, IE | NdjsonError, OutDone, InDone, R>) => Channel.Channel<Chunk.Chunk<unknown>, Chunk.Chunk<unknown>, NdjsonError | OE, IE, OutDone, InDone, R>; <R, IE, OE, OutDone, InDone>(self: Channel.Channel<Chunk.Chunk<string>, Chunk.Chunk<string>, OE, IE | NdjsonError, OutDone, InDone, R>, options?: NdjsonOptions): Channel.Channel<Chunk.Chunk<unknown>, Chunk.Chunk<unknown>, NdjsonError | OE, IE, OutDone, InDone, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "duplexSchema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const duplexSchema: { <IA, II, IR, OA, OI, OR>(options: Partial<NdjsonOptions> & { readonly inputSchema: Schema.Schema<IA, II, IR>; readonly outputSchema: Schema.Schema<OA, OI, OR>; }): <R, InErr, OutErr, OutDone, InDone>(self: Channel.Channel<Chunk.Chunk<Uint8Array>, Chunk.Chunk<Uint8Array>, OutErr, NdjsonError | ParseError | InErr, OutDone, InDone, R>) => Channel.Channel<Chunk.Chunk<OA>, Chunk.Chunk<IA>, NdjsonError | ParseError | OutErr, InErr, OutDone, InDone, R | IR | OR>; <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(self: Channel.Channel<Chunk.Chunk<Uint8Array>, Chunk.Chunk<Uint8Array>, OutErr, NdjsonError | ParseError | InErr, OutDone, InDone, R>, options: Partial<NdjsonOptions> & { readonly inputSchema: Schema.Schema<IA, II, IR>; readonly outputSchema: Schema.Schema<OA, OI, OR>; }): Channel.Channel<Chunk.Chunk<OA>, Chunk.Chunk<IA>, NdjsonError | ParseError | OutErr, InErr, OutDone, InDone, R | IR | OR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "duplexSchemaString",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const duplexSchemaString: { <IA, II, IR, OA, OI, OR>(options: Partial<NdjsonOptions> & { readonly inputSchema: Schema.Schema<IA, II, IR>; readonly outputSchema: Schema.Schema<OA, OI, OR>; }): <R, InErr, OutErr, OutDone, InDone>(self: Channel.Channel<Chunk.Chunk<string>, Chunk.Chunk<string>, OutErr, NdjsonError | ParseError | InErr, OutDone, InDone, R>) => Channel.Channel<Chunk.Chunk<OA>, Chunk.Chunk<IA>, NdjsonError | ParseError | OutErr, InErr, OutDone, InDone, R | IR | OR>; <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(self: Channel.Channel<Chunk.Chunk<string>, Chunk.Chunk<string>, OutErr, NdjsonError | ParseError | InErr, OutDone, InDone, R>, options: Partial<NdjsonOptions> & { readonly inputSchema: Schema.Schema<IA, II, IR>; readonly outputSchema: Schema.Schema<OA, OI, OR>; }): Channel.Channel<Chunk.Chunk<OA>, Chunk.Chunk<IA>, NdjsonError | ParseError | OutErr, InErr, OutDone, InDone, R | IR | OR>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "packString",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const packString: <IE = never, Done = unknown>() => Channel.Channel<Chunk.Chunk<string>, Chunk.Chunk<unknown>, IE | NdjsonError, IE, Done, Done>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "pack",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const pack: <IE = never, Done = unknown>() => Channel.Channel<Chunk.Chunk<Uint8Array>, Chunk.Chunk<unknown>, IE | NdjsonError, IE, Done, Done>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "packSchema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const packSchema: <A, I, R>(schema: Schema.Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel.Channel<Chunk.Chunk<Uint8Array>, Chunk.Chunk<A>, IE | NdjsonError | ParseError, IE, Done, Done, R>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "packSchemaString",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const packSchemaString: <A, I, R>(schema: Schema.Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel.Channel<Chunk.Chunk<string>, Chunk.Chunk<A>, IE | NdjsonError | ParseError, IE, Done, Done, R>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "unpackString",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const unpackString: <IE = never, Done = unknown>(options?: NdjsonOptions) => Channel.Channel<Chunk.Chunk<unknown>, Chunk.Chunk<string>, IE | NdjsonError, IE, Done, Done>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "unpack",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const unpack: <IE = never, Done = unknown>(options?: NdjsonOptions) => Channel.Channel<Chunk.Chunk<unknown>, Chunk.Chunk<Uint8Array>, IE | NdjsonError, IE, Done, Done>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "unpackSchema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const unpackSchema: <A, I, R>(schema: Schema.Schema<A, I, R>) => <IE = never, Done = unknown>(options?: NdjsonOptions) => Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<Uint8Array>, NdjsonError | ParseError | IE, IE, Done, Done, R>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "unpackSchemaString",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const unpackSchemaString: <A, I, R>(schema: Schema.Schema<A, I, R>) => <IE = never, Done = unknown>(options?: NdjsonOptions) => Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<string>, NdjsonError | ParseError | IE, IE, Done, Done, R>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "NdjsonOptions",
    "description": "Represents a set of options which can be used to control how the newline\ndelimited JSON is handled.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface NdjsonOptions {\n  /**\n   * Whether or not the newline delimited JSON parser should ignore empty lines.\n   *\n   * Defaults to `false`.\n   *\n   * From the [newline delimited JSON spec](https://github.com/ndjson/ndjson-spec):\n   * ```text\n   * The parser MAY silently ignore empty lines, e.g. \\n\\n. This behavior MUST\n   * be documented and SHOULD be configurable by the user of the parser.\n   * ```\n   *\n   * @since 1.0.0\n   */\n  readonly ignoreEmptyLines?: boolean\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Ndjson.ts",
      "path": "src/Ndjson.ts"
    },
    "project": "@effect/experimental",
    "name": "NdjsonErrorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type NdjsonErrorTypeId = typeof NdjsonErrorTypeId"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "PersistedCache.ts",
      "path": "src/PersistedCache.ts"
    },
    "project": "@effect/experimental",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: <K extends Persistence.ResultPersistence.KeyAny, R>(options: { readonly storeId: string; readonly lookup: (key: K) => Effect.Effect<Schema.WithResult.Success<K>, Schema.WithResult.Failure<K>, R>; readonly timeToLive: (...args: Persistence.ResultPersistence.TimeToLiveArgs<K>) => Duration.DurationInput; readonly inMemoryCapacity?: number | undefined; readonly inMemoryTTL?: Duration.DurationInput | undefined; }) => Effect.Effect<PersistedCache<K>, never, Schema.SerializableWithResult.Context<K> | R | Persistence.ResultPersistence | Scope.Scope>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "PersistedCache.ts",
      "path": "src/PersistedCache.ts"
    },
    "project": "@effect/experimental",
    "name": "PersistedCache",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface PersistedCache<K extends Persistence.ResultPersistence.KeyAny> {\n  readonly get: (\n    key: K\n  ) => Effect.Effect<\n    Schema.WithResult.Success<K>,\n    Schema.WithResult.Failure<K> | Persistence.PersistenceError\n  >\n  readonly invalidate: (key: K) => Effect.Effect<void, Persistence.PersistenceError>\n}"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "PersistenceParseError",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "errors",
    "signature": "declare class PersistenceParseError"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "PersistenceBackingError",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "errors",
    "signature": "declare class PersistenceBackingError"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "ErrorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const ErrorTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "BackingPersistenceTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const BackingPersistenceTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "BackingPersistence",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "tags",
    "signature": "declare const BackingPersistence: Context.Tag<BackingPersistence, BackingPersistence>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "ResultPersistenceTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const ResultPersistenceTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "ResultPersistence",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "tags",
    "signature": "declare const ResultPersistence: Context.Tag<ResultPersistence, ResultPersistence>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "layerResult",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerResult: Layer.Layer<ResultPersistence, never, BackingPersistence>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "layerMemory",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerMemory: Layer.Layer<BackingPersistence, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "layerKeyValueStore",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerKeyValueStore: Layer.Layer<BackingPersistence, never, KeyValueStore.KeyValueStore>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "layerResultMemory",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerResultMemory: Layer.Layer<ResultPersistence, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "layerResultKeyValueStore",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerResultKeyValueStore: Layer.Layer<ResultPersistence, never, KeyValueStore.KeyValueStore>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "unsafeTtlToExpires",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "declare const unsafeTtlToExpires: (clock: Clock.Clock, ttl: Option.Option<Duration.Duration>) => number | null"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "BackingPersistence",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface BackingPersistence {\n  readonly [BackingPersistenceTypeId]: BackingPersistenceTypeId\n  readonly make: (storeId: string) => Effect.Effect<BackingPersistenceStore, never, Scope.Scope>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "BackingPersistenceStore",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface BackingPersistenceStore {\n  readonly get: (key: string) => Effect.Effect<Option.Option<unknown>, PersistenceError>\n  readonly getMany: (key: Array<string>) => Effect.Effect<Array<Option.Option<unknown>>, PersistenceError>\n  readonly set: (\n    key: string,\n    value: unknown,\n    ttl: Option.Option<Duration.Duration>\n  ) => Effect.Effect<void, PersistenceError>\n  readonly remove: (key: string) => Effect.Effect<void, PersistenceError>\n  readonly clear: Effect.Effect<void, PersistenceError>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "ResultPersistence",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface ResultPersistence {\n  readonly [ResultPersistenceTypeId]: ResultPersistenceTypeId\n  readonly make: (options: {\n    readonly storeId: string\n    readonly timeToLive?: (key: ResultPersistence.KeyAny, exit: Exit.Exit<unknown, unknown>) => Duration.DurationInput\n  }) => Effect.Effect<ResultPersistenceStore, never, Scope.Scope>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "ResultPersistenceStore",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface ResultPersistenceStore {\n  readonly get: <R, IE, E, IA, A>(\n    key: ResultPersistence.Key<R, IE, E, IA, A>\n  ) => Effect.Effect<Option.Option<Exit.Exit<A, E>>, PersistenceError, R>\n  readonly getMany: <R, IE, E, IA, A>(\n    key: ReadonlyArray<ResultPersistence.Key<R, IE, E, IA, A>>\n  ) => Effect.Effect<Array<Option.Option<Exit.Exit<A, E>>>, PersistenceError, R>\n  readonly set: <R, IE, E, IA, A>(\n    key: ResultPersistence.Key<R, IE, E, IA, A>,\n    value: Exit.Exit<A, E>\n  ) => Effect.Effect<void, PersistenceError, R>\n  readonly remove: <R, IE, E, IA, A>(\n    key: ResultPersistence.Key<R, IE, E, IA, A>\n  ) => Effect.Effect<void, PersistenceError>\n  readonly clear: Effect.Effect<void, PersistenceError>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "ErrorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type ErrorTypeId = typeof ErrorTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "PersistenceError",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "errors",
    "signature": "type PersistenceError = PersistenceParseError | PersistenceBackingError"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "BackingPersistenceTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type BackingPersistenceTypeId = typeof BackingPersistenceTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "ResultPersistenceTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type ResultPersistenceTypeId = typeof ResultPersistenceTypeId"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "ResultPersistence.Key",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Key<R, IE, E, IA, A> extends Schema.WithResult<A, IA, E, IE, R>, PrimaryKey.PrimaryKey {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "ResultPersistence.KeyAny",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type KeyAny = Key<any, any, any, any, any> | Key<any, never, never, any, any>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Persistence.ts",
      "path": "src/Persistence.ts"
    },
    "project": "@effect/experimental",
    "name": "ResultPersistence.TimeToLiveArgs",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type TimeToLiveArgs<A> = A extends infer K\n    ? K extends Key<infer _R, infer _IE, infer _E, infer _IA, infer _A> ? [request: K, exit: Exit.Exit<_A, _E>]\n    : never\n    : never"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Lmdb.ts",
      "path": "src/Persistence/Lmdb.ts"
    },
    "project": "@effect/experimental",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: (options: Lmdb.RootDatabaseOptionsWithPath) => Effect.Effect<Persistence.BackingPersistence, never, Scope>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Lmdb.ts",
      "path": "src/Persistence/Lmdb.ts"
    },
    "project": "@effect/experimental",
    "name": "layer",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layer: (options: Lmdb.RootDatabaseOptionsWithPath) => Layer.Layer<Persistence.BackingPersistence>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Lmdb.ts",
      "path": "src/Persistence/Lmdb.ts"
    },
    "project": "@effect/experimental",
    "name": "layerResult",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerResult: (options: Lmdb.RootDatabaseOptionsWithPath) => Layer.Layer<Persistence.ResultPersistence>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Redis.ts",
      "path": "src/Persistence/Redis.ts"
    },
    "project": "@effect/experimental",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: (options: RedisOptions) => Effect.Effect<Persistence.BackingPersistence, never, Scope>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Redis.ts",
      "path": "src/Persistence/Redis.ts"
    },
    "project": "@effect/experimental",
    "name": "layer",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layer: (options: RedisOptions) => Layer.Layer<Persistence.BackingPersistence>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Redis.ts",
      "path": "src/Persistence/Redis.ts"
    },
    "project": "@effect/experimental",
    "name": "layerConfig",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerConfig: (options: Config.Config.Wrap<RedisOptions>) => Layer.Layer<Persistence.BackingPersistence, ConfigError>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Redis.ts",
      "path": "src/Persistence/Redis.ts"
    },
    "project": "@effect/experimental",
    "name": "layerResult",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerResult: (options: RedisOptions) => Layer.Layer<Persistence.ResultPersistence>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Redis.ts",
      "path": "src/Persistence/Redis.ts"
    },
    "project": "@effect/experimental",
    "name": "layerResultConfig",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerResultConfig: (options: Config.Config.Wrap<RedisOptions>) => Layer.Layer<Persistence.ResultPersistence, ConfigError>"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Reactivity.ts",
      "path": "src/Reactivity.ts"
    },
    "project": "@effect/experimental",
    "name": "Reactivity",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "tags",
    "signature": "declare class Reactivity"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reactivity.ts",
      "path": "src/Reactivity.ts"
    },
    "project": "@effect/experimental",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: Effect.Effect<Reactivity.Service, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reactivity.ts",
      "path": "src/Reactivity.ts"
    },
    "project": "@effect/experimental",
    "name": "layer",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layer: Layer.Layer<Reactivity, never, never>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Reactivity.ts",
      "path": "src/Reactivity.ts"
    },
    "project": "@effect/experimental",
    "name": "Reactivity.Service",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "model",
    "signature": "export interface Service {\n    readonly unsafeInvalidate: (keys: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>>) => void\n    readonly invalidate: (\n      keys: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>>\n    ) => Effect.Effect<void>\n    readonly mutation: <A, E, R>(\n      keys: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>>,\n      effect: Effect.Effect<A, E, R>\n    ) => Effect.Effect<A, E, R>\n    readonly query: <A, E, R>(\n      keys: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>>,\n      effect: Effect.Effect<A, E, R>\n    ) => Effect.Effect<Mailbox.ReadonlyMailbox<A, E>, never, R | Scope.Scope>\n    readonly stream: <A, E, R>(\n      keys: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>>,\n      effect: Effect.Effect<A, E, R>\n    ) => Stream.Stream<A, E, Exclude<R, Scope.Scope>>\n  }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "@effect/experimental",
    "name": "dataLoader",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const dataLoader: ((options: { readonly window: Duration.DurationInput; readonly maxBatchSize?: number; }) => <A extends Request.Request<any, any>>(self: RequestResolver.RequestResolver<A, never>) => Effect.Effect<RequestResolver.RequestResolver<A, never>, never, Scope.Scope>) & (<A extends Request.Request<any, any>>(self: RequestResolver.RequestResolver<A, never>, options: { readonly window: Duration.DurationInput; readonly maxBatchSize?: number; }) => Effect.Effect<RequestResolver.RequestResolver<A, never>, never, Scope.Scope>)"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "@effect/experimental",
    "name": "persisted",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "combinators",
    "signature": "declare const persisted: { <Req extends PersistedRequest.Any>(options: { readonly storeId: string; readonly timeToLive: (...args: Persistence.ResultPersistence.TimeToLiveArgs<Req>) => Duration.DurationInput; }): (self: RequestResolver.RequestResolver<Req, never>) => Effect.Effect<RequestResolver.RequestResolver<Req, Schema.WithResult.Context<Req>>, never, Persistence.ResultPersistence | Scope.Scope>; <Req extends PersistedRequest.Any>(self: RequestResolver.RequestResolver<Req, never>, options: { readonly storeId: string; readonly timeToLive: (...args: Persistence.ResultPersistence.TimeToLiveArgs<Req>) => Duration.DurationInput; }): Effect.Effect<RequestResolver.RequestResolver<Req, Schema.WithResult.Context<Req>>, never, Persistence.ResultPersistence | Scope.Scope>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "@effect/experimental",
    "name": "PersistedRequest",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "model",
    "signature": "export interface PersistedRequest<R, IE, E, IA, A> extends Request.Request<A, E>, Schema.WithResult<A, IA, E, IE, R> {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "@effect/experimental",
    "name": "PersistedRequest.Any",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "model",
    "signature": "type Any = PersistedRequest<any, any, any, any, any> | PersistedRequest<any, never, never, any, any>"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SocketServer.ts",
      "path": "src/SocketServer.ts"
    },
    "project": "@effect/experimental",
    "name": "SocketServerError",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "errors",
    "signature": "declare class SocketServerError"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SocketServer.ts",
      "path": "src/SocketServer.ts"
    },
    "project": "@effect/experimental",
    "name": "SocketServerTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const SocketServerTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SocketServer.ts",
      "path": "src/SocketServer.ts"
    },
    "project": "@effect/experimental",
    "name": "SocketServer",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "tags",
    "signature": "declare const SocketServer: Context.Tag<SocketServer, SocketServer>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SocketServer.ts",
      "path": "src/SocketServer.ts"
    },
    "project": "@effect/experimental",
    "name": "SocketServer",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface SocketServer {\n  readonly [SocketServerTypeId]: SocketServerTypeId\n  readonly address: Address\n  readonly run: <R, E, _>(\n    handler: (socket: Socket.Socket) => Effect.Effect<_, E, R>\n  ) => Effect.Effect<never, SocketServerError, R>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SocketServer.ts",
      "path": "src/SocketServer.ts"
    },
    "project": "@effect/experimental",
    "name": "TcpAddress",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface TcpAddress {\n  readonly _tag: \"TcpAddress\"\n  readonly hostname: string\n  readonly port: number\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SocketServer.ts",
      "path": "src/SocketServer.ts"
    },
    "project": "@effect/experimental",
    "name": "UnixAddress",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface UnixAddress {\n  readonly _tag: \"UnixAddress\"\n  readonly path: string\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SocketServer.ts",
      "path": "src/SocketServer.ts"
    },
    "project": "@effect/experimental",
    "name": "SocketServerTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type SocketServerTypeId = typeof SocketServerTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SocketServer.ts",
      "path": "src/SocketServer.ts"
    },
    "project": "@effect/experimental",
    "name": "Address",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Address = UnixAddress | TcpAddress"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Node.ts",
      "path": "src/SocketServer/Node.ts"
    },
    "project": "@effect/experimental",
    "name": "IncomingMessage",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "tags",
    "signature": "declare const IncomingMessage: Context.Tag<IncomingMessage, Http.IncomingMessage>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Node.ts",
      "path": "src/SocketServer/Node.ts"
    },
    "project": "@effect/experimental",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: (options: Net.ServerOpts & Net.ListenOptions) => Effect.Effect<SocketServer.SocketServer, SocketServer.SocketServerError, Scope.Scope>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Node.ts",
      "path": "src/SocketServer/Node.ts"
    },
    "project": "@effect/experimental",
    "name": "layer",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layer: (options: Net.ServerOpts & Net.ListenOptions) => Layer.Layer<SocketServer.SocketServer, SocketServer.SocketServerError>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Node.ts",
      "path": "src/SocketServer/Node.ts"
    },
    "project": "@effect/experimental",
    "name": "makeWebSocket",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const makeWebSocket: (options: WS.ServerOptions) => Effect.Effect<SocketServer.SocketServer, SocketServer.SocketServerError, Scope.Scope>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Node.ts",
      "path": "src/SocketServer/Node.ts"
    },
    "project": "@effect/experimental",
    "name": "layerWebSocket",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const layerWebSocket: (options: WS.ServerOptions) => Layer.Layer<SocketServer.SocketServer, SocketServer.SocketServerError>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Node.ts",
      "path": "src/SocketServer/Node.ts"
    },
    "project": "@effect/experimental",
    "name": "IncomingMessage",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "tags",
    "signature": "export interface IncomingMessage {\n  readonly _: unique symbol\n}"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Sse.ts",
      "path": "src/Sse.ts"
    },
    "project": "@effect/experimental",
    "name": "Retry",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class Retry"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sse.ts",
      "path": "src/Sse.ts"
    },
    "project": "@effect/experimental",
    "name": "RetryTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const RetryTypeId: unique symbol"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Sse.ts",
      "path": "src/Sse.ts"
    },
    "project": "@effect/experimental",
    "name": "makeParser",
    "description": "Create a SSE parser.\n\nAdapted from https://github.com/rexxars/eventsource-parser under MIT license.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const makeParser: (onParse: (event: AnyEvent) => void) => Parser"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Sse.ts",
      "path": "src/Sse.ts"
    },
    "project": "@effect/experimental",
    "name": "makeChannel",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const makeChannel: <IE, Done>(options?: { readonly bufferSize?: number; }) => Channel.Channel<Chunk.Chunk<Event>, Chunk.Chunk<string>, IE, IE, void, Done>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Sse.ts",
      "path": "src/Sse.ts"
    },
    "project": "@effect/experimental",
    "name": "Parser",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Parser {\n  feed(chunk: string): void\n  reset(): void\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Sse.ts",
      "path": "src/Sse.ts"
    },
    "project": "@effect/experimental",
    "name": "Event",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Event {\n  readonly _tag: \"Event\"\n  readonly event: string\n  readonly id: string | undefined\n  readonly data: string\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Sse.ts",
      "path": "src/Sse.ts"
    },
    "project": "@effect/experimental",
    "name": "RetryTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type RetryTypeId = typeof RetryTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Sse.ts",
      "path": "src/Sse.ts"
    },
    "project": "@effect/experimental",
    "name": "AnyEvent",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type AnyEvent = Event | Retry"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const TypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "FieldTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "declare const FieldTypeId: unique symbol"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "isStruct",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "guards",
    "signature": "declare const isStruct: (u: unknown) => u is Struct<any>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "isField",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "guards",
    "signature": "declare const isField: (u: unknown) => u is Field<any>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "fields",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "accessors",
    "signature": "declare const fields: <A extends Struct<any>>(self: A) => A[TypeId]"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: <const Variants extends ReadonlyArray<string>, const Default extends Variants[number]>(options: { readonly variants: Variants; readonly defaultVariant: Default; }) => { readonly Struct: <const A extends Struct.Fields>(fields: A & Struct.Validate<A, Variants[number]>) => Struct<A>; readonly Field: <const A extends Field.ConfigWithKeys<Variants[number]>>(config: A & { readonly [K in Exclude<keyof A, Variants[number]>]: never; }) => Field<A>; readonly FieldOnly: <const Keys extends ReadonlyArray<Variants[number]>>(...keys: Keys) => <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => Field<{ readonly [K in Keys[number]]: S; }>; readonly FieldExcept: <const Keys extends ReadonlyArray<Variants[number]>>(...keys: Keys) => <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => Field<{ readonly [K in Exclude<Variants[number], Keys[number]>]: S; }>; readonly fieldEvolve: { <Self extends Field<any> | Field.ValueAny, const Mapping extends (Self extends Field<infer S> ? { readonly [K in keyof S]?: (variant: S[K]) => Field.ValueAny; } : { readonly [K in Variants[number]]?: (variant: Self) => Field.ValueAny; })>(f: Mapping): (self: Self) => Field<Self extends Field<infer S> ? { readonly [K in keyof S]: K extends keyof Mapping ? Mapping[K] extends (arg: any) => any ? ReturnType<Mapping[K]> : S[K] : S[K]; } : { readonly [K in Variants[number]]: K extends keyof Mapping ? Mapping[K] extends (arg: any) => any ? ReturnType<Mapping[K]> : Self : Self; }>; <Self extends Field<any> | Field.ValueAny, const Mapping extends (Self extends Field<infer S> ? { readonly [K in keyof S]?: (variant: S[K]) => Field.ValueAny; } : { readonly [K in Variants[number]]?: (variant: Self) => Field.ValueAny; })>(self: Self, f: Mapping): Field<Self extends Field<infer S> ? { readonly [K in keyof S]: K extends keyof Mapping ? Mapping[K] extends (arg: any) => any ? ReturnType<Mapping[K]> : S[K] : S[K]; } : { readonly [K in Variants[number]]: K extends keyof Mapping ? Mapping[K] extends (arg: any) => any ? ReturnType<Mapping[K]> : Self : Self; }>; }; readonly fieldFromKey: { <Self extends Field<any> | Field.ValueAny, const Mapping extends (Self extends Field<infer S> ? { readonly [K in keyof S]?: string; } : { readonly [K in Variants[number]]?: string; })>(mapping: Mapping): (self: Self) => Field<Self extends Field<infer S> ? { readonly [K in keyof S]: K extends keyof Mapping ? Mapping[K] extends string ? fromKey.Rename<S[K], Mapping[K]> : S[K] : S[K]; } : { readonly [K in Variants[number]]: K extends keyof Mapping ? Mapping[K] extends string ? fromKey.Rename<Self, Mapping[K]> : Self : Self; }>; <Self extends Field<any> | Field.ValueAny, const Mapping extends (Self extends Field<infer S> ? { readonly [K in keyof S]?: string; } : { readonly [K in Variants[number]]?: string; })>(self: Self, mapping: Mapping): Field<Self extends Field<infer S> ? { readonly [K in keyof S]: K extends keyof Mapping ? Mapping[K] extends string ? fromKey.Rename<S[K], Mapping[K]> : S[K] : S[K]; } : { readonly [K in Variants[number]]: K extends keyof Mapping ? Mapping[K] extends string ? fromKey.Rename<Self, Mapping[K]> : Self : Self; }>; }; readonly Class: <Self = never>(identifier: string) => <const Fields extends Struct.Fields>(fields: Fields & Struct.Validate<Fields, Variants[number]>, annotations?: Schema.Annotations.Schema<Self>) => [Self] extends [never] ? MissingSelfGeneric : ClassFromFields<Self, Fields, Schema.Simplify<ExtractFields<Default, Fields, true>>> & { readonly [V in Variants[number]]: Extract<V, Struct<Fields>>; }; readonly Union: <const Members extends ReadonlyArray<Struct<any>>>(...members: Members) => Union<Members> & Union.Variants<Members, Variants[number]>; readonly extract: { <V extends Variants[number]>(variant: V): <A extends Struct<any>>(self: A) => Extract<V, A, V extends Default ? true : false>; <V extends Variants[number], A extends Struct<any>>(self: A, variant: V): Extract<V, A, V extends Default ? true : false>; }; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Override",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "overrideable",
    "signature": "declare const Override: <A>(value: A) => A & Brand<\"Override\">"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Overrideable",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "overrideable",
    "signature": "declare const Overrideable: <From, IFrom, RFrom, To, ITo, R>(from: Schema.Schema<From, IFrom, RFrom>, to: Schema.Schema<To, ITo>, options: { readonly generate: (_: Option.Option<ITo>) => Effect.Effect<From, ParseResult.ParseIssue, R>; readonly decode?: Schema.Schema<ITo, From>; readonly constructorDefault?: () => To; }) => Overrideable<To, IFrom, RFrom | R>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Struct",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Struct<in out A extends Field.Fields> extends Pipeable {\n  readonly [TypeId]: A\n  /** @internal */\n  [cacheSymbol]?: Record<string, Schema.Schema.All>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Field",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Field<in out A extends Field.Config> extends Pipeable {\n  readonly [FieldTypeId]: FieldTypeId\n  readonly schemas: A\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Class",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Class<\n  Self,\n  Fields extends Struct.Fields,\n  SchemaFields extends Schema.Struct.Fields,\n  A,\n  I,\n  R,\n  C\n> extends Schema.Schema<Self, Schema.Simplify<I>, R>, Struct<Fields> {\n  new(\n    props: RequiredKeys<C> extends never ? void | Schema.Simplify<C>\n      : Schema.Simplify<C>,\n    options?: {\n      readonly disableValidation?: boolean\n    }\n  ): A\n\n  readonly ast: AST.Transformation\n\n  make<Args extends Array<any>, X>(\n    this: { new(...args: Args): X },\n    ...args: Args\n  ): X\n\n  annotations(\n    annotations: Schema.Annotations.Schema<Self>\n  ): Schema.SchemaClass<Self, Schema.Simplify<I>, R>\n\n  readonly identifier: string\n  readonly fields: SchemaFields\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Union",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Union<Members extends ReadonlyArray<Struct<any>>> extends\n  Schema.Union<\n    {\n      readonly [K in keyof Members]: [Members[K]] extends [Schema.Schema.All] ? Members[K] : never\n    }\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "fromKey",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface fromKey<S extends Schema.Schema.All, Key extends string> extends\n  Schema.PropertySignature<\n    \":\",\n    Schema.Schema.Type<S>,\n    Key,\n    \":\",\n    Schema.Schema.Encoded<S>,\n    false,\n    Schema.Schema.Context<S>\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Overrideable",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "overrideable",
    "signature": "export interface Overrideable<To, From, R = never>\n  extends Schema.PropertySignature<\":\", (To & Brand<\"Override\">) | undefined, never, \":\", From, true, R>\n{}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type TypeId = typeof TypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "FieldTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "type ids",
    "signature": "type FieldTypeId = typeof FieldTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "ExtractFields",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "extractors",
    "signature": "type ExtractFields<V, Fields, IsDefault> = {\n  readonly [\n    K in keyof Fields as [Fields[K]] extends [Field<infer Config>] ? V extends keyof Config ? K\n      : never\n      : K\n  ]: [Fields[K]] extends [Struct<infer _>] ? Extract<V, Fields[K], IsDefault>\n    : [Fields[K]] extends [Field<infer Config>]\n      ? [Config[V]] extends [Schema.Schema.All | Schema.PropertySignature.All] ? Config[V]\n      : never\n    : [Fields[K]] extends [Schema.Schema.All | Schema.PropertySignature.All] ? Fields[K]\n    : never\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Extract",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "extractors",
    "signature": "type Extract<V, A, IsDefault> = [A] extends [\n  Struct<infer Fields>\n] ?\n  IsDefault extends true\n    ? [A] extends [Schema.Schema.Any] ? A : Schema.Struct<Schema.Simplify<ExtractFields<V, Fields>>>\n  : Schema.Struct<Schema.Simplify<ExtractFields<V, Fields>>>\n  : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Struct.Any",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Any = { readonly [TypeId]: any }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Struct.Fields",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Fields = {\n    readonly [key: string]:\n      | Schema.Schema.All\n      | Schema.PropertySignature.All\n      | Field<any>\n      | Struct<any>\n      | undefined\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Struct.Validate",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Validate<A, Variant> = {\n    readonly [K in keyof A]: A[K] extends { readonly [TypeId]: infer _ } ? Validate<A[K], Variant> :\n      A[K] extends Field<infer Config> ? [keyof Config] extends [Variant] ? {} : \"field must have valid variants\"\n      : {}\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Field.Any",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Any = { readonly [FieldTypeId]: FieldTypeId }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Field.Config",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Config = {\n    readonly [key: string]: Schema.Schema.All | Schema.PropertySignature.All | undefined\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Field.ConfigWithKeys",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type ConfigWithKeys<K> = {\n    readonly [P in K]?: Schema.Schema.All | Schema.PropertySignature.All\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Field.Fields",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Fields = {\n    readonly [key: string]:\n      | Schema.Schema.All\n      | Schema.PropertySignature.All\n      | Field<any>\n      | Struct<any>\n      | undefined\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "Union.Variants",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Union.Variants<Members, Variants> = {\n    readonly [Variant in Variants]: Schema.Union<\n      {\n        [K in keyof Members]: Extract<Variant, Members[K]>\n      }\n    >\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "VariantSchema.ts",
      "path": "src/VariantSchema.ts"
    },
    "project": "@effect/experimental",
    "name": "fromKey.Rename",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type Rename<S, Key> = S extends Schema.PropertySignature<\n    infer _TypeToken,\n    infer _Type,\n    infer _Key,\n    infer _EncodedToken,\n    infer _Encoded,\n    infer _HasDefault,\n    infer _R\n  > ? Schema.PropertySignature<_TypeToken, _Type, Key, _EncodedToken, _Encoded, _HasDefault, _R>\n    : S extends Schema.Schema.All ? fromKey<S, Key>\n    : never"
  }
]