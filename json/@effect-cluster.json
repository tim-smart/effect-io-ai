[
  {
    "_tag": "Constant",
    "module": {
      "name": "AtLeastOnce.ts",
      "path": "src/AtLeastOnce.ts"
    },
    "project": "@effect/cluster",
    "name": "atLeastOnceRecipientBehaviour",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const atLeastOnceRecipientBehaviour: <Msg, R>(fa: RecipientBehaviour.RecipientBehaviour<Msg, R>) => RecipientBehaviour.RecipientBehaviour<Msg, R | AtLeastOnceStorage.AtLeastOnceStorage>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "AtLeastOnce.ts",
      "path": "src/AtLeastOnce.ts"
    },
    "project": "@effect/cluster",
    "name": "runPendingMessageSweeperScoped",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const runPendingMessageSweeperScoped: (interval: Duration.Duration) => Effect.Effect<void, never, AtLeastOnceStorage.AtLeastOnceStorage | Sharding.Sharding | Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "AtLeastOnceStorage.ts",
      "path": "src/AtLeastOnceStorage.ts"
    },
    "project": "@effect/cluster",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const TypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "AtLeastOnceStorage.ts",
      "path": "src/AtLeastOnceStorage.ts"
    },
    "project": "@effect/cluster",
    "name": "AtLeastOnceStorage",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "context",
    "signature": "declare const AtLeastOnceStorage: Tag<AtLeastOnceStorage, AtLeastOnceStorage>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "AtLeastOnceStorage.ts",
      "path": "src/AtLeastOnceStorage.ts"
    },
    "project": "@effect/cluster",
    "name": "layer",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "context",
    "signature": "declare const layer: (options: AtLeastOnceStorage.MakeOptions) => Layer<AtLeastOnceStorage, SqlError, SqlClient | Serialization>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "AtLeastOnceStorage.ts",
      "path": "src/AtLeastOnceStorage.ts"
    },
    "project": "@effect/cluster",
    "name": "AtLeastOnceStorage",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface AtLeastOnceStorage extends AtLeastOnceStorage.Proto {\n  /**\n   * Upserts a message into the storage, eventually returning the already\n   * existing message state as result in the storage.\n   */\n  upsert<Msg extends Message.Any>(\n    recipientType: RecipientType<Msg>,\n    shardId: ShardId,\n    entityId: string,\n    message: Msg\n  ): Effect<void>\n\n  /**\n   * Marks the specified message as processed to prevent additional attempts to\n   * send the message.\n   */\n  markAsProcessed<Msg extends Message.Any>(\n    recipientType: RecipientType<Msg>,\n    shardId: ShardId,\n    entityId: string,\n    message: Msg\n  ): Effect<void>\n\n  /**\n   * Returns a stream of messages that will be sent to the local pod as a second\n   * attempt.\n   */\n  sweepPending(shardIds: Iterable<ShardId>): Stream<SerializedEnvelope>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "AtLeastOnceStorage.ts",
      "path": "src/AtLeastOnceStorage.ts"
    },
    "project": "@effect/cluster",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type TypeId = typeof TypeId"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "AtLeastOnceStorage.ts",
      "path": "src/AtLeastOnceStorage.ts"
    },
    "project": "@effect/cluster",
    "name": "AtLeastOnceStorage.Proto",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Proto {\n    readonly [TypeId]: TypeId\n  }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "AtLeastOnceStorage.ts",
      "path": "src/AtLeastOnceStorage.ts"
    },
    "project": "@effect/cluster",
    "name": "AtLeastOnceStorage.MakeOptions",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface MakeOptions {\n    readonly table: string\n  }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Broadcaster.ts",
      "path": "src/Broadcaster.ts"
    },
    "project": "@effect/cluster",
    "name": "Broadcaster",
    "description": "An interface to communicate with a remote broadcast receiver",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Broadcaster<Msg extends Message.Message.Any> {\n  /**\n   * Broadcast a message without waiting for a response (fire and forget)\n   *\n   * You can use Effect timeout to get send timeouts. The default behaviour is to send the message indifinetely.\n   * @since 1.0.0\n   */\n  readonly broadcastDiscard: (\n    topicId: string\n  ) => (message: Msg) => Effect.Effect<void, ShardingException.ShardingException>\n\n  /**\n   * Broadcast a message and wait for a response from each consumer\n   *\n   * You can use Effect timeout to get send timeouts. The default behaviour is to send the message indifinetely\n   * @since 1.0.0\n   */\n  readonly broadcast: (\n    topicId: string\n  ) => <A extends Msg>(\n    message: A\n  ) => Effect.Effect<\n    HashMap.HashMap<\n      PodAddress.PodAddress,\n      Either.Either<\n        ShardingException.ShardingException | Message.Message.Error<A>,\n        Message.Message.Success<A>\n      >\n    >,\n    ShardingException.ShardingException\n  >\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ManagerConfig.ts",
      "path": "src/ManagerConfig.ts"
    },
    "project": "@effect/cluster",
    "name": "ManagerConfigTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const ManagerConfigTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ManagerConfig.ts",
      "path": "src/ManagerConfig.ts"
    },
    "project": "@effect/cluster",
    "name": "ManagerConfig",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "context",
    "signature": "declare const ManagerConfig: Context.Tag<ManagerConfig, ManagerConfig>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ManagerConfig.ts",
      "path": "src/ManagerConfig.ts"
    },
    "project": "@effect/cluster",
    "name": "defaults",
    "description": "Uses the default as ManagerConfig.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const defaults: Layer.Layer<ManagerConfig, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ManagerConfig.ts",
      "path": "src/ManagerConfig.ts"
    },
    "project": "@effect/cluster",
    "name": "fromConfig",
    "description": "Reads the ManagerConfig from the provided Config.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const fromConfig: Layer.Layer<ManagerConfig, ConfigError.ConfigError, never>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ManagerConfig.ts",
      "path": "src/ManagerConfig.ts"
    },
    "project": "@effect/cluster",
    "name": "ManagerConfig",
    "description": "This is the Shard Manager configuration.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface ManagerConfig {\n  readonly numberOfShards: number\n  readonly apiPort: number\n  readonly rebalanceInterval: Duration.Duration\n  readonly rebalanceRetryInterval: Duration.Duration\n  readonly pingTimeout: Duration.Duration\n  readonly persistRetryInterval: Duration.Duration\n  readonly persistRetryCount: number\n  readonly rebalanceRate: number\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ManagerConfig.ts",
      "path": "src/ManagerConfig.ts"
    },
    "project": "@effect/cluster",
    "name": "ManagerConfigTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type ManagerConfigTypeId = typeof ManagerConfigTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Message.ts",
      "path": "src/Message.ts"
    },
    "project": "@effect/cluster",
    "name": "TaggedMessage",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "declare const TaggedMessage: <Self>() => <Tag extends string, E, IE, A, IA, Fields extends Schema.Struct.Fields>(tag: Tag, failure: Schema.Schema<E, IE, never>, success: Schema.Schema<A, IA, never>, fields: Fields, messageToId: (message: Schema.Struct.Encoded<Fields>) => string) => TaggedMessageConstructor<Tag, Self, Schema.Schema.Context<Fields[keyof Fields]>, Types.Simplify<Schema.Struct.Encoded<Fields>>, Types.Simplify<Schema.Struct.Type<Fields>>, IE, E, IA, A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Message.ts",
      "path": "src/Message.ts"
    },
    "project": "@effect/cluster",
    "name": "isMessageWithResult",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const isMessageWithResult: (value: unknown) => value is Message<unknown, unknown, unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Message.ts",
      "path": "src/Message.ts"
    },
    "project": "@effect/cluster",
    "name": "exitSchema",
    "description": "Extracts the exit schema from a Message. This schema will be used to encode the remote exit of the Message processor.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const exitSchema: <A extends Message.Any>(message: A) => Schema.Schema<Message.Exit<A>, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Message.ts",
      "path": "src/Message.ts"
    },
    "project": "@effect/cluster",
    "name": "failureSchema",
    "description": "Extracts the failure schema from a Message. This schema will be used to encode remote failures of the Message processor.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const failureSchema: <A extends Message.Any>(message: A) => Schema.Schema<Message.Error<A>, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Message.ts",
      "path": "src/Message.ts"
    },
    "project": "@effect/cluster",
    "name": "successSchema",
    "description": "Extracts the success schema from a Message. This schema will be used to encode the remote success of the Message processor.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const successSchema: <A extends Message.Any>(message: A) => Schema.Schema<Message.Success<A>, unknown>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Message.ts",
      "path": "src/Message.ts"
    },
    "project": "@effect/cluster",
    "name": "Message",
    "description": "A Message is a request for an entity that will process it.\nA Message also has a PrimaryKey so that the receiver is eventually able to detect duplicated messages.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Message<A, AI, E, EI>\n  extends Schema.SerializableWithResult<any, any, never, A, AI, E, EI, never>, PrimaryKey.PrimaryKey\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Message.ts",
      "path": "src/Message.ts"
    },
    "project": "@effect/cluster",
    "name": "TaggedMessageConstructor",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schemas",
    "signature": "export interface TaggedMessageConstructor<Tag extends string, Self, R, IS, S, IE, E, IA, A>\n  extends Schema.Schema<Self, Types.Simplify<IS & { readonly _tag: Tag }>, R>\n{\n  new(\n    props: Types.Equals<S, {}> extends true ? void : S,\n    disableValidation?: boolean\n  ):\n    & Schema.TaggedRequest<Tag, S, IS & { readonly _tag: Tag }, never, A, IA, E, IE, never>\n    & S\n    & PrimaryKey.PrimaryKey\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Message.ts",
      "path": "src/Message.ts"
    },
    "project": "@effect/cluster",
    "name": "Message.Any",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Any = | Message<any, any, any, any>\n    | Message<any, any, never, never>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Message.ts",
      "path": "src/Message.ts"
    },
    "project": "@effect/cluster",
    "name": "Message.Success",
    "description": "Extracts the success type from a `Message`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "type Success<S> = S extends Message<infer A, infer _AI, infer _E, infer _EI> ? A : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Message.ts",
      "path": "src/Message.ts"
    },
    "project": "@effect/cluster",
    "name": "Message.SuccessEncoded",
    "description": "Extracts the success type from a `Message`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "type SuccessEncoded<S> = S extends Message<infer _A, infer _AI, infer _E, infer _EI> ? _AI : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Message.ts",
      "path": "src/Message.ts"
    },
    "project": "@effect/cluster",
    "name": "Message.Error",
    "description": "Extracts the error type from a `Message`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "type Error<S> = S extends Message<infer _A, infer _AI, infer E, infer _EI> ? E : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Message.ts",
      "path": "src/Message.ts"
    },
    "project": "@effect/cluster",
    "name": "Message.ErrorEncoded",
    "description": "Extracts the error type from a `Message`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "type ErrorEncoded<S> = S extends Message<infer _A, infer _AI, infer _E, infer _EI> ? _EI : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Message.ts",
      "path": "src/Message.ts"
    },
    "project": "@effect/cluster",
    "name": "Message.Exit",
    "description": "Extracts the exit type from a `Message`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "type Exit<S> = S extends Schema.WithResult<infer A, infer _AI, infer E, infer _EI, infer _R> ? Exit_.Exit<A, E>\n    : never"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MessageState.ts",
      "path": "src/MessageState.ts"
    },
    "project": "@effect/cluster",
    "name": "MessageStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const MessageStateTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MessageState.ts",
      "path": "src/MessageState.ts"
    },
    "project": "@effect/cluster",
    "name": "isMessageState",
    "description": "Ensures that the given value is a MessageState",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const isMessageState: (value: unknown) => value is MessageState<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MessageState.ts",
      "path": "src/MessageState.ts"
    },
    "project": "@effect/cluster",
    "name": "match",
    "description": "Match over the possible states of a MessageState",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const match: <A, B, C = B>(cases: { onAcknowledged: (value: MessageStateAcknowledged) => B; onProcessed: (exit: MessageStateProcessed<A>) => C; }) => (value: MessageState<A>) => B | C"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MessageState.ts",
      "path": "src/MessageState.ts"
    },
    "project": "@effect/cluster",
    "name": "Acknowledged",
    "description": "Constructs an AcknowledgedMessageState.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const Acknowledged: MessageStateAcknowledged"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MessageState.ts",
      "path": "src/MessageState.ts"
    },
    "project": "@effect/cluster",
    "name": "Processed",
    "description": "Constructs a ProcessedMessageState from the result of the message being processed.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const Processed: <A>(result: A) => MessageStateProcessed<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MessageState.ts",
      "path": "src/MessageState.ts"
    },
    "project": "@effect/cluster",
    "name": "mapEffect",
    "description": "Effectfully transform the <A> type of the MessageState<A>.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const mapEffect: <A, B, R, E>(value: MessageState<A>, fn: (value: A) => Effect.Effect<B, E, R>) => Effect.Effect<MessageState<B>, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MessageState.ts",
      "path": "src/MessageState.ts"
    },
    "project": "@effect/cluster",
    "name": "schema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schema",
    "signature": "declare const schema: <A, I>(result: Schema.Schema<A, I>) => Schema.Schema<MessageState<A>, MessageState.Encoded<I>>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MessageState.ts",
      "path": "src/MessageState.ts"
    },
    "project": "@effect/cluster",
    "name": "MessageStateAcknowledged",
    "description": "A message state given to just acknowledged messages.\nThis state tells the sender that the receiver has received the message and will eventually process it later.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface MessageStateAcknowledged {\n  readonly [MessageStateTypeId]: MessageStateTypeId\n  readonly _tag: \"@effect/cluster/MessageState/Acknowledged\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MessageState.ts",
      "path": "src/MessageState.ts"
    },
    "project": "@effect/cluster",
    "name": "MessageStateProcessed",
    "description": "A message state given to processed messages.\nThis state tells the sender that the receiver has already received and processed the message.\nThis will also tell the sender the result for this message.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface MessageStateProcessed<A> {\n  readonly [MessageStateTypeId]: MessageStateTypeId\n  readonly _tag: \"@effect/cluster/MessageState/Processed\"\n  readonly result: A\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MessageState.ts",
      "path": "src/MessageState.ts"
    },
    "project": "@effect/cluster",
    "name": "MessageStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type MessageStateTypeId = typeof MessageStateTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MessageState.ts",
      "path": "src/MessageState.ts"
    },
    "project": "@effect/cluster",
    "name": "MessageState",
    "description": "Once a Message is sent to an entity to be processed,\nthe state of that message over that entity is either Acknoledged (not yet processed) or Processed.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type MessageState<A> = MessageStateAcknowledged | MessageStateProcessed<A>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MessageState.ts",
      "path": "src/MessageState.ts"
    },
    "project": "@effect/cluster",
    "name": "MessageState.Encoded",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type Encoded<I> = {\n    readonly \"@effect/cluster/MessageState\": \"@effect/cluster/MessageState\"\n    readonly _tag: \"@effect/cluster/MessageState/Acknowledged\"\n  } | {\n    readonly result: I\n    readonly \"@effect/cluster/MessageState\": \"@effect/cluster/MessageState\"\n    readonly _tag: \"@effect/cluster/MessageState/Processed\"\n  }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Messenger.ts",
      "path": "src/Messenger.ts"
    },
    "project": "@effect/cluster",
    "name": "Messenger",
    "description": "An interface to communicate with a remote entity.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Messenger<Msg extends Message.Message.Any> {\n  /**\n   * Send a message without waiting for a response (fire and forget)\n   *\n   * You can use Effect timeout to get send timeouts. The default behaviour is to send the message indifinetely\n   *\n   * @since 1.0.0\n   */\n  sendDiscard(entityId: string): (message: Msg) => Effect.Effect<void, ShardingException.ShardingException>\n\n  /**\n   * Send a message and wait for a response.\n   *\n   * You can use Effect timeout to get send timeouts. The default behaviour is to send the message indifinetely\n   *\n   * @since 1.0.0\n   */\n  send(\n    entityId: string\n  ): <A extends Msg>(\n    message: A\n  ) => Effect.Effect<\n    Message.Message.Success<A>,\n    ShardingException.ShardingException | Message.Message.Error<A>\n  >\n}"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Pod.ts",
      "path": "src/Pod.ts"
    },
    "project": "@effect/cluster",
    "name": "Pod",
    "description": "A pod is an application server that is able to run entities. A pod can run multiple entities,\nbut a single entity will live on a given pod at a time.\nSince this is an application server, it needs to have an unique identifier where it's addressed (PodAddress),\nand has a version of the application that's running on it.\nVersion is used during the rebalance phase to give priority to newer application servers and slowly kill older ones.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class Pod"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pod.ts",
      "path": "src/Pod.ts"
    },
    "project": "@effect/cluster",
    "name": "PodTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const PodTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pod.ts",
      "path": "src/Pod.ts"
    },
    "project": "@effect/cluster",
    "name": "schema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schema",
    "signature": "declare const schema: Schema.Schema<Pod, Pod.Encoded, never>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Pod.ts",
      "path": "src/Pod.ts"
    },
    "project": "@effect/cluster",
    "name": "isPod",
    "description": "Given a value, ensures that it's a valid Pod.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const isPod: (value: unknown) => value is Pod"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Pod.ts",
      "path": "src/Pod.ts"
    },
    "project": "@effect/cluster",
    "name": "make",
    "description": "Constructs a Pod from it's identifing PodAddress and application server version.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: (address: PodAddress.PodAddress, version: string) => Pod"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Pod.ts",
      "path": "src/Pod.ts"
    },
    "project": "@effect/cluster",
    "name": "PodTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type PodTypeId = typeof PodTypeId"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Pod.ts",
      "path": "src/Pod.ts"
    },
    "project": "@effect/cluster",
    "name": "Pod.Encoded",
    "description": "This is the shape that a Pod is represented over the wire.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Encoded extends Schema.Schema.Encoded<typeof Pod> {}"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "PodAddress.ts",
      "path": "src/PodAddress.ts"
    },
    "project": "@effect/cluster",
    "name": "PodAddress",
    "description": "A PodAddress is a unique identifier of a Pod (application server).\nIt is conventially built by using an address and a port, so that messaging implementations may use directly the\nPodAddress to know how to connect to the specific Pod.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class PodAddress"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PodAddress.ts",
      "path": "src/PodAddress.ts"
    },
    "project": "@effect/cluster",
    "name": "PodAddressTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const PodAddressTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PodAddress.ts",
      "path": "src/PodAddress.ts"
    },
    "project": "@effect/cluster",
    "name": "schema",
    "description": "This is the schema for a PodAddress.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schema",
    "signature": "declare const schema: Schema.Schema<PodAddress, PodAddress.Encoded, never>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "PodAddress.ts",
      "path": "src/PodAddress.ts"
    },
    "project": "@effect/cluster",
    "name": "make",
    "description": "Constructs a PodAddress from an host and a port.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: (host: string, port: number) => PodAddress"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "PodAddress.ts",
      "path": "src/PodAddress.ts"
    },
    "project": "@effect/cluster",
    "name": "isPodAddress",
    "description": "Ensures that the given value is a valid PodAddress.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const isPodAddress: (value: unknown) => value is PodAddress"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "PodAddress.ts",
      "path": "src/PodAddress.ts"
    },
    "project": "@effect/cluster",
    "name": "PodAddressTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type PodAddressTypeId = typeof PodAddressTypeId"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "PodAddress.ts",
      "path": "src/PodAddress.ts"
    },
    "project": "@effect/cluster",
    "name": "PodAddress.Encoded",
    "description": "This is the shape one PodAddress has over the wire.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Encoded extends Schema.Schema.Encoded<typeof PodAddress> {}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pods.ts",
      "path": "src/Pods.ts"
    },
    "project": "@effect/cluster",
    "name": "PodsTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const PodsTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pods.ts",
      "path": "src/Pods.ts"
    },
    "project": "@effect/cluster",
    "name": "Pods",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "context",
    "signature": "declare const Pods: Context.Tag<Pods, Pods>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pods.ts",
      "path": "src/Pods.ts"
    },
    "project": "@effect/cluster",
    "name": "make",
    "description": "Constructs a Pods service from its implementation",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "context",
    "signature": "declare const make: (args: Omit<Pods, typeof PodsTypeId>) => Pods"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pods.ts",
      "path": "src/Pods.ts"
    },
    "project": "@effect/cluster",
    "name": "noop",
    "description": "A layer that creates a service that does nothing when called.\nUseful for testing ShardManager or when using Sharding.local.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const noop: Layer.Layer<Pods, never, never>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Pods.ts",
      "path": "src/Pods.ts"
    },
    "project": "@effect/cluster",
    "name": "Pods",
    "description": "An interface to communicate with remote pods.\nThis is used by the Shard Manager for assigning and unassigning shards.\nThis is also used by pods for internal communication (forward messages to each other).",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Pods {\n  /**\n   * @since 1.0.0\n   */\n  readonly [PodsTypeId]: PodsTypeId\n\n  /**\n   * Notify a pod that it was assigned a list of shards\n   * @since 1.0.0\n   */\n  readonly assignShards: (\n    pod: PodAddress.PodAddress,\n    shards: HashSet.HashSet<ShardId.ShardId>\n  ) => Effect.Effect<void, ShardingException.PodUnavailableException>\n\n  /**\n   * Notify a pod that it was unassigned a list of shards\n   * @since 1.0.0\n   */\n  readonly unassignShards: (\n    pod: PodAddress.PodAddress,\n    shards: HashSet.HashSet<ShardId.ShardId>\n  ) => Effect.Effect<void, ShardingException.PodUnavailableException>\n\n  /**\n   * Check that a pod is responsive\n   * @since 1.0.0\n   */\n  readonly ping: (pod: PodAddress.PodAddress) => Effect.Effect<void, ShardingException.PodUnavailableException>\n\n  /**\n   * Send a message to a pod and receive its message state\n   * @since 1.0.0\n   */\n  readonly sendAndGetState: (\n    pod: PodAddress.PodAddress,\n    envelope: SerializedEnvelope.SerializedEnvelope\n  ) => Effect.Effect<\n    MessageState.MessageState<SerializedMessage.SerializedMessage>,\n    ShardingException.ShardingException\n  >\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Pods.ts",
      "path": "src/Pods.ts"
    },
    "project": "@effect/cluster",
    "name": "PodsTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type PodsTypeId = typeof PodsTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PodsHealth.ts",
      "path": "src/PodsHealth.ts"
    },
    "project": "@effect/cluster",
    "name": "PodsHealthTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const PodsHealthTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PodsHealth.ts",
      "path": "src/PodsHealth.ts"
    },
    "project": "@effect/cluster",
    "name": "make",
    "description": "Constructs a PodsHealth from its implementation",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: (args: Omit<PodsHealth, typeof PodsHealthTypeId>) => PodsHealth"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PodsHealth.ts",
      "path": "src/PodsHealth.ts"
    },
    "project": "@effect/cluster",
    "name": "PodsHealth",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "context",
    "signature": "declare const PodsHealth: Context.Tag<PodsHealth, PodsHealth>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PodsHealth.ts",
      "path": "src/PodsHealth.ts"
    },
    "project": "@effect/cluster",
    "name": "noop",
    "description": "A layer that considers pods as always alive.\nThis is useful for testing only.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const noop: Layer.Layer<PodsHealth, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PodsHealth.ts",
      "path": "src/PodsHealth.ts"
    },
    "project": "@effect/cluster",
    "name": "local",
    "description": "A layer that pings the pod directly to check if it's alive.\nThis is useful for developing and testing but not reliable in production.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const local: Layer.Layer<PodsHealth, never, Pods.Pods>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "PodsHealth.ts",
      "path": "src/PodsHealth.ts"
    },
    "project": "@effect/cluster",
    "name": "PodsHealth",
    "description": "An interface to check a pod's health.\nThis is used when a pod is unresponsive, to check if it should be unassigned all its shards or not.\nIf the pod is alive, shards will not be unassigned because the pods might still be processing messages and might be responsive again.\nIf the pod is not alive, shards can be safely reassigned somewhere else.\nA typical implementation for this is using k8s to check if the pod still exists.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface PodsHealth {\n  /**\n   * @since 1.0.0\n   */\n  readonly [PodsHealthTypeId]: PodsHealthTypeId\n\n  /**\n   * Check if a pod is still alive.\n   * @since 1.0.0\n   */\n  readonly isAlive: (podAddress: PodAddress.PodAddress) => Effect.Effect<boolean>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "PodsHealth.ts",
      "path": "src/PodsHealth.ts"
    },
    "project": "@effect/cluster",
    "name": "PodsHealthTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type PodsHealthTypeId = typeof PodsHealthTypeId"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "PoisonPill.ts",
      "path": "src/PoisonPill.ts"
    },
    "project": "@effect/cluster",
    "name": "PoisonPill",
    "description": "A PoisonPill is a special value that tells a behaviour entity to shut itself down.\nPoisonPill is handled only when you are using a Queue-based RecipientBehaviour.\nOther RecipientBehaviour such as fromFunctionEffect would not care about PoisonPill.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class PoisonPill"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PoisonPill.ts",
      "path": "src/PoisonPill.ts"
    },
    "project": "@effect/cluster",
    "name": "PoisonPillTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const PoisonPillTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PoisonPill.ts",
      "path": "src/PoisonPill.ts"
    },
    "project": "@effect/cluster",
    "name": "make",
    "description": "Constructs a new PosionPill",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: Effect.Effect<PoisonPill, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PoisonPill.ts",
      "path": "src/PoisonPill.ts"
    },
    "project": "@effect/cluster",
    "name": "schema",
    "description": "This is the schema for a PoisonPill that is used to encode the value over the wire.\nThis is useful if you want a behavior that can be shut down from an external message.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schema",
    "signature": "declare const schema: Schema.Schema<PoisonPill, PoisonPill.Encoded, never>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "PoisonPill.ts",
      "path": "src/PoisonPill.ts"
    },
    "project": "@effect/cluster",
    "name": "isPoisonPill",
    "description": "Checks if the given value is a PoisonPill.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const isPoisonPill: (value: unknown) => value is PoisonPill"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "PoisonPill.ts",
      "path": "src/PoisonPill.ts"
    },
    "project": "@effect/cluster",
    "name": "takeOrInterrupt",
    "description": "Attempts to take a message from the queue in the same way Queue.take does.\nIf the result is a PoisonPill, it will interrupt the effect.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const takeOrInterrupt: <Req>(dequeue: Queue.Dequeue<Req | PoisonPill>) => Effect.Effect<Req>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "PoisonPill.ts",
      "path": "src/PoisonPill.ts"
    },
    "project": "@effect/cluster",
    "name": "PoisonPillTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type PoisonPillTypeId = typeof PoisonPillTypeId"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "PoisonPill.ts",
      "path": "src/PoisonPill.ts"
    },
    "project": "@effect/cluster",
    "name": "PoisonPill.Encoded",
    "description": "This is the shape that a PoisonPill takes over the wire.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Encoded extends Schema.Schema.Encoded<typeof PoisonPill> {}"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "RecipientAddress.ts",
      "path": "src/RecipientAddress.ts"
    },
    "project": "@effect/cluster",
    "name": "RecipientAddress",
    "description": "A RecipientAddress uniquely identifies a RecipientType + EntityId instance.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class RecipientAddress"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RecipientAddress.ts",
      "path": "src/RecipientAddress.ts"
    },
    "project": "@effect/cluster",
    "name": "RecipientAddressTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const RecipientAddressTypeId: unique symbol"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "RecipientAddress.ts",
      "path": "src/RecipientAddress.ts"
    },
    "project": "@effect/cluster",
    "name": "isRecipientAddress",
    "description": "Ensure that given value is a RecipientAddress",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const isRecipientAddress: (value: unknown) => value is RecipientAddress"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "RecipientAddress.ts",
      "path": "src/RecipientAddress.ts"
    },
    "project": "@effect/cluster",
    "name": "makeRecipientAddress",
    "description": "Given a name and a schema for the protocol, constructs an EntityType.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const makeRecipientAddress: (recipientTypeName: string, entityId: string) => RecipientAddress"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RecipientBehaviour.ts",
      "path": "src/RecipientBehaviour.ts"
    },
    "project": "@effect/cluster",
    "name": "fromFunctionEffect",
    "description": "This is the simplest behaviour you can have.\nYou provide a function that given the entityId and the message, it will immediatly process it.\nYou are then required to return a MessageState to tell the caller\nif the message has just arrived and will be later processed or it has been processed.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const fromFunctionEffect: <Msg extends Message.Message.Any, R>(handler: (entityId: string, message: Msg) => Effect.Effect<MessageState.MessageState<Message.Message.Exit<Msg>>, never, R>) => RecipientBehaviour<Msg, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RecipientBehaviour.ts",
      "path": "src/RecipientBehaviour.ts"
    },
    "project": "@effect/cluster",
    "name": "fromFunctionEffectStateful",
    "description": "This is a stateful version of fromFunctionEffect.\nYou can provide a function to get the initialState, and then it will be passed as Ref.\nEverything here is just stored in memory, so eventual persistence of the state is up to you!",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const fromFunctionEffectStateful: <S, R, Msg extends Message.Message.Any, R2>(initialState: (entityId: string) => Effect.Effect<S, never, R>, handler: (entityId: string, message: Msg, stateRef: Ref.Ref<S>) => Effect.Effect<MessageState.MessageState<Message.Message.Exit<Msg>>, never, R2>) => RecipientBehaviour<Msg, R | R2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RecipientBehaviour.ts",
      "path": "src/RecipientBehaviour.ts"
    },
    "project": "@effect/cluster",
    "name": "fromInMemoryQueue",
    "description": "This behaviour uses a Queue where the entity will accumulate messages to be processed,\nand then you can use the Dequeue to take messages and process them.\nA PoisonPill is provided to request interruption of the entity behaviour.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const fromInMemoryQueue: <Msg extends Message.Message.Any, R>(handler: (entityId: string, dequeue: Queue.Dequeue<Msg | PoisonPill.PoisonPill>, processed: <A extends Msg>(message: A, value: Option.Option<Message.Message.Exit<A>>) => Effect.Effect<void, never, never>) => Effect.Effect<void, never, R>) => RecipientBehaviour<Msg, R>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RecipientBehaviour.ts",
      "path": "src/RecipientBehaviour.ts"
    },
    "project": "@effect/cluster",
    "name": "RecipientBehaviour",
    "description": "A RecipientBehaviour describes how a specific RecipientType should behave.\nThis is the actual implementation of what an entity should do upon receiving a Msg,\nthis could require additional context.\n\nThe scope provided in the context is controlled by the cluster EntityManager,\nand is used to request the shoutdown of the entity,\nso you can safely scope whatever resource you want to use for your behaviour\n and the EntityManager will close the scope for you when the entity is shoutdown.\n\nThe function returned by the RecipientBehaviour effect is what we call \"offer\" effect.\nThe offer effect is used by the EntityManager to give messages to the RecipientBehaviour.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface RecipientBehaviour<Msg, R> extends\n  Effect.Effect<\n    <A extends Msg>(\n      message: A\n    ) => Effect.Effect<\n      MessageState.MessageState<Message.Message.Exit<A>>,\n      ShardingException.ExceptionWhileOfferingMessageException\n    >,\n    never,\n    R | RecipientBehaviourContext.RecipientBehaviourContext | Scope.Scope\n  >\n{}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RecipientBehaviour.ts",
      "path": "src/RecipientBehaviour.ts"
    },
    "project": "@effect/cluster",
    "name": "EntityBehaviourOptions",
    "description": "This are the options for an EntityBehaviour. This controls the entityMaxIdleTime,\ncheck out more on that over the ShardingConfig.\nThis allows to override the setting for a specific entity.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "type EntityBehaviourOptions = {\n  entityMaxIdleTime?: Option.Option<Duration.Duration>\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RecipientBehaviourContext.ts",
      "path": "src/RecipientBehaviourContext.ts"
    },
    "project": "@effect/cluster",
    "name": "RecipientBehaviourContextTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const RecipientBehaviourContextTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RecipientBehaviourContext.ts",
      "path": "src/RecipientBehaviourContext.ts"
    },
    "project": "@effect/cluster",
    "name": "RecipientBehaviourContext",
    "description": "A tag to access current RecipientBehaviourContext",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "context",
    "signature": "declare const RecipientBehaviourContext: Context.Tag<RecipientBehaviourContext, RecipientBehaviourContext>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RecipientBehaviourContext.ts",
      "path": "src/RecipientBehaviourContext.ts"
    },
    "project": "@effect/cluster",
    "name": "make",
    "description": "Creates a new RecipientBehaviourContext",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: (args: Omit<RecipientBehaviourContext, typeof RecipientBehaviourContextTypeId>) => RecipientBehaviourContext"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RecipientBehaviourContext.ts",
      "path": "src/RecipientBehaviourContext.ts"
    },
    "project": "@effect/cluster",
    "name": "entityId",
    "description": "Gets the current entityId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const entityId: Effect.Effect<string, never, RecipientBehaviourContext>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RecipientBehaviourContext.ts",
      "path": "src/RecipientBehaviourContext.ts"
    },
    "project": "@effect/cluster",
    "name": "recipientAddress",
    "description": "Gets the current entityId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const recipientAddress: Effect.Effect<RecipientAddress.RecipientAddress, never, RecipientBehaviourContext>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RecipientBehaviourContext.ts",
      "path": "src/RecipientBehaviourContext.ts"
    },
    "project": "@effect/cluster",
    "name": "shardId",
    "description": "Gets the current shardId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const shardId: Effect.Effect<ShardId.ShardId, never, RecipientBehaviourContext>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RecipientBehaviourContext.ts",
      "path": "src/RecipientBehaviourContext.ts"
    },
    "project": "@effect/cluster",
    "name": "recipientType",
    "description": "Gets the current recipientType",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const recipientType: Effect.Effect<RecipientType.RecipientType<Message.Message.Any>, never, RecipientBehaviourContext>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RecipientBehaviourContext.ts",
      "path": "src/RecipientBehaviourContext.ts"
    },
    "project": "@effect/cluster",
    "name": "forkShutdown",
    "description": "Forks the shutdown of the current recipient behaviour as soon as possible.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const forkShutdown: Effect.Effect<void, never, RecipientBehaviourContext>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RecipientBehaviourContext.ts",
      "path": "src/RecipientBehaviourContext.ts"
    },
    "project": "@effect/cluster",
    "name": "RecipientBehaviourContext",
    "description": "This is the context information that is available to the RecipientBehaviour and has general informations\nabout this specific entity, like the entityId or the recipientType.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface RecipientBehaviourContext {\n  readonly [RecipientBehaviourContextTypeId]: RecipientBehaviourContextTypeId\n  readonly recipientAddress: RecipientAddress.RecipientAddress\n  readonly shardId: ShardId.ShardId\n  readonly recipientType: RecipientType.RecipientType<Message.Message.Any>\n  readonly forkShutdown: Effect.Effect<void>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RecipientBehaviourContext.ts",
      "path": "src/RecipientBehaviourContext.ts"
    },
    "project": "@effect/cluster",
    "name": "RecipientBehaviourContextTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type RecipientBehaviourContextTypeId = typeof RecipientBehaviourContextTypeId"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "RecipientType.ts",
      "path": "src/RecipientType.ts"
    },
    "project": "@effect/cluster",
    "name": "EntityType",
    "description": "An EntityType is a RecipientType that is ensured to be alive only on a single Pod at a time.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class EntityType<Msg>"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "RecipientType.ts",
      "path": "src/RecipientType.ts"
    },
    "project": "@effect/cluster",
    "name": "TopicType",
    "description": "A TopicType can live on multiple Pods at the same time.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class TopicType<Msg>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RecipientType.ts",
      "path": "src/RecipientType.ts"
    },
    "project": "@effect/cluster",
    "name": "RecipientTypeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const RecipientTypeTypeId: unique symbol"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "RecipientType.ts",
      "path": "src/RecipientType.ts"
    },
    "project": "@effect/cluster",
    "name": "isRecipientType",
    "description": "Ensure that given value is a RecipientType",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const isRecipientType: <A extends Message.Message.Any>(value: unknown) => value is RecipientType<A>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "RecipientType.ts",
      "path": "src/RecipientType.ts"
    },
    "project": "@effect/cluster",
    "name": "makeEntityType",
    "description": "Given a name and a schema for the protocol, constructs an EntityType.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const makeEntityType: <Msg extends Message.Message.Any, I>(name: string, schema: Schema.Schema<Msg, I>) => EntityType<Msg>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "RecipientType.ts",
      "path": "src/RecipientType.ts"
    },
    "project": "@effect/cluster",
    "name": "makeTopicType",
    "description": "Given a name and a schema for the protocol, constructs an TopicType.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const makeTopicType: <Msg extends Message.Message.Any, I>(name: string, schema: Schema.Schema<Msg, I>) => TopicType<Msg>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RecipientType.ts",
      "path": "src/RecipientType.ts"
    },
    "project": "@effect/cluster",
    "name": "RecipientType",
    "description": "A RecipientType is basically a pointer to a logical grouping of multiple enties having the same RecipientBehaviour.\nThis value is required to be able to message with an entity/topic since it holds the Schema for the messages over the wire.\nWithout the schema, you cannot ensure that the messages sent are what the receiver expects.\nIdeally, you can share this definition between the caller and the receiver.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type RecipientType<Msg> = EntityType<Msg> | TopicType<Msg>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Serialization.ts",
      "path": "src/Serialization.ts"
    },
    "project": "@effect/cluster",
    "name": "SerializationTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const SerializationTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Serialization.ts",
      "path": "src/Serialization.ts"
    },
    "project": "@effect/cluster",
    "name": "Serialization",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "context",
    "signature": "declare const Serialization: Context.Tag<Serialization, Serialization>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Serialization.ts",
      "path": "src/Serialization.ts"
    },
    "project": "@effect/cluster",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: (args: Omit<Serialization, typeof SerializationTypeId>) => Serialization"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Serialization.ts",
      "path": "src/Serialization.ts"
    },
    "project": "@effect/cluster",
    "name": "json",
    "description": "A layer that uses JSON serialization for encoding and decoding messages.\nThis is useful for testing and not recommended to use in production.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const json: Layer.Layer<Serialization, never, never>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Serialization.ts",
      "path": "src/Serialization.ts"
    },
    "project": "@effect/cluster",
    "name": "Serialization",
    "description": "An interface to serialize user messages that will be sent between pods.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Serialization {\n  /**\n   * @since 1.0.0\n   */\n  readonly [SerializationTypeId]: SerializationTypeId\n\n  /**\n   * Transforms the given message into binary\n   * @since 1.0.0\n   */\n  readonly encode: <A, I>(\n    schema: Schema.Schema<A, I>,\n    message: A\n  ) => Effect.Effect<SerializedMessage.SerializedMessage, ShardingException.SerializationException>\n\n  /**\n   * Transform binary back into the given type\n   * @since 1.0.0\n   */\n  readonly decode: <A, I>(\n    schema: Schema.Schema<A, I>,\n    bytes: SerializedMessage.SerializedMessage\n  ) => Effect.Effect<A, ShardingException.SerializationException>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Serialization.ts",
      "path": "src/Serialization.ts"
    },
    "project": "@effect/cluster",
    "name": "SerializationTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type SerializationTypeId = typeof SerializationTypeId"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SerializedEnvelope.ts",
      "path": "src/SerializedEnvelope.ts"
    },
    "project": "@effect/cluster",
    "name": "SerializedEnvelope",
    "description": "A SerializedEnvelope is the message that goes over the wire between pods.\nInside the Envelope, you have the encoded messages, plus some informations on where it should be routed to.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class SerializedEnvelope"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SerializedEnvelope.ts",
      "path": "src/SerializedEnvelope.ts"
    },
    "project": "@effect/cluster",
    "name": "SerializedEnvelopeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const SerializedEnvelopeTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SerializedEnvelope.ts",
      "path": "src/SerializedEnvelope.ts"
    },
    "project": "@effect/cluster",
    "name": "schema",
    "description": "This is the schema for a value.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schema",
    "signature": "declare const schema: Schema.Schema<SerializedEnvelope, SerializedEnvelope.Encoded, never>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SerializedEnvelope.ts",
      "path": "src/SerializedEnvelope.ts"
    },
    "project": "@effect/cluster",
    "name": "make",
    "description": "Construct a new `SerializedEnvelope`",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: (recipientAddress: RecipientAddress.RecipientAddress, messageId: string, body: SerializedMessage.SerializedMessage) => SerializedEnvelope"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SerializedEnvelope.ts",
      "path": "src/SerializedEnvelope.ts"
    },
    "project": "@effect/cluster",
    "name": "isSerializedEnvelope",
    "description": "Ensures that the given value is a SerializedEnvelope.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const isSerializedEnvelope: (value: unknown) => value is SerializedEnvelope"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SerializedEnvelope.ts",
      "path": "src/SerializedEnvelope.ts"
    },
    "project": "@effect/cluster",
    "name": "SerializedEnvelopeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type SerializedEnvelopeTypeId = typeof SerializedEnvelopeTypeId"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SerializedEnvelope.ts",
      "path": "src/SerializedEnvelope.ts"
    },
    "project": "@effect/cluster",
    "name": "SerializedEnvelope.Encoded",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Encoded extends Schema.Schema.Encoded<typeof SerializedEnvelope> {}"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SerializedMessage.ts",
      "path": "src/SerializedMessage.ts"
    },
    "project": "@effect/cluster",
    "name": "SerializedMessage",
    "description": "Represents a Message that has been serialized.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class SerializedMessage"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SerializedMessage.ts",
      "path": "src/SerializedMessage.ts"
    },
    "project": "@effect/cluster",
    "name": "SerializedMessageTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const SerializedMessageTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SerializedMessage.ts",
      "path": "src/SerializedMessage.ts"
    },
    "project": "@effect/cluster",
    "name": "schema",
    "description": "This is the schema for a value.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schema",
    "signature": "declare const schema: Schema.Schema<SerializedMessage, SerializedMessage.Encoded, never>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SerializedMessage.ts",
      "path": "src/SerializedMessage.ts"
    },
    "project": "@effect/cluster",
    "name": "make",
    "description": "Construct a new `SerializedMessage` from its internal string value.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: (value: string) => SerializedMessage"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SerializedMessage.ts",
      "path": "src/SerializedMessage.ts"
    },
    "project": "@effect/cluster",
    "name": "isSerializedMessage",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const isSerializedMessage: (value: unknown) => value is SerializedMessage"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SerializedMessage.ts",
      "path": "src/SerializedMessage.ts"
    },
    "project": "@effect/cluster",
    "name": "SerializedMessageTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type SerializedMessageTypeId = typeof SerializedMessageTypeId"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SerializedMessage.ts",
      "path": "src/SerializedMessage.ts"
    },
    "project": "@effect/cluster",
    "name": "SerializedMessage.Encoded",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Encoded extends Schema.Schema.Encoded<typeof SerializedMessage> {}"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ShardId.ts",
      "path": "src/ShardId.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardId",
    "description": "A shard is a logical grouping of multiple entities. There could be thousands of entities in your system,\nso instead of managing every single entity id, the shard manager group them by shard id, and when they are assigned\nor moved around, we always move all the entities with the same shard id.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class ShardId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardId.ts",
      "path": "src/ShardId.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardIdTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const ShardIdTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardId.ts",
      "path": "src/ShardId.ts"
    },
    "project": "@effect/cluster",
    "name": "schema",
    "description": "This is the schema for a ShardId.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schema",
    "signature": "declare const schema: Schema.Schema<ShardId, ShardId.Encoded, never>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ShardId.ts",
      "path": "src/ShardId.ts"
    },
    "project": "@effect/cluster",
    "name": "make",
    "description": "Constructs a shard id from its numerical value.\nThe shard id is currently built up by making the hash of the entity id, and then modulo the max amount of shards configured in ManagerConfig.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: (value: number) => ShardId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ShardId.ts",
      "path": "src/ShardId.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardIdTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type ShardIdTypeId = typeof ShardIdTypeId"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ShardId.ts",
      "path": "src/ShardId.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardId.Encoded",
    "description": "This is the shape that a shard id has over the wire.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Encoded extends Schema.Schema.Encoded<typeof ShardId> {}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardingTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const ShardingTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "Tag",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "context",
    "signature": "declare const Tag: Tag<Sharding, Sharding>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "live",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const live: Layer<Sharding, never, Storage | ShardingConfig | Pods | ShardManagerClient | Serialization>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "register",
    "description": "Notify the shard manager that shards can now be assigned to this pod.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const register: Effect.Effect<void, never, Sharding>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "unregister",
    "description": "Notify the shard manager that shards must be unassigned from this pod.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const unregister: Effect.Effect<void, never, Sharding>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "registerScoped",
    "description": "Same as `register`, but will automatically call `unregister` when the `Scope` is terminated.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const registerScoped: Effect.Effect<void, never, Sharding | Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "registerSingleton",
    "description": "Start a computation that is guaranteed to run only on a single pod.\nEach pod should call `registerSingleton` but only a single pod will actually run it at any given time.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const registerSingleton: <R>(name: string, run: Effect.Effect<void, never, R>) => Effect.Effect<void, never, Sharding | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "registerEntity",
    "description": "Register a new entity type, allowing pods to send messages to entities of this type.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const registerEntity: <Msg extends Message.Message.Any>(entityType: RecipentType.EntityType<Msg>) => <R>(behavior: RecipientBehaviour.RecipientBehaviour<Msg, R>, options?: RecipientBehaviour.EntityBehaviourOptions | undefined) => Effect.Effect<void, never, Sharding | Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "registerTopic",
    "description": "Register a new topic type, allowing pods to broadcast messages to subscribers.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const registerTopic: <Msg extends Message.Message.Any>(topicType: RecipentType.TopicType<Msg>) => <R>(behavior: RecipientBehaviour.RecipientBehaviour<Msg, R>, options?: RecipientBehaviour.EntityBehaviourOptions | undefined) => Effect.Effect<void, never, Sharding | Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "messenger",
    "description": "Get an object that allows sending messages to a given entity type.\nYou can provide a custom send timeout to override the one globally defined.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const messenger: <Msg extends Message.Message.Any>(entityType: RecipentType.EntityType<Msg>) => Effect.Effect<Messenger<Msg>, never, Sharding>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "broadcaster",
    "description": "Get an object that allows broadcasting messages to a given topic type.\nYou can provide a custom send timeout to override the one globally defined.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const broadcaster: <Msg extends Message.Message.Any>(topicType: RecipentType.TopicType<Msg>) => Effect.Effect<Broadcaster<Msg>, never, Sharding>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "getPods",
    "description": "Get the list of pods currently registered to the Shard Manager",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const getPods: Effect.Effect<HashSet.HashSet<PodAddress.PodAddress>, never, Sharding>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "sendMessageToLocalEntityManagerWithoutRetries",
    "description": "Sends a raw message to the local entity manager without performing reties.\nThose are up to the caller.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const sendMessageToLocalEntityManagerWithoutRetries: (message: SerializedEnvelope.SerializedEnvelope) => Effect.Effect<MessageState.MessageState<SerializedMessage.SerializedMessage>, ShardingException.ShardingException, Sharding>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "getAssignedShardIds",
    "description": "Gets the list of shardIds assigned to the current Pod",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const getAssignedShardIds: Effect.Effect<HashSet.HashSet<ShardId.ShardId>, never, Sharding>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "Sharding",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Sharding {\n  readonly [ShardingTypeId]: ShardingTypeId\n  readonly register: Effect.Effect<void>\n  readonly unregister: Effect.Effect<void>\n  readonly messenger: <Msg extends Message.Message.Any>(\n    entityType: RecipentType.EntityType<Msg>\n  ) => Messenger<Msg>\n  readonly broadcaster: <Msg extends Message.Message.Any>(\n    topicType: RecipentType.TopicType<Msg>\n  ) => Broadcaster<Msg>\n  readonly isEntityOnLocalShards: (\n    recipientAddress: RecipientAddress.RecipientAddress\n  ) => Effect.Effect<boolean>\n  readonly isShuttingDown: Effect.Effect<boolean>\n\n  readonly registerScoped: Effect.Effect<void, never, Scope.Scope>\n  readonly registerEntity: <Msg extends Message.Message.Any>(\n    entityType: RecipentType.EntityType<Msg>\n  ) => <R>(\n    behaviour: RecipientBehaviour.RecipientBehaviour<Msg, R>,\n    options?: RecipientBehaviour.EntityBehaviourOptions\n  ) => Effect.Effect<void, never, Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>>\n  readonly registerTopic: <Msg extends Message.Message.Any>(\n    topicType: RecipentType.TopicType<Msg>\n  ) => <R>(\n    behaviour: RecipientBehaviour.RecipientBehaviour<Msg, R>,\n    options?: RecipientBehaviour.EntityBehaviourOptions\n  ) => Effect.Effect<void, never, Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>>\n  readonly getShardingRegistrationEvents: Stream.Stream<ShardingRegistrationEvent.ShardingRegistrationEvent>\n  readonly registerSingleton: <R>(name: string, run: Effect.Effect<void, never, R>) => Effect.Effect<void, never, R>\n  readonly assign: (shards: HashSet.HashSet<ShardId.ShardId>) => Effect.Effect<void>\n  readonly unassign: (shards: HashSet.HashSet<ShardId.ShardId>) => Effect.Effect<void>\n  readonly sendMessageToLocalEntityManagerWithoutRetries: (\n    message: SerializedEnvelope.SerializedEnvelope\n  ) => Effect.Effect<\n    MessageState.MessageState<SerializedMessage.SerializedMessage>,\n    ShardingException.ShardingException\n  >\n  readonly getPods: Effect.Effect<HashSet.HashSet<PodAddress.PodAddress>>\n  readonly getAssignedShardIds: Effect.Effect<HashSet.HashSet<ShardId.ShardId>>\n  /** @internal */\n  readonly refreshAssignments: Effect.Effect<void, never, Scope.Scope>\n  /** @internal */\n  readonly getShardId: (recipientAddress: RecipientAddress.RecipientAddress) => ShardId.ShardId\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Sharding.ts",
      "path": "src/Sharding.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardingTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type ShardingTypeId = typeof ShardingTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardingConfig.ts",
      "path": "src/ShardingConfig.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardingConfigTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const ShardingConfigTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardingConfig.ts",
      "path": "src/ShardingConfig.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardingConfig",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "context",
    "signature": "declare const ShardingConfig: Context.Tag<ShardingConfig, ShardingConfig>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardingConfig.ts",
      "path": "src/ShardingConfig.ts"
    },
    "project": "@effect/cluster",
    "name": "defaults",
    "description": "Provides the default values for the ShardingConfig.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const defaults: Layer.Layer<ShardingConfig, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardingConfig.ts",
      "path": "src/ShardingConfig.ts"
    },
    "project": "@effect/cluster",
    "name": "withDefaults",
    "description": "Provides the ShardingConfig, values that are omitted will be read from the defaults",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const withDefaults: (customs: Partial<ShardingConfig>) => Layer.Layer<ShardingConfig>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardingConfig.ts",
      "path": "src/ShardingConfig.ts"
    },
    "project": "@effect/cluster",
    "name": "fromConfig",
    "description": "Reads the ShardingConfig from the effect/ConfigProvider",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const fromConfig: Layer.Layer<ShardingConfig, ConfigError.ConfigError, never>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ShardingConfig.ts",
      "path": "src/ShardingConfig.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardingConfig",
    "description": "Sharding configuration",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface ShardingConfig {\n  readonly numberOfShards: number\n  readonly selfHost: string\n  readonly shardingPort: number\n  readonly shardManagerUri: string\n  readonly serverVersion: string\n  readonly entityMaxIdleTime: Duration.Duration\n  readonly entityTerminationTimeout: Duration.Duration\n  readonly refreshAssignmentsRetryInterval: Duration.Duration\n  readonly unhealthyPodReportInterval: Duration.Duration\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ShardingConfig.ts",
      "path": "src/ShardingConfig.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardingConfigTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type ShardingConfigTypeId = typeof ShardingConfigTypeId"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ShardingEvent.ts",
      "path": "src/ShardingEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardsAssigned",
    "description": "Constructs the event that occurs when new shards are assigned to Pod.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const ShardsAssigned: (pod: PodAddress.PodAddress, shards: HashSet.HashSet<ShardId.ShardId>) => ShardsAssigned"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ShardingEvent.ts",
      "path": "src/ShardingEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardsUnassigned",
    "description": "Constructs the event that occurs when shards are unassigned to a Pod",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const ShardsUnassigned: (pod: PodAddress.PodAddress, shards: HashSet.HashSet<ShardId.ShardId>) => ShardsUnassigned"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ShardingEvent.ts",
      "path": "src/ShardingEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "PodHealthChecked",
    "description": "Constructs the event that occurs when the health of a Pod has been checked",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const PodHealthChecked: (pod: PodAddress.PodAddress) => PodHealthChecked"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ShardingEvent.ts",
      "path": "src/ShardingEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "PodRegistered",
    "description": "Constructs the event that occurs when a new Pod has registered",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const PodRegistered: (pod: PodAddress.PodAddress) => PodRegistered"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ShardingEvent.ts",
      "path": "src/ShardingEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "PodUnregistered",
    "description": "Constructs the event that occurs when a pod has unregistered",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const PodUnregistered: (pod: PodAddress.PodAddress) => PodUnregistered"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ShardingEvent.ts",
      "path": "src/ShardingEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardsAssigned",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface ShardsAssigned {\n  readonly _tag: \"ShardsAssigned\"\n  readonly pod: PodAddress.PodAddress\n  readonly shards: HashSet.HashSet<ShardId.ShardId>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ShardingEvent.ts",
      "path": "src/ShardingEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardsUnassigned",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface ShardsUnassigned {\n  readonly _tag: \"ShardsUnassigned\"\n  readonly pod: PodAddress.PodAddress\n  readonly shards: HashSet.HashSet<ShardId.ShardId>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ShardingEvent.ts",
      "path": "src/ShardingEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "PodHealthChecked",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface PodHealthChecked {\n  readonly _tag: \"PodHealthChecked\"\n  readonly pod: PodAddress.PodAddress\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ShardingEvent.ts",
      "path": "src/ShardingEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "PodRegistered",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface PodRegistered {\n  readonly _tag: \"PodRegistered\"\n  readonly pod: PodAddress.PodAddress\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ShardingEvent.ts",
      "path": "src/ShardingEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "PodUnregistered",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface PodUnregistered {\n  readonly _tag: \"PodUnregistered\"\n  readonly pod: PodAddress.PodAddress\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ShardingEvent.ts",
      "path": "src/ShardingEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardingEvent",
    "description": "This are the events that may occur over the ShardManager during its lifetime.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type ShardingEvent = | ShardsAssigned\n  | ShardsUnassigned\n  | PodHealthChecked\n  | PodRegistered\n  | PodUnregistered"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "EntityNotManagedByThisPodException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class EntityNotManagedByThisPodException"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "EntityTypeNotRegisteredException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class EntityTypeNotRegisteredException"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "NoResultInProcessedMessageStateException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class NoResultInProcessedMessageStateException"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "PodNoLongerRegisteredException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class PodNoLongerRegisteredException"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "PodUnavailableException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class PodUnavailableException"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "SerializationException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class SerializationException"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "ExceptionWhileOfferingMessageException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "declare class ExceptionWhileOfferingMessageException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "isEntityNotManagedByThisPodException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const isEntityNotManagedByThisPodException: (u: unknown, overrideOptions?: ParseOptions | number) => u is EntityNotManagedByThisPodException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "isEntityTypeNotRegisteredException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const isEntityTypeNotRegisteredException: (u: unknown, overrideOptions?: ParseOptions | number) => u is EntityTypeNotRegisteredException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "isNoResultInProcessedMessageStateException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const isNoResultInProcessedMessageStateException: (u: unknown, overrideOptions?: ParseOptions | number) => u is NoResultInProcessedMessageStateException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "isPodNoLongerRegisteredException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const isPodNoLongerRegisteredException: (u: unknown, overrideOptions?: ParseOptions | number) => u is PodNoLongerRegisteredException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "isPodUnavailableException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const isPodUnavailableException: (u: unknown, overrideOptions?: ParseOptions | number) => u is PodUnavailableException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "isSerializationException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const isSerializationException: (u: unknown, overrideOptions?: ParseOptions | number) => u is SerializationException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "isExceptionWhileOfferingMessageException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "utils",
    "signature": "declare const isExceptionWhileOfferingMessageException: (u: unknown, overrideOptions?: ParseOptions | number) => u is ExceptionWhileOfferingMessageException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "schema",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "schema",
    "signature": "declare const schema: Schema.Union<[typeof SerializationException, typeof EntityNotManagedByThisPodException, typeof EntityTypeNotRegisteredException, typeof PodNoLongerRegisteredException, typeof PodUnavailableException, typeof NoResultInProcessedMessageStateException, typeof ExceptionWhileOfferingMessageException]>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ShardingException.ts",
      "path": "src/ShardingException.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardingException",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type ShardingException = Schema.Schema.Type<typeof schema>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ShardingRegistrationEvent.ts",
      "path": "src/ShardingRegistrationEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "EntityRegistered",
    "description": "Constructs and event that occurs when a new EntityType gets registered.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const EntityRegistered: <Msg extends Message.Message.Any>(entityType: RecipientType.EntityType<Msg>) => ShardingRegistrationEvent"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ShardingRegistrationEvent.ts",
      "path": "src/ShardingRegistrationEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "SingletonRegistered",
    "description": "Constructs a new event that occurs when a new Singleton is registered.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const SingletonRegistered: (name: string) => ShardingRegistrationEvent"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ShardingRegistrationEvent.ts",
      "path": "src/ShardingRegistrationEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "TopicRegistered",
    "description": "Constructs a new event that occurs when a topic is Registered.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const TopicRegistered: <Msg extends Message.Message.Any>(topicType: RecipientType.TopicType<Msg>) => ShardingRegistrationEvent"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ShardingRegistrationEvent.ts",
      "path": "src/ShardingRegistrationEvent.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardingRegistrationEvent",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type ShardingRegistrationEvent = | EntityRegistered<any>\n  | SingletonRegistered\n  | TopicRegistered<any>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardManager.ts",
      "path": "src/ShardManager.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardManagerTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const ShardManagerTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardManager.ts",
      "path": "src/ShardManager.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardManager",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "context",
    "signature": "declare const ShardManager: Tag<ShardManager, ShardManager>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardManager.ts",
      "path": "src/ShardManager.ts"
    },
    "project": "@effect/cluster",
    "name": "live",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const live: Layer<ShardManager, never, Storage | Pods | ManagerConfig | PodsHealth>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ShardManager.ts",
      "path": "src/ShardManager.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardManager",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface ShardManager {\n  readonly getShardingEvents: Stream.Stream<ShardingEvent.ShardingEvent>\n  readonly register: (pod: Pod.Pod) => Effect.Effect<void>\n  readonly unregister: (podAddress: PodAddress.PodAddress) => Effect.Effect<void>\n  readonly notifyUnhealthyPod: (podAddress: PodAddress.PodAddress) => Effect.Effect<void>\n  readonly checkAllPodsHealth: Effect.Effect<void>\n  readonly getAssignments: Effect.Effect<HashMap.HashMap<ShardId.ShardId, Option.Option<PodAddress.PodAddress>>>\n  /* @internal */\n  readonly rebalance: (rebalanceImmediately: boolean) => Effect.Effect<void>\n  /* @internal */\n  readonly persistPods: Effect.Effect<void>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ShardManager.ts",
      "path": "src/ShardManager.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardManagerTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type ShardManagerTypeId = typeof ShardManagerTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardManagerClient.ts",
      "path": "src/ShardManagerClient.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardManagerClientTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const ShardManagerClientTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardManagerClient.ts",
      "path": "src/ShardManagerClient.ts"
    },
    "project": "@effect/cluster",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: (args: Omit<ShardManagerClient, typeof ShardManagerClientTypeId>) => ShardManagerClient"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardManagerClient.ts",
      "path": "src/ShardManagerClient.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardManagerClient",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "context",
    "signature": "declare const ShardManagerClient: Context.Tag<ShardManagerClient, ShardManagerClient>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ShardManagerClient.ts",
      "path": "src/ShardManagerClient.ts"
    },
    "project": "@effect/cluster",
    "name": "local",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const local: Layer.Layer<ShardManagerClient, never, ShardingConfig.ShardingConfig>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ShardManagerClient.ts",
      "path": "src/ShardManagerClient.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardManagerClient",
    "description": "ShardManagerClient provides the methods exposed by the ShardManager and called by the Pod.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface ShardManagerClient {\n  readonly [ShardManagerClientTypeId]: ShardManagerClientTypeId\n  readonly register: (podAddress: PodAddress.PodAddress) => Effect.Effect<void>\n  readonly unregister: (podAddress: PodAddress.PodAddress) => Effect.Effect<void>\n  readonly notifyUnhealthyPod: (podAddress: PodAddress.PodAddress) => Effect.Effect<void>\n  readonly getAssignments: Effect.Effect<HashMap.HashMap<ShardId.ShardId, Option.Option<PodAddress.PodAddress>>>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ShardManagerClient.ts",
      "path": "src/ShardManagerClient.ts"
    },
    "project": "@effect/cluster",
    "name": "ShardManagerClientTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type ShardManagerClientTypeId = typeof ShardManagerClientTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Storage.ts",
      "path": "src/Storage.ts"
    },
    "project": "@effect/cluster",
    "name": "StorageTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "declare const StorageTypeId: unique symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Storage.ts",
      "path": "src/Storage.ts"
    },
    "project": "@effect/cluster",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "constructors",
    "signature": "declare const make: (args: Omit<Storage, typeof StorageTypeId>) => Storage"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Storage.ts",
      "path": "src/Storage.ts"
    },
    "project": "@effect/cluster",
    "name": "Storage",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "context",
    "signature": "declare const Storage: Context.Tag<Storage, Storage>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Storage.ts",
      "path": "src/Storage.ts"
    },
    "project": "@effect/cluster",
    "name": "memory",
    "description": "A layer that stores data in-memory.\nThis is useful for testing with a single pod only.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const memory: Layer.Layer<Storage, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Storage.ts",
      "path": "src/Storage.ts"
    },
    "project": "@effect/cluster",
    "name": "noop",
    "description": "A layer that does nothing, useful for testing.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "layers",
    "signature": "declare const noop: Layer.Layer<Storage, never, never>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Storage.ts",
      "path": "src/Storage.ts"
    },
    "project": "@effect/cluster",
    "name": "Storage",
    "description": "The storage Service is responsible of persisting assignments and registered pods.\nThe storage is expected to be shared among all pods, so it works also as communication of assignments between Pods.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface Storage {\n  readonly [StorageTypeId]: StorageTypeId\n\n  /**\n   * Get the current state of shard assignments to pods\n   */\n  readonly getAssignments: Effect.Effect<HashMap.HashMap<ShardId.ShardId, Option.Option<PodAddress.PodAddress>>>\n\n  /**\n   * Save the current state of shard assignments to pods\n   */\n  readonly saveAssignments: (\n    assignments: HashMap.HashMap<ShardId.ShardId, Option.Option<PodAddress.PodAddress>>\n  ) => Effect.Effect<void>\n\n  /**\n   * A stream that will emit the state of shard assignments whenever it changes\n   */\n  readonly assignmentsStream: Stream.Stream<HashMap.HashMap<ShardId.ShardId, Option.Option<PodAddress.PodAddress>>>\n\n  /**\n   * Get the list of existing pods\n   */\n  readonly getPods: Effect.Effect<HashMap.HashMap<PodAddress.PodAddress, Pod.Pod>>\n\n  /**\n   * Save the list of existing pods\n   */\n  readonly savePods: (pods: HashMap.HashMap<PodAddress.PodAddress, Pod.Pod>) => Effect.Effect<void>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Storage.ts",
      "path": "src/Storage.ts"
    },
    "project": "@effect/cluster",
    "name": "StorageTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "symbols",
    "signature": "type StorageTypeId = typeof StorageTypeId"
  }
]