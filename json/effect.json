[
  {
    "_tag": "Function",
    "module": {
      "name": "Arbitrary.ts",
      "path": "src/Arbitrary.ts"
    },
    "project": "effect",
    "name": "makeLazy",
    "description": "Returns a LazyArbitrary for the `A` type of the provided schema.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "arbitrary",
    "signature": "declare const makeLazy: <A, I, R>(schema: Schema.Schema<A, I, R>) => LazyArbitrary<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Arbitrary.ts#L52"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Arbitrary.ts",
      "path": "src/Arbitrary.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Returns a fast-check Arbitrary for the `A` type of the provided schema.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "arbitrary",
    "signature": "declare const make: <A, I, R>(schema: Schema.Schema<A, I, R>) => FastCheck.Arbitrary<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Arbitrary.ts#L63"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Arbitrary.ts",
      "path": "src/Arbitrary.ts"
    },
    "project": "effect",
    "name": "LazyArbitrary",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface LazyArbitrary<A> {\n  (fc: typeof FastCheck): FastCheck.Arbitrary<A>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Arbitrary.ts#L21"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Arbitrary.ts",
      "path": "src/Arbitrary.ts"
    },
    "project": "effect",
    "name": "ArbitraryGenerationContext",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export interface ArbitraryGenerationContext {\n  readonly maxDepth: number\n  readonly depthIdentifier?: string\n  readonly constraints?: StringConstraints | NumberConstraints | BigIntConstraints | DateConstraints | ArrayConstraints\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Arbitrary.ts#L29"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Arbitrary.ts",
      "path": "src/Arbitrary.ts"
    },
    "project": "effect",
    "name": "ArbitraryAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type ArbitraryAnnotation<A, TypeParameters> = (\n  ...arbitraries: [\n    ...{ readonly [K in keyof TypeParameters]: LazyArbitrary<TypeParameters[K]> },\n    ctx: ArbitraryGenerationContext\n  ]\n) => LazyArbitrary<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Arbitrary.ts#L39"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "makeBy",
    "description": "Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n\n**Note**. `n` is normalized to an integer >= 1.\n\n**Example**\n\n```ts\nimport { makeBy } from \"effect/Array\"\n\nconst result = makeBy(5, n => n * 2)\nconsole.log(result) // [0, 2, 4, 6, 8]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeBy: { <A>(f: (i: number) => A): (n: number) => NonEmptyArray<A>; <A>(n: number, f: (i: number) => A): NonEmptyArray<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L96"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "replicate",
    "description": "Return a `NonEmptyArray` containing a value repeated the specified number of times.\n\n**Note**. `n` is normalized to an integer >= 1.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.replicate(\"a\", 3)\nconsole.log(result) // [\"a\", \"a\", \"a\"]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const replicate: { (n: number): <A>(a: A) => NonEmptyArray<A>; <A>(a: A, n: number): NonEmptyArray<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L143"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "fromRecord",
    "description": "Takes a record and returns an array of tuples containing its keys and values.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.fromRecord({ a: 1, b: 2, c: 3 })\nconsole.log(result) // [[\"a\", 1], [\"b\", 2], [\"c\", 3]]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Array<[K, A]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L201"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "fromOption",
    "description": "Converts an `Option` to an array.\n\n**Example**\n\n```ts\nimport { Array, Option } from \"effect\"\n\nconsole.log(Array.fromOption(Option.some(1))) // [1]\nconsole.log(Array.fromOption(Option.none())) // []\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const fromOption: <A>(self: Option.Option<A>) => Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L218"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Matches the elements of an array, applying functions to cases of empty and non-empty arrays.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst match = Array.match({\n  onEmpty: () => \"empty\",\n  onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`\n})\nconsole.log(match([])) // \"empty\"\nconsole.log(match([1, 2, 3])) // \"head: 1, tail: 2\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "declare const match: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C; }): B | C; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L239"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "matchLeft",
    "description": "Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst matchLeft = Array.matchLeft({\n  onEmpty: () => \"empty\",\n  onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`\n})\nconsole.log(matchLeft([])) // \"empty\"\nconsole.log(matchLeft([1, 2, 3])) // \"head: 1, tail: 2\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "declare const matchLeft: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (head: A, tail: Array<A>) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (head: A, tail: Array<A>) => C; }): B | C; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L280"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "matchRight",
    "description": "Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst matchRight = Array.matchRight({\n  onEmpty: () => \"empty\",\n  onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`\n})\nconsole.log(matchRight([])) // \"empty\"\nconsole.log(matchRight([1, 2, 3])) // \"init: 2, last: 3\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "declare const matchRight: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (init: Array<A>, last: A) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (init: Array<A>, last: A) => C; }): B | C; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L321"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "prepend",
    "description": "Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.prepend([2, 3, 4], 1)\nconsole.log(result) // [1, 2, 3, 4]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const prepend: { <B>(head: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, head: B): NonEmptyArray<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L361"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "prependAll",
    "description": "Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\nIf either array is non-empty, the result is also a non-empty array.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.prependAll([2, 3], [0, 1])\nconsole.log(result) // [0, 1, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const prependAll: { <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L382"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "append",
    "description": "Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.append([1, 2, 3], 4);\nconsole.log(result) // [1, 2, 3, 4]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const append: { <B>(last: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, last: B): NonEmptyArray<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L409"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "appendAll",
    "description": "Concatenates two arrays (or iterables), combining their elements.\nIf either array is non-empty, the result is also a non-empty array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const appendAll: { <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L421"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "scan",
    "description": "Accumulates values from an `Iterable` starting from the left, storing\neach intermediate result in an array. Useful for tracking the progression of\na value through a series of transformations.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\";\n\nconst result = Array.scan([1, 2, 3, 4], 0, (acc, value) => acc + value)\nconsole.log(result) // [0, 1, 3, 6, 10]\n\n// Explanation:\n// This function starts with the initial value (0 in this case)\n// and adds each element of the array to this accumulator one by one,\n// keeping track of the cumulative sum after each addition.\n// Each of these sums is captured in the resulting array.\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const scan: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L456"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "scanRight",
    "description": "Accumulates values from an `Iterable` starting from the right, storing\neach intermediate result in an array. Useful for tracking the progression of\na value through a series of transformations.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\";\n\nconst result = Array.scanRight([1, 2, 3, 4], 0, (acc, value) => acc + value)\nconsole.log(result) // [10, 9, 7, 4, 0]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const scanRight: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L486"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "isArray",
    "description": "Determine if `unknown` is an Array.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconsole.log(Array.isArray(null)) // false\nconsole.log(Array.isArray([1, 2, 3])) // true\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isArray: { (self: unknown): self is Array<unknown>; <T>(self: T): self is Extract<T, ReadonlyArray<any>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L514"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "isEmptyReadonlyArray",
    "description": "Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconsole.log(Array.isEmptyReadonlyArray([])) // true\nconsole.log(Array.isEmptyReadonlyArray([1, 2, 3])) // false\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is readonly []",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L551"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "isNonEmptyArray",
    "description": "Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.\n\nAn `Array` is considered to be a `NonEmptyArray` if it contains at least one element.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconsole.log(Array.isNonEmptyArray([])) // false\nconsole.log(Array.isNonEmptyArray([1, 2, 3])) // true\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isNonEmptyArray: <A>(self: Array<A>) => self is NonEmptyArray<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L570"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "isNonEmptyReadonlyArray",
    "description": "Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.\n\nA `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconsole.log(Array.isNonEmptyReadonlyArray([])) // false\nconsole.log(Array.isNonEmptyReadonlyArray([1, 2, 3])) // true\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isNonEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L589"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const get: { (index: number): <A>(self: ReadonlyArray<A>) => Option.Option<A>; <A>(self: ReadonlyArray<A>, index: number): Option.Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L610"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "unsafeGet",
    "description": "Gets an element unsafely, will throw on out of bounds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeGet: { (index: number): <A>(self: ReadonlyArray<A>) => A; <A>(self: ReadonlyArray<A>, index: number): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L624"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "head",
    "description": "Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const head: <A>(self: ReadonlyArray<A>) => Option.Option<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L679"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "headNonEmpty",
    "description": "Get the first element of a non empty array.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.headNonEmpty([1, 2, 3, 4])\nconsole.log(result) // 1\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const headNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L696"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "take",
    "description": "Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n\n**Note**. `n` is normalized to a non negative integer.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.take([1, 2, 3, 4, 5], 3)\nconsole.log(result) // [1, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const take: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L797"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "takeRight",
    "description": "Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n\n**Note**. `n` is normalized to a non negative integer.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.takeRight([1, 2, 3, 4, 5], 3)\nconsole.log(result) // [3, 4, 5]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const takeRight: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L822"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "takeWhile",
    "description": "Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\nconsole.log(result) // [1, 3, 2]\n\n// Explanation:\n// - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n// - The next element (`3`) is also less than `4`, so it adds `3`.\n// - The next element (`2`) is again less than `4`, so it adds `2`.\n// - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const takeWhile: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Array<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Array<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L852"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "span",
    "description": "Split an `Iterable` into two parts:\n\n1. the longest initial subarray for which all elements satisfy the specified predicate\n2. the remaining elements",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "declare const span: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => [init: Array<B>, rest: Array<Exclude<A, B>>]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [init: Array<A>, rest: Array<A>]; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [init: Array<B>, rest: Array<Exclude<A, B>>]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [init: Array<A>, rest: Array<A>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L890"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "drop",
    "description": "Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n\n**Note**. `n` is normalized to a non negative integer.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.drop([1, 2, 3, 4, 5], 2)\nconsole.log(result) // [3, 4, 5]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const drop: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L923"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "dropRight",
    "description": "Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n\n**Note**. `n` is normalized to a non negative integer.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.dropRight([1, 2, 3, 4, 5], 2)\nconsole.log(result) // [1, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const dropRight: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L948"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "dropWhile",
    "description": "Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)\nconsole.log(result) // [4, 5]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const dropWhile: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L971"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "findFirstIndex",
    "description": "Return the first index for which a predicate holds.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)\nconsole.log(result) // Option.some(2)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirstIndex: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<number>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L995"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "findLastIndex",
    "description": "Return the last index for which a predicate holds.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)\nconsole.log(result) // Option.some(1)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findLastIndex: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<number>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1024"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\nconsole.log(result) // Option.some(4)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirst: { <A, B>(f: (a: NoInfer<A>, i: number) => Option.Option<B>): (self: Iterable<A>) => Option.Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option.Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Option.Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option.Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1053"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "findLast",
    "description": "Finds the last element in an iterable collection that satisfies the given predicate or refinement.\nReturns an `Option` containing the found element, or `Option.none` if no element matches.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\nconsole.log(result) // Option.some(4)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findLast: { <A, B>(f: (a: NoInfer<A>, i: number) => Option.Option<B>): (self: Iterable<A>) => Option.Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option.Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Option.Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option.Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1078"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "insertAt",
    "description": "Insert an element at the specified index, creating a new `NonEmptyArray`,\nor return `None` if the index is out of bounds.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.insertAt(['a', 'b', 'c', 'e'], 3, 'd')\nconsole.log(result) // Option.some(['a', 'b', 'c', 'd', 'e'])\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const insertAt: { <B>(i: number, b: B): <A>(self: Iterable<A>) => Option.Option<NonEmptyArray<A | B>>; <A, B>(self: Iterable<A>, i: number, b: B): Option.Option<NonEmptyArray<A | B>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1124"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "replace",
    "description": "Change the element at the specified index, creating a new `Array`,\nor return a copy of the input if the index is out of bounds.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.replace(['a', 'b', 'c', 'd'], 1, 'z')\nconsole.log(result) // ['a', 'z', 'c', 'd']\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const replace: { <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1152"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "replaceOption",
    "description": "Replaces an element in an array with the given value, returning an option of the updated array.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.replaceOption([1, 2, 3], 1, 4)\nconsole.log(result) // Option.some([1, 4, 3])\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const replaceOption: { <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(self: S) => Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1180"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "modify",
    "description": "Apply a function to the element at the specified index, creating a new `Array`,\nor return a copy of the input if the index is out of bounds.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.modify([1, 2, 3, 4], 2, (n) => n * 2)\nconsole.log(result) // [1, 2, 6, 4]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const modify: { <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1212"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "modifyOption",
    "description": "Apply a function to the element at the specified index, creating a new `Array`,\nor return `None` if the index is out of bounds.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst input = [1, 2, 3, 4]\nconst result = Array.modifyOption(input, 2, (n) => n * 2)\nconsole.log(result) // Option.some([1, 2, 6, 4])\n\nconst outOfBoundsResult = Array.modifyOption(input, 5, (n) => n * 2)\nconsole.log(outOfBoundsResult) // Option.none()\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const modifyOption: { <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1247"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "remove",
    "description": "Delete the element at the specified index, creating a new `Array`,\nor return a copy of the input if the index is out of bounds.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst input = [1, 2, 3, 4]\nconst result = Array.remove(input, 2)\nconsole.log(result) // [1, 2, 4]\n\nconst outOfBoundsResult = Array.remove(input, 5)\nconsole.log(outOfBoundsResult) // [1, 2, 3, 4]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const remove: { (i: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, i: number): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1287"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "sort",
    "description": "Create a new array with elements sorted in increasing order based on the specified comparator.\nIf the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sorting",
    "signature": "declare const sort: { <B>(O: Order.Order<B>): <A extends B, S extends Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A extends B, B>(self: NonEmptyReadonlyArray<A>, O: Order.Order<B>): NonEmptyArray<A>; <A extends B, B>(self: Iterable<A>, O: Order.Order<B>): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1326"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "sortWith",
    "description": "Sorts an array based on a provided mapping function and order. The mapping\nfunction transforms the elements into a value that can be compared, and the\norder defines how those values should be sorted.\n\n**Example**\n\n```ts\nimport { Array, Order } from \"effect\"\n\nconst result = Array.sortWith([\"aaa\", \"b\", \"cc\"], (s) => s.length, Order.number)\nconsole.log(result) // [\"b\", \"cc\", \"aaa\"]\n\n// Explanation:\n// The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n// converts each string into its length, and the `Order.number` specifies that the lengths should\n// be sorted in ascending order.\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const sortWith: { <S extends Iterable<any>, B>(f: (a: ReadonlyArray.Infer<S>) => B, order: Order.Order<B>): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B, O: Order.Order<B>): NonEmptyArray<A>; <A, B>(self: Iterable<A>, f: (a: A) => B, order: Order.Order<B>): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1360"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Takes two `Iterable`s and returns an `Array` of corresponding pairs.\nIf one input `Iterable` is short, excess elements of the\nlonger `Iterable` are discarded.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.zip([1, 2, 3], ['a', 'b'])\nconsole.log(result) // [[1, 'a'], [2, 'b']]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zip: { <B>(that: NonEmptyReadonlyArray<B>): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<[A, B]>; <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<[A, B]>; <A, B>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<[A, B]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1444"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\ninput `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\nconsole.log(result) // [5, 7, 9]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWith: { <B, A, C>(that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<C>; <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Array<C>; <A, B, C>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): NonEmptyArray<C>; <B, A, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Array<C>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1470"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "unzip",
    "description": "This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.unzip([[1, \"a\"], [2, \"b\"], [3, \"c\"]])\nconsole.log(result) // [[1, 2, 3], ['a', 'b', 'c']]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const unzip: <S extends Iterable<readonly [any, any]>>(self: S) => S extends NonEmptyReadonlyArray<readonly [infer A, infer B]> ? [NonEmptyArray<A>, NonEmptyArray<B>] : S extends Iterable<readonly [infer A, infer B]> ? [Array<A>, Array<B>] : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1503"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "intersperse",
    "description": "Places an element in between members of an `Iterable`.\nIf the input is a non-empty array, the result is also a non-empty array.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.intersperse([1, 2, 3], 0)\nconsole.log(result) // [1, 0, 2, 0, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const intersperse: { <B>(middle: B): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B>(self: NonEmptyReadonlyArray<A>, middle: B): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, middle: B): Array<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1536"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "modifyNonEmptyHead",
    "description": "Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)\nconsole.log(result) // [10, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const modifyNonEmptyHead: { <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1572"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "setNonEmptyHead",
    "description": "Change the head, creating a new `NonEmptyReadonlyArray`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.setNonEmptyHead([1, 2, 3], 10)\nconsole.log(result) // [10, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const setNonEmptyHead: { <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1597"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "modifyNonEmptyLast",
    "description": "Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)\nconsole.log(result) // [1, 2, 6]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const modifyNonEmptyLast: { <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1619"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "setNonEmptyLast",
    "description": "Change the last element, creating a new `NonEmptyReadonlyArray`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.setNonEmptyLast([1, 2, 3], 4)\nconsole.log(result) // [1, 2, 4]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const setNonEmptyLast: { <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1642"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "rotate",
    "description": "Rotate an `Iterable` by `n` steps.\nIf the input is a non-empty array, the result is also a non-empty array.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.rotate(['a', 'b', 'c', 'd'], 2)\nconsole.log(result) // ['c', 'd', 'a', 'b']\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const rotate: { (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<A>; <A>(self: Iterable<A>, n: number): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1665"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "contains",
    "description": "Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.\n\n**Example**\n\n```ts\nimport { Array, pipe } from \"effect\"\n\nconst result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))\nconsole.log(result) // true\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const contains: { <A>(a: A): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, a: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1734"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "chop",
    "description": "A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n`Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\nvalue and the rest of the `Array`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\nconsole.log(result) // [2, 4, 6, 8, 10]\n\n// Explanation:\n// The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n// The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n// resulting in a new array `[2, 4, 6, 8, 10]`.\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const chop: { <S extends Iterable<any>, B>(f: (as: NonEmptyReadonlyArray<ReadonlyArray.Infer<S>>) => readonly [B, ReadonlyArray<ReadonlyArray.Infer<S>>]): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]): NonEmptyArray<B>; <A, B>(self: Iterable<A>, f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]): Array<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1760"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "splitAt",
    "description": "Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.\nThe value of `n` can be `0`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.splitAt([1, 2, 3, 4, 5], 3)\nconsole.log(result) // [[1, 2, 3], [4, 5]]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "declare const splitAt: { (n: number): <A>(self: Iterable<A>) => [beforeIndex: Array<A>, fromIndex: Array<A>]; <A>(self: Iterable<A>, n: number): [beforeIndex: Array<A>, fromIndex: Array<A>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1807"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "splitNonEmptyAt",
    "description": "Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.\nThe value of `n` must be `>= 1`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.splitNonEmptyAt([\"a\", \"b\", \"c\", \"d\", \"e\"], 3)\nconsole.log(result) // [[\"a\", \"b\", \"c\"], [\"d\", \"e\"]]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "declare const splitNonEmptyAt: { (n: number): <A>(self: NonEmptyReadonlyArray<A>) => [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]; <A>(self: NonEmptyReadonlyArray<A>, n: number): [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1838"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "split",
    "description": "Splits this iterable into `n` equally sized arrays.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.split([1, 2, 3, 4, 5, 6, 7, 8], 3)\nconsole.log(result) // [[1, 2, 3], [4, 5, 6], [7, 8]]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "declare const split: { (n: number): <A>(self: Iterable<A>) => Array<Array<A>>; <A>(self: Iterable<A>, n: number): Array<Array<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1863"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "splitWhere",
    "description": "Splits this iterable on the first element that matches this predicate.\nReturns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.splitWhere([1, 2, 3, 4, 5], n => n > 3)\nconsole.log(result) // [[1, 2, 3], [4, 5]]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "declare const splitWhere: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [beforeMatch: Array<A>, fromMatch: Array<A>]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [beforeMatch: Array<A>, fromMatch: Array<A>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1887"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "copy",
    "description": "Copies an array.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.copy([1, 2, 3])\nconsole.log(result) // [1, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const copy: { <A>(self: NonEmptyReadonlyArray<A>): NonEmptyArray<A>; <A>(self: ReadonlyArray<A>): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1912"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "pad",
    "description": "Pads an array.\nReturns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.\nIf `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.\nIf `n` is less than or equal to 0, the returned array will be an empty array.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.pad([1, 2, 3], 6, 0)\nconsole.log(result) // [1, 2, 3, 0, 0, 0]\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.8.4",
    "category": null,
    "signature": "declare const pad: { <A, T>(n: number, fill: T): (self: Array<A>) => Array<A | T>; <A, T>(self: Array<A>, n: number, fill: T): Array<A | T>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1934"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "chunksOf",
    "description": "Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\nthe `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\ndefinition of `chunksOf`; it satisfies the property that\n\n```ts skip-type-checking\nchunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n```\n\nwhenever `n` evenly divides the length of `self`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.chunksOf([1, 2, 3, 4, 5], 2)\nconsole.log(result) // [[1, 2], [3, 4], [5]]\n\n// Explanation:\n// The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n// It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n// the last chunk contains the remaining elements.\n// The result is `[[1, 2], [3, 4], [5]]`.\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "declare const chunksOf: { (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, NonEmptyArray<ReadonlyArray.Infer<S>>>; <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<NonEmptyArray<A>>; <A>(self: Iterable<A>, n: number): Array<NonEmptyArray<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1981"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "window",
    "description": "Creates sliding windows of size `n` from an `Iterable`.\nIf the number of elements is less than `n` or if `n` is not greater than zero,\nan empty array is returned.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nassert.deepStrictEqual(Array.window(numbers, 3), [[1, 2, 3], [2, 3, 4], [3, 4, 5]])\nassert.deepStrictEqual(Array.window(numbers, 6), [])\n```"
    ],
    "since": "3.13.2",
    "category": "splitting",
    "signature": "declare const window: { (n: number): <A>(self: Iterable<A>) => Array<Array<A>>; <A>(self: Iterable<A>, n: number): Array<Array<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2015"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "groupWith",
    "description": "Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.groupWith([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"a\"], (x, y) => x === y)\nconsole.log(result) // [[\"a\", \"a\"], [\"b\", \"b\", \"b\"], [\"c\"], [\"a\"]]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "declare const groupWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>; <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<NonEmptyArray<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2044"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "group",
    "description": "Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.group([1, 1, 2, 2, 2, 3, 1])\nconsole.log(result) // [[1, 1], [2, 2, 2], [3], [1]]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "declare const group: <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2081"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "groupBy",
    "description": "Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\nfunction on each element, and grouping the results according to values returned\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst people = [\n  { name: \"Alice\", group: \"A\" },\n  { name: \"Bob\", group: \"B\" },\n  { name: \"Charlie\", group: \"A\" }\n]\n\nconst result = Array.groupBy(people, person => person.group)\nconsole.log(result)\n// {\n//  A: [{ name: \"Alice\", group: \"A\" }, { name: \"Charlie\", group: \"A\" }],\n//  B: [{ name: \"Bob\", group: \"B\" }]\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "declare const groupBy: { <A, K extends string | symbol>(f: (a: A) => K): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; <A, K extends string | symbol>(self: Iterable<A>, f: (a: A) => K): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2111"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "unionWith",
    "description": "Calculates the union of two arrays using the provided equivalence relation.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\nconsole.log(union) // [1, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const unionWith: { <S extends Iterable<any>, T extends Iterable<any>>(that: T, isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<T>) => boolean): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>, isEquivalent: (self: A, that: B) => boolean): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>, isEquivalent: (self: A, that: B) => boolean): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>, isEquivalent: (self: A, that: B) => boolean): Array<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2149"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "union",
    "description": "Creates a union of two arrays, removing duplicates.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.union([1, 2], [2, 3])\nconsole.log(result) // [1, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const union: { <T extends Iterable<any>>(that: T): <S extends Iterable<any>>(self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, that: ReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: ReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2192"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "intersection",
    "description": "Creates an `Array` of unique values that are included in all given `Iterable`s.\nThe order and references of result values are determined by the first `Iterable`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.intersection([1, 2, 3], [3, 4, 1])\nconsole.log(result) // [1, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const intersection: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<A & B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A & B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2247"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "difference",
    "description": "Creates a `Array` of values not included in the other given `Iterable`.\nThe order and references of result values are determined by the first `Iterable`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst difference = Array.difference([1, 2, 3], [2, 3, 4])\nconsole.log(difference) // [1]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const difference: { <A>(that: Iterable<A>): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, that: Iterable<A>): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2295"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "map",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <S extends ReadonlyArray<any>, B>(f: (a: ReadonlyArray.Infer<S>, i: number) => B): (self: S) => ReadonlyArray.With<S, B>; <S extends ReadonlyArray<any>, B>(self: S, f: (a: ReadonlyArray.Infer<S>, i: number) => B): ReadonlyArray.With<S, B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2366"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMap: { <S extends ReadonlyArray<any>, T extends ReadonlyArray<any>>(f: (a: ReadonlyArray.Infer<S>, i: number) => T): (self: S) => ReadonlyArray.AndNonEmpty<S, T, ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A, i: number) => NonEmptyReadonlyArray<B>): NonEmptyArray<B>; <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => ReadonlyArray<B>): Array<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2379"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "flatten",
    "description": "Combines multiple arrays into a single array by concatenating all elements\nfrom each nested array. This function ensures that the structure of nested\narrays is collapsed into a single, flat array.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.flatten([[1, 2], [], [3, 4], [], [5, 6]])\nconsole.log(result) // [1, 2, 3, 4, 5, 6]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatten: <S extends ReadonlyArray<ReadonlyArray<any>>>(self: S) => ReadonlyArray.Flatten<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2419"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.\nThis method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.\n\n**Example**\n\n```ts\nimport { Array, Option } from \"effect\"\n\nconst evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n\nconst result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);\nconsole.log(result) // [4, 16]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterMap: { <A, B>(f: (a: A, i: number) => Option.Option<B>): (self: Iterable<A>) => Array<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Array<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2441"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "filterMapWhile",
    "description": "Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.\nThis method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.\nThis is useful when you need to transform an array but only up to the point where a certain condition holds true.\n\n**Example**\n\n```ts\nimport { Array, Option } from \"effect\"\n\nconst toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n\nconst result = Array.filterMapWhile([2, 4, 5], toSquareTillOdd)\nconsole.log(result) // [4, 16]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterMapWhile: { <A, B>(f: (a: A, i: number) => Option.Option<B>): (self: Iterable<A>) => Array<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Array<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2478"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "partitionMap",
    "description": "Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.\nThis function is particularly useful for operations where each element can result in two possible types,\nand you want to separate these types into different collections. For instance, separating validation results\ninto successes and failures.\n\n**Example**\n\n```ts\nimport { Array, Either } from \"effect\";\n\nconst isEven = (x: number) => x % 2 === 0\n\nconst result = Array.partitionMap([1, 2, 3, 4, 5], x =>\n  isEven(x) ? Either.right(x) : Either.left(x)\n)\nconsole.log(result)\n// [\n//   [1, 3, 5],\n//   [2, 4]\n// ]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const partitionMap: { <A, B, C>(f: (a: A, i: number) => Either.Either<C, B>): (self: Iterable<A>) => [left: Array<B>, right: Array<C>]; <A, B, C>(self: Iterable<A>, f: (a: A, i: number) => Either.Either<C, B>): [left: Array<B>, right: Array<C>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2522"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "getSomes",
    "description": "Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.\n\n**Example**\n\n```ts\nimport { Array, Option } from \"effect\"\n\nconst result = Array.getSomes([Option.some(1), Option.none(), Option.some(2)])\nconsole.log(result) // [1, 2]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const getSomes: <T extends Iterable<Option.Option<X>>, X = any>(self: T) => Array<Option.Option.Value<ReadonlyArray.Infer<T>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2559"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "filter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filter: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Array<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Array<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2623"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "partition",
    "description": "Separate elements based on a predicate that also exposes the index of the element.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\nconsole.log(result) // [[1, 3], [2, 4]]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const partition: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [excluded: Array<A>, satisfying: Array<A>]; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [excluded: Array<A>, satisfying: Array<A>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2657"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "separate",
    "description": "Separates an `Iterable` into two arrays based on a predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const separate: <T extends Iterable<Either.Either<any, any>>>(self: T) => [Array<Either.Either.Left<ReadonlyArray.Infer<T>>>, Array<Either.Either.Right<ReadonlyArray.Infer<T>>>]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2692"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "reduce",
    "description": "Reduces an array from the left.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)\nconsole.log(result) // 6\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduce: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2712"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "reduceRight",
    "description": "Reduces an array from the right.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)\nconsole.log(result) // 6\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduceRight: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2736"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "flatMapNullable",
    "description": "Maps over an array and flattens the result, removing null and undefined values.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.flatMapNullable([1, 2, 3], n => (n % 2 === 0 ? null : n))\nconsole.log(result) // [1, 3]\n\n// Explanation:\n// The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers\n// and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened\n// to remove null values, resulting in [1, 3].\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMapNullable: { <A, B>(f: (a: A) => B | null | undefined): (self: ReadonlyArray<A>) => Array<NonNullable<B>>; <A, B>(self: ReadonlyArray<A>, f: (a: A) => B | null | undefined): Array<NonNullable<B>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2811"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "every",
    "description": "Check if a predicate holds true for every `ReadonlyArray` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const every: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: ReadonlyArray<A>) => self is ReadonlyArray<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => boolean; <A, B extends A>(self: ReadonlyArray<A>, refinement: (a: A, i: number) => a is B): self is ReadonlyArray<B>; <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2864"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "some",
    "description": "Check if a predicate holds true for some `ReadonlyArray` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const some: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>; <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): self is NonEmptyReadonlyArray<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2883"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "extend",
    "description": "Extends an array with a function that maps each subarray to a value.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.extend([1, 2, 3], as => as.length)\nconsole.log(result) // [3, 2, 1]\n\n// Explanation:\n// The function maps each subarray starting from each element to its length.\n// The subarrays are: [1, 2, 3], [2, 3], [3].\n// The lengths are: 3, 2, 1.\n// Therefore, the result is [3, 2, 1].\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const extend: { <A, B>(f: (as: ReadonlyArray<A>) => B): (self: ReadonlyArray<A>) => Array<B>; <A, B>(self: ReadonlyArray<A>, f: (as: ReadonlyArray<A>) => B): Array<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2914"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "min",
    "description": "Finds the minimum element in an array based on a comparator.\n\n**Example**\n\n```ts\nimport { Array, Order } from \"effect\"\n\nconst result = Array.min([3, 1, 2], Order.number)\nconsole.log(result) // 1\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const min: { <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A; <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2936"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "max",
    "description": "Finds the maximum element in an array based on a comparator.\n\n**Example**\n\n```ts\nimport { Array, Order } from \"effect\"\n\nconst result = Array.max([3, 1, 2], Order.number)\nconsole.log(result) // 3\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const max: { <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A; <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2955"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "getOrder",
    "description": "This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\nThe returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\nIf all elements are equal, the arrays are then compared based on their length.\nIt is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const getOrder: <A>(O: Order.Order<A>) => Order.Order<ReadonlyArray<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2985"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": "Creates an equivalence relation for arrays.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst eq = Array.getEquivalence<number>((a, b) => a === b)\nconsole.log(eq([1, 2, 3], [1, 2, 3])) // true\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<ReadonlyArray<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3002"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "Performs a side-effect for each element of the `Iterable`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nArray.forEach([1, 2, 3], n => console.log(n)) // 1, 2, 3\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const forEach: { <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void; <A>(self: Iterable<A>, f: (a: A, i: number) => void): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3019"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "dedupeWith",
    "description": "Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\npreserving the order of the first occurrence of each element.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)\nconsole.log(result) // [1, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const dedupeWith: { <S extends Iterable<any>>(isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<S>) => boolean): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<A>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3039"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "dedupeAdjacentWith",
    "description": "Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.dedupeAdjacentWith([1, 1, 2, 2, 3, 3], (a, b) => a === b)\nconsole.log(result) // [1, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const dedupeAdjacentWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3088"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "dedupeAdjacent",
    "description": "Deduplicates adjacent elements that are identical.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.dedupeAdjacent([1, 1, 2, 2, 3, 3])\nconsole.log(result) // [1, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const dedupeAdjacent: <A>(self: Iterable<A>) => Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3117"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "join",
    "description": "Joins the elements together with \"sep\" in the middle.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst strings = [\"a\", \"b\", \"c\"]\nconst joined = Array.join(strings, \"-\")\nconsole.log(joined) // \"a-b-c\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const join: { (sep: string): (self: Iterable<string>) => string; (self: Iterable<string>, sep: string): string; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3135"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "mapAccum",
    "description": "Statefully maps over the chunk, producing new elements of type `B`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.mapAccum([1, 2, 3], 0, (acc, n) => [acc + n, acc + n])\nconsole.log(result) // [6, [1, 3, 6]]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const mapAccum: { <S, A, B, I extends Iterable<A> = Iterable<A>>(s: S, f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]): (self: I) => [state: S, mappedArray: ReadonlyArray.With<I, B>]; <S, A, B, I extends Iterable<A> = Iterable<A>>(self: I, s: S, f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]): [state: S, mappedArray: ReadonlyArray.With<I, B>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3155"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "cartesianWith",
    "description": "Zips this chunk crosswise with the specified chunk using the specified combiner.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.cartesianWith([1, 2], [\"a\", \"b\"], (a, b) => `${a}-${b}`)\nconsole.log(result) // [\"1-a\", \"1-b\", \"2-a\", \"2-b\"]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const cartesianWith: { <A, B, C>(that: ReadonlyArray<B>, f: (a: A, b: B) => C): (self: ReadonlyArray<A>) => Array<C>; <A, B, C>(self: ReadonlyArray<A>, that: ReadonlyArray<B>, f: (a: A, b: B) => C): Array<C>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3196"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "cartesian",
    "description": "Zips this chunk crosswise with the specified chunk.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.cartesian([1, 2], [\"a\", \"b\"])\nconsole.log(result) // [[1, \"a\"], [1, \"b\"], [2, \"a\"], [2, \"b\"]]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const cartesian: { <B>(that: ReadonlyArray<B>): <A>(self: ReadonlyArray<A>) => Array<[A, B]>; <A, B>(self: ReadonlyArray<A>, that: ReadonlyArray<B>): Array<[A, B]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3220"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "Do",
    "description": "The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n\nIt can be used to simulate \"array comprehension\".\nIt's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n\n**Example**\n\n```ts\nimport { Array, pipe } from \"effect\"\n\nconst doResult = pipe(\n  Array.Do,\n  Array.bind(\"x\", () => [1, 3, 5]),\n  Array.bind(\"y\", () => [2, 4, 6]),\n  Array.filter(({ x, y }) => x < y), // condition\n  Array.map(({ x, y }) => [x, y] as const) // transformation\n)\nconsole.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": "do notation",
    "signature": "declare const Do: ReadonlyArray<{}>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3279"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "bind",
    "description": "The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n\nIt can be used to simulate \"array comprehension\".\nIt's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n\n**Example**\n\n```ts\nimport { Array, pipe } from \"effect\"\n\nconst doResult = pipe(\n  Array.Do,\n  Array.bind(\"x\", () => [1, 3, 5]),\n  Array.bind(\"y\", () => [2, 4, 6]),\n  Array.filter(({ x, y }) => x < y), // condition\n  Array.map(({ x, y }) => [x, y] as const) // transformation\n)\nconsole.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": "do notation",
    "signature": "declare const bind: { <A extends object, N extends string, B>(tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => ReadonlyArray<B>): (self: ReadonlyArray<A>) => Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <A extends object, N extends string, B>(self: ReadonlyArray<A>, tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => ReadonlyArray<B>): Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3328"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "bindTo",
    "description": "The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n\nIt can be used to simulate \"array comprehension\".\nIt's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n\n**Example**\n\n```ts\nimport { Array, pipe } from \"effect\"\n\nconst doResult = pipe(\n  Array.Do,\n  Array.bind(\"x\", () => [1, 3, 5]),\n  Array.bind(\"y\", () => [2, 4, 6]),\n  Array.filter(({ x, y }) => x < y), // condition\n  Array.map(({ x, y }) => [x, y] as const) // transformation\n)\nconsole.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": "do notation",
    "signature": "declare const bindTo: { <N extends string>(tag: N): <A>(self: ReadonlyArray<A>) => Array<{ [K in N]: A; }>; <A, N extends string>(self: ReadonlyArray<A>, tag: N): Array<{ [K in N]: A; }>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3389"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Builds a `NonEmptyArray` from an non-empty collection of elements.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.make(1, 2, 3)\nconsole.log(result) // [1, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Elements extends NonEmptyArray<any>>(...elements: Elements) => NonEmptyArray<Elements[number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L58"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "allocate",
    "description": "Creates a new `Array` of the specified length.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.allocate<number>(3)\nconsole.log(result) // [ <3 empty items> ]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const allocate: <A = never>(n: number) => Array<A | undefined>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L77"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "range",
    "description": "Return a `NonEmptyArray` containing a range of integers, including both endpoints.\n\n**Example**\n\n```ts\nimport { range } from \"effect/Array\"\n\nconst result = range(1, 3)\nconsole.log(result) // [1, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const range: (start: number, end: number) => NonEmptyArray<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L123"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `Array` from an iterable collection of values.\nIf the input is already an array, it returns the input as-is.\nOtherwise, it converts the iterable collection to an array.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.fromIterable(new Set([1, 2, 3]))\nconsole.log(result) // [1, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: <A>(collection: Iterable<A>) => Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L165"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "ensure",
    "description": "Creates a new `Array` from a value that might not be an iterable.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconsole.log(Array.ensure(\"a\")) // [\"a\"]\nconsole.log(Array.ensure([\"a\"])) // [\"a\"]\nconsole.log(Array.ensure([\"a\", \"b\", \"c\"])) // [\"a\", \"b\", \"c\"]\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "constructors",
    "signature": "declare const ensure: <A>(self: ReadonlyArray<A> | A) => Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L184"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "isEmptyArray",
    "description": "Determine if an `Array` is empty narrowing down the type to `[]`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconsole.log(Array.isEmptyArray([])) // true\nconsole.log(Array.isEmptyArray([1, 2, 3])) // false\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isEmptyArray: <A>(self: Array<A>) => self is []",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L534"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "length",
    "description": "Return the number of elements in a `ReadonlyArray`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const length: <A>(self: ReadonlyArray<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L598"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "unprepend",
    "description": "Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\";\n\nconst result = Array.unprepend([1, 2, 3, 4])\nconsole.log(result) // [1, [2, 3, 4]]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "declare const unprepend: <A>(self: NonEmptyReadonlyArray<A>) => [firstElement: A, remainingElements: Array<A>]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L650"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "unappend",
    "description": "Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\";\n\nconst result = Array.unappend([1, 2, 3, 4])\nconsole.log(result) // [[1, 2, 3], 4]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "declare const unappend: <A>(self: NonEmptyReadonlyArray<A>) => [arrayWithoutLastElement: Array<A>, lastElement: A]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L669"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "last",
    "description": "Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const last: <A>(self: ReadonlyArray<A>) => Option.Option<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L704"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "lastNonEmpty",
    "description": "Get the last element of a non empty array.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.lastNonEmpty([1, 2, 3, 4])\nconsole.log(result) // 4\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const lastNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L722"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "tail",
    "description": "Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const tail: <A>(self: Iterable<A>) => Option.Option<Array<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L730"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "tailNonEmpty",
    "description": "Get all but the first element of a `NonEmptyReadonlyArray`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.tailNonEmpty([1, 2, 3, 4])\nconsole.log(result) // [2, 3, 4]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const tailNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L750"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "init",
    "description": "Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const init: <A>(self: Iterable<A>) => Option.Option<Array<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L758"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "initNonEmpty",
    "description": "Get all but the last element of a non empty array, creating a new array.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.initNonEmpty([1, 2, 3, 4])\nconsole.log(result) // [1, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const initNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L778"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "reverse",
    "description": "Reverse an `Iterable`, creating a new `Array`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.reverse([1, 2, 3, 4])\nconsole.log(result) // [4, 3, 2, 1]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const reverse: <S extends Iterable<any>>(self: S) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1314"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "sortBy",
    "description": "Sorts the elements of an `Iterable` in increasing order based on the provided\norders. The elements are compared using the first order in `orders`, then the\nsecond order if the first comparison is equal, and so on.\n\n**Example**\n\n```ts\nimport { Array, Order, pipe } from \"effect\"\n\nconst users = [\n  { name: \"Alice\", age: 30 },\n  { name: \"Bob\", age: 25 },\n  { name: \"Charlie\", age: 30 }\n]\n\nconst result = pipe(\n  users,\n  Array.sortBy(\n    Order.mapInput(Order.number, (user: (typeof users)[number]) => user.age),\n    Order.mapInput(Order.string, (user: (typeof users)[number]) => user.name)\n  )\n)\n\nconsole.log(result)\n// [\n//   { name: \"Bob\", age: 25 },\n//   { name: \"Alice\", age: 30 },\n//   { name: \"Charlie\", age: 30 }\n// ]\n\n// Explanation:\n// The array of users is sorted first by age in ascending order. When ages are equal,\n// the users are further sorted by name in ascending order.\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sorting",
    "signature": "declare const sortBy: <S extends Iterable<any>>(...orders: ReadonlyArray<Order.Order<ReadonlyArray.Infer<S>>>) => (self: S) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1412"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "containsWith",
    "description": "Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.\n\n**Example**\n\n```ts\nimport { Array, pipe } from \"effect\"\n\nconst isEquivalent = (a: number, b: number) => a === b\nconst containsNumber = Array.containsWith(isEquivalent)\nconst result = pipe([1, 2, 3, 4], containsNumber(3))\nconsole.log(result) // true\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Iterable<A>) => boolean; (self: Iterable<A>, a: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L1704"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "intersectionWith",
    "description": "Creates an `Array` of unique values that are included in all given `Iterable`s using the provided `isEquivalent` function.\nThe order and references of result values are determined by the first `Iterable`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]\nconst array2 = [{ id: 3 }, { id: 4 }, { id: 1 }]\nconst isEquivalent = (a: { id: number }, b: { id: number }) => a.id === b.id\nconst result = Array.intersectionWith(isEquivalent)(array2)(array1)\nconsole.log(result) // [{ id: 1 }, { id: 3 }]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const intersectionWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Iterable<A>): (self: Iterable<A>) => Array<A>; (self: Iterable<A>, that: Iterable<A>): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2221"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "differenceWith",
    "description": "Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.\nThe order and references of result values are determined by the first `Iterable`.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst array1 = [1, 2, 3]\nconst array2 = [2, 3, 4]\nconst difference = Array.differenceWith<number>((a, b) => a === b)(array1, array2)\nconsole.log(difference) // [1]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const differenceWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Iterable<A>): (self: Iterable<A>) => Array<A>; (self: Iterable<A>, that: Iterable<A>): Array<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2269"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <A = never>() => Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2304"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "of",
    "description": "Constructs a new `NonEmptyArray<A>` from the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const of: <A>(a: A) => NonEmptyArray<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2312"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "getLefts",
    "description": "Retrieves the `Left` values from an `Iterable` of `Either`s, collecting them into an array.\n\n**Example**\n\n```ts\nimport { Array, Either } from \"effect\"\n\nconst result = Array.getLefts([Either.right(1), Either.left(\"err\"), Either.right(2)])\nconsole.log(result) // [\"err\"]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const getLefts: <T extends Iterable<Either.Either<any, any>>>(self: T) => Array<Either.Either.Left<ReadonlyArray.Infer<T>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2578"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "getRights",
    "description": "Retrieves the `Right` values from an `Iterable` of `Either`s, collecting them into an array.\n\n**Example**\n\n```ts\nimport { Array, Either } from \"effect\"\n\nconst result = Array.getRights([Either.right(1), Either.left(\"err\"), Either.right(2)])\nconsole.log(result) // [1, 2]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const getRights: <T extends Iterable<Either.Either<any, any>>>(self: T) => Array<Either.Either.Right<ReadonlyArray.Infer<T>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2606"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "liftPredicate",
    "description": "Lifts a predicate into an array.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst isEven = (n: number) => n % 2 === 0\nconst to = Array.liftPredicate(isEven)\nconsole.log(to(1)) // []\nconsole.log(to(2)) // [2]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "lifting",
    "signature": "declare const liftPredicate: { <A, B extends A>(refinement: Predicate.Refinement<A, B>): (a: A) => Array<B>; <A>(predicate: Predicate.Predicate<A>): <B extends A>(b: B) => Array<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2762"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "liftOption",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "lifting",
    "signature": "declare const liftOption: <A extends Array<unknown>, B>(f: (...a: A) => Option.Option<B>) => (...a: A) => Array<B>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2771"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "fromNullable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const fromNullable: <A>(a: A) => Array<NonNullable<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2780"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "liftNullable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "lifting",
    "signature": "declare const liftNullable: <A extends Array<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => Array<NonNullable<B>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2786"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "liftEither",
    "description": "Lifts a function that returns an `Either` into a function that returns an array.\nIf the `Either` is a left, it returns an empty array.\nIf the `Either` is a right, it returns an array with the right value.\n\n**Example**\n\n```ts\nimport { Array, Either } from \"effect\"\n\nconst parseNumber = (s: string): Either.Either<number, Error> =>\n  isNaN(Number(s)) ? Either.left(new Error(\"Not a number\")) : Either.right(Number(s))\n\nconst liftedParseNumber = Array.liftEither(parseNumber)\n\nconst result1 = liftedParseNumber(\"42\")\nconsole.log(result1) // [42]\n\nconst result2 = liftedParseNumber(\"not a number\")\nconsole.log(result2) // []\n\n// Explanation:\n// The function parseNumber is lifted to return an array.\n// When parsing \"42\", it returns an Either.left with the number 42, resulting in [42].\n// When parsing \"not a number\", it returns an Either.right with an error, resulting in an empty array [].\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "lifting",
    "signature": "declare const liftEither: <A extends Array<unknown>, E, B>(f: (...a: A) => Either.Either<B, E>) => (...a: A) => Array<B>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2850"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "unfold",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unfold: <B, A>(b: B, f: (b: B) => Option.Option<readonly [A, B]>) => Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2964"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "dedupe",
    "description": "Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.\nThe equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const dedupe: <S extends Iterable<any>>(self: S) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L3069"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "ReadonlyArrayTypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface ReadonlyArrayTypeLambda extends TypeLambda {\n  readonly type: ReadonlyArray<this[\"Target\"]>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L27"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "NonEmptyReadonlyArray",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type readonly [A, ...A[]] = readonly [A, ...Array<A>]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L35"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "NonEmptyArray",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type [A, ...A[]] = [A, ...Array<A>]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L41"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "ReadonlyArray.Infer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Infer<S> = S extends ReadonlyArray<infer A> ? A\n    : S extends Iterable<infer A> ? A\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2321"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "ReadonlyArray.With",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type With<S, A> = S extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2328"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "ReadonlyArray.OrNonEmpty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type OrNonEmpty<S, T, A> = S extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : T extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2334"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "ReadonlyArray.AndNonEmpty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type AndNonEmpty<S, T, A> = S extends NonEmptyReadonlyArray<any> ? T extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : Array<A>\n    : Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2345"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Array.ts",
      "path": "src/Array.ts"
    },
    "project": "effect",
    "name": "ReadonlyArray.Flatten",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Flatten<T> = T extends\n    NonEmptyReadonlyArray<NonEmptyReadonlyArray<infer A>> ? NonEmptyArray<A>\n    : T extends ReadonlyArray<ReadonlyArray<infer A>> ? Array<A>\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Array.ts#L2356"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L35"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "scale",
    "description": "Scales a given `BigDecimal` to the specified scale.\n\nIf the given scale is smaller than the current scale, the value will be rounded down to\nthe nearest integer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "scaling",
    "signature": "declare const scale: { (scale: number): (self: BigDecimal) => BigDecimal; (self: BigDecimal, scale: number): BigDecimal; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L181"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "sum",
    "description": "Provides an addition operation on `BigDecimal`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { sum, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(sum(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"5\"))\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const sum: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L210"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "multiply",
    "description": "Provides a multiplication operation on `BigDecimal`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { multiply, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(multiply(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"6\"))\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const multiply: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L247"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "subtract",
    "description": "Provides a subtraction operation on `BigDecimal`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { subtract, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(subtract(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"-1\"))\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const subtract: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L272"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "divide",
    "description": "Provides a division operation on `BigDecimal`s.\n\nIf the dividend is not a multiple of the divisor the result will be a `BigDecimal` value\nwhich represents the integer division rounded down to the nearest integer.\n\nIf the divisor is `0`, the result will be `None`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { BigDecimal, Option } from \"effect\"\n\nassert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString(\"6\"), BigDecimal.unsafeFromString(\"3\")), Option.some(BigDecimal.unsafeFromString(\"2\")))\nassert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString(\"6\"), BigDecimal.unsafeFromString(\"4\")), Option.some(BigDecimal.unsafeFromString(\"1.5\")))\nassert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString(\"6\"), BigDecimal.unsafeFromString(\"0\")), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const divide: { (that: BigDecimal): (self: BigDecimal) => Option.Option<BigDecimal>; (self: BigDecimal, that: BigDecimal): Option.Option<BigDecimal>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L384"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "unsafeDivide",
    "description": "Provides an unsafe division operation on `BigDecimal`s.\n\nIf the dividend is not a multiple of the divisor the result will be a `BigDecimal` value\nwhich represents the integer division rounded down to the nearest integer.\n\nThrows a `RangeError` if the divisor is `0`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { unsafeDivide, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeDivide(unsafeFromString(\"6\"), unsafeFromString(\"3\")), unsafeFromString(\"2\"))\nassert.deepStrictEqual(unsafeDivide(unsafeFromString(\"6\"), unsafeFromString(\"4\")), unsafeFromString(\"1.5\"))\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const unsafeDivide: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L424"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "Order",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Order: order.Order<BigDecimal>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L447"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "lessThan",
    "description": "Returns `true` if the first argument is less than the second, otherwise `false`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { lessThan, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(lessThan(unsafeFromString(\"2\"), unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(lessThan(unsafeFromString(\"3\"), unsafeFromString(\"3\")), false)\nassert.deepStrictEqual(lessThan(unsafeFromString(\"4\"), unsafeFromString(\"3\")), false)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const lessThan: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L480"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "lessThanOrEqualTo",
    "description": "Checks if a given `BigDecimal` is less than or equal to the provided one.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { lessThanOrEqualTo, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString(\"2\"), unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString(\"3\"), unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString(\"4\"), unsafeFromString(\"3\")), false)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const lessThanOrEqualTo: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L501"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "greaterThan",
    "description": "Returns `true` if the first argument is greater than the second, otherwise `false`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { greaterThan, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(greaterThan(unsafeFromString(\"2\"), unsafeFromString(\"3\")), false)\nassert.deepStrictEqual(greaterThan(unsafeFromString(\"3\"), unsafeFromString(\"3\")), false)\nassert.deepStrictEqual(greaterThan(unsafeFromString(\"4\"), unsafeFromString(\"3\")), true)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const greaterThan: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L522"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "greaterThanOrEqualTo",
    "description": "Checks if a given `BigDecimal` is greater than or equal to the provided one.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { greaterThanOrEqualTo, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString(\"2\"), unsafeFromString(\"3\")), false)\nassert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString(\"3\"), unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString(\"4\"), unsafeFromString(\"3\")), true)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const greaterThanOrEqualTo: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L543"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "between",
    "description": "Checks if a `BigDecimal` is between a `minimum` and `maximum` value (inclusive).",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { BigDecimal } from \"effect\"\n\nconst between = BigDecimal.between({\n  minimum: BigDecimal.unsafeFromString(\"1\"),\n  maximum: BigDecimal.unsafeFromString(\"5\") }\n)\n\nassert.deepStrictEqual(between(BigDecimal.unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(between(BigDecimal.unsafeFromString(\"0\")), false)\nassert.deepStrictEqual(between(BigDecimal.unsafeFromString(\"6\")), false)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const between: { (options: { minimum: BigDecimal; maximum: BigDecimal; }): (self: BigDecimal) => boolean; (self: BigDecimal, options: { minimum: BigDecimal; maximum: BigDecimal; }): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L569"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "clamp",
    "description": "Restricts the given `BigDecimal` to be within the range specified by the `minimum` and `maximum` values.\n\n- If the `BigDecimal` is less than the `minimum` value, the function returns the `minimum` value.\n- If the `BigDecimal` is greater than the `maximum` value, the function returns the `maximum` value.\n- Otherwise, it returns the original `BigDecimal`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { BigDecimal } from \"effect\"\n\nconst clamp = BigDecimal.clamp({\n  minimum: BigDecimal.unsafeFromString(\"1\"),\n  maximum: BigDecimal.unsafeFromString(\"5\") }\n)\n\nassert.deepStrictEqual(clamp(BigDecimal.unsafeFromString(\"3\")), BigDecimal.unsafeFromString(\"3\"))\nassert.deepStrictEqual(clamp(BigDecimal.unsafeFromString(\"0\")), BigDecimal.unsafeFromString(\"1\"))\nassert.deepStrictEqual(clamp(BigDecimal.unsafeFromString(\"6\")), BigDecimal.unsafeFromString(\"5\"))\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const clamp: { (options: { minimum: BigDecimal; maximum: BigDecimal; }): (self: BigDecimal) => BigDecimal; (self: BigDecimal, options: { minimum: BigDecimal; maximum: BigDecimal; }): BigDecimal; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L605"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "min",
    "description": "Returns the minimum between two `BigDecimal`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { min, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(min(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"2\"))\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const min: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L630"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "max",
    "description": "Returns the maximum between two `BigDecimal`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { max, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(max(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"3\"))\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const max: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L649"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "remainder",
    "description": "Returns the remainder left over when one operand is divided by a second operand.\n\nIf the divisor is `0`, the result will be `None`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { BigDecimal, Option } from \"effect\"\n\nassert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString(\"2\"), BigDecimal.unsafeFromString(\"2\")), Option.some(BigDecimal.unsafeFromString(\"0\")))\nassert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString(\"3\"), BigDecimal.unsafeFromString(\"2\")), Option.some(BigDecimal.unsafeFromString(\"1\")))\nassert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString(\"-4\"), BigDecimal.unsafeFromString(\"2\")), Option.some(BigDecimal.unsafeFromString(\"0\")))\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const remainder: { (divisor: BigDecimal): (self: BigDecimal) => Option.Option<BigDecimal>; (self: BigDecimal, divisor: BigDecimal): Option.Option<BigDecimal>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L725"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "unsafeRemainder",
    "description": "Returns the remainder left over when one operand is divided by a second operand.\n\nThrows a `RangeError` if the divisor is `0`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { unsafeRemainder, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeRemainder(unsafeFromString(\"2\"), unsafeFromString(\"2\")), unsafeFromString(\"0\"))\nassert.deepStrictEqual(unsafeRemainder(unsafeFromString(\"3\"), unsafeFromString(\"2\")), unsafeFromString(\"1\"))\nassert.deepStrictEqual(unsafeRemainder(unsafeFromString(\"-4\"), unsafeFromString(\"2\")), unsafeFromString(\"0\"))\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const unsafeRemainder: { (divisor: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, divisor: BigDecimal): BigDecimal; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L755"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "Equivalence",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Equivalence: equivalence.Equivalence<BigDecimal>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L771"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "equals",
    "description": "Checks if two `BigDecimal`s are equal.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const equals: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L789"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "fromNumber",
    "description": "Creates a `BigDecimal` from a `number` value.\n\nIt is not recommended to convert a floating point number to a decimal directly,\nas the floating point representation may be unexpected.\n\nThrows a `RangeError` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromNumber: (n: number) => BigDecimal",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L837"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "isBigDecimal",
    "description": "Checks if a given value is a `BigDecimal`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isBigDecimal: (u: unknown) => u is BigDecimal",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L92"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a `BigDecimal` from a `bigint` value and a scale.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (value: bigint, scale: number) => BigDecimal",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L100"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "normalize",
    "description": "Normalizes a given `BigDecimal` by removing trailing zeros.\n\n**Example**\n\n```ts\nimport * as assert from \"node:assert\"\nimport { normalize, make, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(normalize(unsafeFromString(\"123.00000\")), normalize(make(123n, 0)))\nassert.deepStrictEqual(normalize(unsafeFromString(\"12300000\")), normalize(make(123n, -5)))\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "scaling",
    "signature": "declare const normalize: (self: BigDecimal) => BigDecimal",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L143"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "sign",
    "description": "Determines the sign of a given `BigDecimal`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { sign, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(sign(unsafeFromString(\"-5\")), -1)\nassert.deepStrictEqual(sign(unsafeFromString(\"0\")), 0)\nassert.deepStrictEqual(sign(unsafeFromString(\"5\")), 1)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const sign: (n: BigDecimal) => Ordering",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L670"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "abs",
    "description": "Determines the absolute value of a given `BigDecimal`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { abs, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(abs(unsafeFromString(\"-5\")), unsafeFromString(\"5\"))\nassert.deepStrictEqual(abs(unsafeFromString(\"0\")), unsafeFromString(\"0\"))\nassert.deepStrictEqual(abs(unsafeFromString(\"5\")), unsafeFromString(\"5\"))\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const abs: (n: BigDecimal) => BigDecimal",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L688"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "negate",
    "description": "Provides a negate operation on `BigDecimal`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { negate, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(negate(unsafeFromString(\"3\")), unsafeFromString(\"-3\"))\nassert.deepStrictEqual(negate(unsafeFromString(\"-6\")), unsafeFromString(\"6\"))\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const negate: (n: BigDecimal) => BigDecimal",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L705"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "fromBigInt",
    "description": "Creates a `BigDecimal` from a `bigint` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromBigInt: (n: bigint) => BigDecimal",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L800"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "unsafeFromNumber",
    "description": "Creates a `BigDecimal` from a `number` value.\n\nIt is not recommended to convert a floating point number to a decimal directly,\nas the floating point representation may be unexpected.\n\nThrows a `RangeError` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { unsafeFromNumber, make } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeFromNumber(123), make(123n, 0))\nassert.deepStrictEqual(unsafeFromNumber(123.456), make(123456n, 3))\n```"
    ],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "declare const unsafeFromNumber: (n: number) => BigDecimal",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L822"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "safeFromNumber",
    "description": "Creates a `BigDecimal` from a `number` value.\n\nIt is not recommended to convert a floating point number to a decimal directly,\nas the floating point representation may be unexpected.\n\nReturns `None` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { BigDecimal, Option } from \"effect\"\n\nassert.deepStrictEqual(BigDecimal.safeFromNumber(123), Option.some(BigDecimal.make(123n, 0)))\nassert.deepStrictEqual(BigDecimal.safeFromNumber(123.456), Option.some(BigDecimal.make(123456n, 3)))\nassert.deepStrictEqual(BigDecimal.safeFromNumber(Infinity), Option.none())\n```"
    ],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "declare const safeFromNumber: (n: number) => Option.Option<BigDecimal>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L861"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "fromString",
    "description": "Parses a numerical `string` into a `BigDecimal`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { BigDecimal, Option } from \"effect\"\n\nassert.deepStrictEqual(BigDecimal.fromString(\"123\"), Option.some(BigDecimal.make(123n, 0)))\nassert.deepStrictEqual(BigDecimal.fromString(\"123.456\"), Option.some(BigDecimal.make(123456n, 3)))\nassert.deepStrictEqual(BigDecimal.fromString(\"123.abc\"), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromString: (s: string) => Option.Option<BigDecimal>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L891"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "unsafeFromString",
    "description": "Parses a numerical `string` into a `BigDecimal`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { unsafeFromString, make } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeFromString(\"123\"), make(123n, 0))\nassert.deepStrictEqual(unsafeFromString(\"123.456\"), make(123456n, 3))\nassert.throws(() => unsafeFromString(\"123.abc\"))\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unsafeFromString: (s: string) => BigDecimal",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L952"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "format",
    "description": "Formats a given `BigDecimal` as a `string`.\n\nIf the scale of the `BigDecimal` is greater than or equal to 16, the `BigDecimal` will\nbe formatted in scientific notation.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { format, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(format(unsafeFromString(\"-5\")), \"-5\")\nassert.deepStrictEqual(format(unsafeFromString(\"123.456\")), \"123.456\")\nassert.deepStrictEqual(format(unsafeFromString(\"-0.00000123\")), \"-0.00000123\")\n```"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const format: (n: BigDecimal) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L974"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "toExponential",
    "description": "Formats a given `BigDecimal` as a `string` in scientific notation.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { toExponential, make } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(toExponential(make(123456n, -5)), \"1.23456e+10\")\n```"
    ],
    "since": "3.11.0",
    "category": "conversions",
    "signature": "declare const toExponential: (n: BigDecimal) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1019"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "unsafeToNumber",
    "description": "Converts a `BigDecimal` to a `number`.\n\nThis function will produce incorrect results if the `BigDecimal` exceeds the 64-bit range of a `number`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { unsafeToNumber, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeToNumber(unsafeFromString(\"123.456\")), 123.456)\n```"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const unsafeToNumber: (n: BigDecimal) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1054"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "isInteger",
    "description": "Checks if a given `BigDecimal` is an integer.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isInteger, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(isInteger(unsafeFromString(\"0\")), true)\nassert.deepStrictEqual(isInteger(unsafeFromString(\"1\")), true)\nassert.deepStrictEqual(isInteger(unsafeFromString(\"1.1\")), false)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const isInteger: (n: BigDecimal) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1072"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "isZero",
    "description": "Checks if a given `BigDecimal` is `0`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isZero, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(isZero(unsafeFromString(\"0\")), true)\nassert.deepStrictEqual(isZero(unsafeFromString(\"1\")), false)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const isZero: (n: BigDecimal) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1089"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "isNegative",
    "description": "Checks if a given `BigDecimal` is negative.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isNegative, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(isNegative(unsafeFromString(\"-1\")), true)\nassert.deepStrictEqual(isNegative(unsafeFromString(\"0\")), false)\nassert.deepStrictEqual(isNegative(unsafeFromString(\"1\")), false)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const isNegative: (n: BigDecimal) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1107"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "isPositive",
    "description": "Checks if a given `BigDecimal` is positive.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isPositive, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(isPositive(unsafeFromString(\"-1\")), false)\nassert.deepStrictEqual(isPositive(unsafeFromString(\"0\")), false)\nassert.deepStrictEqual(isPositive(unsafeFromString(\"1\")), true)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const isPositive: (n: BigDecimal) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L1125"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "BigDecimal",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BigDecimal extends Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly value: bigint\n  readonly scale: number\n  /** @internal */\n  normalized?: BigDecimal\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L47"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "BigDecimal.ts",
      "path": "src/BigDecimal.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigDecimal.ts#L41"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "isBigInt",
    "description": "Tests if a value is a `bigint`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isBigInt } from \"effect/BigInt\"\n\nassert.deepStrictEqual(isBigInt(1n), true)\nassert.deepStrictEqual(isBigInt(1), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isBigInt: (u: unknown) => u is bigint",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L35"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "sum",
    "description": "Provides an addition operation on `bigint`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { sum } from \"effect/BigInt\"\n\nassert.deepStrictEqual(sum(2n, 3n), 5n)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const sum: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L51"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "multiply",
    "description": "Provides a multiplication operation on `bigint`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { multiply } from \"effect/BigInt\"\n\nassert.deepStrictEqual(multiply(2n, 3n), 6n)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const multiply: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L70"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "subtract",
    "description": "Provides a subtraction operation on `bigint`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { subtract } from \"effect/BigInt\"\n\nassert.deepStrictEqual(subtract(2n, 3n), -1n)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const subtract: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L89"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "divide",
    "description": "Provides a division operation on `bigint`s.\n\nIf the dividend is not a multiple of the divisor the result will be a `bigint` value\nwhich represents the integer division rounded down to the nearest integer.\n\nReturns `None` if the divisor is `0n`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { BigInt, Option } from \"effect\"\n\nassert.deepStrictEqual(BigInt.divide(6n, 3n), Option.some(2n))\nassert.deepStrictEqual(BigInt.divide(6n, 0n), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const divide: { (that: bigint): (self: bigint) => Option.Option<bigint>; (self: bigint, that: bigint): Option.Option<bigint>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L114"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "unsafeDivide",
    "description": "Provides a division operation on `bigint`s.\n\nIf the dividend is not a multiple of the divisor the result will be a `bigint` value\nwhich represents the integer division rounded down to the nearest integer.\n\nThrows a `RangeError` if the divisor is `0n`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { unsafeDivide } from \"effect/BigInt\"\n\nassert.deepStrictEqual(unsafeDivide(6n, 3n), 2n)\nassert.deepStrictEqual(unsafeDivide(6n, 4n), 1n)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const unsafeDivide: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L142"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "Equivalence",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Equivalence: equivalence.Equivalence<bigint>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L183"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "Order",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Order: order.Order<bigint>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L189"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "lessThan",
    "description": "Returns `true` if the first argument is less than the second, otherwise `false`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { lessThan } from \"effect/BigInt\"\n\nassert.deepStrictEqual(lessThan(2n, 3n), true)\nassert.deepStrictEqual(lessThan(3n, 3n), false)\nassert.deepStrictEqual(lessThan(4n, 3n), false)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const lessThan: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L207"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "lessThanOrEqualTo",
    "description": "Returns a function that checks if a given `bigint` is less than or equal to the provided one.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { lessThanOrEqualTo } from \"effect/BigInt\"\n\nassert.deepStrictEqual(lessThanOrEqualTo(2n, 3n), true)\nassert.deepStrictEqual(lessThanOrEqualTo(3n, 3n), true)\nassert.deepStrictEqual(lessThanOrEqualTo(4n, 3n), false)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const lessThanOrEqualTo: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L228"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "greaterThan",
    "description": "Returns `true` if the first argument is greater than the second, otherwise `false`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { greaterThan } from \"effect/BigInt\"\n\nassert.deepStrictEqual(greaterThan(2n, 3n), false)\nassert.deepStrictEqual(greaterThan(3n, 3n), false)\nassert.deepStrictEqual(greaterThan(4n, 3n), true)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const greaterThan: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L249"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "greaterThanOrEqualTo",
    "description": "Returns a function that checks if a given `bigint` is greater than or equal to the provided one.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { greaterThanOrEqualTo } from \"effect/BigInt\"\n\nassert.deepStrictEqual(greaterThanOrEqualTo(2n, 3n), false)\nassert.deepStrictEqual(greaterThanOrEqualTo(3n, 3n), true)\nassert.deepStrictEqual(greaterThanOrEqualTo(4n, 3n), true)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const greaterThanOrEqualTo: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L270"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "between",
    "description": "Checks if a `bigint` is between a `minimum` and `maximum` value (inclusive).",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { BigInt } from \"effect\"\n\nconst between = BigInt.between({ minimum: 0n, maximum: 5n })\n\nassert.deepStrictEqual(between(3n), true)\nassert.deepStrictEqual(between(-1n), false)\nassert.deepStrictEqual(between(6n), false)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const between: { (options: { minimum: bigint; maximum: bigint; }): (self: bigint) => boolean; (self: bigint, options: { minimum: bigint; maximum: bigint; }): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L293"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "clamp",
    "description": "Restricts the given `bigint` to be within the range specified by the `minimum` and `maximum` values.\n\n- If the `bigint` is less than the `minimum` value, the function returns the `minimum` value.\n- If the `bigint` is greater than the `maximum` value, the function returns the `maximum` value.\n- Otherwise, it returns the original `bigint`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { BigInt } from \"effect\"\n\nconst clamp = BigInt.clamp({ minimum: 1n, maximum: 5n })\n\nassert.equal(clamp(3n), 3n)\nassert.equal(clamp(0n), 1n)\nassert.equal(clamp(6n), 5n)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const clamp: { (options: { minimum: bigint; maximum: bigint; }): (self: bigint) => bigint; (self: bigint, options: { minimum: bigint; maximum: bigint; }): bigint; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L325"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "min",
    "description": "Returns the minimum between two `bigint`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { min } from \"effect/BigInt\"\n\nassert.deepStrictEqual(min(2n, 3n), 2n)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const min: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L349"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "max",
    "description": "Returns the maximum between two `bigint`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { max } from \"effect/BigInt\"\n\nassert.deepStrictEqual(max(2n, 3n), 3n)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const max: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L367"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "gcd",
    "description": "Determines the greatest common divisor of two `bigint`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { gcd } from \"effect/BigInt\"\n\nassert.deepStrictEqual(gcd(2n, 3n), 1n)\nassert.deepStrictEqual(gcd(2n, 4n), 2n)\nassert.deepStrictEqual(gcd(16n, 24n), 8n)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const gcd: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L424"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "lcm",
    "description": "Determines the least common multiple of two `bigint`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { lcm } from \"effect/BigInt\"\n\nassert.deepStrictEqual(lcm(2n, 3n), 6n)\nassert.deepStrictEqual(lcm(2n, 4n), 4n)\nassert.deepStrictEqual(lcm(16n, 24n), 48n)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const lcm: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L452"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "increment",
    "description": "Returns the result of adding `1n` to a given number.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { increment } from \"effect/BigInt\"\n\nassert.deepStrictEqual(increment(2n), 3n)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const increment: (n: bigint) => bigint",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L161"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "decrement",
    "description": "Decrements a number by `1n`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { decrement } from \"effect/BigInt\"\n\nassert.deepStrictEqual(decrement(3n), 2n)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const decrement: (n: bigint) => bigint",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L177"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "sign",
    "description": "Determines the sign of a given `bigint`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { sign } from \"effect/BigInt\"\n\nassert.deepStrictEqual(sign(-5n), -1)\nassert.deepStrictEqual(sign(0n), 0)\nassert.deepStrictEqual(sign(5n), 1)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const sign: (n: bigint) => Ordering",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L388"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "abs",
    "description": "Determines the absolute value of a given `bigint`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { abs } from \"effect/BigInt\"\n\nassert.deepStrictEqual(abs(-5n), 5n)\nassert.deepStrictEqual(abs(0n), 0n)\nassert.deepStrictEqual(abs(5n), 5n)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const abs: (n: bigint) => bigint",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L406"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "unsafeSqrt",
    "description": "Determines the square root of a given `bigint` unsafely. Throws if the given `bigint` is negative.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { unsafeSqrt } from \"effect/BigInt\"\n\nassert.deepStrictEqual(unsafeSqrt(4n), 2n)\nassert.deepStrictEqual(unsafeSqrt(9n), 3n)\nassert.deepStrictEqual(unsafeSqrt(16n), 4n)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const unsafeSqrt: (n: bigint) => bigint",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L473"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "sqrt",
    "description": "Determines the square root of a given `bigint` safely. Returns `none` if the given `bigint` is negative.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { BigInt, Option } from \"effect\"\n\nassert.deepStrictEqual(BigInt.sqrt(4n), Option.some(2n))\nassert.deepStrictEqual(BigInt.sqrt(9n), Option.some(3n))\nassert.deepStrictEqual(BigInt.sqrt(16n), Option.some(4n))\nassert.deepStrictEqual(BigInt.sqrt(-1n), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const sqrt: (n: bigint) => Option.Option<bigint>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L504"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "sumAll",
    "description": "Takes an `Iterable` of `bigint`s and returns their sum as a single `bigint",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { sumAll } from \"effect/BigInt\"\n\nassert.deepStrictEqual(sumAll([2n, 3n, 4n]), 9n)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const sumAll: (collection: Iterable<bigint>) => bigint",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L521"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "multiplyAll",
    "description": "Takes an `Iterable` of `bigint`s and returns their multiplication as a single `number`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { multiplyAll } from \"effect/BigInt\"\n\nassert.deepStrictEqual(multiplyAll([2n, 3n, 4n]), 24n)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const multiplyAll: (collection: Iterable<bigint>) => bigint",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L543"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "toNumber",
    "description": "Takes a `bigint` and returns an `Option` of `number`.\n\nIf the `bigint` is outside the safe integer range for JavaScript (`Number.MAX_SAFE_INTEGER`\nand `Number.MIN_SAFE_INTEGER`), it returns `Option.none()`. Otherwise, it converts the `bigint`\nto a number and returns `Option.some(number)`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { BigInt as BI, Option } from \"effect\"\n\nassert.deepStrictEqual(BI.toNumber(BigInt(42)), Option.some(42))\nassert.deepStrictEqual(BI.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)), Option.none())\nassert.deepStrictEqual(BI.toNumber(BigInt(Number.MIN_SAFE_INTEGER) - BigInt(1)), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const toNumber: (b: bigint) => Option.Option<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L574"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "fromString",
    "description": "Takes a string and returns an `Option` of `bigint`.\n\nIf the string is empty or contains characters that cannot be converted into a `bigint`,\nit returns `Option.none()`, otherwise, it returns `Option.some(bigint)`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { BigInt as BI, Option } from \"effect\"\n\nassert.deepStrictEqual(BI.fromString(\"42\"), Option.some(BigInt(42)))\nassert.deepStrictEqual(BI.fromString(\" \"), Option.none())\nassert.deepStrictEqual(BI.fromString(\"a\"), Option.none())\n```"
    ],
    "since": "2.4.12",
    "category": "conversions",
    "signature": "declare const fromString: (s: string) => Option.Option<bigint>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L600"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt.ts",
      "path": "src/BigInt.ts"
    },
    "project": "effect",
    "name": "fromNumber",
    "description": "Takes a number and returns an `Option` of `bigint`.\n\nIf the number is outside the safe integer range for JavaScript (`Number.MAX_SAFE_INTEGER`\nand `Number.MIN_SAFE_INTEGER`), it returns `Option.none()`. Otherwise, it attempts to\nconvert the number to a `bigint` and returns `Option.some(bigint)`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { BigInt as BI, Option } from \"effect\"\n\nassert.deepStrictEqual(BI.fromNumber(42), Option.some(BigInt(42)))\nassert.deepStrictEqual(BI.fromNumber(Number.MAX_SAFE_INTEGER + 1), Option.none())\nassert.deepStrictEqual(BI.fromNumber(Number.MIN_SAFE_INTEGER - 1), Option.none())\n```"
    ],
    "since": "2.4.12",
    "category": "conversions",
    "signature": "declare const fromNumber: (n: number) => Option.Option<bigint>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/BigInt.ts#L630"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean.ts",
      "path": "src/Boolean.ts"
    },
    "project": "effect",
    "name": "isBoolean",
    "description": "Tests if a value is a `boolean`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isBoolean } from \"effect/Boolean\"\n\nassert.deepStrictEqual(isBoolean(true), true)\nassert.deepStrictEqual(isBoolean(\"true\"), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isBoolean: (input: unknown) => input is boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L29"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean.ts",
      "path": "src/Boolean.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "This function returns the result of either of the given functions depending on the value of the boolean parameter.\nIt is useful when you have to run one of two functions depending on the boolean value.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Boolean } from \"effect\"\n\nassert.deepStrictEqual(Boolean.match(true, { onFalse: () => \"It's false!\", onTrue: () => \"It's true!\" }), \"It's true!\")\n```"
    ],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "declare const match: { <A, B = A>(options: { readonly onFalse: LazyArg<A>; readonly onTrue: LazyArg<B>; }): (value: boolean) => A | B; <A, B>(value: boolean, options: { readonly onFalse: LazyArg<A>; readonly onTrue: LazyArg<B>; }): A | B; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L46"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean.ts",
      "path": "src/Boolean.ts"
    },
    "project": "effect",
    "name": "Equivalence",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Equivalence: equivalence.Equivalence<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L64"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean.ts",
      "path": "src/Boolean.ts"
    },
    "project": "effect",
    "name": "Order",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Order: order.Order<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L70"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean.ts",
      "path": "src/Boolean.ts"
    },
    "project": "effect",
    "name": "and",
    "description": "Combines two boolean using AND: `self && that`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { and } from \"effect/Boolean\"\n\nassert.deepStrictEqual(and(true, true), true)\nassert.deepStrictEqual(and(true, false), false)\nassert.deepStrictEqual(and(false, true), false)\nassert.deepStrictEqual(and(false, false), false)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const and: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L106"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean.ts",
      "path": "src/Boolean.ts"
    },
    "project": "effect",
    "name": "nand",
    "description": "Combines two boolean using NAND: `!(self && that)`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { nand } from \"effect/Boolean\"\n\nassert.deepStrictEqual(nand(true, true), false)\nassert.deepStrictEqual(nand(true, false), true)\nassert.deepStrictEqual(nand(false, true), true)\nassert.deepStrictEqual(nand(false, false), true)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const nand: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L128"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean.ts",
      "path": "src/Boolean.ts"
    },
    "project": "effect",
    "name": "or",
    "description": "Combines two boolean using OR: `self || that`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { or } from \"effect/Boolean\"\n\nassert.deepStrictEqual(or(true, true), true)\nassert.deepStrictEqual(or(true, false), true)\nassert.deepStrictEqual(or(false, true), true)\nassert.deepStrictEqual(or(false, false), false)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const or: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L150"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean.ts",
      "path": "src/Boolean.ts"
    },
    "project": "effect",
    "name": "nor",
    "description": "Combines two booleans using NOR: `!(self || that)`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { nor } from \"effect/Boolean\"\n\nassert.deepStrictEqual(nor(true, true), false)\nassert.deepStrictEqual(nor(true, false), false)\nassert.deepStrictEqual(nor(false, true), false)\nassert.deepStrictEqual(nor(false, false), true)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const nor: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L172"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean.ts",
      "path": "src/Boolean.ts"
    },
    "project": "effect",
    "name": "xor",
    "description": "Combines two booleans using XOR: `(!self && that) || (self && !that)`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { xor } from \"effect/Boolean\"\n\nassert.deepStrictEqual(xor(true, true), false)\nassert.deepStrictEqual(xor(true, false), true)\nassert.deepStrictEqual(xor(false, true), true)\nassert.deepStrictEqual(xor(false, false), false)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const xor: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L194"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean.ts",
      "path": "src/Boolean.ts"
    },
    "project": "effect",
    "name": "eqv",
    "description": "Combines two booleans using EQV (aka XNOR): `!xor(self, that)`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { eqv } from \"effect/Boolean\"\n\nassert.deepStrictEqual(eqv(true, true), true)\nassert.deepStrictEqual(eqv(true, false), false)\nassert.deepStrictEqual(eqv(false, true), false)\nassert.deepStrictEqual(eqv(false, false), true)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const eqv: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L216"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean.ts",
      "path": "src/Boolean.ts"
    },
    "project": "effect",
    "name": "implies",
    "description": "Combines two booleans using an implication: `(!self || that)`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { implies } from \"effect/Boolean\"\n\nassert.deepStrictEqual(implies(true, true), true)\nassert.deepStrictEqual(implies(true, false), false)\nassert.deepStrictEqual(implies(false, true), true)\nassert.deepStrictEqual(implies(false, false), true)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const implies: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L238"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Boolean.ts",
      "path": "src/Boolean.ts"
    },
    "project": "effect",
    "name": "not",
    "description": "Negates the given boolean: `!self`",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { not } from \"effect/Boolean\"\n\nassert.deepStrictEqual(not(true), false)\nassert.deepStrictEqual(not(false), true)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const not: (self: boolean) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L87"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Boolean.ts",
      "path": "src/Boolean.ts"
    },
    "project": "effect",
    "name": "every",
    "description": "This utility function is used to check if all the elements in a collection of boolean values are `true`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { every } from \"effect/Boolean\"\n\nassert.deepStrictEqual(every([true, true, true]), true)\nassert.deepStrictEqual(every([true, false, true]), false)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const every: (collection: Iterable<boolean>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L257"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Boolean.ts",
      "path": "src/Boolean.ts"
    },
    "project": "effect",
    "name": "some",
    "description": "This utility function is used to check if at least one of the elements in a collection of boolean values is `true`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { some } from \"effect/Boolean\"\n\nassert.deepStrictEqual(some([true, false, true]), true)\nassert.deepStrictEqual(some([false, false, false]), false)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const some: (collection: Iterable<boolean>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Boolean.ts#L280"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "BrandTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const BrandTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L30"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "RefinedConstructorsTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const RefinedConstructorsTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L42"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "refined",
    "description": "Returns a `Brand.Constructor` that can construct a branded type from an unbranded value using the provided `refinement`\npredicate as validation of the input data.\n\nIf you don't want to perform any validation but only distinguish between two values of the same type but with different meanings,\nsee {@link nominal}.\n\n**Example**\n\n```ts\nimport * as assert from \"node:assert\"\nimport { Brand } from \"effect\"\n\ntype Int = number & Brand.Brand<\"Int\">\n\nconst Int = Brand.refined<Int>(\n  (n) => Number.isInteger(n),\n  (n) => Brand.error(`Expected ${n} to be an integer`)\n)\n\nconsole.log(Int(1))\n// 1\n\nassert.throws(() => Int(1.1))\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const refined: { <A extends Brand<any>>(f: (unbranded: Brand.Unbranded<A>) => Option.Option<Brand.BrandErrors>): Brand.Constructor<A>; <A extends Brand<any>>(refinement: Predicate<Brand.Unbranded<A>>, onFailure: (unbranded: Brand.Unbranded<A>) => Brand.BrandErrors): Brand.Constructor<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L224"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "error",
    "description": "Returns a `BrandErrors` that contains a single `RefinementError`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const error: (message: string, meta?: unknown) => Brand.BrandErrors",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L173"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "errors",
    "description": "Takes a variable number of `BrandErrors` and returns a single `BrandErrors` that contains all refinement errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const errors: (...errors: Array<Brand.BrandErrors>) => Brand.BrandErrors",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L184"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "nominal",
    "description": "This function returns a `Brand.Constructor` that **does not apply any runtime checks**, it just returns the provided value.\nIt can be used to create nominal types that allow distinguishing between two values of the same type but with different meanings.\n\nIf you also want to perform some validation, see {@link refined}.\n\n**Example**\n\n```ts\nimport * as assert from \"node:assert\"\nimport { Brand } from \"effect\"\n\ntype UserId = number & Brand.Brand<\"UserId\">\n\nconst UserId = Brand.nominal<UserId>()\n\nconsole.log(UserId(1))\n// 1\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const nominal: <A extends Brand<any>>() => Brand.Constructor<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L269"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "all",
    "description": "Combines two or more brands together to form a single branded type.\nThis API is useful when you want to validate that the input data passes multiple brand validators.\n\n**Example**\n\n```ts\nimport * as assert from \"node:assert\"\nimport { Brand } from \"effect\"\n\ntype Int = number & Brand.Brand<\"Int\">\nconst Int = Brand.refined<Int>(\n  (n) => Number.isInteger(n),\n  (n) => Brand.error(`Expected ${n} to be an integer`)\n)\ntype Positive = number & Brand.Brand<\"Positive\">\nconst Positive = Brand.refined<Positive>(\n  (n) => n > 0,\n  (n) => Brand.error(`Expected ${n} to be positive`)\n)\n\nconst PositiveInt = Brand.all(Int, Positive)\n\nconsole.log(PositiveInt(1))\n// 1\n\nassert.throws(() => PositiveInt(1.1))\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const all: <Brands extends readonly [Brand.Constructor<any>, ...Array<Brand.Constructor<any>>]>(...brands: Brand.EnsureCommonBase<Brands>) => Brand.Constructor<Types.UnionToIntersection<{ [B in keyof Brands]: Brand.FromConstructor<Brands[B]>; }[number]> extends infer X extends Brand<any> ? X : Brand<any>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L313"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "Brand",
    "description": "A generic interface that defines a branded type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Brand<in out K extends string | symbol> {\n  readonly [BrandTypeId]: {\n    readonly [k in K]: K\n  }\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L56"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "BrandTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type BrandTypeId = typeof BrandTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L36"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "RefinedConstructorsTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type RefinedConstructorsTypeId = typeof RefinedConstructorsTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L48"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "Branded",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "alias",
    "signature": "type Branded<A, K> = A & Brand<K>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L165"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "Brand.BrandErrors",
    "description": "Represents a list of refinement errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BrandErrors extends Array<RefinementError> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L72"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "Brand.RefinementError",
    "description": "Represents an error that occurs when the provided value of the branded type does not pass the refinement predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RefinementError {\n    readonly meta: unknown\n    readonly message: string\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L80"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "Brand.Constructor",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Constructor<in out A extends Brand<any>> {\n    readonly [RefinedConstructorsTypeId]: RefinedConstructorsTypeId\n    /**\n     * Constructs a branded type from a value of type `A`, throwing an error if\n     * the provided `A` is not valid.\n     */\n    (args: Brand.Unbranded<A>): A\n    /**\n     * Constructs a branded type from a value of type `A`, returning `Some<A>`\n     * if the provided `A` is valid, `None` otherwise.\n     */\n    option(args: Brand.Unbranded<A>): Option.Option<A>\n    /**\n     * Constructs a branded type from a value of type `A`, returning `Right<A>`\n     * if the provided `A` is valid, `Left<BrandError>` otherwise.\n     */\n    either(args: Brand.Unbranded<A>): Either.Either<A, Brand.BrandErrors>\n    /**\n     * Attempts to refine the provided value of type `A`, returning `true` if\n     * the provided `A` is valid, `false` otherwise.\n     */\n    is(a: Brand.Unbranded<A>): a is Brand.Unbranded<A> & A\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L89"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "Brand.FromConstructor",
    "description": "A utility type to extract a branded type from a `Brand.Constructor`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type FromConstructor<A> = A extends Brand.Constructor<infer B> ? B : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L119"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "Brand.Unbranded",
    "description": "A utility type to extract the value type from a brand.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Unbranded<P> = P extends infer Q & Brands<P> ? Q : P",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L127"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "Brand.Brands",
    "description": "A utility type to extract the brands from a branded type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Brands<P> = P extends Brand<any> ? Types.UnionToIntersection<\n      {\n        [k in keyof P[BrandTypeId]]: k extends string | symbol ? Brand<k>\n          : never\n      }[keyof P[BrandTypeId]]\n    >\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L135"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Brand.ts",
      "path": "src/Brand.ts"
    },
    "project": "effect",
    "name": "Brand.EnsureCommonBase",
    "description": "A utility type that checks that all brands have the same base type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type EnsureCommonBase<Brands> = {\n    [B in keyof Brands]: Brand.Unbranded<Brand.FromConstructor<Brands[0]>> extends\n      Brand.Unbranded<Brand.FromConstructor<Brands[B]>>\n      ? Brand.Unbranded<Brand.FromConstructor<Brands[B]>> extends Brand.Unbranded<Brand.FromConstructor<Brands[0]>>\n        ? Brands[B]\n      : Brands[B]\n      : \"ERROR: All brands should have the same base type\"\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Brand.ts#L149"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "CacheTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const CacheTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L17"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "ConsumerCacheTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.6.4",
    "category": "symbols",
    "signature": "declare const ConsumerCacheTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L29"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new cache with the specified capacity, time to live, and\nlookup function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly timeToLive: Duration.DurationInput; readonly lookup: Lookup<Key, Value, Error, Environment>; }) => Effect.Effect<Cache<Key, Value, Error>, never, Environment>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L202"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "makeWith",
    "description": "Constructs a new cache with the specified capacity, time to live, and\nlookup function, where the time to live can depend on the `Exit` value\nreturned by the lookup function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeWith: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly lookup: Lookup<Key, Value, Error, Environment>; readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput; }) => Effect.Effect<Cache<Key, Value, Error>, never, Environment>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L218"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "makeCacheStats",
    "description": "Constructs a new `CacheStats` from the specified values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeCacheStats: (options: { readonly hits: number; readonly misses: number; readonly size: number; }) => CacheStats",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L245"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "makeEntryStats",
    "description": "Constructs a new `EntryStats` from the specified values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeEntryStats: (loadedMillis: number) => EntryStats",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L269"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "Cache",
    "description": "A `Cache` is defined in terms of a lookup function that, given a key of\ntype `Key`, can either fail with an error of type `Error` or succeed with a\nvalue of type `Value`. Getting a value from the cache will either return\nthe previous result of the lookup function if it is available or else\ncompute a new result with the lookup function, put it in the cache, and\nreturn it.\n\nA cache also has a specified capacity and time to live. When the cache is\nat capacity the least recently accessed values in the cache will be\nremoved to make room for new values. Getting a value with a life older than\nthe specified time to live will result in a new value being computed with\nthe lookup function and returned when available.\n\nThe cache is safe for concurrent access. If multiple fibers attempt to get\nthe same key the lookup function will only be computed once and the result\nwill be returned to all fibers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Cache<in out Key, in out Value, out Error = never>\n  extends ConsumerCache<Key, Value, Error>, Cache.Variance<Key, Value, Error>\n{\n  /**\n   * Retrieves the value associated with the specified key if it exists.\n   * Otherwise computes the value with the lookup function, puts it in the\n   * cache, and returns it.\n   */\n  get(key: Key): Effect.Effect<Value, Error>\n\n  /**\n   * Retrieves the value associated with the specified key if it exists as a left.\n   * Otherwise computes the value with the lookup function, puts it in the\n   * cache, and returns it as a right.\n   */\n  getEither(key: Key): Effect.Effect<Either<Value, Value>, Error>\n\n  /**\n   * Computes the value associated with the specified key, with the lookup\n   * function, and puts it in the cache. The difference between this and\n   * `get` method is that `refresh` triggers (re)computation of the value\n   * without invalidating it in the cache, so any request to the associated\n   * key can still be served while the value is being re-computed/retrieved\n   * by the lookup function. Additionally, `refresh` always triggers the\n   * lookup function, disregarding the last `Error`.\n   */\n  refresh(key: Key): Effect.Effect<void, Error>\n\n  /**\n   * Associates the specified value with the specified key in the cache.\n   */\n  set(key: Key, value: Value): Effect.Effect<void>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L58"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "ConsumerCache",
    "description": "A ConsumerCache models a portion of a cache which is safe to share without allowing to create new values or access existing ones.\n\nIt can be used safely to give over control for request management without leaking writer side details.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ConsumerCache<in out Key, out Value, out Error = never>\n  extends Cache.ConsumerVariance<Key, Value, Error>\n{\n  /**\n   * Retrieves the value associated with the specified key if it exists.\n   * Otherwise returns `Option.none`.\n   */\n  getOption(key: Key): Effect.Effect<Option.Option<Value>, Error>\n\n  /**\n   * Retrieves the value associated with the specified key if it exists and the\n   * lookup function has completed. Otherwise returns `Option.none`.\n   */\n  getOptionComplete(key: Key): Effect.Effect<Option.Option<Value>>\n\n  /**\n   * Returns statistics for this cache.\n   */\n  readonly cacheStats: Effect.Effect<CacheStats>\n\n  /**\n   * Returns whether a value associated with the specified key exists in the\n   * cache.\n   */\n  contains(key: Key): Effect.Effect<boolean>\n\n  /**\n   * Returns statistics for the specified entry.\n   */\n  entryStats(key: Key): Effect.Effect<Option.Option<EntryStats>>\n\n  /**\n   * Invalidates the value associated with the specified key.\n   */\n  invalidate(key: Key): Effect.Effect<void>\n\n  /**\n   * Invalidates the value associated with the specified key if the predicate holds.\n   */\n  invalidateWhen(key: Key, predicate: Predicate.Predicate<Value>): Effect.Effect<void>\n\n  /**\n   * Invalidates all values in the cache.\n   */\n  readonly invalidateAll: Effect.Effect<void>\n\n  /**\n   * Returns the approximate number of values in the cache.\n   */\n  readonly size: Effect.Effect<number>\n\n  /**\n   * Returns an approximation of the values in the cache.\n   */\n  readonly keys: Effect.Effect<Array<Key>>\n\n  /**\n   * Returns an approximation of the values in the cache.\n   */\n  readonly values: Effect.Effect<Array<Value>>\n\n  /**\n   * Returns an approximation of the values in the cache.\n   */\n  readonly entries: Effect.Effect<Array<[Key, Value]>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L100"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "CacheStats",
    "description": "`CacheStats` represents a snapshot of statistics for the cache as of a\npoint in time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface CacheStats {\n  readonly hits: number\n  readonly misses: number\n  readonly size: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L233"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "EntryStats",
    "description": "Represents a snapshot of statistics for an entry in the cache.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface EntryStats {\n  readonly loadedMillis: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L259"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "CacheTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type CacheTypeId = typeof CacheTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L23"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "ConsumerCacheTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.6.4",
    "category": "symbols",
    "signature": "type ConsumerCacheTypeId = typeof ConsumerCacheTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L35"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "Lookup",
    "description": "A `Lookup` represents a lookup function that, given a key of type `Key`, can\nreturn an effect that will either produce a value of type `Value` or fail\nwith an error of type `Error` using an environment of type `Environment`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Lookup<Key, Value, Error, Environment> = (\n  key: Key\n) => Effect.Effect<Value, Error, Environment>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L279"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "Cache.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out Key, in out Value, out Error> {\n    readonly [CacheTypeId]: {\n      readonly _Key: Types.Invariant<Key>\n      readonly _Error: Types.Covariant<Error>\n      readonly _Value: Types.Invariant<Value>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L175"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cache.ts",
      "path": "src/Cache.ts"
    },
    "project": "effect",
    "name": "Cache.ConsumerVariance",
    "deprecated": false,
    "examples": [],
    "since": "3.6.4",
    "category": "models",
    "signature": "export interface ConsumerVariance<in out Key, out Value, out Error> {\n    readonly [ConsumerCacheTypeId]: {\n      readonly _Key: Types.Invariant<Key>\n      readonly _Error: Types.Covariant<Error>\n      readonly _Value: Types.Covariant<Value>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cache.ts#L186"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "CauseTypeId",
    "description": "A unique symbol identifying the `Cause` type.\n\n**Details**\n\nThis provides a symbol that helps identify instances of the `Cause` data\ntype. This can be used for advanced operations such as refining types or\nbuilding internal utilities that check whether an unknown value is a `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "declare const CauseTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L56"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "RuntimeExceptionTypeId",
    "description": "A unique symbol identifying the `RuntimeException` type.\n\n**Details**\n\nThis provides a symbol that identifies a `RuntimeException`. This is\ntypically used internally by the library to recognize checked exceptions that\noccur during runtime.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "declare const RuntimeExceptionTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L78"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "InterruptedExceptionTypeId",
    "description": "A unique symbol identifying the `InterruptedException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `InterruptedException`. This is\ntypically used internally to recognize when a fiber has been interrupted,\nhelping the framework handle interruption logic correctly.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "declare const InterruptedExceptionTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L100"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "IllegalArgumentExceptionTypeId",
    "description": "A unique symbol identifying the `IllegalArgumentException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `IllegalArgumentException`. This is\noften used in scenarios where invalid arguments are supplied to methods that\nexpect specific input.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "declare const IllegalArgumentExceptionTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L122"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "NoSuchElementExceptionTypeId",
    "description": "A unique symbol identifying the `NoSuchElementException` type.\n\n**Details**\n\nThis provides a symbol that identifies a `NoSuchElementException`. It helps\ndifferentiate cases where a required element is missing within a data\nstructure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "declare const NoSuchElementExceptionTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L144"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "InvalidPubSubCapacityExceptionTypeId",
    "description": "A unique symbol identifying the `InvalidPubSubCapacityException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `InvalidPubSubCapacityException`.\nIt indicates an error related to an invalid capacity passed to a `PubSub`\nstructure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "declare const InvalidPubSubCapacityExceptionTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L166"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "ExceededCapacityExceptionTypeId",
    "description": "A unique symbol identifying the `ExceededCapacityException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `ExceededCapacityException`. It\ndenotes situations where a resource has exceeded its configured capacity\nlimit.",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "Symbols",
    "signature": "declare const ExceededCapacityExceptionTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L188"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "TimeoutExceptionTypeId",
    "description": "A unique symbol identifying the `TimeoutException` type.\n\n**Details**\n\nThis provides a symbol that identifies a `TimeoutException`. It helps the\nframework recognize errors related to operations that fail to complete within\na given timeframe.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "declare const TimeoutExceptionTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L210"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "UnknownExceptionTypeId",
    "description": "A unique symbol identifying the `UnknownException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `UnknownException`. It is typically\nused for generic or unexpected errors that do not fit other specific\nexception categories.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "declare const UnknownExceptionTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L232"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "YieldableError",
    "description": "Creates an error that occurs at runtime, extendable for other exception\ntypes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "declare const YieldableError: new (message?: string | undefined) => YieldableError",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L326"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates an `Empty` cause.\n\n**Details**\n\nThis function returns a cause that signifies \"no error.\" It's commonly used\nto represent an absence of failure conditions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const empty: Cause<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L575"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "fail",
    "description": "Creates a `Fail` cause from an expected error.\n\n**Details**\n\nThis function constructs a `Cause` carrying an error of type `E`. It's used\nwhen you want to represent a known or anticipated failure in your effectful\ncomputations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const fail: <E>(error: E) => Cause<E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L591"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "die",
    "description": "Creates a `Die` cause from an unexpected error.\n\n**Details**\n\nThis function wraps an unhandled or unknown defect (like a runtime crash)\ninto a `Cause`. It's useful for capturing unforeseen issues in a structured\nway.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const die: (defect: unknown) => Cause<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L607"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "interrupt",
    "description": "Creates an `Interrupt` cause from a `FiberId`.\n\n**Details**\n\nThis function represents a fiber that has been interrupted. It stores the\nidentifier of the interrupted fiber, enabling precise tracking of concurrent\ncancellations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const interrupt: (fiberId: FiberId.FiberId) => Cause<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L623"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "parallel",
    "description": "Combines two `Cause`s in parallel.\n\n**Details**\n\nThis function merges two errors that occurred simultaneously. Instead of\ndiscarding one error, both are retained, allowing for richer error reporting\nand debugging.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const parallel: <E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L639"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "sequential",
    "description": "Combines two `Cause`s sequentially.\n\n**Details**\n\nThis function merges two errors that occurred in sequence, such as a main\nerror followed by a finalization error. It preserves both errors for complete\nfailure information.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const sequential: <E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L655"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isCause",
    "description": "Checks if a value is a `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isCause: (u: unknown) => u is Cause<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L663"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isEmptyType",
    "description": "Checks if a `Cause` is an `Empty` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isEmptyType: <E>(self: Cause<E>) => self is Empty",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L673"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isFailType",
    "description": "Checks if a `Cause` is a `Fail` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isFailType: <E>(self: Cause<E>) => self is Fail<E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L683"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isDieType",
    "description": "Checks if a `Cause` is a `Die` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isDieType: <E>(self: Cause<E>) => self is Die",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L693"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isInterruptType",
    "description": "Checks if a `Cause` is an `Interrupt` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isInterruptType: <E>(self: Cause<E>) => self is Interrupt",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L703"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isSequentialType",
    "description": "Checks if a `Cause` is a `Sequential` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isSequentialType: <E>(self: Cause<E>) => self is Sequential<E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L713"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isParallelType",
    "description": "Checks if a `Cause` is a `Parallel` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isParallelType: <E>(self: Cause<E>) => self is Parallel<E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L723"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Calculates the size of a `Cause`.\n\n**Details**\n\nThis function returns the total number of `Cause` nodes in the semiring\nstructure, reflecting how many individual error elements are recorded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const size: <E>(self: Cause<E>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L736"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Checks if a `Cause` is entirely empty.\n\n**Details**\n\nThis function returns `true` if the `Cause` contains no errors, defects, or\ninterruptions. It's helpful for verifying if a computation truly had no\nfailures.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const isEmpty: <E>(self: Cause<E>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L750"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isFailure",
    "description": "Checks if a `Cause` contains a failure.\n\n**Details**\n\nThis function returns `true` if the `Cause` includes any `Fail` error. It's\ncommonly used to confirm whether a workflow encountered an anticipated error\nversus just defects or interruptions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const isFailure: <E>(self: Cause<E>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L764"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isDie",
    "description": "Checks if a `Cause` contains a defect.\n\n**Details**\n\nThis function returns `true` if the `Cause` includes any unexpected or\nunhandled errors (`Die`). It's useful for differentiating known failures from\nunexpected ones.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const isDie: <E>(self: Cause<E>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L778"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isInterrupted",
    "description": "Checks if a `Cause` contains an interruption.\n\n**Details**\n\nThis function returns `true` if the `Cause` includes any fiber interruptions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const isInterrupted: <E>(self: Cause<E>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L790"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isInterruptedOnly",
    "description": "Checks if a `Cause` contains only interruptions.\n\n**Details**\n\nThis function returns `true` if the `Cause` has been interrupted but does not\ncontain any other failures, such as `Fail` or `Die`. It's helpful for\nverifying purely \"cancellation\" scenarios.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const isInterruptedOnly: <E>(self: Cause<E>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L804"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "failures",
    "description": "Extracts all recoverable errors of type `E` from a `Cause`.\n\n**Details**\n\nThis function returns a chunk of errors, providing a list of all `Fail`\nvalues found in the cause. It's useful for collecting all known failures for\nlogging or combined error handling.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const failures: <E>(self: Cause<E>) => Chunk.Chunk<E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L818"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "defects",
    "description": "Extracts all unrecoverable defects from a `Cause`.\n\n**Details**\n\nThis function returns a chunk of values representing unexpected errors\n(`Die`). It's handy for capturing or logging unanticipated failures that\nmight need special handling, such as bug reports.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const defects: <E>(self: Cause<E>) => Chunk.Chunk<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L832"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "interruptors",
    "description": "Collects all `FiberId`s responsible for interrupting a fiber.\n\n**Details**\n\nThis function returns a set of IDs indicating which fibers caused\ninterruptions within this `Cause`. It's useful for debugging concurrency\nissues or tracing cancellations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const interruptors: <E>(self: Cause<E>) => HashSet.HashSet<FiberId.FiberId>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L846"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "failureOption",
    "description": "Retrieves the first `Fail` error in a `Cause`, if present.\n\n**Details**\n\nThis function returns an `Option` containing the first recoverable error\n(`E`) from the cause. It's often used to quickly check if there's a primary\nerror to handle or display.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const failureOption: <E>(self: Cause<E>) => Option.Option<E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L860"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "failureOrCause",
    "description": "Splits a `Cause` into either its first `Fail` error or the rest of the cause\n(which might only contain `Die` or `Interrupt`).\n\n**Details**\n\nThis function either returns the checked error (`E`) or the remaining\n`Cause<never>` with defects/interruptions. It helps you decide if there's a\nrecoverable path or if only unhandled issues remain.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const failureOrCause: <E>(self: Cause<E>) => Either.Either<Cause<never>, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L875"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "flipCauseOption",
    "description": "Strips out failures with an error of `None` from a `Cause<Option<E>>`.\n\n**Details**\n\nThis function turns a `Cause<Option<E>>` into an `Option<Cause<E>>`. If the\ncause only contains failures of `None`, it becomes `None`; otherwise, it\nreturns a `Cause` of the remaining errors. It's helpful when working with\noptional errors and filtering out certain error paths.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const flipCauseOption: <E>(self: Cause<Option.Option<E>>) => Option.Option<Cause<E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L890"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "dieOption",
    "description": "Retrieves the first `Die` defect in a `Cause`, if present.\n\n**Details**\n\nThis function returns an `Option` containing the first unexpected failure\n(`Die`) discovered. It's helpful for diagnosing the primary defect in a chain\nof errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const dieOption: <E>(self: Cause<E>) => Option.Option<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L904"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "interruptOption",
    "description": "Retrieves the first `Interrupt` in a `Cause`, if present.\n\n**Details**\n\nThis function returns an `Option` with the first fiber interruption\ndiscovered. This is particularly useful for concurrency analysis or debugging\ncancellations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const interruptOption: <E>(self: Cause<E>) => Option.Option<FiberId.FiberId>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L918"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "keepDefects",
    "description": "Removes all `Fail` and `Interrupt` nodes, keeping only defects (`Die`) in a\n`Cause`.\n\n**Details**\n\nThis function strips a cause of recoverable errors and interruptions, leaving\nonly unexpected failures. If no defects remain, it returns `None`. It's\nvaluable for focusing only on unanticipated problems when both known errors\nand defects could occur.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const keepDefects: <E>(self: Cause<E>) => Option.Option<Cause<never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L934"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "linearize",
    "description": "Linearizes a `Cause` into a set of parallel causes, each containing a\nsequential chain of failures.\n\n**Details**\n\nThis function reorganizes the cause structure so that you can analyze each\nparallel branch separately, even if they have multiple sequential errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const linearize: <E>(self: Cause<E>) => HashSet.HashSet<Cause<E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L949"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "stripFailures",
    "description": "Removes `Fail` and `Interrupt` nodes from a `Cause`, keeping only defects\n(`Die`).\n\n**Details**\n\nThis function is similar to `keepDefects` but returns a `Cause<never>`\ndirectly, which can still store `Die` or finalizer-related defects. It's\nhelpful for analyzing only the irrecoverable portion of the error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const stripFailures: <E>(self: Cause<E>) => Cause<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L964"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "stripSomeDefects",
    "description": "Removes matching defects from a `Cause` using a partial function, returning\nthe remainder.\n\n**Details**\n\nThis function applies a user-defined extraction function to each defect\n(`Die`). If the function matches the defect, that defect is removed. If all\ndefects match, the result is `None`. Otherwise, you get a `Cause` with the\nunmatched defects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const stripSomeDefects: { (pf: (defect: unknown) => Option.Option<unknown>): <E>(self: Cause<E>) => Option.Option<Cause<E>>; <E>(self: Cause<E>, pf: (defect: unknown) => Option.Option<unknown>): Option.Option<Cause<E>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L980"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "as",
    "description": "Replaces any errors in a `Cause` with a provided constant error.\n\n**Details**\n\nThis function transforms all `Fail` errors into the specified error value,\npreserving the structure of the `Cause`. It's useful when you no longer need\nthe original error details but still want to keep the cause shape.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const as: { <E2>(error: E2): <E>(self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, error: E2): Cause<E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L999"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms the errors in a `Cause` using a user-provided function.\n\n**Details**\n\nThis function applies `f` to each `Fail` error while leaving defects (`Die`)\nand interruptions untouched. It's useful for changing or simplifying error\ntypes in your effectful workflows.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const map: { <E, E2>(f: (e: E) => E2): (self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => E2): Cause<E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1018"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Transforms errors in a `Cause` into new causes.\n\n**Details**\n\nThis function applies a function `f` to each `Fail` error, converting it into\na new `Cause`. This is especially powerful for merging or restructuring error\ntypes while preserving or combining cause information.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const flatMap: { <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1037"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "andThen",
    "description": "Sequences two `Cause`s. The second `Cause` can be dependent on the result of\nthe first `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const andThen: { <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>; <E2>(f: Cause<E2>): <E>(self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>; <E, E2>(self: Cause<E>, f: Cause<E2>): Cause<E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1049"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens a nested `Cause` structure.\n\n**Details**\n\nThis function takes a `Cause<Cause<E>>` and merges the layers into a single\n`Cause<E>`. It's useful for eliminating additional nesting created by\nrepeated transformations or compositions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const flatten: <E>(self: Cause<Cause<E>>) => Cause<E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1070"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "contains",
    "description": "Checks if the current `Cause` contains or is equal to another `Cause`.\n\n**Details**\n\nThis function returns `true` if `that` cause is part of or the same as\nthe current `Cause`. It's useful when you need to check for specific\nerror patterns or deduplicate repeated failures.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Elements",
    "signature": "declare const contains: { <E2>(that: Cause<E2>): <E>(self: Cause<E>) => boolean; <E, E2>(self: Cause<E>, that: Cause<E2>): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1084"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "squash",
    "description": "Extracts the most \"important\" defect from a `Cause`.\n\n**Details**\n\nThis function reduces a `Cause` to a single, prioritized defect. It evaluates\nthe `Cause` in the following order of priority:\n\n1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it returns\n   the raw error value.\n2. If there is no failure, it looks for the first defect (e.g., from\n   `Effect.die`).\n3. If neither of the above is present, and the `Cause` stems from an\n   interruption, it creates and returns an `InterruptedException`.\n\nThis function ensures you can always extract a meaningful representation of\nthe primary issue from a potentially complex `Cause` structure.\n\n**When to Use**\n\nUse this function when you need to extract the most relevant error or defect\nfrom a `Cause`, especially in scenarios where multiple errors or defects may\nbe present. It's particularly useful for simplifying error reporting or\nlogging.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Destructors",
    "signature": "declare const squash: <E>(self: Cause<E>) => unknown",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1119"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "squashWith",
    "description": "Extracts the most \"important\" defect from a `Cause`, transforming failures\ninto defects using a provided function.\n\n**Details**\n\nThis function reduces a `Cause` to a single, prioritized defect, while\nallowing you to transform recoverable failures into defects through a custom\nfunction. It processes the `Cause` in the following order:\n\n1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it applies\n   the provided function `f` to the error to transform it into a defect.\n2. If there is no failure, it looks for the first defect (e.g., from\n   `Effect.die`) and returns it.\n3. If neither is present and the `Cause` stems from an interruption, it\n   returns an `InterruptedException`.\n\nThis function is particularly useful when you need custom handling or\ntransformation of errors while processing a `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Destructors",
    "signature": "declare const squashWith: { <E>(f: (error: E) => unknown): (self: Cause<E>) => unknown; <E>(self: Cause<E>, f: (error: E) => unknown): unknown; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1146"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "find",
    "description": "Searches a `Cause` using a partial function to extract information.\n\n**Details**\n\nThis function allows you to search through a `Cause` using a custom partial\nfunction. The partial function is applied to the `Cause`, and if it matches,\nthe result is returned wrapped in a `Some`. If no match is found, the result\nis `None`.\n\nThis is particularly useful when you are only interested in specific types of\nerrors, defects, or interruption causes within a potentially complex `Cause`\nstructure. By leveraging a partial function, you can focus on extracting only\nthe relevant information you care about.\n\nThe partial function should return an `Option` indicating whether it matched\nand the value it extracted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Elements",
    "signature": "declare const find: { <E, Z>(pf: (cause: Cause<E>) => Option.Option<Z>): (self: Cause<E>) => Option.Option<Z>; <E, Z>(self: Cause<E>, pf: (cause: Cause<E>) => Option.Option<Z>): Option.Option<Z>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1172"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "filter",
    "description": "Preserves parts of a `Cause` that match a given predicate.\n\n**Details**\n\nThis function allows you to retain only the parts of a `Cause` structure that\nmatch a specified predicate or refinement. Any parts of the `Cause` that do\nnot match the provided condition are excluded from the result.\n\nYou can use this function in two ways:\n- With a `Predicate`: A function that evaluates whether a `Cause` should be\n  retained based on its value.\n- With a `Refinement`: A more specific predicate that can refine the type of\n  the `Cause`.\n\nThis is useful when you need to extract specific types of errors, defects, or\ninterruptions from a `Cause` while discarding unrelated parts.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "declare const filter: { <E, EB extends E>(refinement: Refinement<Cause<NoInfer<E>>, Cause<EB>>): (self: Cause<E>) => Cause<EB>; <E>(predicate: Predicate<Cause<NoInfer<E>>>): (self: Cause<E>) => Cause<E>; <E, EB extends E>(self: Cause<E>, refinement: Refinement<Cause<E>, Cause<EB>>): Cause<EB>; <E>(self: Cause<E>, predicate: Predicate<Cause<E>>): Cause<E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1198"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Transforms a `Cause` into a single value using custom handlers for each\npossible case.\n\n**Details**\n\nThis function processes a `Cause` by applying a set of custom handlers to\neach possible type of cause: `Empty`, `Fail`, `Die`, `Interrupt`,\n`Sequential`, and `Parallel`. The result of this function is a single value\nof type `Z`. This function allows you to define exactly how to handle each\npart of a `Cause`, whether it's a failure, defect, interruption, or a\ncombination of these.\n\nThe options parameter provides handlers for:\n- `onEmpty`: Handles the case where the cause is `Empty`, meaning no errors\n  occurred.\n- `onFail`: Processes a failure with an error of type `E`.\n- `onDie`: Processes a defect (unexpected error).\n- `onInterrupt`: Handles a fiber interruption, providing the `FiberId` of the\n  interruption.\n- `onSequential`: Combines two sequential causes into a single value of type\n  `Z`.\n- `onParallel`: Combines two parallel causes into a single value of type `Z`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Matching",
    "signature": "declare const match: { <Z, E>(options: { readonly onEmpty: Z; readonly onFail: (error: E) => Z; readonly onDie: (defect: unknown) => Z; readonly onInterrupt: (fiberId: FiberId.FiberId) => Z; readonly onSequential: (left: Z, right: Z) => Z; readonly onParallel: (left: Z, right: Z) => Z; }): (self: Cause<E>) => Z; <Z, E>(self: Cause<E>, options: { readonly onEmpty: Z; readonly onFail: (error: E) => Z; readonly onDie: (defect: unknown) => Z; readonly onInterrupt: (fiberId: FiberId.FiberId) => Z; readonly onSequential: (left: Z, right: Z) => Z; readonly onParallel: (left: Z, right: Z) => Z; }): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1232"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "reduce",
    "description": "Combines all parts of a `Cause` into a single value by starting with an\ninitial value.\n\n**Details**\n\nThis function processes a `Cause` by starting with an initial value (`zero`)\nand applying a custom function (`pf`) to combine all elements of the `Cause`\ninto a single result of type `Z`. The custom function determines how each\npart of the `Cause` contributes to the final result. The function can return\nan `Option` to either continue combining values or skip specific parts of the\n`Cause`.\n\nThis function is useful for tasks such as:\n- Aggregating error messages from a `Cause` into a single string.\n- Summarizing the structure of a `Cause` into a simplified result.\n- Filtering or processing only specific parts of a `Cause`.\n\nThe reduction proceeds in a top-down manner, visiting all nodes in the\n`Cause` structure. This gives you complete control over how each part of the\n`Cause` contributes to the final result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Reducing",
    "signature": "declare const reduce: { <Z, E>(zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option.Option<Z>): (self: Cause<E>) => Z; <Z, E>(self: Cause<E>, zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option.Option<Z>): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1281"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "reduceWithContext",
    "description": "Combines all parts of a `Cause` into a single value using a custom reducer\nand a context.\n\n**Details**\n\nThis function allows you to reduce a `Cause` into a single value of type `Z`\nusing a custom `CauseReducer`. A `CauseReducer` provides methods to handle\nspecific parts of the `Cause`, such as failures, defects, or interruptions.\nAdditionally, this function provides access to a `context` value, which can\nbe used to carry information or maintain state during the reduction process.\n\nThis is particularly useful when the reduction process needs additional\ncontext or configuration, such as:\n- Aggregating error details with dynamic formatting.\n- Collecting logs or statistics about the `Cause`.\n- Performing stateful transformations based on the `context`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Reducing",
    "signature": "declare const reduceWithContext: { <C, E, Z>(context: C, reducer: CauseReducer<C, E, Z>): (self: Cause<E>) => Z; <C, E, Z>(self: Cause<E>, context: C, reducer: CauseReducer<C, E, Z>): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1309"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "InterruptedException",
    "description": "Creates an error that indicates a `Fiber` was interrupted.\n\n**Details**\n\nThis function constructs an `InterruptedException` recognized by the Effect\nruntime. It is usually thrown or returned when a fiber's execution is\ninterrupted by external events or by another fiber. This is particularly\nhelpful in concurrent programs where fibers may halt each other before\ncompletion.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "declare const InterruptedException: new (message?: string | undefined) => InterruptedException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1328"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isInterruptedException",
    "description": "Checks if a given unknown value is an `InterruptedException`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isInterruptedException: (u: unknown) => u is InterruptedException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1336"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "IllegalArgumentException",
    "description": "Creates an error indicating an invalid method argument.\n\n**Details**\n\nThis function constructs an `IllegalArgumentException`. It is typically\nthrown or returned when an operation receives improper inputs, such as\nout-of-range values or invalid object states.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "declare const IllegalArgumentException: new (message?: string | undefined) => IllegalArgumentException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1350"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isIllegalArgumentException",
    "description": "Checks if a given unknown value is an `IllegalArgumentException`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isIllegalArgumentException: (u: unknown) => u is IllegalArgumentException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1359"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "NoSuchElementException",
    "description": "Creates an error indicating a missing element.\n\n**Details**\n\nThis function constructs a `NoSuchElementException`. It helps you clearly\ncommunicate that a required element is unavailable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "declare const NoSuchElementException: new (message?: string | undefined) => NoSuchElementException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1372"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isNoSuchElementException",
    "description": "Checks if a given unknown value is a `NoSuchElementException`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isNoSuchElementException: (u: unknown) => u is NoSuchElementException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1381"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "RuntimeException",
    "description": "Creates an error for general runtime errors.\n\n**Details**\n\nThis function constructs a `RuntimeException`, for errors that occur at\nruntime but are not specifically typed or categorized as interruptions,\nmissing elements, or invalid arguments. It helps unify a wide range of\nunexpected conditions under a single, recognizable error type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "declare const RuntimeException: new (message?: string | undefined) => RuntimeException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1396"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isRuntimeException",
    "description": "Checks if a given unknown value is a `RuntimeException`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isRuntimeException: (u: unknown) => u is RuntimeException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1404"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "TimeoutException",
    "description": "Creates an error for operations that exceed their expected time.\n\n**Details**\n\nThis function constructs a `TimeoutException`. It is typically used to signal\nthat an operation or fiber did not complete within a designated time limit,\nallowing you to handle slow or hanging processes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "declare const TimeoutException: new (message?: string | undefined) => TimeoutException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1418"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "UnknownException",
    "description": "Creates an instance of `UnknownException`, an error object used to handle\nunknown errors such as those from rejected promises.\n\n**Details**\n\nThis function constructs an `UnknownException` with flexible behavior for\nmanaging the error message and cause.\n\nThe required `error` argument is passed as the `cause` to the global `Error`\nconstructor, ensuring that the original cause is preserved in the error chain\nfor debugging purposes. This ensures that the origin stack trace is\npreserved.\n\nThe `error` argument is always stored in the `error` property of the\n`UnknownException` instance for reference, regardless of its type.\n\nAdditionally, if you provide a `message` argument, it is used as the error\nmessage. If no `message` is provided, the error message defaults to `\"An\nunknown error occurred\"`.\n\n**When to Use**\n\nUse this function when you need to handle unexpected or unknown errors in\nyour application, particularly when the source of the error might not provide\na clear message. This is useful for wrapping generic errors thrown from\npromises or external APIs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "declare const UnknownException: new (error: unknown, message?: string | undefined) => UnknownException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1451"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isUnknownException",
    "description": "Checks if a given unknown value is an `UnknownException`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isUnknownException: (u: unknown) => u is UnknownException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1460"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "ExceededCapacityException",
    "description": "Creates an error indicating resource capacity has been exceeded.\n\n**Details**\n\nThis function constructs an `ExceededCapacityException`, signifying that an\noperation or resource usage surpassed established limits. This can be\nessential for concurrency or resource management situations, ensuring your\napplication doesn't go beyond acceptable thresholds.",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "Errors",
    "signature": "declare const ExceededCapacityException: new (message?: string | undefined) => ExceededCapacityException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1475"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "isExceededCapacityException",
    "description": "Checks if a given unknown value is an `ExceededCapacityException`.",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "Guards",
    "signature": "declare const isExceededCapacityException: (u: unknown) => u is ExceededCapacityException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1484"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "pretty",
    "description": "Converts a `Cause` into a human-readable string.\n\n**Details**\n\nThis function pretty-prints the entire `Cause`, including any failures,\ndefects, and interruptions. It can be especially helpful for logging,\ndebugging, or displaying structured errors to users.\n\nYou can optionally pass `options` to configure how the error cause is\nrendered. By default, it includes essential details of all errors in the\n`Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Formatting",
    "signature": "declare const pretty: <E>(cause: Cause<E>, options?: { readonly renderErrorCause?: boolean | undefined; }) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1505"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "prettyErrors",
    "description": "Returns a list of prettified errors (`PrettyError`) from a `Cause`.\n\n**Details**\n\nThis function inspects the entire `Cause` and produces an array of\n`PrettyError` objects. Each object may include additional metadata, such as a\n`Span`, to provide deeper insights into where and how the error occurred.",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": "Formatting",
    "signature": "declare const prettyErrors: <E>(cause: Cause<E>) => Array<PrettyError>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1531"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "originalError",
    "description": "Retrieves the original, unproxied error instance from an error object.\n\n**Details**\n\nThis function returns the underlying error object without any\nlibrary-specific wrapping or proxying that might occur during error handling.\nThis can be essential if you need direct access to the error's native\nproperties, such as stack traces or custom data fields, for detailed\ndebugging or integration with external systems.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "declare const originalError: <E>(obj: E) => E",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1547"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "CauseReducer",
    "description": "Describes methods for reducing a `Cause<E>` into a value of type `Z` with\naccess to contextual information.\n\n**Details**\n\nThis interface is meant for advanced transformations of `Cause`. By\nimplementing each method, you can define how different parts of the `Cause`\nstructure (like `Fail`, `Die`, or `Interrupt`) should be transformed into a\nfinal type `Z`. The `context` parameter carries additional data needed during\nthis reduction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface CauseReducer<in C, in E, in out Z> {\n  emptyCase(context: C): Z\n  failCase(context: C, error: E): Z\n  dieCase(context: C, defect: unknown): Z\n  interruptCase(context: C, fiberId: FiberId.FiberId): Z\n  sequentialCase(context: C, left: Z, right: Z): Z\n  parallelCase(context: C, left: Z, right: Z): Z\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L296"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "YieldableError",
    "description": "Represents an error object that can be yielded in `Effect.gen`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface YieldableError extends Pipeable, Inspectable, Readonly<Error> {\n  readonly [Effect.EffectTypeId]: Effect.Effect.VarianceStruct<never, this, never>\n  readonly [Stream.StreamTypeId]: Stream.Stream.VarianceStruct<never, this, never>\n  readonly [Sink.SinkTypeId]: Sink.Sink.VarianceStruct<never, unknown, never, this, never>\n  readonly [Channel.ChannelTypeId]: Channel.Channel.VarianceStruct<never, unknown, this, unknown, never, unknown, never>\n  [Symbol.iterator](): Effect.EffectGenerator<Effect.Effect<never, this, never>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L311"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "RuntimeException",
    "description": "An error representing a runtime error.\n\n**Details**\n\nThis interface is used for errors that occur at runtime but are still\nconsidered recoverable or typed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface RuntimeException extends YieldableError {\n  readonly _tag: \"RuntimeException\"\n  readonly [RuntimeExceptionTypeId]: RuntimeExceptionTypeId\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L339"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "InterruptedException",
    "description": "An error representing fiber interruption.\n\n**Details**\n\nThis interface represents errors that occur when a fiber is forcefully\ninterrupted. Interruption can happen for various reasons, including\ncancellations or system directives to halt operations. Code that deals with\nconcurrency might need to catch or handle these to ensure proper cleanup.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface InterruptedException extends YieldableError {\n  readonly _tag: \"InterruptedException\"\n  readonly [InterruptedExceptionTypeId]: InterruptedExceptionTypeId\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L357"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "IllegalArgumentException",
    "description": "An error representing an invalid argument passed to a method.\n\n**Details**\n\nThis interface is used for signaling that a function or method received an\nargument that does not meet its preconditions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface IllegalArgumentException extends YieldableError {\n  readonly _tag: \"IllegalArgumentException\"\n  readonly [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L373"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "NoSuchElementException",
    "description": "An error that occurs when an expected element is missing.\n\n**Details**\n\nThis interface indicates scenarios like looking up an item in a collection\nor searching for data that should be present but isn't. It helps your code\nsignal a more specific issue rather than a general error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface NoSuchElementException extends YieldableError {\n  readonly _tag: \"NoSuchElementException\"\n  readonly [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L390"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "InvalidPubSubCapacityException",
    "description": "An error indicating invalid capacity for a `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface InvalidPubSubCapacityException extends YieldableError {\n  readonly _tag: \"InvalidPubSubCapacityException\"\n  readonly [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L401"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "ExceededCapacityException",
    "description": "An error that occurs when resource capacity is exceeded.",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "Models",
    "signature": "export interface ExceededCapacityException extends YieldableError {\n  readonly _tag: \"ExceededCapacityException\"\n  readonly [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L412"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "TimeoutException",
    "description": "An error representing a computation that timed out.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface TimeoutException extends YieldableError {\n  readonly _tag: \"TimeoutException\"\n  readonly [TimeoutExceptionTypeId]: TimeoutExceptionTypeId\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L423"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "UnknownException",
    "description": "A checked exception for handling unknown or unexpected errors.\n\n**Details**\n\nThis interface captures errors that don't fall under known categories. It is\nespecially helpful for wrapping low-level or third-party library errors that\nmight provide little or no context, such as from a rejected promise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface UnknownException extends YieldableError {\n  readonly _tag: \"UnknownException\"\n  readonly [UnknownExceptionTypeId]: UnknownExceptionTypeId\n  readonly error: unknown\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L440"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "Empty",
    "description": "Represents a lack of errors within a `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Empty extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Empty\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L455"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "Fail",
    "description": "Represents an expected error within a `Cause`.\n\n**Details**\n\nThis interface models a `Cause` that carries an expected or known error of\ntype `E`. For example, if you validate user input and find it invalid, you\nmight store that error within a `Fail`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Fail<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Fail\"\n  readonly error: E\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L474"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "Die",
    "description": "Represents an unexpected defect within a `Cause`.\n\n**Details**\n\nThis interface models a `Cause` for errors that are typically unrecoverable or\nunanticipatedlike runtime exceptions or bugs. When code \"dies,\" it indicates a\nsevere failure that wasn't accounted for.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Die extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Die\"\n  readonly defect: unknown\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L494"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "Interrupt",
    "description": "Represents fiber interruption within a `Cause`.\n\n**Details**\n\nThis interface models a scenario where an effect was halted by an external\nsignal, carrying a `FiberId` that identifies which fiber was interrupted.\nInterruption is a normal part of concurrency, used for cancellation or\nresource cleanup.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Interrupt extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Interrupt\"\n  readonly fiberId: FiberId.FiberId\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L515"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "Parallel",
    "description": "Represents parallel composition of two `Cause`s.\n\n**Details**\n\nThis interface captures failures that happen simultaneously. In scenarios\nwith concurrency, more than one operation can fail in parallel. Instead of\nlosing information, this structure stores both errors together.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Parallel<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Parallel\"\n  readonly left: Cause<E>\n  readonly right: Cause<E>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L535"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "Sequential",
    "description": "Represents sequential composition of two `Cause`s.\n\n**Details**\n\nThis interface models the scenario where one error follows another in\nsequence, such as when a main effect fails and then a finalizer also fails.\nIt ensures both errors are retained in the final `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Sequential<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Sequential\"\n  readonly left: Cause<E>\n  readonly right: Cause<E>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L556"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "PrettyError",
    "description": "A shape for prettified errors, optionally including a source span.",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": "Models",
    "signature": "export interface PrettyError extends Error {\n  readonly span: Span | undefined\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L1515"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "CauseTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "type CauseTypeId = typeof CauseTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L62"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "RuntimeExceptionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "type RuntimeExceptionTypeId = typeof RuntimeExceptionTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L84"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "InterruptedExceptionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "type InterruptedExceptionTypeId = typeof InterruptedExceptionTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L106"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "IllegalArgumentExceptionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "type IllegalArgumentExceptionTypeId = typeof IllegalArgumentExceptionTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L128"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "NoSuchElementExceptionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "type NoSuchElementExceptionTypeId = typeof NoSuchElementExceptionTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L150"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "InvalidPubSubCapacityExceptionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "type InvalidPubSubCapacityExceptionTypeId = typeof InvalidPubSubCapacityExceptionTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L172"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "ExceededCapacityExceptionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "Symbols",
    "signature": "type ExceededCapacityExceptionTypeId = typeof ExceededCapacityExceptionTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L194"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "TimeoutExceptionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "type TimeoutExceptionTypeId = typeof TimeoutExceptionTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L216"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "UnknownExceptionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "type UnknownExceptionTypeId = typeof UnknownExceptionTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L238"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "Cause",
    "description": "Represents the full history of a failure within an `Effect`.\n\n**Details**\n\nThis type is a data structure that captures all information about why and how\nan effect has failed, including parallel errors, sequential errors, defects,\nand interruptions. It enables a \"lossless\" error model: no error-related\ninformation is discarded, which helps in debugging and understanding the root\ncause of failures.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "type Cause<E> = | Empty\n  | Fail<E>\n  | Die\n  | Interrupt\n  | Sequential<E>\n  | Parallel<E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L254"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause.ts",
      "path": "src/Cause.ts"
    },
    "project": "effect",
    "name": "Cause.Variance",
    "description": "This interface is used internally to manage the type variance of `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Variance<out E> {\n    readonly [CauseTypeId]: {\n      readonly _E: Covariant<E>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cause.ts#L272"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "ChannelTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const ChannelTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L40"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "ChannelExceptionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const ChannelExceptionTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L168"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "isChannel",
    "deprecated": false,
    "examples": [],
    "since": "3.5.4",
    "category": "refinements",
    "signature": "declare const isChannel: (u: unknown) => u is Channel<unknown, unknown, unknown, unknown, unknown, unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L193"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "acquireUseRelease",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const acquireUseRelease: <Acquired, OutErr, Env, OutElem1, InElem, InErr, OutDone, InDone>(acquire: Effect.Effect<Acquired, OutErr, Env>, use: (a: Acquired) => Channel<OutElem1, InElem, OutErr, InErr, OutDone, InDone, Env>, release: (a: Acquired, exit: Exit.Exit<OutDone, OutErr>) => Effect.Effect<any, never, Env>) => Channel<OutElem1, InElem, OutErr, InErr, OutDone, InDone, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L207"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "acquireReleaseOut",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const acquireReleaseOut: { <Z, R2>(release: (z: Z, e: Exit.Exit<unknown, unknown>) => Effect.Effect<unknown, never, R2>): <E, R>(self: Effect.Effect<Z, E, R>) => Channel<Z, unknown, E, unknown, void, unknown, R2 | R>; <Z, E, R, R2>(self: Effect.Effect<Z, E, R>, release: (z: Z, e: Exit.Exit<unknown, unknown>) => Effect.Effect<unknown, never, R2>): Channel<Z, unknown, E, unknown, void, unknown, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L217"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "as",
    "description": "Returns a new channel that is the same as this one, except the terminal\nvalue of the channel is the specified constant value.\n\nThis method produces the same result as mapping this channel to the\nspecified constant value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const as: { <OutDone2>(value: OutDone2): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, value: OutDone2): Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L237"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "asVoid",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const asVoid: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, void, InDone, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L253"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "buffer",
    "description": "Creates a channel backed by a buffer. When the buffer is empty, the channel\nwill simply passthrough its input as output. However, when the buffer is\nnon-empty, the value inside the buffer will be passed along as output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const buffer: <InElem, InErr, InDone>(options: { readonly empty: InElem; readonly isEmpty: Predicate<InElem>; readonly ref: Ref.Ref<InElem>; }) => Channel<InElem, InElem, InErr, InErr, InDone, InDone, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L265"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "bufferChunk",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const bufferChunk: <InElem, InErr, InDone>(ref: Ref.Ref<Chunk.Chunk<InElem>>) => Channel<Chunk.Chunk<InElem>, Chunk.Chunk<InElem>, InErr, InErr, InDone, InDone>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L273"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "catchAll",
    "description": "Returns a new channel that is the same as this one, except if this channel\nerrors for any typed error, then the returned channel will switch over to\nusing the fallback channel returned by the specified error handler.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const catchAll: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(f: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L285"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "catchAllCause",
    "description": "Returns a new channel that is the same as this one, except if this channel\nerrors for any typed error, then the returned channel will switch over to\nusing the fallback channel returned by the specified error handler.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const catchAllCause: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(f: (cause: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (cause: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L321"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "concatAll",
    "description": "Concat sequentially a channel of channels.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const concatAll: <OutElem, InElem, OutErr, InErr, InDone, Env>(channels: Channel<Channel<OutElem, InElem, OutErr, InErr, any, InDone, Env>, InElem, OutErr, InErr, any, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, any, InDone, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L355"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "concatAllWith",
    "description": "Concat sequentially a channel of channels.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const concatAllWith: <OutElem, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, InElem, OutErr, InErr, OutDone2, InDone, Env, OutDone3>(channels: Channel<Channel<OutElem, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutDone, o1: OutDone) => OutDone, g: (o: OutDone, o2: OutDone2) => OutDone3) => Channel<OutElem, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L365"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "concatMap",
    "description": "Returns a new channel whose outputs are fed to the specified factory\nfunction, which creates new channels in response. These new channels are\nsequentially concatenated together, and all their outputs appear as outputs\nof the newly returned channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const concatMap: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>): <Env, InErr, InElem, InDone, OutErr, OutDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, unknown, InDone & InDone2, Env2 | Env>; <Env, InErr, InElem, InDone, OutErr, OutDone, OutElem, OutElem2, Env2, InErr2, InElem2, InDone2, OutErr2, X>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, unknown, InDone & InDone2, Env | Env2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L404"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "concatMapWith",
    "description": "Returns a new channel whose outputs are fed to the specified factory\nfunction, which creates new channels in response. These new channels are\nsequentially concatenated together, and all their outputs appear as outputs\nof the newly returned channel. The provided merging function is used to\nmerge the terminal values of all channels into the single terminal value of\nthe returned channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const concatMapWith: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone2, OutDone3>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3): <Env, InErr, InElem, InDone, OutErr>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, OutDone3, InDone & InDone2, Env | Env2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L427"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "concatMapWithCustom",
    "description": "Returns a new channel whose outputs are fed to the specified factory\nfunction, which creates new channels in response. These new channels are\nsequentially concatenated together, and all their outputs appear as outputs\nof the newly returned channel. The provided merging function is used to\nmerge the terminal values of all channels into the single terminal value of\nthe returned channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const concatMapWithCustom: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone2, OutDone3>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3, onPull: (upstreamPullRequest: UpstreamPullRequest.UpstreamPullRequest<OutElem>) => UpstreamPullStrategy.UpstreamPullStrategy<OutElem2>, onEmit: (elem: OutElem2) => ChildExecutorDecision.ChildExecutorDecision): <Env, InErr, InElem, InDone, OutErr>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3, onPull: (upstreamPullRequest: UpstreamPullRequest.UpstreamPullRequest<OutElem>) => UpstreamPullStrategy.UpstreamPullStrategy<OutElem2>, onEmit: (elem: OutElem2) => ChildExecutorDecision.ChildExecutorDecision): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, OutDone3, InDone & InDone2, Env | Env2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L470"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "collect",
    "description": "Returns a new channel, which is the same as this one, except its outputs\nare filtered and transformed by the specified partial function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const collect: { <OutElem, OutElem2>(pf: (o: OutElem) => Option.Option<OutElem2>): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, unknown, never, unknown, void, unknown, never>) => Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, pf: (o: OutElem) => Option.Option<OutElem2>): Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L517"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "concatOut",
    "description": "Returns a new channel, which is the concatenation of all the channels that\nare written out by this channel. This method may only be called on channels\nthat output other channels.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const concatOut: <OutElem, InElem, OutErr, InErr, InDone, Env, OutDone>(self: Channel<Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L537"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mapInput",
    "description": "Returns a new channel which is the same as this one but applies the given\nfunction to the input channel's done value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mapInput: { <InDone0, InDone>(f: (a: InDone0) => InDone): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InDone0) => InDone): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L556"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mapInputEffect",
    "description": "Returns a new channel which is the same as this one but applies the given\neffectual function to the input channel's done value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mapInputEffect: { <InDone0, InDone, InErr, Env1>(f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>): <OutElem, InElem, OutErr, OutDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L575"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mapInputError",
    "description": "Returns a new channel which is the same as this one but applies the given\nfunction to the input channel's error value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mapInputError: { <InErr0, InErr>(f: (a: InErr0) => InErr): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InErr0) => InErr): Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L594"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mapInputErrorEffect",
    "description": "Returns a new channel which is the same as this one but applies the given\neffectual function to the input channel's error value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mapInputErrorEffect: { <InErr0, InDone, InErr, Env1>(f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>): <OutElem, InElem, OutErr, OutDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>): Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L613"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mapInputIn",
    "description": "Returns a new channel which is the same as this one but applies the given\nfunction to the input channel's output elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mapInputIn: { <InElem0, InElem>(f: (a: InElem0) => InElem): <OutElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InElem0) => InElem): Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L632"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mapInputInEffect",
    "description": "Returns a new channel which is the same as this one but applies the given\neffectual function to the input channel's output elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mapInputInEffect: { <InElem0, InElem, InErr, Env1>(f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>): <OutElem, OutErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>): Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L651"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "doneCollect",
    "description": "Returns a new channel, which is the same as this one, except that all the\noutputs are collected and bundled into a tuple together with the terminal\nvalue of this channel.\n\nAs the channel returned from this channel collects all of this channel's\noutput into an in- memory chunk, it is not safe to call this method on\nchannels that output a large or unbounded number of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const doneCollect: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<never, InElem, OutErr, InErr, [Chunk.Chunk<OutElem>, OutDone], InDone, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L675"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "drain",
    "description": "Returns a new channel which reads all the elements from upstream's output\nchannel and ignores them, then terminates with the upstream result value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const drain: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<never, InElem, OutErr, InErr, OutDone, InDone, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L686"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "embedInput",
    "description": "Returns a new channel which connects the given `AsyncInputProducer` as\nthis channel's input.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const embedInput: { <InErr, InElem, InDone>(input: SingleProducerAsyncInput.AsyncInputProducer<InErr, InElem, InDone>): <OutElem, OutErr, OutDone, Env>(self: Channel<OutElem, unknown, OutErr, unknown, OutDone, unknown, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>; <OutElem, OutErr, OutDone, Env, InErr, InElem, InDone>(self: Channel<OutElem, unknown, OutErr, unknown, OutDone, unknown, Env>, input: SingleProducerAsyncInput.AsyncInputProducer<InErr, InElem, InDone>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L697"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "emitCollect",
    "description": "Returns a new channel that collects the output and terminal value of this\nchannel, which it then writes as output of the returned channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const emitCollect: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<[Chunk.Chunk<OutElem>, OutDone], InElem, OutErr, InErr, void, InDone, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L716"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "ensuring",
    "description": "Returns a new channel with an attached finalizer. The finalizer is\nguaranteed to be executed so long as the channel begins execution (and\nregardless of whether or not it completes).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const ensuring: { <Z, Env1>(finalizer: Effect.Effect<Z, never, Env1>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Z, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, finalizer: Effect.Effect<Z, never, Env1>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L728"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "ensuringWith",
    "description": "Returns a new channel with an attached finalizer. The finalizer is\nguaranteed to be executed so long as the channel begins execution (and\nregardless of whether or not it completes).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const ensuringWith: { <OutDone, OutErr, Env2>(finalizer: (e: Exit.Exit<OutDone, OutErr>) => Effect.Effect<unknown, never, Env2>): <OutElem, InElem, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, finalizer: (e: Exit.Exit<OutDone, OutErr>) => Effect.Effect<unknown, never, Env2>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L748"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "context",
    "description": "Accesses the whole context of the channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const context: <Env>() => Channel<never, unknown, never, unknown, Context.Context<Env>, unknown, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L766"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "contextWith",
    "description": "Accesses the context of the channel with the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const contextWith: <Env, OutDone>(f: (env: Context.Context<Env>) => OutDone) => Channel<never, unknown, never, unknown, OutDone, unknown, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L775"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "contextWithChannel",
    "description": "Accesses the context of the channel in the context of a channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const contextWithChannel: <Env, OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>(f: (env: Context.Context<Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L785"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "contextWithEffect",
    "description": "Accesses the context of the channel in the context of an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const contextWithEffect: <Env, OutDone, OutErr, Env1>(f: (env: Context.Context<Env>) => Effect.Effect<OutDone, OutErr, Env1>) => Channel<never, unknown, OutErr, unknown, OutDone, unknown, Env | Env1>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L795"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "fail",
    "description": "Constructs a channel that fails immediately with the specified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fail: <E>(error: E) => Channel<never, unknown, E, unknown, never, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L805"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "failSync",
    "description": "Constructs a channel that succeeds immediately with the specified lazily\nevaluated value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failSync: <E>(evaluate: LazyArg<E>) => Channel<never, unknown, E, unknown, never, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L814"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "failCause",
    "description": "Constructs a channel that fails immediately with the specified `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failCause: <E>(cause: Cause.Cause<E>) => Channel<never, unknown, E, unknown, never, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L822"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "failCauseSync",
    "description": "Constructs a channel that succeeds immediately with the specified lazily\nevaluated `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Channel<never, unknown, E, unknown, never, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L832"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Returns a new channel, which sequentially combines this channel, together\nwith the provided factory function, which creates a second channel based on\nthe terminal value of this channel. The result is a channel that will first\nperform the functions of this channel, before performing the functions of\nthe created channel (including yielding its terminal value).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMap: { <OutDone, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>(f: (d: OutDone) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>): <OutElem, InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone2, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (d: OutDone) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone2, InDone & InDone1, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L846"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "flatten",
    "description": "Returns a new channel, which flattens the terminal value of this channel.\nThis function may only be called if the terminal value of this channel is\nanother channel of compatible types.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatten: <OutElem, InElem, OutErr, InErr, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>, InDone, Env>) => Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone2, InDone & InDone1, Env1 | Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L882"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "foldChannel",
    "description": "Folds over the result of this channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const foldChannel: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutDone, OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>(options: { readonly onFailure: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSuccess: (done: OutDone) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem2 | OutElem, InElem & InElem1 & InElem2, OutErr1 | OutErr2, InErr & InErr1 & InErr2, OutDone1 | OutDone2, InDone & InDone1 & InDone2, Env1 | Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly onFailure: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSuccess: (done: OutDone) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>; }): Channel<OutElem | OutElem1 | OutElem2, InElem & InElem1 & InElem2, OutErr1 | OutErr2, InErr & InErr1 & InErr2, OutDone1 | OutDone2, InDone & InDone1 & InDone2, Env | Env1 | Env2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L922"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "foldCauseChannel",
    "description": "Folds over the result of this channel including any cause of termination.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const foldCauseChannel: { <OutErr, OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1, OutDone, OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>(options: { readonly onFailure: (c: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1>; readonly onSuccess: (o: OutDone) => Channel<OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem2 | OutElem, InElem & InElem1 & InElem2, OutErr2 | OutErr3, InErr & InErr1 & InErr2, OutDone2 | OutDone3, InDone & InDone1 & InDone2, Env1 | Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1, OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly onFailure: (c: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1>; readonly onSuccess: (o: OutDone) => Channel<OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>; }): Channel<OutElem | OutElem1 | OutElem2, InElem & InElem1 & InElem2, OutErr2 | OutErr3, InErr & InErr1 & InErr2, OutDone2 | OutDone3, InDone & InDone1 & InDone2, Env | Env1 | Env2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1001"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "fromEffect",
    "description": "Use an effect to end a channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Channel<never, unknown, E, unknown, A, unknown, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1084"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "fromEither",
    "description": "Constructs a channel from an `Either`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromEither: <R, L>(either: Either.Either<R, L>) => Channel<never, unknown, L, unknown, R, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1094"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "fromInput",
    "description": "Construct a `Channel` from an `AsyncInputConsumer`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromInput: <Err, Elem, Done>(input: SingleProducerAsyncInput.AsyncInputConsumer<Err, Elem, Done>) => Channel<Elem, unknown, Err, unknown, Done, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1103"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "fromPubSub",
    "description": "Construct a `Channel` from a `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromPubSub: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<Elem, unknown, Err, unknown, Done, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1113"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "fromPubSubScoped",
    "description": "Construct a `Channel` from a `PubSub` within a scoped effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromPubSubScoped: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Effect.Effect<Channel<Elem, unknown, Err, unknown, Done, unknown>, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1123"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "fromOption",
    "description": "Construct a `Channel` from an `Option`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromOption: <A>(option: Option.Option<A>) => Channel<never, unknown, Option.Option<never>, unknown, A, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1133"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "fromQueue",
    "description": "Construct a `Channel` from a `Queue`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromQueue: <Done, Err, Elem>(queue: Queue.Dequeue<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<Elem, unknown, Err, unknown, Done, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1143"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "identity",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const identity: <Elem, Err, Done>() => Channel<Elem, Elem, Err, Err, Done, Done>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1151"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "interruptWhen",
    "description": "Returns a new channel, which is the same as this one, except it will be\ninterrupted when the specified effect completes. If the effect completes\nsuccessfully before the underlying channel is done, then the returned\nchannel will yield the success value of the effect as its terminal value.\nOn the other hand, if the underlying channel finishes first, then the\nreturned channel will yield the success value of the underlying channel as\nits terminal value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const interruptWhen: { <OutDone1, OutErr1, Env1>(effect: Effect.Effect<OutDone1, OutErr1, Env1>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, effect: Effect.Effect<OutDone1, OutErr1, Env1>): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1165"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "interruptWhenDeferred",
    "description": "Returns a new channel, which is the same as this one, except it will be\ninterrupted when the specified deferred is completed. If the deferred is\ncompleted before the underlying channel is done, then the returned channel\nwill yield the value of the deferred. Otherwise, if the underlying channel\nfinishes first, then the returned channel will yield the value of the\nunderlying channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const interruptWhenDeferred: { <OutDone1, OutErr1>(deferred: Deferred.Deferred<OutDone1, OutErr1>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, deferred: Deferred.Deferred<OutDone1, OutErr1>): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1188"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Returns a new channel, which is the same as this one, except the terminal\nvalue of the returned channel is created by applying the specified function\nto the terminal value of this channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <OutDone, OutDone2>(f: (out: OutDone) => OutDone2): <OutElem, InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (out: OutDone) => OutDone2): Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1208"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mapEffect",
    "description": "Returns a new channel, which is the same as this one, except the terminal\nvalue of the returned channel is created by applying the specified\neffectful function to the terminal value of this channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapEffect: { <OutDone, OutDone1, OutErr1, Env1>(f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>): <OutElem, InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone1, InDone, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1228"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mapError",
    "description": "Returns a new channel, which is the same as this one, except the failure\nvalue of the returned channel is created by applying the specified function\nto the failure value of this channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapError: { <OutErr, OutErr2>(f: (err: OutErr) => OutErr2): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (err: OutErr) => OutErr2): Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1248"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mapErrorCause",
    "description": "A more powerful version of `mapError` which also surfaces the `Cause`\nof the channel failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapErrorCause: { <OutErr, OutErr2>(f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>): Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1267"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mapOut",
    "description": "Maps the output of this channel using the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapOut: { <OutElem, OutElem2>(f: (o: OutElem) => OutElem2): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => OutElem2): Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1285"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mapOutEffect",
    "description": "Creates a channel that is like this channel but the given effectful function\ngets applied to each emitted output element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapOutEffect: { <OutElem, OutElem1, OutErr1, Env1>(f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>): Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1304"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mapOutEffectPar",
    "description": "Creates a channel that is like this channel but the given ZIO function gets\napplied to each emitted output element, taking `n` elements at once and\nmapping them in parallel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapOutEffectPar: { <OutElem, OutElem1, OutErr1, Env1>(f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>, n: number): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>, n: number): Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1324"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mergeAll",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mergeAll: (options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined; }) => <OutElem, InElem1, OutErr1, InErr1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(channels: Channel<Channel<OutElem, InElem1, OutErr1, InErr1, unknown, InDone1, Env1>, InElem, OutErr, InErr, unknown, InDone, Env>) => Channel<OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1342"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mergeAllUnbounded",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mergeAllUnbounded: <OutElem, InElem1, OutErr1, InErr1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(channels: Channel<Channel<OutElem, InElem1, OutErr1, InErr1, unknown, InDone1, Env1>, InElem, OutErr, InErr, unknown, InDone, Env>) => Channel<OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1365"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mergeAllUnboundedWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mergeAllUnboundedWith: <OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(channels: Channel<Channel<OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1>, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o1: OutDone, o2: OutDone) => OutDone) => Channel<OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone, InDone & InDone1, Env1 | Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1382"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mergeAllWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mergeAllWith: ({ bufferSize, concurrency, mergeStrategy }: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined; }) => <OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(channels: Channel<Channel<OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1>, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o1: OutDone, o2: OutDone) => OutDone) => Channel<OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone, InDone & InDone1, Env1 | Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1413"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mergeMap",
    "description": "Returns a new channel which creates a new channel for each emitted element\nand merges some of them together. Different merge strategies control what\nhappens if there are more than the given maximum number of channels gets\ncreated. See `Channel.mergeAll`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mergeMap: { <OutElem, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(f: (outElem: OutElem) => Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined; }): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (outElem: OutElem) => Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined; }): Channel<OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, unknown, InDone & InDone1, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1442"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mergeOut",
    "description": "Returns a new channel which merges a number of channels emitted by this\nchannel using the back pressuring merge strategy. See `Channel.mergeAll`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mergeOut: { (n: number): <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, InElem, OutErr, InErr, OutDone, InDone, Env>, n: number): Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1471"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mergeOutWith",
    "description": "Returns a new channel which merges a number of channels emitted by this\nchannel using the back pressuring merge strategy and uses a given function\nto merge each completed subchannel's result value. See\n`Channel.mergeAll`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mergeOutWith: { <OutDone1>(n: number, f: (o1: OutDone1, o2: OutDone1) => OutDone1): <OutElem1, InElem1, OutErr1, InErr1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, InElem, OutErr, InErr, OutDone1, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, InElem, OutErr, InErr, OutDone1, InDone, Env>, n: number, f: (o1: OutDone1, o2: OutDone1) => OutDone1): Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1508"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mergeWith",
    "description": "Returns a new channel, which is the merge of this channel and the specified\nchannel, where the behavior of the returned channel on left or right early\ntermination is decided by the specified `leftDone` and `rightDone` merge\ndecisions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mergeWith: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutDone, OutErr, OutErr2, OutDone2, OutErr3, OutDone3>(options: { readonly other: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSelfDone: (exit: Exit.Exit<OutDone, OutErr>) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>; readonly onOtherDone: (ex: Exit.Exit<OutDone1, OutErr1>) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr2 | OutErr3, InErr & InErr1, OutDone2 | OutDone3, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutErr2, OutDone2, OutErr3, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly other: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSelfDone: (exit: Exit.Exit<OutDone, OutErr>) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>; readonly onOtherDone: (ex: Exit.Exit<OutDone1, OutErr1>) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>; }): Channel<OutElem | OutElem1, InElem & InElem1, OutErr2 | OutErr3, InErr & InErr1, OutDone2 | OutDone3, InDone & InDone1, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1547"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "never",
    "description": "Returns a channel that never completes",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const never: Channel<never, unknown, never, unknown, never, unknown, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1616"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "orDie",
    "description": "Translates channel failure into death of the fiber, making all failures\nunchecked and not a part of the type of the channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orDie: { <E>(error: LazyArg<E>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, error: LazyArg<E>): Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1625"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "orDieWith",
    "description": "Keeps none of the errors, and terminates the fiber with them, using the\nspecified function to convert the `OutErr` into a defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orDieWith: { <OutErr>(f: (e: OutErr) => unknown): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (e: OutErr) => unknown): Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1644"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "orElse",
    "description": "Returns a new channel that will perform the operations of this one, until\nfailure, and then it will switch over to the operations of the specified\nfallback channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElse: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: LazyArg<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: LazyArg<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1664"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "pipeTo",
    "description": "Returns a new channel that pipes the output of this channel into the\nspecified channel. The returned channel has the input type of this channel,\nand the output type of the specified channel, terminating with the value of\nthe specified channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const pipeTo: { <OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>(that: Channel<OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>): <InElem, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>): Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env | Env2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1701"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "pipeToOrFail",
    "description": "Returns a new channel that pipes the output of this channel into the\nspecified channel and preserves this channel's failures without providing\nthem to the other channel for observation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const pipeToOrFail: { <OutElem2, OutElem, OutErr2, OutDone2, OutDone, Env2>(that: Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>): <InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem, OutErr2 | OutErr, InErr, OutDone2, InDone, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>): Channel<OutElem2, InElem, OutErr | OutErr2, InErr, OutDone2, InDone, Env | Env2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1721"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "provideContext",
    "description": "Provides the channel with its required context, which eliminates its\ndependency on `Env`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideContext: { <Env>(env: Context.Context<Env>): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, never>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, env: Context.Context<Env>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, never>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1740"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "provideLayer",
    "description": "Provides a layer to the channel, which translates it to another level.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideLayer: { <Env, OutErr2, Env0>(layer: Layer.Layer<Env, OutErr2, Env0>): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2, Env0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, layer: Layer.Layer<Env, OutErr2, Env0>): Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1758"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "mapInputContext",
    "description": "Transforms the context being provided to the channel with the specified\nfunction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const mapInputContext: { <Env0, Env>(f: (env: Context.Context<Env0>) => Context.Context<Env>): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (env: Context.Context<Env0>) => Context.Context<Env>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1777"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "provideSomeLayer",
    "description": "Splits the context into two parts, providing one part using the\nspecified layer and leaving the remainder `Env0`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideSomeLayer: { <R2, OutErr2, Env0>(layer: Layer.Layer<R2, OutErr2, Env0>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, R>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>) => Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, R, R2, OutErr2, Env0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>, layer: Layer.Layer<R2, OutErr2, Env0>): Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1796"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "provideService",
    "description": "Provides the effect with the single service it requires. If the effect\nrequires more than one service use `provideContext` instead.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: Types.NoInfer<S>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, I, S>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, tag: Context.Tag<I, S>, service: Types.NoInfer<S>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1815"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "read",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const read: <In>() => Channel<never, In, Option.Option<never>, unknown, In, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1833"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "readOrFail",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const readOrFail: <E, In = unknown>(error: E) => Channel<never, In, E, unknown, In, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1839"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "readWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const readWith: <InElem, OutElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2, OutElem3, OutErr3, OutDone3, Env3>(options: { readonly onInput: (input: InElem) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>; readonly onFailure: (error: InErr) => Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env2>; readonly onDone: (done: InDone) => Channel<OutElem3, InElem, OutErr3, InErr, OutDone3, InDone, Env3>; }) => Channel<OutElem | OutElem2 | OutElem3, InElem, OutErr | OutErr2 | OutErr3, InErr, OutDone | OutDone2 | OutDone3, InDone, Env | Env2 | Env3>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1845"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "readWithCause",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const readWithCause: <InElem, OutElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2, OutElem3, OutErr3, OutDone3, Env3>(options: { readonly onInput: (input: InElem) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>; readonly onFailure: (cause: Cause.Cause<InErr>) => Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env2>; readonly onDone: (done: InDone) => Channel<OutElem3, InElem, OutErr3, InErr, OutDone3, InDone, Env3>; }) => Channel<OutElem | OutElem2 | OutElem3, InElem, OutErr | OutErr2 | OutErr3, InErr, OutDone | OutDone2 | OutDone3, InDone, Env | Env2 | Env3>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1881"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "repeated",
    "description": "Creates a channel which repeatedly runs this channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const repeated: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1919"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "run",
    "description": "Runs a channel until the end is received.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const run: <OutErr, InErr, OutDone, InDone, Env>(self: Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1929"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "runCollect",
    "description": "Run the channel until it finishes with a done value or fails with an error\nand collects its emitted output elements.\n\nThe channel must not read any input.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runCollect: <OutElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<[Chunk.Chunk<OutElem>, OutDone], OutErr, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1942"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "runDrain",
    "description": "Runs a channel until the end is received.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runDrain: <OutElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1952"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "runScoped",
    "description": "Run the channel until it finishes with a done value or fails with an error.\nThe channel must not read any input or write any output.\n\nClosing the channel, which includes execution of all the finalizers\nattached to the channel will be added to the current scope as a finalizer.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "destructors",
    "signature": "declare const runScoped: <OutErr, InErr, OutDone, InDone, Env>(self: Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env | Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1966"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "scoped",
    "description": "Use a scoped effect to emit an output element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const scoped: <A, E, R>(effect: Effect.Effect<A, E, R>) => Channel<A, unknown, E, unknown, unknown, unknown, Exclude<R, Scope.Scope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1976"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "scopedWith",
    "description": "Use a function that receives a scope and returns an effect to emit an output\nelement. The output element will be the result of the returned effect, if\nsuccessful.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "declare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect.Effect<A, E, R>) => Channel<A, unknown, E, unknown, unknown, unknown, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1988"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "splitLines",
    "description": "Splits strings on newlines. Handles both Windows newlines (`\\r\\n`) and UNIX\nnewlines (`\\n`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const splitLines: <Err, Done>() => Channel<Chunk.Chunk<string>, Chunk.Chunk<string>, Err, Err, Done, Done, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L1999"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "succeed",
    "description": "Constructs a channel that succeeds immediately with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const succeed: <A>(value: A) => Channel<never, unknown, never, unknown, A, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2015"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "suspend",
    "description": "Lazily constructs a channel from the given side effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const suspend: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(evaluate: LazyArg<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2023"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "sync",
    "description": "Constructs a channel that succeeds immediately with the specified lazy value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sync: <OutDone>(evaluate: LazyArg<OutDone>) => Channel<never, unknown, never, unknown, OutDone, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2033"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "toPubSub",
    "description": "Converts a `Channel` to a `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toPubSub: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<never, Elem, never, Err, unknown, Done>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2043"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "toPull",
    "description": "Returns a scoped `Effect` that can be used to repeatedly pull elements from\nthe constructed `Channel`. The pull effect fails with the channel's failure\nin case the channel fails, or returns either the channel's done value or an\nemitted element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toPull: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Scope.Scope | Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2056"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "toPullIn",
    "description": "Returns an `Effect` that can be used to repeatedly pull elements from the\nconstructed `Channel` within the provided `Scope`. The pull effect fails\nwith the channel's failure in case the channel fails, or returns either the\nchannel's done value or an emitted element.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "destructors",
    "signature": "declare const toPullIn: { (scope: Scope.Scope): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, scope: Scope.Scope): Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2070"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "toQueue",
    "description": "Converts a `Channel` to a `Queue`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toQueue: <Done, Err, Elem>(queue: Queue.Enqueue<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<never, Elem, never, Err, unknown, Done>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2088"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "toSink",
    "description": "Converts this channel to a `Sink`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toSink: <OutElem, InElem, OutErr, InErr, OutDone, Env>(self: Channel<Chunk.Chunk<OutElem>, Chunk.Chunk<InElem>, OutErr, InErr, OutDone, unknown, Env>) => Sink.Sink<OutDone, InElem, OutElem, OutErr, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2097"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "toStream",
    "description": "Converts this channel to a `Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toStream: <OutElem, OutErr, OutDone, Env>(self: Channel<Chunk.Chunk<OutElem>, unknown, OutErr, unknown, OutDone, unknown, Env>) => Stream.Stream<OutElem, OutErr, Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2107"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "unwrap",
    "description": "Constructs a `Channel` from an effect that will result in a `Channel` if\nsuccessful.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unwrap: <OutElem, InElem, OutErr, InErr, OutDone, InDone, R2, E, R>(channel: Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R2>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | R2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2127"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "unwrapScoped",
    "description": "Constructs a `Channel` from a scoped effect that will result in a\n`Channel` if successful.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unwrapScoped: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(self: Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, Env | Exclude<R, Scope.Scope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2138"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "unwrapScopedWith",
    "description": "Constructs a `Channel` from a function which receives a `Scope` and returns\nan effect that will result in a `Channel` if successful.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "declare const unwrapScopedWith: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | Env>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2149"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "updateService",
    "description": "Updates a service in the context of this channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const updateService: { <I, S>(tag: Context.Tag<I, S>, f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>): <OutElem, OutErr, InErr, OutDone, InDone, R>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>) => Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, I | R>; <OutElem, OutErr, InErr, OutDone, InDone, R, I, S>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>, tag: Context.Tag<I, S>, f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>): Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, I | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2159"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "withSpan",
    "description": "Wraps the channel with a new span for tracing.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "declare const withSpan: { (name: string, options?: Tracer.SpanOptions | undefined): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, name: string, options?: Tracer.SpanOptions | undefined): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2179"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "write",
    "description": "Writes a single value to the channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const write: <OutElem>(out: OutElem) => Channel<OutElem>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2199"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "writeAll",
    "description": "Writes a sequence of values to the channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const writeAll: <OutElems extends Array<any>>(...outs: OutElems) => Channel<OutElems[number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2207"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "writeChunk",
    "description": "Writes a `Chunk` of values to the channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const writeChunk: <OutElem>(outs: Chunk.Chunk<OutElem>) => Channel<OutElem>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2217"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Returns a new channel that is the sequential composition of this channel\nand the specified channel. The returned channel terminates with a tuple of\nthe terminal values of both channels.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zip: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, readonly [OutDone, OutDone1], InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, readonly [OutDone, OutDone1], InDone & InDone1, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2229"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Returns a new channel that is the sequential composition of this channel\nand the specified channel. The returned channel terminates with the\nterminal value of this channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipLeft: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone, InDone & InDone1, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2267"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Returns a new channel that is the sequential composition of this channel\nand the specified channel. The returned channel terminates with the\nterminal value of that channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipRight: { <Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; }): <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; }): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone1, InDone & InDone1, Env | Env1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2305"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "ChannelException",
    "description": "Represents a generic checked exception which occurs when a `Channel` is\nexecuted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "errors",
    "signature": "declare const ChannelException: <E>(error: E) => ChannelException<E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2346"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "isChannelException",
    "description": "Returns `true` if the specified value is an `ChannelException`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isChannelException: (u: unknown) => u is ChannelException<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L2355"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "Channel",
    "description": "A `Channel` is a nexus of I/O operations, which supports both reading and\nwriting. A channel may read values of type `InElem` and write values of type\n`OutElem`. When the channel finishes, it yields a value of type `OutDone`. A\nchannel may fail with a value of type `OutErr`.\n\nChannels are the foundation of Streams: both streams and sinks are built on\nchannels. Most users shouldn't have to use channels directly, as streams and\nsinks are much more convenient and cover all common use cases. However, when\nadding new stream and sink operators, or doing something highly specialized,\nit may be useful to use channels directly.\n\nChannels compose in a variety of ways:\n\n - **Piping**: One channel can be piped to another channel, assuming the\n   input type of the second is the same as the output type of the first.\n - **Sequencing**: The terminal value of one channel can be used to create\n   another channel, and both the first channel and the function that makes\n   the second channel can be composed into a channel.\n - **Concatenating**: The output of one channel can be used to create other\n   channels, which are all concatenated together. The first channel and the\n   function that makes the other channels can be composed into a channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Channel<\n  out OutElem,\n  in InElem = unknown,\n  out OutErr = never,\n  in InErr = unknown,\n  out OutDone = void,\n  in InDone = unknown,\n  out Env = never\n> extends\n  Channel.Variance<\n    OutElem,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >,\n  Pipeable\n{\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: ChannelUnify<this>\n  [Unify.ignoreSymbol]?: ChannelUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L75"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "ChannelUnify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ChannelUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Channel?: () => A[Unify.typeSymbol] extends\n    | Channel<\n      infer OutElem,\n      infer InElem,\n      infer OutErr,\n      infer InErr,\n      infer OutDone,\n      infer InDone,\n      infer Env\n    >\n    | infer _ ? Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n    : never\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L104"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "ChannelUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ChannelUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Channel?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L123"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "ChannelException",
    "description": "Represents a generic checked exception which occurs when a `Channel` is\nexecuted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ChannelException<out E> {\n  readonly _tag: \"ChannelException\"\n  readonly [ChannelExceptionTypeId]: ChannelExceptionTypeId\n  readonly error: E\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L183"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "ChannelTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type ChannelTypeId = typeof ChannelTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L46"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "ChannelExceptionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type ChannelExceptionTypeId = typeof ChannelExceptionTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L174"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "Channel.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out OutElem, in InElem, out OutErr, in InErr, out OutDone, in InDone, out Env> {\n    readonly [ChannelTypeId]: VarianceStruct<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L146"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Channel.ts",
      "path": "src/Channel.ts"
    },
    "project": "effect",
    "name": "Channel.VarianceStruct",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface VarianceStruct<out OutElem, in InElem, out OutErr, in InErr, out OutDone, in InDone, out Env> {\n    _Env: Types.Covariant<Env>\n    _InErr: Types.Contravariant<InErr>\n    _InElem: Types.Contravariant<InElem>\n    _InDone: Types.Contravariant<InDone>\n    _OutErr: Types.Covariant<OutErr>\n    _OutElem: Types.Covariant<OutElem>\n    _OutDone: Types.Covariant<OutDone>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Channel.ts#L153"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "ChildExecutorDecisionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const ChildExecutorDecisionTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L10"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "Continue",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Continue: (_: void) => ChildExecutorDecision",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L74"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "Close",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Close: (value: unknown) => ChildExecutorDecision",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L80"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "Yield",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Yield: (_: void) => ChildExecutorDecision",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L86"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "isChildExecutorDecision",
    "description": "Returns `true` if the specified value is a `ChildExecutorDecision`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isChildExecutorDecision: (u: unknown) => u is ChildExecutorDecision",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L95"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "isContinue",
    "description": "Returns `true` if the specified `ChildExecutorDecision` is a `Continue`,\n`false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isContinue: (self: ChildExecutorDecision) => self is Continue",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L104"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "isClose",
    "description": "Returns `true` if the specified `ChildExecutorDecision` is a `Close`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isClose: (self: ChildExecutorDecision) => self is Close",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L113"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "isYield",
    "description": "Returns `true` if the specified `ChildExecutorDecision` is a `Yield`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isYield: (self: ChildExecutorDecision) => self is Yield",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L122"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Folds over a `ChildExecutorDecision` to produce a value of type `A`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const match: { <A>(options: { readonly onContinue: () => A; readonly onClose: (value: unknown) => A; readonly onYield: () => A; }): (self: ChildExecutorDecision) => A; <A>(self: ChildExecutorDecision, options: { readonly onContinue: () => A; readonly onClose: (value: unknown) => A; readonly onYield: () => A; }): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L130"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "Continue",
    "description": "Continue executing the current substream",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Continue extends ChildExecutorDecision.Proto {\n  readonly _tag: \"Continue\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L43"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "Close",
    "description": "Close the current substream with a given value and pass execution to the\nnext substream",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Close extends ChildExecutorDecision.Proto {\n  readonly _tag: \"Close\"\n  readonly value: unknown\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L54"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "Yield",
    "description": "Pass execution to the next substream. This either pulls a new element\nfrom upstream, or yields to an already created active substream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Yield extends ChildExecutorDecision.Proto {\n  readonly _tag: \"Yield\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L66"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "ChildExecutorDecisionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type ChildExecutorDecisionTypeId = typeof ChildExecutorDecisionTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L16"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "ChildExecutorDecision",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type ChildExecutorDecision = Continue | Close | Yield",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L22"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ChildExecutorDecision.ts",
      "path": "src/ChildExecutorDecision.ts"
    },
    "project": "effect",
    "name": "ChildExecutorDecision.Proto",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Proto {\n    readonly [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ChildExecutorDecision.ts#L32"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "toArray",
    "description": "Converts a `Chunk` into an `Array`. If the provided `Chunk` is non-empty\n(`NonEmptyChunk`), the function will return a `NonEmptyArray`, ensuring the\nnon-empty property is preserved.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const toArray: <S extends Chunk<any>>(self: S) => S extends NonEmptyChunk<any> ? RA.NonEmptyArray<Chunk.Infer<S>> : Array<Chunk.Infer<S>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L291"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "toReadonlyArray",
    "description": "Converts a `Chunk` into a `ReadonlyArray`. If the provided `Chunk` is\nnon-empty (`NonEmptyChunk`), the function will return a\n`NonEmptyReadonlyArray`, ensuring the non-empty property is preserved.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const toReadonlyArray: <S extends Chunk<any>>(self: S) => S extends NonEmptyChunk<any> ? RA.NonEmptyReadonlyArray<Chunk.Infer<S>> : ReadonlyArray<Chunk.Infer<S>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L326"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "reverse",
    "description": "Reverses the order of elements in a `Chunk`.\nImportantly, if the input chunk is a `NonEmptyChunk`, the reversed chunk will also be a `NonEmptyChunk`.\n\n**Example**\n\n```ts\nimport { Chunk } from \"effect\"\n\nconst chunk = Chunk.make(1, 2, 3)\nconst result = Chunk.reverse(chunk)\n\nconsole.log(result)\n// { _id: 'Chunk', values: [ 3, 2, 1 ] }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const reverse: <S extends Chunk<any>>(self: S) => Chunk.With<S, Chunk.Infer<S>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L366"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "This function provides a safe way to read a value at a particular index from a `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const get: { (index: number): <A>(self: Chunk<A>) => Option<A>; <A>(self: Chunk<A>, index: number): Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L374"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "unsafeGet",
    "description": "Gets an element unsafely, will throw on out of bounds",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeGet: { (index: number): <A>(self: Chunk<A>) => A; <A>(self: Chunk<A>, index: number): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L407"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "append",
    "description": "Appends the specified element to the end of the `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const append: { <A2>(a: A2): <A>(self: Chunk<A>) => NonEmptyChunk<A2 | A>; <A, A2>(self: Chunk<A>, a: A2): NonEmptyChunk<A | A2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L444"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "prepend",
    "description": "Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const prepend: { <B>(elem: B): <A>(self: Chunk<A>) => NonEmptyChunk<B | A>; <A, B>(self: Chunk<A>, elem: B): NonEmptyChunk<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L455"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "take",
    "description": "Takes the first up to `n` elements from the chunk",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const take: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L465"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "drop",
    "description": "Drops the first up to `n` elements from the chunk",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const drop: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L511"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "dropRight",
    "description": "Drops the last `n` elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const dropRight: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L556"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "dropWhile",
    "description": "Drops all elements so long as the predicate returns true.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const dropWhile: { <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L566"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "prependAll",
    "description": "Prepends the specified prefix chunk to the beginning of the specified chunk.\nIf either chunk is non-empty, the result is also a non-empty chunk.\n\n**Example**\n\n```ts\nimport { Chunk } from \"effect\"\n\nconst result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n\nconsole.log(result)\n// [ \"a\", \"b\", 1, 2 ]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const prependAll: { <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>; <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>; <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L597"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "appendAll",
    "description": "Concatenates two chunks, combining their elements.\nIf either chunk is non-empty, the result is also a non-empty chunk.\n\n**Example**\n\n```ts\nimport { Chunk } from \"effect\"\n\nconst result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n\nconsole.log(result)\n// [ 1, 2, \"a\", \"b\" ]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const appendAll: { <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>; <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>; <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L624"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Returns a filtered and mapped subset of the elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterMap: { <A, B>(f: (a: A, i: number) => Option<B>): (self: Chunk<A>) => Chunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => Option<B>): Chunk<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L678"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "filter",
    "description": "Returns a filtered and mapped subset of the elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L692"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "filterMapWhile",
    "description": "Transforms all elements of the chunk for as long as the specified function returns some value",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterMapWhile: { <A, B>(f: (a: A) => Option<B>): (self: Chunk<A>) => Chunk<B>; <A, B>(self: Chunk<A>, f: (a: A) => Option<B>): Chunk<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L708"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMap: { <S extends Chunk<any>, T extends Chunk<any>>(f: (a: Chunk.Infer<S>, i: number) => T): (self: S) => Chunk.AndNonEmpty<S, T, Chunk.Infer<T>>; <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => NonEmptyChunk<B>): NonEmptyChunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => Chunk<B>): Chunk<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L727"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "Iterates over each element of a `Chunk` and applies a function to it.\n\n**Details**\n\nThis function processes every element of the given `Chunk`, calling the\nprovided function `f` on each element. It does not return a new value;\ninstead, it is primarily used for side effects, such as logging or\naccumulating data in an external variable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const forEach: { <A, B>(f: (a: A, index: number) => B): (self: Chunk<A>) => void; <A, B>(self: Chunk<A>, f: (a: A, index: number) => B): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L758"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens a chunk of chunks into a single chunk by concatenating all chunks.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatten: <S extends Chunk<Chunk<any>>>(self: S) => Chunk.Flatten<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L769"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "chunksOf",
    "description": "Groups elements in chunks of up to `n` elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const chunksOf: { (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>; <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L777"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "intersection",
    "description": "Creates a Chunk of unique values that are included in all given Chunks.\n\nThe order and references of result values are determined by the Chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const intersection: { <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A & B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A & B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L804"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "head",
    "description": "Returns the first element of this chunk if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const head: <A>(self: Chunk<A>) => Option<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L835"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "headNonEmpty",
    "description": "Returns the first element of this non empty chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const headNonEmpty: <A>(self: NonEmptyChunk<A>) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L853"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "lastNonEmpty",
    "description": "Returns the last element of this non empty chunk.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "elements",
    "signature": "declare const lastNonEmpty: <A>(self: NonEmptyChunk<A>) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L879"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms the elements of a chunk using the specified mapping function.\nIf the input chunk is non-empty, the resulting chunk will also be non-empty.\n\n**Example**\n\n```ts\nimport { Chunk } from \"effect\"\n\nconst result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)\n\nconsole.log(result)\n// { _id: 'Chunk', values: [ 2, 3 ] }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <S extends Chunk<any>, B>(f: (a: Chunk.Infer<S>, i: number) => B): (self: S) => Chunk.With<S, B>; <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => B): NonEmptyChunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => B): Chunk<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L937"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "mapAccum",
    "description": "Statefully maps over the chunk, producing new elements of type `B`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const mapAccum: { <S, A, B>(s: S, f: (s: S, a: A) => readonly [S, B]): (self: Chunk<A>) => [S, Chunk<B>]; <S, A, B>(self: Chunk<A>, s: S, f: (s: S, a: A) => readonly [S, B]): [S, Chunk<B>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L952"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "partition",
    "description": "Separate elements based on a predicate that also exposes the index of the element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const partition: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Chunk<A>) => [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Chunk<A>) => [excluded: Chunk<A>, satisfying: Chunk<A>]; <A, B extends A>(self: Chunk<A>, refinement: (a: A, i: number) => a is B): [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]; <A>(self: Chunk<A>, predicate: (a: A, i: number) => boolean): [excluded: Chunk<A>, satisfying: Chunk<A>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L966"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "partitionMap",
    "description": "Partitions the elements of this chunk into two chunks using f.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const partitionMap: { <A, B, C>(f: (a: A) => Either<C, B>): (self: Chunk<A>) => [left: Chunk<B>, right: Chunk<C>]; <A, B, C>(self: Chunk<A>, f: (a: A) => Either<C, B>): [left: Chunk<B>, right: Chunk<C>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L993"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "sort",
    "description": "Sort the elements of a Chunk in increasing order, creating a new Chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sorting",
    "signature": "declare const sort: { <B>(O: Order.Order<B>): <A extends B>(self: Chunk<A>) => Chunk<A>; <A extends B, B>(self: Chunk<A>, O: Order.Order<B>): Chunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1028"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "sortWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sorting",
    "signature": "declare const sortWith: { <A, B>(f: (a: A) => B, order: Order.Order<B>): (self: Chunk<A>) => Chunk<A>; <A, B>(self: Chunk<A>, f: (a: A) => B, order: Order.Order<B>): Chunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1040"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "splitAt",
    "description": "Returns two splits of this chunk at the specified index.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "declare const splitAt: { (n: number): <A>(self: Chunk<A>) => [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]; <A>(self: Chunk<A>, n: number): [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1054"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "splitNonEmptyAt",
    "description": "Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.\nThe value of `n` must be `>= 1`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "declare const splitNonEmptyAt: { (n: number): <A>(self: NonEmptyChunk<A>) => [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]; <A>(self: NonEmptyChunk<A>, n: number): [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1066"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "split",
    "description": "Splits this chunk into `n` equally sized chunks.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "declare const split: { (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>; <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1082"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "splitWhere",
    "description": "Splits this chunk on the first element that matches this predicate.\nReturns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "declare const splitWhere: { <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]; <A>(self: Chunk<A>, predicate: Predicate<A>): [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1094"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "takeRight",
    "description": "Takes the last `n` elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const takeRight: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1131"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "takeWhile",
    "description": "Takes all elements so long as the predicate returns true.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const takeWhile: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1142"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "union",
    "description": "Creates a Chunks of unique values, in order, from all given Chunks.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const union: { <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1165"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Zips this chunk pointwise with the specified chunk using the specified combiner.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWith: { <A, B, C>(that: Chunk<B>, f: (a: A, b: B) => C): (self: Chunk<A>) => Chunk<C>; <A, B, C>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => C): Chunk<C>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1208"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Zips this chunk pointwise with the specified chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zip: { <B>(that: Chunk<B>): <A>(self: Chunk<A>) => Chunk<[A, B]>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<[A, B]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1223"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "remove",
    "description": "Delete the element at the specified index, creating a new `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const remove: { (i: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, i: number): Chunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1236"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "modifyOption",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const modifyOption: { <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Option<Chunk<A | B>>; <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Option<Chunk<A | B>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1247"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "modify",
    "description": "Apply a function to the element at the specified index, creating a new `Chunk`,\nor returning the input if the index is out of bounds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const modify: { <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Chunk<A | B>; <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Chunk<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1262"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "replace",
    "description": "Change the element at the specified index, creating a new `Chunk`,\nor returning the input if the index is out of bounds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const replace: { <B>(i: number, b: B): <A>(self: Chunk<A>) => Chunk<B | A>; <A, B>(self: Chunk<A>, i: number, b: B): Chunk<B | A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1276"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "replaceOption",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const replaceOption: { <B>(i: number, b: B): <A>(self: Chunk<A>) => Option<Chunk<B | A>>; <A, B>(self: Chunk<A>, i: number, b: B): Option<Chunk<B | A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1284"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "makeBy",
    "description": "Return a Chunk of length n with element i initialized with f(i).\n\n**Note**. `n` is normalized to an integer >= 1.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeBy: { <A>(f: (i: number) => A): (n: number) => NonEmptyChunk<A>; <A>(n: number, f: (i: number) => A): NonEmptyChunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1297"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "contains",
    "description": "Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const contains: { <A>(a: A): (self: Chunk<A>) => boolean; <A>(self: Chunk<A>, a: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1321"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "containsWith",
    "description": "Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Chunk<A>) => boolean; (self: Chunk<A>, a: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1332"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirst: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1346"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "findFirstIndex",
    "description": "Return the first index for which a predicate holds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirstIndex: { <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1359"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "findLast",
    "description": "Find the last element for which a predicate holds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findLast: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1370"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "findLastIndex",
    "description": "Return the last index for which a predicate holds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findLastIndex: { <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1383"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "every",
    "description": "Check if a predicate holds true for every `Chunk` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const every: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => self is Chunk<B>; <A>(predicate: Predicate<A>): (self: Chunk<A>) => boolean; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): self is Chunk<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1394"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "some",
    "description": "Check if a predicate holds true for some `Chunk` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const some: { <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => self is NonEmptyChunk<A>; <A>(self: Chunk<A>, predicate: Predicate<A>): self is NonEmptyChunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1411"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "join",
    "description": "Joins the elements together with \"sep\" in the middle.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const join: { (sep: string): (self: Chunk<string>) => string; (self: Chunk<string>, sep: string): string; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1425"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "reduce",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduce: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Chunk<A>) => B; <A, B>(self: Chunk<A>, b: B, f: (b: B, a: A, i: number) => B): B; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1434"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "reduceRight",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduceRight: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Chunk<A>) => B; <A, B>(self: Chunk<A>, b: B, f: (b: B, a: A, i: number) => B): B; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1443"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "difference",
    "description": "Creates a `Chunk` of values not included in the other given `Chunk`.\nThe order and references of result values are determined by the first `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": null,
    "signature": "declare const difference: { <A>(that: Chunk<A>): (self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, that: Chunk<A>): Chunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1470"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": "Compares the two chunks of equal length using the specified function",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "equivalence",
    "signature": "declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Chunk<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L118"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "isChunk",
    "description": "Checks if `u` is a `Chunk<unknown>`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const isChunk: { <A>(u: Iterable<A>): u is Chunk<A>; (u: unknown): u is Chunk<unknown>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L214"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <A = never>() => Chunk<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L225"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Builds a `NonEmptyChunk` from an non-empty collection of elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <As extends readonly [any, ...ReadonlyArray<any>]>(...as: As) => NonEmptyChunk<As[number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L233"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "of",
    "description": "Builds a `NonEmptyChunk` from a single element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const of: <A>(a: A) => NonEmptyChunk<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L242"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `Chunk` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: <A>(self: Iterable<A>) => Chunk<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L250"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "unsafeFromArray",
    "description": "Wraps an array into a chunk without copying, unsafe on mutable arrays",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeFromArray: <A>(self: ReadonlyArray<A>) => Chunk<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L389"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "unsafeFromNonEmptyArray",
    "description": "Wraps an array into a chunk without copying, unsafe on mutable arrays",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeFromNonEmptyArray: <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyChunk<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L398"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "compact",
    "description": "Filter out optional values",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const compact: <A>(self: Chunk<Option<A>>) => Chunk<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L719"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Determines if the chunk is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const isEmpty: <A>(self: Chunk<A>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L819"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "isNonEmpty",
    "description": "Determines if the chunk is not empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const isNonEmpty: <A>(self: Chunk<A>) => self is NonEmptyChunk<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L827"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "unsafeHead",
    "description": "Returns the first element of this chunk.\n\nIt will throw an error if the chunk is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeHead: <A>(self: Chunk<A>) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L845"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "last",
    "description": "Returns the last element of this chunk if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const last: <A>(self: Chunk<A>) => Option<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L861"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "unsafeLast",
    "description": "Returns the last element of this chunk.\n\nIt will throw an error if the chunk is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeLast: <A>(self: Chunk<A>) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L871"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "separate",
    "description": "Partitions the elements of this chunk into two chunks.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const separate: <A, B>(self: Chunk<Either<B, A>>) => [Chunk<A>, Chunk<B>]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1008"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Retireves the size of the chunk",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const size: <A>(self: Chunk<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1020"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "tail",
    "description": "Returns every elements after the first.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const tail: <A>(self: Chunk<A>) => Option<Chunk<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1115"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "tailNonEmpty",
    "description": "Returns every elements after the first.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const tailNonEmpty: <A>(self: NonEmptyChunk<A>) => Chunk<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1123"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "dedupe",
    "description": "Remove duplicates from an array, keeping the first occurrence of an element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const dedupe: <A>(self: Chunk<A>) => Chunk<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1179"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "dedupeAdjacent",
    "description": "Deduplicates adjacent elements that are identical.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const dedupeAdjacent: <A>(self: Chunk<A>) => Chunk<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1187"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "unzip",
    "description": "Takes a `Chunk` of pairs and return two corresponding `Chunk`s.\n\nNote: The function is reverse of `zip`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const unzip: <A, B>(self: Chunk<readonly [A, B]>) => [Chunk<A>, Chunk<B>]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1197"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "range",
    "description": "Create a non empty `Chunk` containing a range of integers, including both endpoints.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const range: (start: number, end: number) => NonEmptyChunk<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1308"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "differenceWith",
    "description": "Creates a `Chunk` of values not included in the other given `Chunk` using the provided `isEquivalent` function.\nThe order and references of result values are determined by the first `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": null,
    "signature": "declare const differenceWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Chunk<A>): (self: Chunk<A>) => Chunk<A>; (self: Chunk<A>, that: Chunk<A>): Chunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L1454"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "Chunk",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Chunk<out A> extends Iterable<A>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _A: Covariant<A>\n  }\n  readonly length: number\n  /** @internal */\n  right: Chunk<A>\n  /** @internal */\n  left: Chunk<A>\n  /** @internal */\n  backing: Backing<A>\n  /** @internal */\n  depth: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L34"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "NonEmptyChunk",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface NonEmptyChunk<out A> extends Chunk<A>, NonEmptyIterable<A> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L53"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "ChunkTypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface ChunkTypeLambda extends TypeLambda {\n  readonly type: Chunk<this[\"Target\"]>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L59"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L28"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "Chunk.Infer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Infer<S> = S extends Chunk<infer A> ? A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L888"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "Chunk.With",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type With<S, A> = S extends NonEmptyChunk<any> ? NonEmptyChunk<A> : Chunk<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L893"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "Chunk.OrNonEmpty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type OrNonEmpty<S, T, A> = S extends NonEmptyChunk<any> ?\n    NonEmptyChunk<A>\n    : T extends NonEmptyChunk<any> ? NonEmptyChunk<A>\n    : Chunk<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L898"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "Chunk.AndNonEmpty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type AndNonEmpty<S, T, A> = S extends NonEmptyChunk<any> ?\n    T extends NonEmptyChunk<any> ? NonEmptyChunk<A>\n    : Chunk<A> :\n    Chunk<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L906"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Chunk.ts",
      "path": "src/Chunk.ts"
    },
    "project": "effect",
    "name": "Chunk.Flatten",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Flatten<T> = T extends NonEmptyChunk<NonEmptyChunk<infer A>> ? NonEmptyChunk<A>\n    : T extends Chunk<Chunk<infer A>> ? Chunk<A>\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Chunk.ts#L914"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Clock.ts",
      "path": "src/Clock.ts"
    },
    "project": "effect",
    "name": "ClockTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const ClockTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Clock.ts#L14"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Clock.ts",
      "path": "src/Clock.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (_: void) => Clock",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Clock.ts#L80"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Clock.ts",
      "path": "src/Clock.ts"
    },
    "project": "effect",
    "name": "sleep",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sleep: (duration: Duration.DurationInput) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Clock.ts#L86"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Clock.ts",
      "path": "src/Clock.ts"
    },
    "project": "effect",
    "name": "currentTimeMillis",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const currentTimeMillis: Effect.Effect<number, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Clock.ts#L92"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Clock.ts",
      "path": "src/Clock.ts"
    },
    "project": "effect",
    "name": "currentTimeNanos",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const currentTimeNanos: Effect.Effect<bigint, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Clock.ts#L98"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Clock.ts",
      "path": "src/Clock.ts"
    },
    "project": "effect",
    "name": "clockWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const clockWith: <A, E, R>(f: (clock: Clock) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Clock.ts#L104"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Clock.ts",
      "path": "src/Clock.ts"
    },
    "project": "effect",
    "name": "Clock",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const Clock: Context.Tag<Clock, Clock>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Clock.ts#L111"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Clock.ts",
      "path": "src/Clock.ts"
    },
    "project": "effect",
    "name": "Clock",
    "description": "Represents a time-based clock which provides functionality related to time\nand scheduling.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Clock {\n  readonly [ClockTypeId]: ClockTypeId\n  /**\n   * Unsafely returns the current time in milliseconds.\n   */\n  unsafeCurrentTimeMillis(): number\n  /**\n   * Returns the current time in milliseconds.\n   */\n  readonly currentTimeMillis: Effect.Effect<number>\n  /**\n   * Unsafely returns the current time in nanoseconds.\n   */\n  unsafeCurrentTimeNanos(): bigint\n  /**\n   * Returns the current time in nanoseconds.\n   */\n  readonly currentTimeNanos: Effect.Effect<bigint>\n  /**\n   * Asynchronously sleeps for the specified duration.\n   */\n  sleep(duration: Duration.Duration): Effect.Effect<void>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Clock.ts#L29"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Clock.ts",
      "path": "src/Clock.ts"
    },
    "project": "effect",
    "name": "ClockScheduler",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ClockScheduler {\n  /**\n   * Unsafely schedules the specified task for the specified duration.\n   */\n  unsafeSchedule(task: Task, duration: Duration.Duration): CancelToken\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Clock.ts#L69"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Clock.ts",
      "path": "src/Clock.ts"
    },
    "project": "effect",
    "name": "ClockTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type ClockTypeId = typeof ClockTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Clock.ts#L20"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Clock.ts",
      "path": "src/Clock.ts"
    },
    "project": "effect",
    "name": "CancelToken",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type CancelToken = () => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Clock.ts#L57"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Clock.ts",
      "path": "src/Clock.ts"
    },
    "project": "effect",
    "name": "Task",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Task = () => void",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Clock.ts#L63"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "ConfigTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const ConfigTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L24"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "all",
    "description": "Constructs a config from a tuple / struct / arguments of configs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const all: <const Arg extends Iterable<Config<any>> | Record<string, Config<any>>>(arg: Arg) => Config<[Arg] extends [ReadonlyArray<Config<any>>] ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Config<infer A>] ? A : never; } : [Arg] extends [Iterable<Config<infer A>>] ? Array<A> : [Arg] extends [Record<string, Config<any>>] ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Config<infer A>] ? A : never; } : never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L102"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "array",
    "description": "Constructs a config for an array of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const array: <A>(config: Config<A>, name?: string) => Config<Array<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L121"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "boolean",
    "description": "Constructs a config for a boolean value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const boolean: (name?: string) => Config<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L129"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "url",
    "description": "Constructs a config for a URL value.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "declare const url: (name?: string) => Config<URL>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L137"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "chunk",
    "description": "Constructs a config for a sequence of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const chunk: <A>(config: Config<A>, name?: string) => Config<Chunk.Chunk<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L145"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "date",
    "description": "Constructs a config for a date value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const date: (name?: string) => Config<Date>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L153"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "fail",
    "description": "Constructs a config that fails with the specified message.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fail: (message: string) => Config<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L161"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "number",
    "description": "Constructs a config for a float value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const number: (name?: string) => Config<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L169"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "integer",
    "description": "Constructs a config for a integer value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const integer: (name?: string) => Config<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L177"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "literal",
    "description": "Constructs a config for a literal value.\n\n**Example**\n\n```ts\nimport { Config } from \"effect\"\n\nconst config = Config.literal(\"http\", \"https\")(\"PROTOCOL\")\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const literal: <Literals extends ReadonlyArray<LiteralValue>>(...literals: Literals) => (name?: string) => Config<Literals[number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L193"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "logLevel",
    "description": "Constructs a config for a `LogLevel` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const logLevel: (name?: string) => Config<LogLevel.LogLevel>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L203"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "duration",
    "description": "Constructs a config for a duration value.",
    "deprecated": false,
    "examples": [],
    "since": "2.5.0",
    "category": "constructors",
    "signature": "declare const duration: (name?: string) => Config<Duration.Duration>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L211"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "isConfig",
    "description": "This function returns `true` if the specified value is an `Config` value,\n`false` otherwise.\n\nThis function can be useful for checking the type of a value before\nattempting to operate on it as an `Config` value. For example, you could\nuse `isConfig` to check the type of a value before using it as an\nargument to a function that expects an `Config` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isConfig: (u: unknown) => u is Config<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L225"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Returns a  config whose structure is the same as this one, but which produces\na different value, constructed using the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <A, B>(f: (a: A) => B): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => B): Config<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L234"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "mapAttempt",
    "description": "Returns a config whose structure is the same as this one, but which may\nproduce a different value, constructed using the specified function, which\nmay throw exceptions that will be translated into validation errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mapAttempt: { <A, B>(f: (a: A) => B): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => B): Config<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L247"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "mapOrFail",
    "description": "Returns a new config whose structure is the samea as this one, but which\nmay produce a different value, constructed using the specified fallible\nfunction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mapOrFail: { <A, B>(f: (a: A) => Either.Either<B, ConfigError.ConfigError>): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => Either.Either<B, ConfigError.ConfigError>): Config<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L260"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "nested",
    "description": "Returns a config that has this configuration nested as a property of the\nspecified name.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const nested: { (name: string): <A>(self: Config<A>) => Config<A>; <A>(self: Config<A>, name: string): Config<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L272"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "orElse",
    "description": "Returns a config whose structure is preferentially described by this\nconfig, but which falls back to the specified config if there is an issue\nreading from this config.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const orElse: { <A2>(that: LazyArg<Config<A2>>): <A>(self: Config<A>) => Config<A2 | A>; <A, A2>(self: Config<A>, that: LazyArg<Config<A2>>): Config<A | A2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L285"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "orElseIf",
    "description": "Returns configuration which reads from this configuration, but which falls\nback to the specified configuration if reading from this configuration\nfails with an error satisfying the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const orElseIf: { <A2>(options: { readonly if: Predicate<ConfigError.ConfigError>; readonly orElse: LazyArg<Config<A2>>; }): <A>(self: Config<A>) => Config<A>; <A, A2>(self: Config<A>, options: { readonly if: Predicate<ConfigError.ConfigError>; readonly orElse: LazyArg<Config<A2>>; }): Config<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L298"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "option",
    "description": "Returns an optional version of this config, which will be `None` if the\ndata is missing from configuration, and `Some` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const option: <A>(self: Config<A>) => Config<Option.Option<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L321"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "primitive",
    "description": "Constructs a new primitive config.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const primitive: <A>(description: string, parse: (text: string) => Either.Either<A, ConfigError.ConfigError>) => Config<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L329"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "repeat",
    "description": "Returns a config that describes a sequence of values, each of which has the\nstructure of this config.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const repeat: <A>(self: Config<A>) => Config<Array<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L341"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "secret",
    "description": "Constructs a config for a secret value.",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const secret: (name?: string) => Config<Secret.Secret>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L350"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "redacted",
    "description": "Constructs a config for a redacted value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const redacted: { (name?: string): Config<Redacted.Redacted>; <A>(config: Config<A>): Config<Redacted.Redacted<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L358"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "hashSet",
    "description": "Constructs a config for a sequence of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const hashSet: <A>(config: Config<A>, name?: string) => Config<HashSet.HashSet<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L369"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "string",
    "description": "Constructs a config for a string value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const string: (name?: string) => Config<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L377"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "nonEmptyString",
    "description": "Constructs a config for a non-empty string value.",
    "deprecated": false,
    "examples": [],
    "since": "3.7.0",
    "category": "constructors",
    "signature": "declare const nonEmptyString: (name?: string) => Config<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L385"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "succeed",
    "description": "Constructs a config which contains the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const succeed: <A>(value: A) => Config<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L393"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "suspend",
    "description": "Lazily constructs a config.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const suspend: <A>(config: LazyArg<Config<A>>) => Config<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L401"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "sync",
    "description": "Constructs a config which contains the specified lazy value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sync: <A>(value: LazyArg<A>) => Config<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L409"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "hashMap",
    "description": "Constructs a config for a sequence of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const hashMap: <A>(config: Config<A>, name?: string) => Config<HashMap.HashMap<string, A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L417"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "unwrap",
    "description": "Constructs a config from some configuration wrapped with the `Wrap<A>` utility type.\n\nFor example:\n\n```\nimport { Config, unwrap } from \"./Config\"\n\ninterface Options { key: string }\n\nconst makeConfig = (config: Config.Wrap<Options>): Config<Options> => unwrap(config)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unwrap: <A>(wrapped: Config.Wrap<A>) => Config<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L435"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "validate",
    "description": "Returns a config that describes the same structure as this one, but which\nperforms validation during loading.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const validate: { <A, B extends A>(options: { readonly message: string; readonly validation: Refinement<A, B>; }): (self: Config<A>) => Config<B>; <A>(options: { readonly message: string; readonly validation: Predicate<A>; }): (self: Config<A>) => Config<A>; <A, B extends A>(self: Config<A>, options: { readonly message: string; readonly validation: Refinement<A, B>; }): Config<B>; <A>(self: Config<A>, options: { readonly message: string; readonly validation: Predicate<A>; }): Config<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L444"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "withDefault",
    "description": "Returns a config that describes the same structure as this one, but has the\nspecified default value in case the information cannot be found.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const withDefault: { <const A2>(def: A2): <A>(self: Config<A>) => Config<A2 | A>; <A, const A2>(self: Config<A>, def: A2): Config<A | A2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L475"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "withDescription",
    "description": "Adds a description to this configuration, which is intended for humans.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const withDescription: { (description: string): <A>(self: Config<A>) => Config<A>; <A>(self: Config<A>, description: string): Config<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L486"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Returns a config that is the composition of this config and the specified\nconfig.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zip: { <B>(that: Config<B>): <A>(self: Config<A>) => Config<[A, B]>; <A, B>(self: Config<A>, that: Config<B>): Config<[A, B]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L498"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Returns a config that is the composes this config and the specified config\nusing the provided function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWith: { <B, A, C>(that: Config<B>, f: (a: A, b: B) => C): (self: Config<A>) => Config<C>; <A, B, C>(self: Config<A>, that: Config<B>, f: (a: A, b: B) => C): Config<C>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L510"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "Config",
    "description": "A `Config` describes the structure of some configuration data.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Config<out A> extends Config.Variance<A>, Effect.Effect<A, ConfigError.ConfigError> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L38"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "ConfigTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type ConfigTypeId = typeof ConfigTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L30"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "LiteralValue",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type LiteralValue = string | number | boolean | null | bigint",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L94"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "Config.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out A> {\n    readonly [ConfigTypeId]: {\n      readonly _A: Types.Covariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L48"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "Config.Primitive",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Primitive<out A> extends Config<A> {\n    readonly description: string\n    parse(text: string): Either.Either<A, ConfigError.ConfigError>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L64"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "Config.Success",
    "deprecated": false,
    "examples": [],
    "since": "2.5.0",
    "category": "models",
    "signature": "type Success<T> = [T] extends [Config<infer _A>] ? _A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L58"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Config.ts",
      "path": "src/Config.ts"
    },
    "project": "effect",
    "name": "Config.Wrap",
    "description": "Wraps a nested structure, converting all primitives to a `Config`.\n\n`Config.Wrap<{ key: string }>` becomes `{ key: Config<string> }`\n\nTo create the resulting config, use the `unwrap` constructor.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Wrap<A> = [NonNullable<A>] extends [infer T] ? [IsPlainObject<T>] extends [true] ?\n        | { readonly [K in keyof A]: Wrap<A[K]> }\n        | Config<A>\n    : Config<A>\n    : Config<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Config.ts#L79"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "ConfigErrorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const ConfigErrorTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L11"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "And",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const And: (self: ConfigError, that: ConfigError) => ConfigError",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L144"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "Or",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Or: (self: ConfigError, that: ConfigError) => ConfigError",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L150"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "MissingData",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const MissingData: (path: Array<string>, message: string, options?: Options) => ConfigError",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L156"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "InvalidData",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const InvalidData: (path: Array<string>, message: string, options?: Options) => ConfigError",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L163"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "SourceUnavailable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const SourceUnavailable: (path: Array<string>, message: string, cause: Cause.Cause<unknown>, options?: Options) => ConfigError",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L170"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "Unsupported",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Unsupported: (path: Array<string>, message: string, options?: Options) => ConfigError",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L181"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "isConfigError",
    "description": "Returns `true` if the specified value is a `ConfigError`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isConfigError: (u: unknown) => u is ConfigError",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L190"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "isAnd",
    "description": "Returns `true` if the specified `ConfigError` is an `And`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isAnd: (self: ConfigError) => self is And",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L198"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "isOr",
    "description": "Returns `true` if the specified `ConfigError` is an `Or`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isOr: (self: ConfigError) => self is Or",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L206"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "isInvalidData",
    "description": "Returns `true` if the specified `ConfigError` is an `InvalidData`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isInvalidData: (self: ConfigError) => self is InvalidData",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L215"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "isMissingData",
    "description": "Returns `true` if the specified `ConfigError` is an `MissingData`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isMissingData: (self: ConfigError) => self is MissingData",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L224"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "isMissingDataOnly",
    "description": "Returns `true` if the specified `ConfigError` contains only `MissingData` errors, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const isMissingDataOnly: (self: ConfigError) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L232"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "isSourceUnavailable",
    "description": "Returns `true` if the specified `ConfigError` is a `SourceUnavailable`,\n`false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isSourceUnavailable: (self: ConfigError) => self is SourceUnavailable",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L241"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "isUnsupported",
    "description": "Returns `true` if the specified `ConfigError` is an `Unsupported`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isUnsupported: (self: ConfigError) => self is Unsupported",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L250"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "prefixed",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const prefixed: { (prefix: Array<string>): (self: ConfigError) => ConfigError; (self: ConfigError, prefix: Array<string>): ConfigError; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L256"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "reduceWithContext",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduceWithContext: { <C, Z>(context: C, reducer: ConfigErrorReducer<C, Z>): (self: ConfigError) => Z; <C, Z>(self: ConfigError, context: C, reducer: ConfigErrorReducer<C, Z>): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L265"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "ConfigErrorReducer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ConfigErrorReducer<in C, in out Z> {\n  andCase(context: C, left: Z, right: Z): Z\n  orCase(context: C, left: Z, right: Z): Z\n  invalidDataCase(context: C, path: Array<string>, message: string): Z\n  missingDataCase(context: C, path: Array<string>, message: string): Z\n  sourceUnavailableCase(\n    context: C,\n    path: Array<string>,\n    message: string,\n    cause: Cause.Cause<unknown>\n  ): Z\n  unsupportedCase(context: C, path: Array<string>, message: string): Z\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L57"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "And",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface And extends ConfigError.Proto {\n  readonly _op: \"And\"\n  readonly left: ConfigError\n  readonly right: ConfigError\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L75"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "Or",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Or extends ConfigError.Proto {\n  readonly _op: \"Or\"\n  readonly left: ConfigError\n  readonly right: ConfigError\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L85"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "InvalidData",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface InvalidData extends ConfigError.Proto {\n  readonly _op: \"InvalidData\"\n  readonly path: Array<string>\n  readonly message: string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L95"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "MissingData",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MissingData extends ConfigError.Proto {\n  readonly _op: \"MissingData\"\n  readonly path: Array<string>\n  readonly message: string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L105"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "SourceUnavailable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SourceUnavailable extends ConfigError.Proto {\n  readonly _op: \"SourceUnavailable\"\n  readonly path: Array<string>\n  readonly message: string\n  readonly cause: Cause.Cause<unknown>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L115"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "Unsupported",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Unsupported extends ConfigError.Proto {\n  readonly _op: \"Unsupported\"\n  readonly path: Array<string>\n  readonly message: string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L126"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "Options",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Options {\n  readonly pathDelim: string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L136"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "ConfigErrorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type ConfigErrorTypeId = typeof ConfigErrorTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L17"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "ConfigError",
    "description": "The possible ways that loading configuration data may fail.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type ConfigError = | And\n  | Or\n  | InvalidData\n  | MissingData\n  | SourceUnavailable\n  | Unsupported",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L25"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "ConfigError.Proto",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Proto {\n    readonly _tag: \"ConfigError\"\n    readonly [ConfigErrorTypeId]: ConfigErrorTypeId\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L41"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ConfigError.ts",
      "path": "src/ConfigError.ts"
    },
    "project": "effect",
    "name": "ConfigError.Reducer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Reducer<C, Z> = ConfigErrorReducer<C, Z>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigError.ts#L50"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "ConfigProviderTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const ConfigProviderTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "FlatConfigProviderTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const FlatConfigProviderTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L30"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "ConfigProvider",
    "description": "The service tag for `ConfigProvider`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const ConfigProvider: Context.Tag<ConfigProvider, ConfigProvider>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L139"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new config provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (options: { readonly load: <A>(config: Config.Config<A>) => Effect.Effect<A, ConfigError.ConfigError>; readonly flattened: ConfigProvider.Flat; }) => ConfigProvider",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L147"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "makeFlat",
    "description": "Creates a new flat config provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeFlat: (options: { readonly load: <A>(path: ReadonlyArray<string>, config: Config.Config.Primitive<A>, split: boolean) => Effect.Effect<Array<A>, ConfigError.ConfigError>; readonly enumerateChildren: (path: ReadonlyArray<string>) => Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError>; readonly patch: PathPatch.PathPatch; }) => ConfigProvider.Flat",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L160"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "fromEnv",
    "description": "A config provider that loads configuration from context variables\n\n**Options**:\n\n- `pathDelim`: The delimiter for the path segments (default: `\"_\"`).\n- `seqDelim`: The delimiter for the sequence of values (default: `\",\"`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromEnv: (options?: Partial<ConfigProvider.FromEnvConfig>) => ConfigProvider",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L183"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "fromFlat",
    "description": "Constructs a new `ConfigProvider` from a key/value (flat) provider, where\nnesting is embedded into the string keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromFlat: (flat: ConfigProvider.Flat) => ConfigProvider",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L192"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "fromJson",
    "description": "Constructs a new `ConfigProvider` from a JSON object.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromJson: (json: unknown) => ConfigProvider",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L200"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "fromMap",
    "description": "Constructs a ConfigProvider using a map and the specified delimiter string,\nwhich determines how to split the keys in the map into path segments.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromMap: (map: Map<string, string>, config?: Partial<ConfigProvider.FromMapConfig>) => ConfigProvider",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L210"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "constantCase",
    "description": "Returns a new config provider that will automatically convert all property\nnames to constant case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const constantCase: (self: ConfigProvider) => ConfigProvider",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L222"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "mapInputPath",
    "description": "Returns a new config provider that will automatically tranform all path\nconfiguration names with the specified function. This can be utilized to\nadapt the names of configuration properties from one naming convention to\nanother.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mapInputPath: { (f: (path: string) => string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, f: (path: string) => string): ConfigProvider; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L233"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "kebabCase",
    "description": "Returns a new config provider that will automatically convert all property\nnames to kebab case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const kebabCase: (self: ConfigProvider) => ConfigProvider",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L247"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "lowerCase",
    "description": "Returns a new config provider that will automatically convert all property\nnames to lower case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const lowerCase: (self: ConfigProvider) => ConfigProvider",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L258"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "nested",
    "description": "Returns a new config provider that will automatically nest all\nconfiguration under the specified property name. This can be utilized to\naggregate separate configuration sources that are all required to load a\nsingle configuration value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const nested: { (name: string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, name: string): ConfigProvider; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L269"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "orElse",
    "description": "Returns a new config provider that preferentially loads configuration data\nfrom this one, but which will fall back to the specified alternate provider\nif there are any issues loading the configuration from this provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const orElse: { (that: LazyArg<ConfigProvider>): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, that: LazyArg<ConfigProvider>): ConfigProvider; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L282"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "unnested",
    "description": "Returns a new config provider that will automatically un-nest all\nconfiguration under the specified property name. This can be utilized to\nde-aggregate separate configuration sources that are all required to load a\nsingle configuration value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const unnested: { (name: string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, name: string): ConfigProvider; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L296"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "snakeCase",
    "description": "Returns a new config provider that will automatically convert all property\nnames to upper case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const snakeCase: (self: ConfigProvider) => ConfigProvider",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L310"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "upperCase",
    "description": "Returns a new config provider that will automatically convert all property\nnames to upper case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const upperCase: (self: ConfigProvider) => ConfigProvider",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L321"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "within",
    "description": "Returns a new config provider that transforms the config provider with the\nspecified function within the specified path.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const within: { (path: ReadonlyArray<string>, f: (self: ConfigProvider) => ConfigProvider): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, path: ReadonlyArray<string>, f: (self: ConfigProvider) => ConfigProvider): ConfigProvider; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L330"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "ConfigProvider",
    "description": "A ConfigProvider is a service that provides configuration given a description\nof the structure of that configuration.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ConfigProvider extends ConfigProvider.Proto, Pipeable {\n  /**\n   * Loads the specified configuration, or fails with a config error.\n   */\n  load<A>(config: Config.Config<A>): Effect.Effect<A, ConfigError.ConfigError>\n  /**\n   * Flattens this config provider into a simplified config provider that knows\n   * only how to deal with flat (key/value) properties.\n   */\n  readonly flattened: ConfigProvider.Flat\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L45"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "ConfigProviderTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type ConfigProviderTypeId = typeof ConfigProviderTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L24"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "FlatConfigProviderTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type FlatConfigProviderTypeId = typeof FlatConfigProviderTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L36"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "ConfigProvider.Proto",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Proto {\n    readonly [ConfigProviderTypeId]: ConfigProviderTypeId\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L65"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "ConfigProvider.Flat",
    "description": "A simplified config provider that knows only how to deal with flat\n(key/value) properties. Because these providers are common, there is\nspecial support for implementing them.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Flat {\n    readonly [FlatConfigProviderTypeId]: FlatConfigProviderTypeId\n    readonly patch: PathPatch.PathPatch\n    load<A>(\n      path: ReadonlyArray<string>,\n      config: Config.Config.Primitive<A>,\n      split?: boolean\n    ): Effect.Effect<Array<A>, ConfigError.ConfigError>\n    enumerateChildren(\n      path: ReadonlyArray<string>\n    ): Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L77"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "ConfigProvider.FromMapConfig",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface FromMapConfig {\n    readonly pathDelim: string\n    readonly seqDelim: string\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L94"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "ConfigProvider.FromEnvConfig",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface FromEnvConfig {\n    readonly pathDelim: string\n    readonly seqDelim: string\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L103"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "ConfigProvider.KeyName",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface KeyName {\n    readonly _tag: \"KeyName\"\n    readonly name: string\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L118"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "ConfigProvider.KeyIndex",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "export interface KeyIndex {\n    readonly _tag: \"KeyIndex\"\n    readonly index: number\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L127"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ConfigProvider.ts",
      "path": "src/ConfigProvider.ts"
    },
    "project": "effect",
    "name": "ConfigProvider.KeyComponent",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "models",
    "signature": "type KeyComponent = KeyName | KeyIndex",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProvider.ts#L112"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProviderPathPatch.ts",
      "path": "src/ConfigProviderPathPatch.ts"
    },
    "project": "effect",
    "name": "empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: PathPatch",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProviderPathPatch.ts#L64"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProviderPathPatch.ts",
      "path": "src/ConfigProviderPathPatch.ts"
    },
    "project": "effect",
    "name": "andThen",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const andThen: { (that: PathPatch): (self: PathPatch) => PathPatch; (self: PathPatch, that: PathPatch): PathPatch; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProviderPathPatch.ts#L70"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProviderPathPatch.ts",
      "path": "src/ConfigProviderPathPatch.ts"
    },
    "project": "effect",
    "name": "mapName",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const mapName: { (f: (string: string) => string): (self: PathPatch) => PathPatch; (self: PathPatch, f: (string: string) => string): PathPatch; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProviderPathPatch.ts#L79"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProviderPathPatch.ts",
      "path": "src/ConfigProviderPathPatch.ts"
    },
    "project": "effect",
    "name": "nested",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const nested: { (name: string): (self: PathPatch) => PathPatch; (self: PathPatch, name: string): PathPatch; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProviderPathPatch.ts#L88"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProviderPathPatch.ts",
      "path": "src/ConfigProviderPathPatch.ts"
    },
    "project": "effect",
    "name": "unnested",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unnested: { (name: string): (self: PathPatch) => PathPatch; (self: PathPatch, name: string): PathPatch; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProviderPathPatch.ts#L97"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProviderPathPatch.ts",
      "path": "src/ConfigProviderPathPatch.ts"
    },
    "project": "effect",
    "name": "Empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Empty {\n  readonly _tag: \"Empty\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProviderPathPatch.ts#L19"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProviderPathPatch.ts",
      "path": "src/ConfigProviderPathPatch.ts"
    },
    "project": "effect",
    "name": "AndThen",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface AndThen {\n  readonly _tag: \"AndThen\"\n  readonly first: PathPatch\n  readonly second: PathPatch\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProviderPathPatch.ts#L27"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProviderPathPatch.ts",
      "path": "src/ConfigProviderPathPatch.ts"
    },
    "project": "effect",
    "name": "MapName",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MapName {\n  readonly _tag: \"MapName\"\n  f(string: string): string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProviderPathPatch.ts#L37"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProviderPathPatch.ts",
      "path": "src/ConfigProviderPathPatch.ts"
    },
    "project": "effect",
    "name": "Nested",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Nested {\n  readonly _tag: \"Nested\"\n  readonly name: string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProviderPathPatch.ts#L46"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProviderPathPatch.ts",
      "path": "src/ConfigProviderPathPatch.ts"
    },
    "project": "effect",
    "name": "Unnested",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Unnested {\n  readonly _tag: \"Unnested\"\n  readonly name: string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProviderPathPatch.ts#L55"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ConfigProviderPathPatch.ts",
      "path": "src/ConfigProviderPathPatch.ts"
    },
    "project": "effect",
    "name": "PathPatch",
    "description": "Represents a description of how to modify the path to a configuration\nvalue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type PathPatch = Empty | AndThen | MapName | Nested | Unnested",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ConfigProviderPathPatch.ts#L13"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L15"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "Console",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const Console: Context.Tag<Console, Console>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L83"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "withConsole",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "default services",
    "signature": "declare const withConsole: { <C extends Console>(console: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, C extends Console>(effect: Effect<A, E, R>, console: C): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L89"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "setConsole",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "default services",
    "signature": "declare const setConsole: <A extends Console>(console: A) => Layer.Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L98"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "consoleWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const consoleWith: <A, E, R>(f: (console: Console) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L104"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "assert",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const assert: (condition: boolean, ...args: ReadonlyArray<any>) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L110"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "clear",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const clear: Effect<void, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L116"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "count",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const count: (label?: string) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L122"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "countReset",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const countReset: (label?: string) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L128"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "debug",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const debug: (...args: ReadonlyArray<any>) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L134"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "dir",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const dir: (item: any, options?: any) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L140"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "dirxml",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const dirxml: (...args: ReadonlyArray<any>) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L146"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "error",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const error: (...args: ReadonlyArray<any>) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L152"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "group",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const group: (options?: { label?: string | undefined; collapsed?: boolean | undefined; } | undefined) => Effect<void, never, Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L158"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "info",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const info: (...args: ReadonlyArray<any>) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L166"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "log",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const log: (...args: ReadonlyArray<any>) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L172"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "table",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const table: (tabularData: any, properties?: ReadonlyArray<string>) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L178"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "time",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const time: (label?: string | undefined) => Effect<void, never, Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L184"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "timeLog",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const timeLog: (label?: string, ...args: ReadonlyArray<any>) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L190"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "trace",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const trace: (...args: ReadonlyArray<any>) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L196"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "warn",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const warn: (...args: ReadonlyArray<any>) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L202"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "withGroup",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const withGroup: { (options?: { readonly label?: string | undefined; readonly collapsed?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, options?: { readonly label?: string | undefined; readonly collapsed?: boolean | undefined; }): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L208"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "withTime",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "declare const withTime: { (label?: string): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, label?: string): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L223"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "Console",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface Console {\n  readonly [TypeId]: TypeId\n  assert(condition: boolean, ...args: ReadonlyArray<any>): Effect<void>\n  readonly clear: Effect<void>\n  count(label?: string): Effect<void>\n  countReset(label?: string): Effect<void>\n  debug(...args: ReadonlyArray<any>): Effect<void>\n  dir(item: any, options?: any): Effect<void>\n  dirxml(...args: ReadonlyArray<any>): Effect<void>\n  error(...args: ReadonlyArray<any>): Effect<void>\n  group(options?: {\n    readonly label?: string | undefined\n    readonly collapsed?: boolean | undefined\n  }): Effect<void>\n  readonly groupEnd: Effect<void>\n  info(...args: ReadonlyArray<any>): Effect<void>\n  log(...args: ReadonlyArray<any>): Effect<void>\n  table(tabularData: any, properties?: ReadonlyArray<string>): Effect<void>\n  time(label?: string): Effect<void>\n  timeEnd(label?: string): Effect<void>\n  timeLog(label?: string, ...args: ReadonlyArray<any>): Effect<void>\n  trace(...args: ReadonlyArray<any>): Effect<void>\n  warn(...args: ReadonlyArray<any>): Effect<void>\n  readonly unsafe: UnsafeConsole\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L27"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "UnsafeConsole",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface UnsafeConsole {\n  assert(condition: boolean, ...args: ReadonlyArray<any>): void\n  clear(): void\n  count(label?: string): void\n  countReset(label?: string): void\n  debug(...args: ReadonlyArray<any>): void\n  dir(item: any, options?: any): void\n  dirxml(...args: ReadonlyArray<any>): void\n  error(...args: ReadonlyArray<any>): void\n  group(...args: ReadonlyArray<any>): void\n  groupCollapsed(...args: ReadonlyArray<any>): void\n  groupEnd(): void\n  info(...args: ReadonlyArray<any>): void\n  log(...args: ReadonlyArray<any>): void\n  table(tabularData: any, properties?: ReadonlyArray<string>): void\n  time(label?: string): void\n  timeEnd(label?: string): void\n  timeLog(label?: string, ...args: ReadonlyArray<any>): void\n  trace(...args: ReadonlyArray<any>): void\n  warn(...args: ReadonlyArray<any>): void\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L57"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Console.ts",
      "path": "src/Console.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Console.ts#L21"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "GenericTag",
    "description": "Creates a new `Tag` instance with an optional key parameter.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nassert.strictEqual(Context.GenericTag(\"PORT\").key === Context.GenericTag(\"PORT\").key, true)\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const GenericTag: <Identifier, Service = Identifier>(key: string) => Tag<Identifier, Service>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L156"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "unsafeMake",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unsafeMake: <Services>(unsafeMap: Map<string, any>) => Context<Services>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L188"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "isContext",
    "description": "Checks if the provided argument is a `Context`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nassert.strictEqual(Context.isContext(Context.empty()), true)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isContext: (input: unknown) => input is Context<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L204"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "isTag",
    "description": "Checks if the provided argument is a `Tag`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nassert.strictEqual(Context.isTag(Context.GenericTag(\"Tag\")), true)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isTag: (input: unknown) => input is Tag<any, any>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L220"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "isReference",
    "description": "Checks if the provided argument is a `Reference`.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "guards",
    "signature": "declare const isReference: (u: unknown) => u is Reference<any, any>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L229"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Returns an empty `Context`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nassert.strictEqual(Context.isContext(Context.empty()), true)\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: () => Context<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L245"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new `Context` with a single service associated to the tag.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n\nconst Services = Context.make(Port, { PORT: 8080 })\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <T extends Tag<any, any>>(tag: T, service: Tag.Service<T>) => Context<Tag.Identifier<T>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L265"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "add",
    "description": "Adds a service to a given `Context`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Context, pipe } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst someContext = Context.make(Port, { PORT: 8080 })\n\nconst Services = pipe(\n  someContext,\n  Context.add(Timeout, { TIMEOUT: 5000 })\n)\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const add: { <T extends Tag<any, any>>(tag: T, service: Tag.Service<T>): <Services>(self: Context<Services>) => Context<Services | Tag.Identifier<T>>; <Services, T extends Tag<any, any>>(self: Context<Services>, tag: T, service: Tag.Service<T>): Context<Services | Tag.Identifier<T>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L292"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Get a service from the context that corresponds to the given tag.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst Services = pipe(\n  Context.make(Port, { PORT: 8080 }),\n  Context.add(Timeout, { TIMEOUT: 5000 })\n)\n\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const get: { <I, S>(tag: Reference<I, S>): <Services>(self: Context<Services>) => S; <Services, I extends Services, S>(tag: Tag<I, S>): (self: Context<Services>) => S; <Services, I, S>(self: Context<Services>, tag: Reference<I, S>): S; <Services, I extends Services, S>(self: Context<Services>, tag: Tag<I, S>): S; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L326"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "getOrElse",
    "description": "Get a service from the context that corresponds to the given tag, or\nuse the fallback value.",
    "deprecated": false,
    "examples": [],
    "since": "3.7.0",
    "category": "getters",
    "signature": "declare const getOrElse: { <S, I, B>(tag: Tag<I, S>, orElse: LazyArg<B>): <Services>(self: Context<Services>) => S | B; <Services, S, I, B>(self: Context<Services>, tag: Tag<I, S>, orElse: LazyArg<B>): S | B; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L340"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "unsafeGet",
    "description": "Get a service from the context that corresponds to the given tag.\nThis function is unsafe because if the tag is not present in the context, a runtime error will be thrown.\n\nFor a safer version see {@link getOption}.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst Services = Context.make(Port, { PORT: 8080 })\n\nassert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })\nassert.throws(() => Context.unsafeGet(Services, Timeout))\n```"
    ],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeGet: { <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => S; <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): S; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L368"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "getOption",
    "description": "Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not\nfound, the `Option` object will be `None`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Context, Option } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst Services = Context.make(Port, { PORT: 8080 })\n\nassert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\nassert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const getOption: { <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => Option<S>; <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): Option<S>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L394"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "merge",
    "description": "Merges two `Context`s, returning a new `Context` containing the services of both.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst firstContext = Context.make(Port, { PORT: 8080 })\nconst secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n\nconst Services = Context.merge(firstContext, secondContext)\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const merge: { <R1>(that: Context<R1>): <Services>(self: Context<Services>) => Context<R1 | Services>; <Services, R1>(self: Context<Services>, that: Context<R1>): Context<Services | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L421"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "mergeAll",
    "description": "Merges any number of `Context`s, returning a new `Context` containing the services of all.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\nconst Host = Context.GenericTag<{ HOST: string }>(\"Host\")\n\nconst firstContext = Context.make(Port, { PORT: 8080 })\nconst secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\nconst thirdContext = Context.make(Host, { HOST: \"localhost\" })\n\nconst Services = Context.mergeAll(firstContext, secondContext, thirdContext)\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\nassert.deepStrictEqual(Context.get(Services, Host), { HOST: \"localhost\" })\n```"
    ],
    "since": "3.12.0",
    "category": null,
    "signature": "declare const mergeAll: <T extends Array<unknown>>(...ctxs: { [K in keyof T]: Context<T[K]>; }) => Context<T[number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L451"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "pick",
    "description": "Returns a new `Context` that contains only the specified services.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, Context, Option } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst someContext = pipe(\n  Context.make(Port, { PORT: 8080 }),\n  Context.add(Timeout, { TIMEOUT: 5000 })\n)\n\nconst Services = pipe(someContext, Context.pick(Port))\n\nassert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\nassert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const pick: <Tags extends ReadonlyArray<Tag<any, any>>>(...tags: Tags) => <Services>(self: Context<Services>) => Context<Services & Tag.Identifier<Tags[number]>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L479"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "omit",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const omit: <Tags extends ReadonlyArray<Tag<any, any>>>(...tags: Tags) => <Services>(self: Context<Services>) => Context<Exclude<Services, Tag.Identifier<Tags[number]>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L486"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "Tag",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Context, Layer } from \"effect\"\n\nclass MyTag extends Context.Tag(\"MyTag\")<\n MyTag,\n { readonly myNum: number }\n>() {\n static Live = Layer.succeed(this, { myNum: 108 })\n}\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Tag: <const Id extends string>(id: Id) => <Self, Shape>() => TagClass<Self, Id, Shape>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L507"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "Reference",
    "description": "Creates a context tag with a default value.\n\n**Details**\n\n`Context.Reference` allows you to create a tag that can hold a value. You can\nprovide a default value for the service, which will automatically be used\nwhen the context is accessed, or override it with a custom implementation\nwhen needed.\n\n**Example** (Declaring a Tag with a default value)\n\n```ts\nimport * as assert from \"node:assert\"\nimport { Context, Effect } from \"effect\"\n\nclass SpecialNumber extends Context.Reference<SpecialNumber>()(\n  \"SpecialNumber\",\n  { defaultValue: () => 2048 }\n) {}\n\n//       Effect<void, never, never>\n//      \nconst program = Effect.gen(function* () {\n  const specialNumber = yield* SpecialNumber\n  console.log(`The special number is ${specialNumber}`)\n})\n\n// No need to provide the SpecialNumber implementation\nEffect.runPromise(program)\n// Output: The special number is 2048\n```\n\n**Example** (Overriding the default value)\n\n```ts\nimport { Context, Effect } from \"effect\"\n\nclass SpecialNumber extends Context.Reference<SpecialNumber>()(\n  \"SpecialNumber\",\n  { defaultValue: () => 2048 }\n) {}\n\nconst program = Effect.gen(function* () {\n  const specialNumber = yield* SpecialNumber\n  console.log(`The special number is ${specialNumber}`)\n})\n\nEffect.runPromise(program.pipe(Effect.provideService(SpecialNumber, -1)))\n// Output: The special number is -1\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "declare const Reference: <Self>() => <const Id extends string, Service>(id: Id, options: { readonly defaultValue: () => Service; }) => ReferenceClass<Self, Id, Service>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L565"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "Tag",
    "deprecated": false,
    "examples": [],
    "since": "3.5.9",
    "category": "models",
    "signature": "export interface Tag<in out Id, in out Value> extends Pipeable, Inspectable {\n  readonly _op: \"Tag\"\n  readonly Service: Value\n  readonly Identifier: Id\n  readonly [TagTypeId]: {\n    readonly _Service: Types.Invariant<Value>\n    readonly _Identifier: Types.Invariant<Id>\n  }\n  of(self: Value): Value\n  context(self: Value): Context<Id>\n  readonly stack?: string | undefined\n  readonly key: string\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: TagUnify<this>\n  [Unify.ignoreSymbol]?: TagUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L31"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "Reference",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "models",
    "signature": "export interface Reference<in out Id, in out Value> extends Pipeable, Inspectable {\n  readonly [ReferenceTypeId]: ReferenceTypeId\n  readonly defaultValue: () => Value\n\n  readonly _op: \"Tag\"\n  readonly Service: Value\n  readonly Identifier: Id\n  readonly [TagTypeId]: {\n    readonly _Service: Types.Invariant<Value>\n    readonly _Identifier: Types.Invariant<Id>\n  }\n  of(self: Value): Value\n  context(self: Value): Context<Id>\n  readonly stack?: string | undefined\n  readonly key: string\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: TagUnify<this>\n  [Unify.ignoreSymbol]?: TagUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L60"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "TagClassShape",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TagClassShape<Id, Shape> {\n  readonly [TagTypeId]: TagTypeId\n  readonly Type: Shape\n  readonly Id: Id\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L84"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "TagClass",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TagClass<Self, Id extends string, Type> extends Tag<Self, Type> {\n  new(_: never): TagClassShape<Id, Type>\n  readonly key: Id\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L95"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "ReferenceClass",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "models",
    "signature": "export interface ReferenceClass<Self, Id extends string, Type> extends Reference<Self, Type> {\n  new(_: never): TagClassShape<Id, Type>\n  readonly key: Id\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L105"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "TagUnify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TagUnify<A extends { [Unify.typeSymbol]?: any }> {\n  Tag?: () => Extract<A[Unify.typeSymbol], Tag<any, any>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L114"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "TagUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TagUnifyIgnore {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L122"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "Context",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Context<in Services> extends Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _Services: Types.Contravariant<Services>\n  }\n  readonly unsafeMap: Map<string, any>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L177"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "TagTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TagTypeId = typeof TagTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L25"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "ReferenceTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "symbol",
    "signature": "type ReferenceTypeId = typeof ReferenceTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L54"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L165"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "ValidTagsById",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type ValidTagsById<R> = R extends infer S ? Tag<S, any> : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L171"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "Tag.Service",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Service<T> = T extends Tag<any, any> ? T[\"Service\"]\n    : T extends TagClassShape<any, infer A> ? A\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L131"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Context.ts",
      "path": "src/Context.ts"
    },
    "project": "effect",
    "name": "Tag.Identifier",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Identifier<T> = T extends Tag<any, any> ? T[\"Identifier\"]\n    : T extends TagClassShape<any, any> ? T\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Context.ts#L137"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "ParseError",
    "description": "Represents a checked exception which occurs when decoding fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "declare class ParseError",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L202"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L25"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "ParseErrorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "declare const ParseErrorTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L188"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "sequence",
    "description": "Returns an `IterableIterator` which yields the sequence of `Date`s that match the `Cron` instance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const sequence: (cron: Cron, startFrom?: DateTime.DateTime.Input) => IterableIterator<Date>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L523"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "Equivalence",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Equivalence: equivalence.Equivalence<Cron>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L533"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "equals",
    "description": "Checks if two `Cron`s are equal.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const equals: { (that: Cron): (self: Cron) => boolean; (self: Cron, that: Cron): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L552"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "isCron",
    "description": "Checks if a given value is a `Cron` instance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isCron: (u: unknown) => u is Cron",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L112"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a `Cron` instance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (values: { readonly seconds?: Iterable<number> | undefined; readonly minutes: Iterable<number>; readonly hours: Iterable<number>; readonly days: Iterable<number>; readonly months: Iterable<number>; readonly weekdays: Iterable<number>; readonly tz?: DateTime.TimeZone | undefined; }) => Cron",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L120"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "isParseError",
    "description": "Returns `true` if the specified value is an `ParseError`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isParseError: (u: unknown) => u is ParseError",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L218"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "parse",
    "description": "Parses a cron expression into a `Cron` instance.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Cron, Either } from \"effect\"\n\n// At 04:00 on every day-of-month from 8 through 14.\nassert.deepStrictEqual(Cron.parse(\"0 0 4 8-14 * *\"), Either.right(Cron.make({\n  seconds: [0],\n  minutes: [0],\n  hours: [4],\n  days: [8, 9, 10, 11, 12, 13, 14],\n  months: [],\n  weekdays: []\n})))\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const parse: (cron: string, tz?: DateTime.TimeZone | string) => Either.Either<Cron, ParseError>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L242"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "unsafeParse",
    "description": "Parses a cron expression into a `Cron` instance.\n\n**Details**\n\nThis function takes a cron expression as a string and attempts to parse it\ninto a `Cron` instance. If the expression is valid, the resulting `Cron`\ninstance will represent the schedule defined by the cron expression.\n\nIf the expression is invalid, the function throws a `ParseError`.\n\nYou can optionally provide a time zone (`tz`) to interpret the cron\nexpression in a specific time zone. If no time zone is provided, the cron\nexpression will use the default time zone.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Cron } from \"effect\"\n\n// At 04:00 on every day-of-month from 8 through 14.\nconsole.log(Cron.unsafeParse(\"0 4 8-14 * *\"))\n// Output:\n// {\n//   _id: 'Cron',\n//   tz: { _id: 'Option', _tag: 'None' },\n//   seconds: [ 0 ],\n//   minutes: [ 0 ],\n//   hours: [ 4 ],\n//   days: [\n//      8,  9, 10, 11,\n//     12, 13, 14\n//   ],\n//   months: [],\n//   weekdays: []\n// }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unsafeParse: (cron: string, tz?: DateTime.TimeZone | string) => Cron",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L317"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Checks if a given `Date` falls within an active `Cron` time window.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Cron, Either } from \"effect\"\n\nconst cron = Either.getOrThrow(Cron.parse(\"0 4 8-14 * *\"))\nassert.deepStrictEqual(Cron.match(cron, new Date(\"2021-01-08 04:00:00\")), true)\nassert.deepStrictEqual(Cron.match(cron, new Date(\"2021-01-08 05:00:00\")), false)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const match: (cron: Cron, date: DateTime.DateTime.Input) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L337"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "next",
    "description": "Returns the next run `Date` for the given `Cron` instance.\n\nUses the current time as a starting point if no value is provided for `now`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Cron, Either } from \"effect\"\n\nconst after = new Date(\"2021-01-01 00:00:00\")\nconst cron = Either.getOrThrow(Cron.parse(\"0 4 8-14 * *\"))\nassert.deepStrictEqual(Cron.next(cron, after), new Date(\"2021-01-08 04:00:00\"))\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const next: (cron: Cron, startFrom?: DateTime.DateTime.Input) => Date",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L396"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "Cron",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Cron extends Pipeable, Equal.Equal, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly tz: Option.Option<DateTime.TimeZone>\n  readonly seconds: ReadonlySet<number>\n  readonly minutes: ReadonlySet<number>\n  readonly hours: ReadonlySet<number>\n  readonly days: ReadonlySet<number>\n  readonly months: ReadonlySet<number>\n  readonly weekdays: ReadonlySet<number>\n  /** @internal */\n  readonly first: {\n    readonly second: number\n    readonly minute: number\n    readonly hour: number\n    readonly day: number\n    readonly month: number\n    readonly weekday: number\n  }\n  /** @internal */\n  readonly next: {\n    readonly second: ReadonlyArray<number | undefined>\n    readonly minute: ReadonlyArray<number | undefined>\n    readonly hour: ReadonlyArray<number | undefined>\n    readonly day: ReadonlyArray<number | undefined>\n    readonly month: ReadonlyArray<number | undefined>\n    readonly weekday: ReadonlyArray<number | undefined>\n  }\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L37"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L31"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cron.ts",
      "path": "src/Cron.ts"
    },
    "project": "effect",
    "name": "ParseErrorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type ParseErrorTypeId = typeof ParseErrorTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Cron.ts#L194"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "struct",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Data, Equal } from \"effect\"\n\nconst alice = Data.struct({ name: \"Alice\", age: 30 })\n\nconst bob = Data.struct({ name: \"Bob\", age: 40 })\n\nassert.deepStrictEqual(Equal.equals(alice, alice), true)\nassert.deepStrictEqual(Equal.equals(alice, Data.struct({ name: \"Alice\", age: 30 })), true)\n\nassert.deepStrictEqual(Equal.equals(alice, { name: \"Alice\", age: 30 }), false)\nassert.deepStrictEqual(Equal.equals(alice, bob), false)\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const struct: <A extends Record<string, any>>(a: A) => { readonly [P in keyof A]: A[P]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L48"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "Class",
    "description": "Provides a constructor for a Case Class.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Data, Equal } from \"effect\"\n\nclass Person extends Data.Class<{ readonly name: string }> {}\n\n// Creating instances of Person\nconst mike1 = new Person({ name: \"Mike\" })\nconst mike2 = new Person({ name: \"Mike\" })\nconst john = new Person({ name: \"John\" })\n\n// Checking equality\nassert.deepStrictEqual(Equal.equals(mike1, mike2), true)\nassert.deepStrictEqual(Equal.equals(mike1, john), false)\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Class: new <A extends Record<string, any> = {}>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P]; }) => Readonly<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L204"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "Structural",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Structural: new <A>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P]; }) => {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L250"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "Error",
    "description": "Provides a constructor for a Case Class.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Error: new <A extends Record<string, any> = {}>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P]; }) => Cause.YieldableError & Readonly<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L553"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "unsafeStruct",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unsafeStruct: <A extends Record<string, any>>(as: A) => { readonly [P in keyof A]: A[P]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L54"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "tuple",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Data, Equal } from \"effect\"\n\nconst alice = Data.tuple(\"Alice\", 30)\n\nconst bob = Data.tuple(\"Bob\", 40)\n\nassert.deepStrictEqual(Equal.equals(alice, alice), true)\nassert.deepStrictEqual(Equal.equals(alice, Data.tuple(\"Alice\", 30)), true)\n\nassert.deepStrictEqual(Equal.equals(alice, [\"Alice\", 30]), false)\nassert.deepStrictEqual(Equal.equals(alice, bob), false)\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const tuple: <As extends ReadonlyArray<any>>(...as: As) => Readonly<As>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L77"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "array",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Data, Equal } from \"effect\"\n\nconst alice = Data.struct({ name: \"Alice\", age: 30 })\nconst bob = Data.struct({ name: \"Bob\", age: 40 })\n\nconst persons = Data.array([alice, bob])\n\nassert.deepStrictEqual(\n  Equal.equals(\n    persons,\n    Data.array([\n      Data.struct({ name: \"Alice\", age: 30 }),\n      Data.struct({ name: \"Bob\", age: 40 })\n    ])\n  ),\n  true\n)\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const array: <As extends ReadonlyArray<any>>(as: As) => Readonly<As>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L105"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "unsafeArray",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unsafeArray: <As extends ReadonlyArray<any>>(as: As) => Readonly<As>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L111"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "tagged",
    "description": "Provides a tagged constructor for the specified `Case`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Data } from \"effect\"\n\ninterface Person {\n  readonly _tag: \"Person\" // the tag\n  readonly name: string\n}\n\nconst Person = Data.tagged<Person>(\"Person\")\n\nconst mike = Person({ name: \"Mike\" })\n\nassert.deepEqual(mike, { _tag: \"Person\", name: \"Mike\" })\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const tagged: <A extends { readonly _tag: string; }>(tag: A[\"_tag\"]) => Case.Constructor<A, \"_tag\">",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L172"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "TaggedClass",
    "description": "Provides a Tagged constructor for a Case Class.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Data, Equal } from \"effect\"\n\nclass Person extends Data.TaggedClass(\"Person\")<{ readonly name: string }> {}\n\n// Creating instances of Person\nconst mike1 = new Person({ name: \"Mike\" })\nconst mike2 = new Person({ name: \"Mike\" })\nconst john = new Person({ name: \"John\" })\n\n// Checking equality\nassert.deepStrictEqual(Equal.equals(mike1, mike2), true)\nassert.deepStrictEqual(Equal.equals(mike1, john), false)\n\nassert.deepStrictEqual(mike1._tag, \"Person\")\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const TaggedClass: <Tag extends string>(tag: Tag) => new <A extends Record<string, any> = {}>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends \"_tag\" ? never : P]: A[P]; }) => Readonly<A> & { readonly _tag: Tag; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L234"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "taggedEnum",
    "description": "Create a constructor for a tagged union of `Data` structs.\n\nYou can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\nthe constructor.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Data } from \"effect\"\n\nconst { BadRequest, NotFound } = Data.taggedEnum<\n  | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n  | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n>()\n\nconst notFound = NotFound({ status: 404, message: \"Not Found\" })\n```",
      "import { Data } from \"effect\"\n\ntype MyResult<E, A> = Data.TaggedEnum<{\n  Failure: { readonly error: E }\n  Success: { readonly value: A }\n}>\ninterface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n  readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n}\nconst { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n\nconst success = Success({ value: 1 })"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const taggedEnum: { <Z extends TaggedEnum.WithGenerics<1>>(): Types.Simplify<{ readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A>, Tag, Extract<TaggedEnum.Kind<Z, A>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <Z extends TaggedEnum.WithGenerics<2>>(): Types.Simplify<{ readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A, B>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A, B>, Tag, Extract<TaggedEnum.Kind<Z, A, B>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <Z extends TaggedEnum.WithGenerics<3>>(): Types.Simplify<{ readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A, B, C>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A, B, C>, Tag, Extract<TaggedEnum.Kind<Z, A, B, C>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B, C>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <Z extends TaggedEnum.WithGenerics<4>>(): Types.Simplify<{ readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A, B, C, D>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A, B, C, D>, Tag, Extract<TaggedEnum.Kind<Z, A, B, C, D>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B, C, D>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <A extends { readonly _tag: string; }>(): TaggedEnum.Constructor<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L456"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "TaggedError",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const TaggedError: <Tag extends string>(tag: Tag) => new <A extends Record<string, any> = {}>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends \"_tag\" ? never : P]: A[P]; }) => Cause.YieldableError & { readonly _tag: Tag; } & Readonly<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L576"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "TaggedEnum",
    "description": "Create a tagged enum data type, which is a union of `Data` structs.\n\n```ts\nimport * as assert from \"node:assert\"\nimport { Data } from \"effect\"\n\ntype HttpError = Data.TaggedEnum<{\n  BadRequest: { readonly status: 400, readonly message: string }\n  NotFound: { readonly status: 404, readonly message: string }\n}>\n\n// Equivalent to:\ntype HttpErrorPlain =\n  | {\n    readonly _tag: \"BadRequest\"\n    readonly status: 400\n    readonly message: string\n  }\n  | {\n    readonly _tag: \"NotFound\"\n    readonly status: 404\n    readonly message: string\n  }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type TaggedEnum<A> = keyof A extends infer Tag ?\n  Tag extends keyof A ? Types.Simplify<{ readonly _tag: Tag } & { readonly [K in keyof A[Tag]]: A[Tag][K] }>\n  : never\n  : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L284"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "Case.Constructor",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Constructor<A, Tag extends keyof A = never> {\n    (\n      args: Types.Equals<Omit<A, Tag>, {}> extends true ? void\n        : { readonly [P in keyof A as P extends Tag ? never : P]: A[P] }\n    ): A\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L20"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "TaggedEnum.WithGenerics",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface WithGenerics<Count extends number> {\n    readonly taggedEnum: { readonly _tag: string }\n    readonly numberOfGenerics: Count\n\n    readonly A: unknown\n    readonly B: unknown\n    readonly C: unknown\n    readonly D: unknown\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L308"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "TaggedEnum.GenericMatchers",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": null,
    "signature": "export interface GenericMatchers<Z extends WithGenerics<number>> {\n    readonly $is: <Tag extends Z[\"taggedEnum\"][\"_tag\"]>(\n      tag: Tag\n    ) => {\n      <T extends TaggedEnum.Kind<Z, any, any, any, any>>(\n        u: T\n      ): u is T & { readonly _tag: Tag }\n      (u: unknown): u is Extract<TaggedEnum.Kind<Z>, { readonly _tag: Tag }>\n    }\n    readonly $match: {\n      <\n        A,\n        B,\n        C,\n        D,\n        Cases extends {\n          readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: (\n            args: Extract<TaggedEnum.Kind<Z, A, B, C, D>, { readonly _tag: Tag }>\n          ) => any\n        }\n      >(\n        cases: Cases\n      ): (self: TaggedEnum.Kind<Z, A, B, C, D>) => Unify<ReturnType<Cases[Z[\"taggedEnum\"][\"_tag\"]]>>\n      <\n        A,\n        B,\n        C,\n        D,\n        Cases extends {\n          readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: (\n            args: Extract<TaggedEnum.Kind<Z, A, B, C, D>, { readonly _tag: Tag }>\n          ) => any\n        }\n      >(\n        self: TaggedEnum.Kind<Z, A, B, C, D>,\n        cases: Cases\n      ): Unify<ReturnType<Cases[Z[\"taggedEnum\"][\"_tag\"]]>>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L380"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "TaggedEnum.Kind",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Kind<Z, A, B, C, D> = (Z & {\n    readonly A: A\n    readonly B: B\n    readonly C: C\n    readonly D: D\n  })[\"taggedEnum\"]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L322"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "TaggedEnum.Args",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Args<A, K, E> = { readonly [K in keyof E as K extends \"_tag\" ? never : K]: E[K] } extends infer T ? {} extends T ? void : T\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L338"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "TaggedEnum.Value",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Value<A, K> = Extract<A, { readonly _tag: K }>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L348"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Data.ts",
      "path": "src/Data.ts"
    },
    "project": "effect",
    "name": "TaggedEnum.Constructor",
    "deprecated": false,
    "examples": [],
    "since": "3.1.0",
    "category": null,
    "signature": "type Constructor<A> = Types.Simplify<\n    & {\n      readonly [Tag in A[\"_tag\"]]: Case.Constructor<Extract<A, { readonly _tag: Tag }>, \"_tag\">\n    }\n    & {\n      readonly $is: <Tag extends A[\"_tag\"]>(tag: Tag) => (u: unknown) => u is Extract<A, { readonly _tag: Tag }>\n      readonly $match: {\n        <\n          Cases extends {\n            readonly [Tag in A[\"_tag\"]]: (args: Extract<A, { readonly _tag: Tag }>) => any\n          }\n        >(cases: Cases): (value: A) => Unify<ReturnType<Cases[A[\"_tag\"]]>>\n        <\n          Cases extends {\n            readonly [Tag in A[\"_tag\"]]: (args: Extract<A, { readonly _tag: Tag }>) => any\n          }\n        >(value: A, cases: Cases): Unify<ReturnType<Cases[A[\"_tag\"]]>>\n      }\n    }\n  >",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Data.ts#L356"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "CurrentTimeZone",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "current time zone",
    "signature": "declare class CurrentTimeZone",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L991"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "type ids",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L22"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "TimeZoneTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "type ids",
    "signature": "declare const TimeZoneTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L170"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "isDateTime",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "guards",
    "signature": "declare const isDateTime: (u: unknown) => u is DateTime",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L226"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "isTimeZone",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "guards",
    "signature": "declare const isTimeZone: (u: unknown) => u is TimeZone",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L232"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "isTimeZoneOffset",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "guards",
    "signature": "declare const isTimeZoneOffset: (u: unknown) => u is TimeZone.Offset",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L238"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "isTimeZoneNamed",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "guards",
    "signature": "declare const isTimeZoneNamed: (u: unknown) => u is TimeZone.Named",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L244"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "isUtc",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "guards",
    "signature": "declare const isUtc: (self: DateTime) => self is Utc",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L250"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "isZoned",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "guards",
    "signature": "declare const isZoned: (self: DateTime) => self is Zoned",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L256"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "Equivalence",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "instances",
    "signature": "declare const Equivalence: equivalence.Equivalence<DateTime>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L266"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "Order",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "instances",
    "signature": "declare const Order: order.Order<DateTime>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L272"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "clamp",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": null,
    "signature": "declare const clamp: { <Min extends DateTime, Max extends DateTime>(options: { readonly minimum: Min; readonly maximum: Max; }): <A extends DateTime>(self: A) => A | Min | Max; <A extends DateTime, Min extends DateTime, Max extends DateTime>(self: A, options: { readonly minimum: Min; readonly maximum: Max; }): A | Min | Max; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L277"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "unsafeFromDate",
    "description": "Create a `DateTime` from a `Date`.\n\nIf the `Date` is invalid, an `IllegalArgumentException` will be thrown.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "declare const unsafeFromDate: (date: Date) => Utc",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L299"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "unsafeMake",
    "description": "Create a `DateTime` from one of the following:\n\n- A `DateTime`\n- A `Date` instance (invalid dates will throw an `IllegalArgumentException`)\n- The `number` of milliseconds since the Unix epoch\n- An object with the parts of a date\n- A `string` that can be parsed by `Date.parse`",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\n// from Date\nDateTime.unsafeMake(new Date())\n\n// from parts\nDateTime.unsafeMake({ year: 2024 })\n\n// from string\nDateTime.unsafeMake(\"2024-01-01\")\n```"
    ],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "declare const unsafeMake: <A extends DateTime.Input>(input: A) => DateTime.PreserveZone<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L326"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "unsafeMakeZoned",
    "description": "Create a `DateTime.Zoned` using `DateTime.unsafeMake` and a time zone.\n\nThe input is treated as UTC and then the time zone is attached, unless\n`adjustForTimeZone` is set to `true`. In that case, the input is treated as\nalready in the time zone.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\nDateTime.unsafeMakeZoned(new Date(), { timeZone: \"Europe/London\" })\n```"
    ],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "declare const unsafeMakeZoned: (input: DateTime.Input, options?: { readonly timeZone?: number | string | TimeZone | undefined; readonly adjustForTimeZone?: boolean | undefined; }) => Zoned",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L344"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "makeZoned",
    "description": "Create a `DateTime.Zoned` using `DateTime.make` and a time zone.\n\nThe input is treated as UTC and then the time zone is attached.\n\nIf the date time input or time zone is invalid, `None` will be returned.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\nDateTime.makeZoned(new Date(), { timeZone: \"Europe/London\" })\n```"
    ],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "declare const makeZoned: (input: DateTime.Input, options?: { readonly timeZone?: number | string | TimeZone | undefined; readonly adjustForTimeZone?: boolean | undefined; }) => Option.Option<Zoned>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L365"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Create a `DateTime` from one of the following:\n\n- A `DateTime`\n- A `Date` instance (invalid dates will throw an `IllegalArgumentException`)\n- The `number` of milliseconds since the Unix epoch\n- An object with the parts of a date\n- A `string` that can be parsed by `Date.parse`\n\nIf the input is invalid, `None` will be returned.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\n// from Date\nDateTime.make(new Date())\n\n// from parts\nDateTime.make({ year: 2024 })\n\n// from string\nDateTime.make(\"2024-01-01\")\n```"
    ],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "declare const make: <A extends DateTime.Input>(input: A) => Option.Option<DateTime.PreserveZone<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L400"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "makeZonedFromString",
    "description": "Create a `DateTime.Zoned` from a string.\n\nIt uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "declare const makeZonedFromString: (input: string) => Option.Option<Zoned>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L410"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "now",
    "description": "Get the current time using the `Clock` service and convert it to a `DateTime`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n})\n```"
    ],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "declare const now: Effect.Effect<Utc, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L426"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "nowAsDate",
    "description": "Get the current time using the `Clock` service.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.nowAsDate\n})\n```"
    ],
    "since": "3.14.0",
    "category": "constructors",
    "signature": "declare const nowAsDate: Effect.Effect<Date, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L442"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "unsafeNow",
    "description": "Get the current time using `Date.now`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "declare const unsafeNow: LazyArg<Utc>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L450"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "toUtc",
    "description": "For a `DateTime` returns a new `DateTime.Utc`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\nconst now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: \"Europe/London\" })\n\n// set as UTC\nconst utc: DateTime.Utc = DateTime.toUtc(now)\n```"
    ],
    "since": "3.13.0",
    "category": "time zones",
    "signature": "declare const toUtc: (self: DateTime) => Utc",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L471"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "setZone",
    "description": "Set the time zone of a `DateTime`, returning a new `DateTime.Zoned`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const zone = DateTime.zoneUnsafeMakeNamed(\"Europe/London\")\n\n  // set the time zone\n  const zoned: DateTime.Zoned = DateTime.setZone(now, zone)\n})\n```"
    ],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "declare const setZone: { (zone: TimeZone, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, zone: TimeZone, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L491"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "setZoneOffset",
    "description": "Add a fixed offset time zone to a `DateTime`.\n\nThe offset is in milliseconds.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n\n  // set the offset time zone in milliseconds\n  const zoned: DateTime.Zoned = DateTime.setZoneOffset(now, 3 * 60 * 60 * 1000)\n})\n```"
    ],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "declare const setZoneOffset: { (offset: number, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, offset: number, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L519"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "zoneUnsafeMakeNamed",
    "description": "Attempt to create a named time zone from a IANA time zone identifier.\n\nIf the time zone is invalid, an `IllegalArgumentException` will be thrown.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "declare const zoneUnsafeMakeNamed: (zoneId: string) => TimeZone.Named",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L536"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "zoneMakeOffset",
    "description": "Create a fixed offset time zone.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "declare const zoneMakeOffset: (offset: number) => TimeZone.Offset",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L544"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "zoneMakeNamed",
    "description": "Create a named time zone from a IANA time zone identifier. If the time zone\nis invalid, `None` will be returned.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "declare const zoneMakeNamed: (zoneId: string) => Option.Option<TimeZone.Named>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L553"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "zoneMakeNamedEffect",
    "description": "Create a named time zone from a IANA time zone identifier. If the time zone\nis invalid, it will fail with an `IllegalArgumentException`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "declare const zoneMakeNamedEffect: (zoneId: string) => Effect.Effect<TimeZone.Named, IllegalArgumentException>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L562"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "zoneMakeLocal",
    "description": "Create a named time zone from the system's local time zone.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "declare const zoneMakeLocal: () => TimeZone.Named",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L571"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "zoneFromString",
    "description": "Try parse a TimeZone from a string",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "declare const zoneFromString: (zone: string) => Option.Option<TimeZone>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L579"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "zoneToString",
    "description": "Format a `TimeZone` as a string.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\n// Outputs \"+03:00\"\nDateTime.zoneToString(DateTime.zoneMakeOffset(3 * 60 * 60 * 1000))\n\n// Outputs \"Europe/London\"\nDateTime.zoneToString(DateTime.zoneUnsafeMakeNamed(\"Europe/London\"))\n```"
    ],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "declare const zoneToString: (self: TimeZone) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L597"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "setZoneNamed",
    "description": "Set the time zone of a `DateTime` from an IANA time zone identifier. If the\ntime zone is invalid, `None` will be returned.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  // set the time zone, returns an Option\n  DateTime.setZoneNamed(now, \"Europe/London\")\n})\n```"
    ],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "declare const setZoneNamed: { (zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Option.Option<Zoned>; (self: DateTime, zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Option.Option<Zoned>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L616"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "unsafeSetZoneNamed",
    "description": "Set the time zone of a `DateTime` from an IANA time zone identifier. If the\ntime zone is invalid, an `IllegalArgumentException` will be thrown.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  // set the time zone\n  DateTime.unsafeSetZoneNamed(now, \"Europe/London\")\n})\n```"
    ],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "declare const unsafeSetZoneNamed: { (zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L642"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "distance",
    "description": "Calulate the difference between two `DateTime` values, returning the number\nof milliseconds the `other` DateTime is from `self`.\n\nIf `other` is *after* `self`, the result will be a positive number.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const other = DateTime.add(now, { minutes: 1 })\n\n  // returns 60000\n  DateTime.distance(now, other)\n})\n```"
    ],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "declare const distance: { (other: DateTime): (self: DateTime) => number; (self: DateTime, other: DateTime): number; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L676"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "distanceDurationEither",
    "description": "Calulate the difference between two `DateTime` values.\n\nIf the `other` DateTime is before `self`, the result will be a negative\n`Duration`, returned as a `Left`.\n\nIf the `other` DateTime is after `self`, the result will be a positive\n`Duration`, returned as a `Right`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const other = DateTime.add(now, { minutes: 1 })\n\n  // returns Either.right(Duration.minutes(1))\n  DateTime.distanceDurationEither(now, other)\n\n  // returns Either.left(Duration.minutes(1))\n  DateTime.distanceDurationEither(other, now)\n})\n```"
    ],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "declare const distanceDurationEither: { (other: DateTime): (self: DateTime) => Either.Either<Duration.Duration, Duration.Duration>; (self: DateTime, other: DateTime): Either.Either<Duration.Duration, Duration.Duration>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L708"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "distanceDuration",
    "description": "Calulate the distance between two `DateTime` values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const other = DateTime.add(now, { minutes: 1 })\n\n  // returns Duration.minutes(1)\n  DateTime.distanceDuration(now, other)\n})\n```"
    ],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "declare const distanceDuration: { (other: DateTime): (self: DateTime) => Duration.Duration; (self: DateTime, other: DateTime): Duration.Duration; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L731"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "min",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "declare const min: { <That extends DateTime>(that: That): <Self extends DateTime>(self: Self) => Self | That; <Self extends DateTime, That extends DateTime>(self: Self, that: That): Self | That; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L740"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "max",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "declare const max: { <That extends DateTime>(that: That): <Self extends DateTime>(self: Self) => Self | That; <Self extends DateTime, That extends DateTime>(self: Self, that: That): Self | That; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L749"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "greaterThan",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "declare const greaterThan: { (that: DateTime): (self: DateTime) => boolean; (self: DateTime, that: DateTime): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L758"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "greaterThanOrEqualTo",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "declare const greaterThanOrEqualTo: { (that: DateTime): (self: DateTime) => boolean; (self: DateTime, that: DateTime): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L767"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "lessThan",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "declare const lessThan: { (that: DateTime): (self: DateTime) => boolean; (self: DateTime, that: DateTime): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L776"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "lessThanOrEqualTo",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "declare const lessThanOrEqualTo: { (that: DateTime): (self: DateTime) => boolean; (self: DateTime, that: DateTime): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L785"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "between",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "declare const between: { (options: { minimum: DateTime; maximum: DateTime; }): (self: DateTime) => boolean; (self: DateTime, options: { minimum: DateTime; maximum: DateTime; }): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L794"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "isFuture",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "declare const isFuture: (self: DateTime) => Effect.Effect<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L803"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "unsafeIsFuture",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "declare const unsafeIsFuture: (self: DateTime) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L809"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "isPast",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "declare const isPast: (self: DateTime) => Effect.Effect<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L815"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "unsafeIsPast",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "declare const unsafeIsPast: (self: DateTime) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L821"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "toDateUtc",
    "description": "Get the UTC `Date` of a `DateTime`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "conversions",
    "signature": "declare const toDateUtc: (self: DateTime) => Date",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L833"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "toDate",
    "description": "Convert a `DateTime` to a `Date`, applying the time zone first.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "conversions",
    "signature": "declare const toDate: (self: DateTime) => Date",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L841"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "zonedOffset",
    "description": "Calculate the time zone offset of a `DateTime.Zoned` in milliseconds.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "conversions",
    "signature": "declare const zonedOffset: (self: Zoned) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L849"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "zonedOffsetIso",
    "description": "Calculate the time zone offset of a `DateTime` in milliseconds.\n\nThe offset is formatted as \"HH:MM\".",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "conversions",
    "signature": "declare const zonedOffsetIso: (self: Zoned) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L859"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "toEpochMillis",
    "description": "Get the milliseconds since the Unix epoch of a `DateTime`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "conversions",
    "signature": "declare const toEpochMillis: (self: DateTime) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L867"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "removeTime",
    "description": "Remove the time aspect of a `DateTime`, first adjusting for the time\nzone. It will return a `DateTime.Utc` only containing the date.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\n// returns \"2024-01-01T00:00:00Z\"\nDateTime.unsafeMakeZoned(\"2024-01-01T05:00:00Z\", {\n  timeZone: \"Pacific/Auckland\",\n  adjustForTimeZone: true\n}).pipe(\n  DateTime.removeTime,\n  DateTime.formatIso\n)\n```"
    ],
    "since": "3.6.0",
    "category": "conversions",
    "signature": "declare const removeTime: (self: DateTime) => Utc",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L889"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "toParts",
    "description": "Get the different parts of a `DateTime` as an object.\n\nThe parts will be time zone adjusted.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "parts",
    "signature": "declare const toParts: (self: DateTime) => DateTime.PartsWithWeekday",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L903"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "toPartsUtc",
    "description": "Get the different parts of a `DateTime` as an object.\n\nThe parts will be in UTC.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "parts",
    "signature": "declare const toPartsUtc: (self: DateTime) => DateTime.PartsWithWeekday",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L913"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "getPartUtc",
    "description": "Get a part of a `DateTime` as a number.\n\nThe part will be in the UTC time zone.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { DateTime } from \"effect\"\n\nconst now = DateTime.unsafeMake({ year: 2024 })\nconst year = DateTime.getPartUtc(now, \"year\")\nassert.strictEqual(year, 2024)\n```"
    ],
    "since": "3.6.0",
    "category": "parts",
    "signature": "declare const getPartUtc: { (part: keyof DateTime.PartsWithWeekday): (self: DateTime) => number; (self: DateTime, part: keyof DateTime.PartsWithWeekday): number; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L932"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "getPart",
    "description": "Get a part of a `DateTime` as a number.\n\nThe part will be time zone adjusted.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { DateTime } from \"effect\"\n\nconst now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: \"Europe/London\" })\nconst year = DateTime.getPart(now, \"year\")\nassert.strictEqual(year, 2024)\n```"
    ],
    "since": "3.6.0",
    "category": "parts",
    "signature": "declare const getPart: { (part: keyof DateTime.PartsWithWeekday): (self: DateTime) => number; (self: DateTime, part: keyof DateTime.PartsWithWeekday): number; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L954"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "setParts",
    "description": "Set the different parts of a `DateTime` as an object.\n\nThe Date will be time zone adjusted.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "parts",
    "signature": "declare const setParts: { (parts: Partial<DateTime.PartsWithWeekday>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsWithWeekday>): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L967"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "setPartsUtc",
    "description": "Set the different parts of a `DateTime` as an object.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "parts",
    "signature": "declare const setPartsUtc: { (parts: Partial<DateTime.PartsWithWeekday>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsWithWeekday>): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L978"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "withCurrentZone",
    "description": "Provide the `CurrentTimeZone` to an effect.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nconst zone = DateTime.zoneUnsafeMakeNamed(\"Europe/London\")\n\nEffect.gen(function* () {\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZone(zone))\n```"
    ],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "declare const withCurrentZone: { (zone: TimeZone): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, zone: TimeZone): Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1030"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "withCurrentZoneOffset",
    "description": "Provide the `CurrentTimeZone` to an effect, using a offset.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  // will use the system's local time zone\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZoneOffset(3 * 60 * 60 * 1000))\n```"
    ],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "declare const withCurrentZoneOffset: { (offset: number): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, offset: number): Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1079"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "withCurrentZoneNamed",
    "description": "Provide the `CurrentTimeZone` to an effect using an IANA time zone\nidentifier.\n\nIf the time zone is invalid, it will fail with an `IllegalArgumentException`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  // will use the \"Europe/London\" time zone\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZoneNamed(\"Europe/London\"))\n```"
    ],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "declare const withCurrentZoneNamed: { (zone: string): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E | IllegalArgumentException, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, zone: string): Effect.Effect<A, E | IllegalArgumentException, Exclude<R, CurrentTimeZone>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1108"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "nowInCurrentZone",
    "description": "Get the current time as a `DateTime.Zoned`, using the `CurrentTimeZone`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  // will use the \"Europe/London\" time zone\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZoneNamed(\"Europe/London\"))\n```"
    ],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "declare const nowInCurrentZone: Effect.Effect<Zoned, never, CurrentTimeZone>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1140"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "mutate",
    "description": "Modify a `DateTime` by applying a function to a cloned `Date` instance.\n\nThe `Date` will first have the time zone applied if possible, and then be\nconverted back to a `DateTime` within the same time zone.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "mapping",
    "signature": "declare const mutate: { (f: (date: Date) => void): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (date: Date) => void): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1155"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "mutateUtc",
    "description": "Modify a `DateTime` by applying a function to a cloned UTC `Date` instance.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "mapping",
    "signature": "declare const mutateUtc: { (f: (date: Date) => void): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (date: Date) => void): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1166"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "mapEpochMillis",
    "description": "Transform a `DateTime` by applying a function to the number of milliseconds\nsince the Unix epoch.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\n// add 10 milliseconds\nDateTime.unsafeMake(0).pipe(\n  DateTime.mapEpochMillis((millis) => millis + 10)\n)\n```"
    ],
    "since": "3.6.0",
    "category": "mapping",
    "signature": "declare const mapEpochMillis: { (f: (millis: number) => number): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (millis: number) => number): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1187"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "withDate",
    "description": "Using the time zone adjusted `Date`, apply a function to the `Date` and\nreturn the result.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\n// get the time zone adjusted date in milliseconds\nDateTime.unsafeMakeZoned(0, { timeZone: \"Europe/London\" }).pipe(\n  DateTime.withDate((date) => date.getTime())\n)\n```"
    ],
    "since": "3.6.0",
    "category": "mapping",
    "signature": "declare const withDate: { <A>(f: (date: Date) => A): (self: DateTime) => A; <A>(self: DateTime, f: (date: Date) => A): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1208"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "withDateUtc",
    "description": "Using the time zone adjusted `Date`, apply a function to the `Date` and\nreturn the result.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\n// get the date in milliseconds\nDateTime.unsafeMake(0).pipe(\n  DateTime.withDateUtc((date) => date.getTime())\n)\n```"
    ],
    "since": "3.6.0",
    "category": "mapping",
    "signature": "declare const withDateUtc: { <A>(f: (date: Date) => A): (self: DateTime) => A; <A>(self: DateTime, f: (date: Date) => A): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1229"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "match",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "mapping",
    "signature": "declare const match: { <A, B>(options: { readonly onUtc: (_: Utc) => A; readonly onZoned: (_: Zoned) => B; }): (self: DateTime) => A | B; <A, B>(self: DateTime, options: { readonly onUtc: (_: Utc) => A; readonly onZoned: (_: Zoned) => B; }): A | B; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1238"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "addDuration",
    "description": "Add the given `Duration` to a `DateTime`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\n// add 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.addDuration(\"5 minutes\")\n)\n```"
    ],
    "since": "3.6.0",
    "category": "math",
    "signature": "declare const addDuration: { (duration: Duration.DurationInput): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, duration: Duration.DurationInput): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1268"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "subtractDuration",
    "description": "Subtract the given `Duration` from a `DateTime`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\n// subtract 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.subtractDuration(\"5 minutes\")\n)\n```"
    ],
    "since": "3.6.0",
    "category": "math",
    "signature": "declare const subtractDuration: { (duration: Duration.DurationInput): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, duration: Duration.DurationInput): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1288"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "add",
    "description": "Add the given `amount` of `unit`'s to a `DateTime`.\n\nThe time zone is taken into account when adding days, weeks, months, and\nyears.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\n// add 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.add({ minutes: 5 })\n)\n```"
    ],
    "since": "3.6.0",
    "category": "math",
    "signature": "declare const add: { (parts: Partial<DateTime.PartsForMath>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsForMath>): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1311"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "subtract",
    "description": "Subtract the given `amount` of `unit`'s from a `DateTime`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\n// subtract 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.subtract({ minutes: 5 })\n)\n```"
    ],
    "since": "3.6.0",
    "category": "math",
    "signature": "declare const subtract: { (parts: Partial<DateTime.PartsForMath>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsForMath>): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1331"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "startOf",
    "description": "Converts a `DateTime` to the start of the given `part`.\n\nIf the part is `week`, the `weekStartsOn` option can be used to specify the\nday of the week that the week starts on. The default is 0 (Sunday).",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\n// returns \"2024-01-01T00:00:00Z\"\nDateTime.unsafeMake(\"2024-01-01T12:00:00Z\").pipe(\n  DateTime.startOf(\"day\"),\n  DateTime.formatIso\n)\n```"
    ],
    "since": "3.6.0",
    "category": "math",
    "signature": "declare const startOf: { (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1355"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "endOf",
    "description": "Converts a `DateTime` to the end of the given `part`.\n\nIf the part is `week`, the `weekStartsOn` option can be used to specify the\nday of the week that the week starts on. The default is 0 (Sunday).",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\n// returns \"2024-01-01T23:59:59.999Z\"\nDateTime.unsafeMake(\"2024-01-01T12:00:00Z\").pipe(\n  DateTime.endOf(\"day\"),\n  DateTime.formatIso\n)\n```"
    ],
    "since": "3.6.0",
    "category": "math",
    "signature": "declare const endOf: { (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1386"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "nearest",
    "description": "Converts a `DateTime` to the nearest given `part`.\n\nIf the part is `week`, the `weekStartsOn` option can be used to specify the\nday of the week that the week starts on. The default is 0 (Sunday).",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime } from \"effect\"\n\n// returns \"2024-01-02T00:00:00Z\"\nDateTime.unsafeMake(\"2024-01-01T12:01:00Z\").pipe(\n  DateTime.nearest(\"day\"),\n  DateTime.formatIso\n)\n```"
    ],
    "since": "3.6.0",
    "category": "math",
    "signature": "declare const nearest: { (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1417"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "format",
    "description": "Format a `DateTime` as a string using the `DateTimeFormat` API.\n\nThe `timeZone` option is set to the offset of the time zone.\n\nNote: On Node versions < 22, fixed \"Offset\" zones will set the time zone to\n\"UTC\" and use the adjusted `Date`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "declare const format: { (options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): (self: DateTime) => string; (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): string; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1444"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "formatLocal",
    "description": "Format a `DateTime` as a string using the `DateTimeFormat` API.\n\nIt will use the system's local time zone & locale.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "declare const formatLocal: { (options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): (self: DateTime) => string; (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): string; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1470"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "formatUtc",
    "description": "Format a `DateTime` as a string using the `DateTimeFormat` API.\n\nThis forces the time zone to be UTC.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "declare const formatUtc: { (options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): (self: DateTime) => string; (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): string; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1496"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "formatIntl",
    "description": "Format a `DateTime` as a string using the `DateTimeFormat` API.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "declare const formatIntl: { (format: Intl.DateTimeFormat): (self: DateTime) => string; (self: DateTime, format: Intl.DateTimeFormat): string; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1520"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "formatIso",
    "description": "Format a `DateTime` as a UTC ISO string.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "declare const formatIso: (self: DateTime) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1531"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "formatIsoDate",
    "description": "Format a `DateTime` as a time zone adjusted ISO date string.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "declare const formatIsoDate: (self: DateTime) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1539"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "formatIsoDateUtc",
    "description": "Format a `DateTime` as a UTC ISO date string.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "declare const formatIsoDateUtc: (self: DateTime) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1547"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "formatIsoOffset",
    "description": "Format a `DateTime.Zoned` as a ISO string with an offset.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "declare const formatIsoOffset: (self: DateTime) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1555"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "formatIsoZoned",
    "description": "Format a `DateTime.Zoned` as a string.\n\nIt uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "declare const formatIsoZoned: (self: Zoned) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1565"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "layerCurrentZoneLocal",
    "description": "Create a Layer from the systems local time zone.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "declare const layerCurrentZoneLocal: Layer.Layer<CurrentTimeZone, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1601"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "setZoneCurrent",
    "description": "Set the time zone of a `DateTime` to the current time zone, which is\ndetermined by the `CurrentTimeZone` service.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n\n  // set the time zone to \"Europe/London\"\n  const zoned = yield* DateTime.setZoneCurrent(now)\n}).pipe(DateTime.withCurrentZoneNamed(\"Europe/London\"))\n```"
    ],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "declare const setZoneCurrent: (self: DateTime) => Effect.Effect<Zoned, never, CurrentTimeZone>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1011"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "withCurrentZoneLocal",
    "description": "Provide the `CurrentTimeZone` to an effect, using the system's local time\nzone.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  // will use the system's local time zone\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZoneLocal)\n```"
    ],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "declare const withCurrentZoneLocal: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1059"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "layerCurrentZone",
    "description": "Create a Layer from the given time zone.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "declare const layerCurrentZone: (zone: TimeZone) => Layer.Layer<CurrentTimeZone>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1573"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "layerCurrentZoneOffset",
    "description": "Create a Layer from the given time zone offset.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "declare const layerCurrentZoneOffset: (offset: number) => Layer.Layer<CurrentTimeZone>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1581"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "layerCurrentZoneNamed",
    "description": "Create a Layer from the given IANA time zone identifier.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "declare const layerCurrentZoneNamed: (zoneId: string) => Layer.Layer<CurrentTimeZone, IllegalArgumentException>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L1590"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "Utc",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export interface Utc extends DateTime.Proto {\n  readonly _tag: \"Utc\"\n  readonly epochMillis: number\n  partsUtc: DateTime.PartsWithWeekday | undefined\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L43"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "Zoned",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export interface Zoned extends DateTime.Proto {\n  readonly _tag: \"Zoned\"\n  readonly epochMillis: number\n  readonly zone: TimeZone\n  adjustedEpochMillis: number | undefined\n  partsAdjusted: DateTime.PartsWithWeekday | undefined\n  partsUtc: DateTime.PartsWithWeekday | undefined\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L53"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "type ids",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L28"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "DateTime",
    "description": "A `DateTime` represents a point in time. It can optionally have a time zone\nassociated with it.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "type DateTime = Utc | Zoned",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L37"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "TimeZoneTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "type ids",
    "signature": "type TimeZoneTypeId = typeof TimeZoneTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L176"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "TimeZone",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "type TimeZone = TimeZone.Offset | TimeZone.Named",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L182"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "DateTime.PartsWithWeekday",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export interface PartsWithWeekday {\n    readonly millis: number\n    readonly seconds: number\n    readonly minutes: number\n    readonly hours: number\n    readonly day: number\n    readonly weekDay: number\n    readonly month: number\n    readonly year: number\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L117"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "DateTime.Parts",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export interface Parts {\n    readonly millis: number\n    readonly seconds: number\n    readonly minutes: number\n    readonly hours: number\n    readonly day: number\n    readonly month: number\n    readonly year: number\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L132"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "DateTime.PartsForMath",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export interface PartsForMath {\n    readonly millis: number\n    readonly seconds: number\n    readonly minutes: number\n    readonly hours: number\n    readonly days: number\n    readonly weeks: number\n    readonly months: number\n    readonly years: number\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L146"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "DateTime.Proto",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export interface Proto extends Pipeable, Inspectable {\n    readonly [TypeId]: TypeId\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L161"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "DateTime.Input",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "type Input = DateTime | Partial<Parts> | Date | number | string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L71"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "DateTime.PreserveZone",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "type PreserveZone<A> = A extends Zoned ? Zoned : Utc",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L77"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "DateTime.Unit",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "type Unit = UnitSingular | UnitPlural",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L83"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "DateTime.UnitSingular",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "type UnitSingular = | \"milli\"\n    | \"second\"\n    | \"minute\"\n    | \"hour\"\n    | \"day\"\n    | \"week\"\n    | \"month\"\n    | \"year\"",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L89"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "DateTime.UnitPlural",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "type UnitPlural = | \"millis\"\n    | \"seconds\"\n    | \"minutes\"\n    | \"hours\"\n    | \"days\"\n    | \"weeks\"\n    | \"months\"\n    | \"years\"",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L103"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "TimeZone.Proto",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export interface Proto extends Inspectable {\n    readonly [TimeZoneTypeId]: TimeZoneTypeId\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L193"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "TimeZone.Offset",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export interface Offset extends Proto {\n    readonly _tag: \"Offset\"\n    readonly offset: number\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L201"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "DateTime.ts",
      "path": "src/DateTime.ts"
    },
    "project": "effect",
    "name": "TimeZone.Named",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export interface Named extends Proto {\n    readonly _tag: \"Named\"\n    readonly id: string\n    /** @internal */\n    readonly format: Intl.DateTimeFormat\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DateTime.ts#L210"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DefaultServices.ts",
      "path": "src/DefaultServices.ts"
    },
    "project": "effect",
    "name": "liveServices",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const liveServices: Context.Context<DefaultServices>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DefaultServices.ts#L28"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DefaultServices.ts",
      "path": "src/DefaultServices.ts"
    },
    "project": "effect",
    "name": "currentServices",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentServices: FiberRef.FiberRef<Context.Context<DefaultServices>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DefaultServices.ts#L34"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DefaultServices.ts",
      "path": "src/DefaultServices.ts"
    },
    "project": "effect",
    "name": "DefaultServices",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type DefaultServices = | Clock.Clock\n  | Console.Console\n  | Random.Random\n  | ConfigProvider.ConfigProvider\n  | Tracer.Tracer",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/DefaultServices.ts#L17"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "DeferredTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const DeferredTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L20"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A, E = never>() => Effect.Effect<Deferred<A, E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L88"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "makeAs",
    "description": "Creates a new `Deferred` from the specified `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeAs: <A, E = never>(fiberId: FiberId.FiberId) => Effect.Effect<Deferred<A, E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L96"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "complete",
    "description": "Completes the deferred with the result of the specified effect. If the\ndeferred has already been completed, the method will produce false.\n\nNote that `Deferred.completeWith` will be much faster, so consider using\nthat if you do not need to memoize the result of the specified effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const complete: { <A, E>(effect: Effect.Effect<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L121"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "completeWith",
    "description": "Completes the deferred with the result of the specified effect. If the\ndeferred has already been completed, the method will produce false.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const completeWith: { <A, E>(effect: Effect.Effect<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L133"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "done",
    "description": "Exits the `Deferred` with the specified `Exit` value, which will be\npropagated to all fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const done: { <A, E>(exit: Exit.Exit<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, exit: Exit.Exit<A, E>): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L145"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "fail",
    "description": "Fails the `Deferred` with the specified error, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const fail: { <E>(error: E): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, error: E): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L157"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "failSync",
    "description": "Fails the `Deferred` with the specified error, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const failSync: { <E>(evaluate: LazyArg<E>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<E>): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L169"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "failCause",
    "description": "Fails the `Deferred` with the specified `Cause`, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const failCause: { <E>(cause: Cause.Cause<E>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, cause: Cause.Cause<E>): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L181"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "failCauseSync",
    "description": "Fails the `Deferred` with the specified `Cause`, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const failCauseSync: { <E>(evaluate: LazyArg<Cause.Cause<E>>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<Cause.Cause<E>>): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L193"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "die",
    "description": "Kills the `Deferred` with the specified defect, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const die: { (defect: unknown): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, defect: unknown): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L205"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "dieSync",
    "description": "Kills the `Deferred` with the specified defect, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const dieSync: { (evaluate: LazyArg<unknown>): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<unknown>): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L217"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "interrupt",
    "description": "Completes the `Deferred` with interruption. This will interrupt all fibers\nwaiting on the value of the `Deferred` with the `FiberId` of the fiber\ncalling this method.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const interrupt: <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L230"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "interruptWith",
    "description": "Completes the `Deferred` with interruption. This will interrupt all fibers\nwaiting on the value of the `Deferred` with the specified `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const interruptWith: { (fiberId: FiberId.FiberId): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, fiberId: FiberId.FiberId): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L239"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "isDone",
    "description": "Returns `true` if this `Deferred` has already been completed with a value or\nan error, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isDone: <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L251"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "poll",
    "description": "Returns a `Some<Effect<A, E, R>>` from the `Deferred` if this `Deferred` has\nalready been completed, `None` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const poll: <A, E>(self: Deferred<A, E>) => Effect.Effect<Option.Option<Effect.Effect<A, E>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L260"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "succeed",
    "description": "Completes the `Deferred` with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const succeed: { <A>(value: A): <E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, value: A): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L270"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "sync",
    "description": "Completes the `Deferred` with the specified lazily evaluated value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const sync: { <A>(evaluate: LazyArg<A>): <E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<A>): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L281"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "unsafeMake",
    "description": "Unsafely creates a new `Deferred` from the specified `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeMake: <A, E = never>(fiberId: FiberId.FiberId) => Deferred<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L292"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "unsafeDone",
    "description": "Unsafely exits the `Deferred` with the specified `Exit` value, which will be\npropagated to all fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeDone: <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>) => void",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L301"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "Deferred",
    "description": "A `Deferred` represents an asynchronous variable that can be set exactly\nonce, with the ability for an arbitrary number of fibers to suspend (by\ncalling `Deferred.await`) and automatically resume when the variable is set.\n\n`Deferred` can be used for building primitive actions whose completions\nrequire the coordinated action of multiple fibers, and for building\nhigher-level concurrent or asynchronous structures.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Deferred<in out A, in out E = never> extends Effect.Effect<A, E>, Deferred.Variance<A, E> {\n  /** @internal */\n  readonly state: MutableRef.MutableRef<internal.State<A, E>>\n  /** @internal */\n  readonly blockingOn: FiberId.FiberId\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: DeferredUnify<this>\n  readonly [Unify.ignoreSymbol]?: DeferredUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L40"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "DeferredUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface DeferredUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Deferred?: () => Extract<A[Unify.typeSymbol], Deferred<any, any>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L54"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "DeferredUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface DeferredUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L62"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "DeferredTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type DeferredTypeId = typeof DeferredTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L26"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Deferred.ts",
      "path": "src/Deferred.ts"
    },
    "project": "effect",
    "name": "Deferred.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out A, in out E> {\n    readonly [DeferredTypeId]: {\n      readonly _A: Types.Invariant<A>\n      readonly _E: Types.Invariant<E>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Deferred.ts#L74"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L25"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "diff",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "patch",
    "signature": "declare const diff: { <Value>(oldValue: Value, newValue: Value): <Patch>(self: Differ<Value, Patch>) => Patch; <Value, Patch>(self: Differ<Value, Patch>, oldValue: Value, newValue: Value): Patch; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L232"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "combine",
    "description": "Combines two patches to produce a new patch that describes the updates of\nthe first patch and then the updates of the second patch. The combine\noperation should be associative. In addition, if the combine operation is\ncommutative then joining multiple fibers concurrently will result in\ndeterministic `FiberRef` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "patch",
    "signature": "declare const combine: { <Patch>(first: Patch, second: Patch): <Value>(self: Differ<Value, Patch>) => Patch; <Value, Patch>(self: Differ<Value, Patch>, first: Patch, second: Patch): Patch; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L260"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "patch",
    "description": "Applies a patch to an old value to produce a new value that is equal to the\nold value with the updates described by the patch.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "patch",
    "signature": "declare const patch: { <Patch, Value>(patch: Patch, oldValue: Value): (self: Differ<Value, Patch>) => Value; <Patch, Value>(self: Differ<Value, Patch>, patch: Patch, oldValue: Value): Value; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L285"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new `Differ`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Value, Patch>(params: { readonly empty: Patch; readonly diff: (oldValue: Value, newValue: Value) => Patch; readonly combine: (first: Patch, second: Patch) => Patch; readonly patch: (patch: Patch, oldValue: Value) => Value; }) => Differ<Value, Patch>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L309"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "environment",
    "description": "Constructs a differ that knows how to diff `Env` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const environment: <A>() => Differ<Context<A>, Differ.Context.Patch<A, A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L322"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "chunk",
    "description": "Constructs a differ that knows how to diff a `Chunk` of values given a\ndiffer that knows how to diff the values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const chunk: <Value, Patch>(differ: Differ<Value, Patch>) => Differ<Chunk<Value>, Differ.Chunk.Patch<Value, Patch>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L334"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "hashMap",
    "description": "Constructs a differ that knows how to diff a `HashMap` of keys and values given\na differ that knows how to diff the values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const hashMap: <Key, Value, Patch>(differ: Differ<Value, Patch>) => Differ<HashMap<Key, Value>, Differ.HashMap.Patch<Key, Value, Patch>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L345"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "hashSet",
    "description": "Constructs a differ that knows how to diff a `HashSet` of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const hashSet: <Value>() => Differ<HashSet<Value>, Differ.HashSet.Patch<Value>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L355"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "orElseEither",
    "description": "Combines this differ and the specified differ to produce a differ that\nknows how to diff the sum of their values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const orElseEither: { <Value2, Patch2>(that: Differ<Value2, Patch2>): <Value, Patch>(self: Differ<Value, Patch>) => Differ<Either<Value2, Value>, Differ.Or.Patch<Value, Value2, Patch, Patch2>>; <Value, Patch, Value2, Patch2>(self: Differ<Value, Patch>, that: Differ<Value2, Patch2>): Differ<Either<Value2, Value>, Differ.Or.Patch<Value, Value2, Patch, Patch2>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L366"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "readonlyArray",
    "description": "Constructs a differ that knows how to diff a `ReadonlyArray` of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const readonlyArray: <Value, Patch>(differ: Differ<Value, Patch>) => Differ<ReadonlyArray<Value>, Differ.ReadonlyArray.Patch<Value, Patch>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L388"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "transform",
    "description": "Transforms the type of values that this differ knows how to differ using\nthe specified functions that map the new and old value types to each other.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const transform: { <Value, Value2>(options: { readonly toNew: (value: Value) => Value2; readonly toOld: (value: Value2) => Value; }): <Patch>(self: Differ<Value, Patch>) => Differ<Value2, Patch>; <Value, Patch, Value2>(self: Differ<Value, Patch>, options: { readonly toNew: (value: Value) => Value2; readonly toOld: (value: Value2) => Value; }): Differ<Value2, Patch>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L398"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "update",
    "description": "Constructs a differ that just diffs two values by returning a function that\nsets the value to the new value. This differ does not support combining\nmultiple updates to the value compositionally and should only be used when\nthere is no compositional way to update them.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const update: <A>() => Differ<A, (a: A) => A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L420"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "updateWith",
    "description": "A variant of `update` that allows specifying the function that will be used\nto combine old values with new values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const updateWith: <A>(f: (x: A, y: A) => A) => Differ<A, (a: A) => A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L428"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Combines this differ and the specified differ to produce a new differ that\nknows how to diff the product of their values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const zip: { <Value2, Patch2>(that: Differ<Value2, Patch2>): <Value, Patch>(self: Differ<Value, Patch>) => Differ<readonly [Value, Value2], readonly [Patch, Patch2]>; <Value, Patch, Value2, Patch2>(self: Differ<Value, Patch>, that: Differ<Value2, Patch2>): Differ<readonly [Value, Value2], readonly [Patch, Patch2]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L436"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "An empty patch that describes no changes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "patch",
    "signature": "declare const empty: <Value, Patch>(self: Differ<Value, Patch>) => Patch",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L224"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "Differ",
    "description": "A `Differ<Value, Patch>` knows how to compare an old value and new value of\ntype `Value` to produce a patch of type `Patch` that describes the\ndifferences between those values. A `Differ` also knows how to apply a patch\nto an old value to produce a new value that represents the old value updated\nwith the changes described by the patch.\n\nA `Differ` can be used to construct a `FiberRef` supporting compositional\nupdates using the `FiberRef.makePatch` constructor.\n\nThe `Differ` companion object contains constructors for `Differ` values for\ncommon data types such as `Chunk`, `HashMap`, and `HashSet``. In addition,\n`Differ`values can be transformed using the `transform` operator and combined\nusing the `orElseEither` and `zip` operators. This allows creating `Differ`\nvalues for arbitrarily complex data types compositionally.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Differ<in out Value, in out Patch> extends Pipeable {\n  readonly [TypeId]: {\n    readonly _V: Types.Invariant<Value>\n    readonly _P: Types.Invariant<Patch>\n  }\n  readonly empty: Patch\n  diff(oldValue: Value, newValue: Value): Patch\n  combine(first: Patch, second: Patch): Patch\n  patch(patch: Patch, oldValue: Value): Value\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L52"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Differ.ts",
      "path": "src/Differ.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Differ.ts#L31"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "decodeUnknown",
    "deprecated": false,
    "examples": [],
    "since": "2.5.0",
    "category": null,
    "signature": "declare const decodeUnknown: (u: unknown) => Option.Option<Duration>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L150"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "zero",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const zero: Duration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L238"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "infinity",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const infinity: Duration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L244"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "match",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "declare const match: { <A, B>(options: { readonly onMillis: (millis: number) => A; readonly onNanos: (nanos: bigint) => B; }): (self: DurationInput) => A | B; <A, B>(self: DurationInput, options: { readonly onMillis: (millis: number) => A; readonly onNanos: (nanos: bigint) => B; }): A | B; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L420"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "matchWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "declare const matchWith: { <A, B>(that: DurationInput, options: { readonly onMillis: (self: number, that: number) => A; readonly onNanos: (self: bigint, that: bigint) => B; }): (self: DurationInput) => A | B; <A, B>(self: DurationInput, that: DurationInput, options: { readonly onMillis: (self: number, that: number) => A; readonly onNanos: (self: bigint, that: bigint) => B; }): A | B; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L456"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "Order",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Order: order.Order<Duration>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L507"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "between",
    "description": "Checks if a `Duration` is between a `minimum` and `maximum` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const between: { (options: { minimum: DurationInput; maximum: DurationInput; }): (self: DurationInput) => boolean; (self: DurationInput, options: { minimum: DurationInput; maximum: DurationInput; }): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L520"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "min",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const min: { (that: DurationInput): (self: DurationInput) => Duration; (self: DurationInput, that: DurationInput): Duration; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L546"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "max",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "order",
    "signature": "declare const max: { (that: DurationInput): (self: DurationInput) => Duration; (self: DurationInput, that: DurationInput): Duration; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L557"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "clamp",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "order",
    "signature": "declare const clamp: { (options: { minimum: DurationInput; maximum: DurationInput; }): (self: DurationInput) => Duration; (self: DurationInput, options: { minimum: DurationInput; maximum: DurationInput; }): Duration; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L568"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "divide",
    "deprecated": false,
    "examples": [],
    "since": "2.4.19",
    "category": "math",
    "signature": "declare const divide: { (by: number): (self: DurationInput) => Option.Option<Duration>; (self: DurationInput, by: number): Option.Option<Duration>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L593"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "unsafeDivide",
    "deprecated": false,
    "examples": [],
    "since": "2.4.19",
    "category": "math",
    "signature": "declare const unsafeDivide: { (by: number): (self: DurationInput) => Duration; (self: DurationInput, by: number): Duration; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L623"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "times",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const times: { (times: number): (self: DurationInput) => Duration; (self: DurationInput, times: number): Duration; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L646"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "subtract",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const subtract: { (that: DurationInput): (self: DurationInput) => Duration; (self: DurationInput, that: DurationInput): Duration; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L662"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "sum",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const sum: { (that: DurationInput): (self: DurationInput) => Duration; (self: DurationInput, that: DurationInput): Duration; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L678"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "lessThan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const lessThan: { (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L694"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "lessThanOrEqualTo",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const lessThanOrEqualTo: { (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L710"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "greaterThan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const greaterThan: { (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L726"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "greaterThanOrEqualTo",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const greaterThanOrEqualTo: { (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L742"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "equals",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const equals: { (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L758"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "decode",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const decode: (input: DurationInput) => Duration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L94"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "isDuration",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isDuration: (u: unknown) => u is Duration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L208"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "isFinite",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isFinite: (self: Duration) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L214"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "isZero",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "guards",
    "signature": "declare const isZero: (self: Duration) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L220"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "nanos",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const nanos: (nanos: bigint) => Duration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L250"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "micros",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const micros: (micros: bigint) => Duration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L256"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "millis",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const millis: (millis: number) => Duration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L262"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "seconds",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const seconds: (seconds: number) => Duration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L268"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "minutes",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const minutes: (minutes: number) => Duration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L274"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "hours",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const hours: (hours: number) => Duration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L280"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "days",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const days: (days: number) => Duration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L286"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "weeks",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const weeks: (weeks: number) => Duration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L292"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "toMillis",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const toMillis: (self: DurationInput) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L298"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "toSeconds",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const toSeconds: (self: DurationInput) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L308"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "toMinutes",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "getters",
    "signature": "declare const toMinutes: (self: DurationInput) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L318"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "toHours",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "getters",
    "signature": "declare const toHours: (self: DurationInput) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L328"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "toDays",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "getters",
    "signature": "declare const toDays: (self: DurationInput) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L338"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "toWeeks",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "getters",
    "signature": "declare const toWeeks: (self: DurationInput) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L348"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "toNanos",
    "description": "Get the duration in nanoseconds as a bigint.\n\nIf the duration is infinite, returns `Option.none()`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const toNanos: (self: DurationInput) => Option.Option<bigint>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L362"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "unsafeToNanos",
    "description": "Get the duration in nanoseconds as a bigint.\n\nIf the duration is infinite, it throws an error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const unsafeToNanos: (self: DurationInput) => bigint",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L382"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "toHrTime",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const toHrTime: (self: DurationInput) => [seconds: number, nanos: number]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L398"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "Equivalence",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Equivalence: equivalence.Equivalence<Duration>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L535"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "parts",
    "description": "Converts a `Duration` to its parts.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "conversions",
    "signature": "declare const parts: (self: DurationInput) => { days: number; hours: number; minutes: number; seconds: number; millis: number; nanos: number; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L769"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "format",
    "description": "Converts a `Duration` to a human readable string.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Duration } from \"effect\"\n\nDuration.format(Duration.millis(1000)) // \"1s\"\nDuration.format(Duration.millis(1001)) // \"1s 1ms\"\n```"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const format: (self: DurationInput) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L819"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "unsafeFormatIso",
    "description": "Formats a Duration into an ISO8601 duration string.\n\nMonths are assumed to be 30 days and years are assumed to be 365 days.\n\nMilliseconds and nanoseconds are expressed as fractional seconds.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Duration } from \"effect\"\n\nDuration.unsafeFormatIso(Duration.days(1)) // => \"P1D\"\nDuration.unsafeFormatIso(Duration.minutes(90)) // => \"PT1H30M\"\nDuration.unsafeFormatIso(Duration.millis(1500)) // => \"PT1.5S\"\n```"
    ],
    "since": "3.13.0",
    "category": "conversions",
    "signature": "declare const unsafeFormatIso: (self: DurationInput) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L878"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "formatIso",
    "description": "Formats a Duration into an ISO8601 duration string.\n\nMonths are assumed to be 30 days and years are assumed to be 365 days.\n\nReturns `Option.none()` if the duration is infinite.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Duration, Option } from \"effect\"\n\nDuration.formatIso(Duration.days(1)) // => Option.some(\"P1D\")\nDuration.formatIso(Duration.minutes(90)) // => Option.some(\"PT1H30M\")\nDuration.formatIso(Duration.millis(1500)) // => Option.some(\"PT1.5S\")\nDuration.formatIso(Duration.infinity) // => Option.none()\n```"
    ],
    "since": "3.13.0",
    "category": "conversions",
    "signature": "declare const formatIso: (self: DurationInput) => Option.Option<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L958"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "fromIso",
    "description": "Parses an ISO8601 duration string into a `Duration`.\n\nMonths are assumed to be 30 days and years are assumed to be 365 days.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Duration, Option } from \"effect\"\n\nDuration.fromIso(\"P1D\") // => Option.some(Duration.days(1))\nDuration.fromIso(\"PT1H\") // => Option.some(Duration.hours(1))\nDuration.fromIso(\"PT1M\") // => Option.some(Duration.minutes(1))\nDuration.fromIso(\"PT1.5S\") // => Option.some(Duration.seconds(1.5))\n```"
    ],
    "since": "3.13.0",
    "category": "conversions",
    "signature": "declare const fromIso: (iso: string) => Option.Option<Duration>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L981"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "Duration",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Duration extends Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly value: DurationValue\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L35"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L29"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "DurationValue",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type DurationValue = | {\n    readonly _tag: \"Millis\"\n    readonly millis: number\n  }\n  | {\n    readonly _tag: \"Nanos\"\n    readonly nanos: bigint\n  }\n  | {\n    readonly _tag: \"Infinity\"\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L43"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "Unit",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Unit = | \"nano\"\n  | \"nanos\"\n  | \"micro\"\n  | \"micros\"\n  | \"milli\"\n  | \"millis\"\n  | \"second\"\n  | \"seconds\"\n  | \"minute\"\n  | \"minutes\"\n  | \"hour\"\n  | \"hours\"\n  | \"day\"\n  | \"days\"\n  | \"week\"\n  | \"weeks\"",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L60"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Duration.ts",
      "path": "src/Duration.ts"
    },
    "project": "effect",
    "name": "DurationInput",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type DurationInput = | Duration\n  | number // millis\n  | bigint // nanos\n  | readonly [seconds: number, nanos: number]\n  | `${number} ${Unit}`",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Duration.ts#L82"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "EffectTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "declare const EffectTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L71"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "isEffect",
    "description": "Checks if a given value is an `Effect` value.\n\n**When to Use**\n\nThis function can be useful for checking the type of a value before\nattempting to operate on it as an `Effect` value. For example, you could use\n`Effect.isEffect` to check the type of a value before using it as an argument\nto a function that expects an `Effect` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isEffect: (u: unknown) => u is Effect<unknown, unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L263"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "cachedWithTTL",
    "description": "Returns an effect that caches its result for a specified `Duration`,\nknown as \"timeToLive\" (TTL).\n\n**Details**\n\nThis function is used to cache the result of an effect for a specified amount\nof time. This means that the first time the effect is evaluated, its result\nis computed and stored.\n\nIf the effect is evaluated again within the specified `timeToLive`, the\ncached result will be used, avoiding recomputation.\n\nAfter the specified duration has passed, the cache expires, and the effect\nwill be recomputed upon the next evaluation.\n\n**When to Use**\n\nUse this function when you have an effect that involves costly operations or\ncomputations, and you want to avoid repeating them within a short time frame.\n\nIt's ideal for scenarios where the result of an effect doesn't change\nfrequently and can be reused for a specified duration.\n\nBy caching the result, you can improve efficiency and reduce unnecessary\ncomputations, especially in performance-critical applications.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log(\"expensive task...\")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  const cached = yield* Effect.cachedWithTTL(expensiveTask, \"150 millis\")\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* Effect.sleep(\"100 millis\")\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// expensive task...\n// result 1\n// result 1\n// expensive task...\n// result 2\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Caching",
    "signature": "declare const cachedWithTTL: { (timeToLive: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E>, never, R>; <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.DurationInput): Effect<Effect<A, E>, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L332"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "cachedInvalidateWithTTL",
    "description": "Caches an effect's result for a specified duration and allows manual\ninvalidation before expiration.\n\n**Details**\n\nThis function behaves similarly to {@link cachedWithTTL} by caching the\nresult of an effect for a specified period of time. However, it introduces an\nadditional feature: it provides an effect that allows you to manually\ninvalidate the cached result before it naturally expires.\n\nThis gives you more control over the cache, allowing you to refresh the\nresult when needed, even if the original cache has not yet expired.\n\nOnce the cache is invalidated, the next time the effect is evaluated, the\nresult will be recomputed, and the cache will be refreshed.\n\n**When to Use**\n\nUse this function when you have an effect whose result needs to be cached for\na certain period, but you also want the option to refresh the cache manually\nbefore the expiration time.\n\nThis is useful when you need to ensure that the cached data remains valid for\na certain period but still want to invalidate it if the underlying data\nchanges or if you want to force a recomputation.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log(\"expensive task...\")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(\n    expensiveTask,\n    \"1 hour\"\n  )\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* invalidate\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// expensive task...\n// result 1\n// result 1\n// expensive task...\n// result 2\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Caching",
    "signature": "declare const cachedInvalidateWithTTL: { (timeToLive: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<[Effect<A, E>, Effect<void>], never, R>; <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.DurationInput): Effect<[Effect<A, E>, Effect<void>], never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L407"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "cached",
    "description": "Returns an effect that lazily computes a result and caches it for subsequent\nevaluations.\n\n**Details**\n\nThis function wraps an effect and ensures that its result is computed only\nonce. Once the result is computed, it is cached, meaning that subsequent\nevaluations of the same effect will return the cached result without\nre-executing the logic.\n\n**When to Use**\n\nUse this function when you have an expensive or time-consuming operation that\nyou want to avoid repeating. The first evaluation will compute the result,\nand all following evaluations will immediately return the cached value,\nimproving performance and reducing unnecessary work.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log(\"expensive task...\")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  console.log(\"non-cached version:\")\n  yield* expensiveTask.pipe(Effect.andThen(Console.log))\n  yield* expensiveTask.pipe(Effect.andThen(Console.log))\n  console.log(\"cached version:\")\n  const cached = yield* Effect.cached(expensiveTask)\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// non-cached version:\n// expensive task...\n// result 1\n// expensive task...\n// result 2\n// cached version:\n// expensive task...\n// result 3\n// result 3\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Caching",
    "signature": "declare const cached: <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E, R>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L481"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "cachedFunction",
    "description": "Returns a memoized version of a function with effects, reusing results for\nthe same inputs.\n\n**Details**\n\nThis function creates a memoized version of a given function that performs an\neffect. Memoization ensures that once a result is computed for a specific\ninput, it is stored and reused for subsequent calls with the same input,\nreducing the need to recompute the result.\n\nThe function can optionally take an `Equivalence` parameter to\ndetermine how inputs are compared for caching purposes.\n\n**When to Use**\n\nUse this function when you have a function that performs an effect and you\nwant to avoid recomputing the result for the same input multiple times.\n\nIt's ideal for functions that produce deterministic results based on their\ninputs, and you want to improve performance by caching the output.\n\nThis is particularly useful in scenarios where the function involves\nexpensive calculations or operations that should be avoided after the first\nexecution with the same parameters.\n\n**Example**\n\n```ts\nimport { Effect, Random } from \"effect\"\n\nconst program = Effect.gen(function* () {\n  const randomNumber = (n: number) => Random.nextIntBetween(1, n)\n  console.log(\"non-memoized version:\")\n  console.log(yield* randomNumber(10))\n  console.log(yield* randomNumber(10))\n\n  console.log(\"memoized version:\")\n  const memoized = yield* Effect.cachedFunction(randomNumber)\n  console.log(yield* memoized(10))\n  console.log(yield* memoized(10))\n})\n\nEffect.runFork(program)\n// Example Output:\n// non-memoized version:\n// 2\n// 8\n// memoized version:\n// 5\n// 5\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Caching",
    "signature": "declare const cachedFunction: <A, B, E, R>(f: (a: A) => Effect<B, E, R>, eq?: Equivalence<A>) => Effect<(a: A) => Effect<B, E, R>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L539"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "once",
    "description": "Returns an effect that executes only once, regardless of how many times it's\ncalled.\n\n**Details**\n\nThis function ensures that a specific effect is executed only a single time,\nno matter how many times it is invoked. The result of the effect will be\ncached, and subsequent calls to the effect will immediately return the cached\nresult without re-executing the original logic.\n\n**When to Use**\n\nUse this function when you need to perform a task only once, regardless of\nhow many times the effect is triggered. It's particularly useful when you\nhave initialization tasks, logging, or other one-time actions that should not\nbe repeated. This can help optimize performance and avoid redundant actions.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst program = Effect.gen(function* () {\n  const task1 = Console.log(\"task1\")\n  yield* Effect.repeatN(task1, 2)\n  const task2 = yield* Effect.once(Console.log(\"task2\"))\n  yield* Effect.repeatN(task2, 2)\n})\n\nEffect.runFork(program)\n// Output:\n// task1\n// task1\n// task1\n// task2\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Caching",
    "signature": "declare const once: <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<void, E, R>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L585"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "all",
    "description": "Combines multiple effects into one, returning results based on the input\nstructure.\n\n**Details**\n\nUse this function when you need to run multiple effects and combine their\nresults into a single output. It supports tuples, iterables, structs, and\nrecords, making it flexible for different input types.\n\nFor instance, if the input is a tuple:\n\n```ts skip-type-checking\n//          a tuple of effects\n//         \nEffect.all([effect1, effect2, ...])\n```\n\nthe effects are executed sequentially, and the result is a new effect\ncontaining the results as a tuple. The results in the tuple match the order\nof the effects passed to `Effect.all`.\n\n**Concurrency**\n\nYou can control the execution order (e.g., sequential vs. concurrent) using\nthe `concurrency` option.\n\n**Short-Circuiting Behavior**\n\nThis function stops execution on the first error it encounters, this is\ncalled \"short-circuiting\". If any effect in the collection fails, the\nremaining effects will not run, and the error will be propagated. To change\nthis behavior, you can use the `mode` option, which allows all effects to run\nand collect results as `Either` or `Option`.\n\n**The `mode` option**\n\nThe `{ mode: \"either\" }` option changes the behavior of `Effect.all` to\nensure all effects run, even if some fail. Instead of stopping on the first\nfailure, this mode collects both successes and failures, returning an array\nof `Either` instances where each result is either a `Right` (success) or a\n`Left` (failure).\n\nSimilarly, the `{ mode: \"validate\" }` option uses `Option` to indicate\nsuccess or failure. Each effect returns `None` for success and `Some` with\nthe error for failure.\n\n**Example** (Combining Effects in Tuples)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst tupleOfEffects = [\n  Effect.succeed(42).pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n] as const\n\n//       Effect<[number, string], never, never>\n//      \nconst resultsAsTuple = Effect.all(tupleOfEffects)\n\nEffect.runPromise(resultsAsTuple).then(console.log)\n// Output:\n// 42\n// Hello\n// [ 42, 'Hello' ]\n```\n\n**Example** (Combining Effects in Iterables)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(\n  (n) => Effect.succeed(n).pipe(Effect.tap(Console.log))\n)\n\n//       Effect<number[], never, never>\n//      \nconst resultsAsArray = Effect.all(iterableOfEffects)\n\nEffect.runPromise(resultsAsArray).then(console.log)\n// Output:\n// 1\n// 2\n// 3\n// [ 1, 2, 3 ]\n```\n\n**Example** (Combining Effects in Structs)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst structOfEffects = {\n  a: Effect.succeed(42).pipe(Effect.tap(Console.log)),\n  b: Effect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n}\n\n//       Effect<{ a: number; b: string; }, never, never>\n//      \nconst resultsAsStruct = Effect.all(structOfEffects)\n\nEffect.runPromise(resultsAsStruct).then(console.log)\n// Output:\n// 42\n// Hello\n// { a: 42, b: 'Hello' }\n```\n\n**Example** (Combining Effects in Records)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst recordOfEffects: Record<string, Effect.Effect<number>> = {\n  key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),\n  key2: Effect.succeed(2).pipe(Effect.tap(Console.log))\n}\n\n//       Effect<{ [x: string]: number; }, never, never>\n//      \nconst resultsAsRecord = Effect.all(recordOfEffects)\n\nEffect.runPromise(resultsAsRecord).then(console.log)\n// Output:\n// 1\n// 2\n// { key1: 1, key2: 2 }\n```\n\n**Example** (Short-Circuiting Behavior)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst program = Effect.all([\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  // Won't execute due to earlier failure\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n])\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Task1\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }\n// }\n```\n\n**Example** (Collecting Results with `mode: \"either\"`)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst effects = [\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n]\n\nconst program = Effect.all(effects, { mode: \"either\" })\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Task1\n// Task3\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: [\n//     { _id: 'Either', _tag: 'Right', right: 'Task1' },\n//     { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },\n//     { _id: 'Either', _tag: 'Right', right: 'Task3' }\n//   ]\n// }\n```\n\n**Example** (Collecting Results with `mode: \"validate\"`)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst effects = [\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n]\n\nconst program = Effect.all(effects, { mode: \"validate\" })\n\nEffect.runPromiseExit(program).then((result) => console.log(\"%o\", result))\n// Output:\n// Task1\n// Task3\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: [\n//       { _id: 'Option', _tag: 'None' },\n//       { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },\n//       { _id: 'Option', _tag: 'None' }\n//     ]\n//   }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const all: <const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: boolean | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(arg: Arg, options?: O) => All.Return<Arg, O>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L806"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "allWith",
    "description": "A data-last version of {@link all}, designed for use in pipelines.\n\n**When to Use**\n\nThis function enables you to combine multiple effects and customize execution\noptions such as concurrency levels. This version is useful in functional\npipelines where you first define your data and then apply operations to it.\n\n**Example**\n\n```ts\nimport { Effect, pipe } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\n\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\nconst program = pipe(\n  [task1, task2],\n  // Run both effects concurrently using the concurrent option\n  Effect.allWith({ concurrency: 2 })\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#3 message=\"task2 done\"\n// timestamp=... level=INFO fiber=#2 message=\"task1 done\"\n// [ 1, 'hello' ]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const allWith: <O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: boolean | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(options?: O) => <const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>>(arg: Arg) => All.Return<Arg, O>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L857"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "allSuccesses",
    "description": "Evaluates and runs each effect in the iterable, collecting only the\nsuccessful results while discarding failures.\n\n**Details**\n\nThis function function processes an iterable of effects and runs each one. If\nan effect is successful, its result is collected; if it fails, the result is\ndiscarded. This ensures that only successful outcomes are kept.\n\n**Options**\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst tasks = [\n  Effect.succeed(1),\n  Effect.fail(\"Error 1\"),\n  Effect.succeed(2),\n  Effect.fail(\"Error 2\")\n]\n\nconst program = Effect.gen(function*() {\n  const successfulResults = yield* Effect.allSuccesses(tasks)\n  console.log(successfulResults)\n})\n\nEffect.runFork(program)\n// Output: [1, 2]\n\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const allSuccesses: <X extends Effect<any, any, any>>(elements: Iterable<X>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined) => Effect<Array<Effect.Success<X>>, never, Effect.Context<X>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1013"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "dropUntil",
    "description": "Drops elements until the effectful predicate returns `true`.\n\n**Details**\n\nThis function processes a collection of elements and uses an effectful\npredicate to determine when to stop dropping elements. It drops elements from\nthe beginning of the collection until the predicate returns `true`.\n\nThe predicate is a function that takes an element and its index in the\ncollection and returns an effect that evaluates to a boolean.\n\nOnce the predicate returns `true`, the remaining elements of the collection\nare returned.\n\n**Note**: The first element for which the predicate returns `true` is also\ndropped.\n\n**When to Use**\n\nThis function allows you to conditionally skip over a part of the collection\nbased on some criteria defined in the predicate.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.dropUntil(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [5, 6]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const dropUntil: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1070"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "dropWhile",
    "description": "Drops elements as long as the predicate returns `true`.\n\n**Details**\n\nThis function processes a collection of elements and uses a predicate to\ndecide whether to drop an element.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nAs long as the predicate returns `true`, elements will continue to be dropped\nfrom the collection.\n\nOnce the predicate returns `false`, the remaining elements are kept.\n\n**When to Use**\n\nThis function allows you to discard elements from the start of a collection\nbased on a condition, and only keep the rest when the condition no longer\nholds.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.dropWhile(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [4, 5, 6]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const dropWhile: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1122"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "takeUntil",
    "description": "Takes elements from a collection until the effectful predicate returns\n`true`.\n\n**Details**\n\nThis function processes a collection of elements and uses an effectful\npredicate to decide when to stop taking elements. The elements are taken from\nthe beginning of the collection until the predicate returns `true`.\n\nThe predicate is a function that takes an element and its index in the\ncollection, and returns an effect that resolves to a boolean.\n\nOnce the predicate returns `true`, the remaining elements of the collection\nare discarded, and the function stops taking more elements.\n\n**Note**: The first element for which the predicate returns `true` is also\nincluded in the result.\n\n**When to Use**\n\nUse this function when you want to conditionally take elements from a\ncollection based on a dynamic condition. For example, you may want to collect\nnumbers from a list until a certain threshold is reached, or gather items\nuntil a specific condition is met.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.takeUntil(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [ 1, 2, 3, 4 ]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const takeUntil: { <A, R, E>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1178"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "takeWhile",
    "description": "Takes elements as long as the predicate returns `true`.\n\n**Details**\n\nThis function processes a collection of elements and uses a predicate to\ndecide whether to take an element.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nAs long as the predicate returns `true`, elements will continue to be taken\nfrom the collection.\n\nOnce the predicate returns `false`, the remaining elements are discarded.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.takeWhile(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [1, 2, 3]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const takeWhile: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1226"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "every",
    "description": "Determines whether all elements of the iterable satisfy the effectful\npredicate.\n\n**Details**\n\nThis function checks whether every element in a given collection (an\niterable) satisfies a condition defined by an effectful predicate.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nThe function will process each element and return `true` if all elements\nsatisfy the predicate; otherwise, it returns `false`.\n\n**When to Use**\n\nThis function is useful when you need to verify that all items in a\ncollection meet certain criteria, even when the evaluation of each item\ninvolves effects, such as asynchronous checks or complex computations.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst numbers = [2, 4, 6, 8]\nconst predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n\nconst program = Effect.gen(function*() {\n  const allEven = yield* Effect.every(numbers, predicate)\n  console.log(allEven)\n})\n\nEffect.runFork(program)\n// Output: true\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Condition Checking",
    "signature": "declare const every: { <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<boolean, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<boolean, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1280"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "exists",
    "description": "Determines whether any element of the iterable satisfies the effectual\npredicate.\n\n**Details**\n\nThis function checks whether any element in a given collection (an iterable)\nsatisfies a condition defined by an effectful predicate.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nThe function will process each element, and if any element satisfies the\npredicate (returns `true`), the function will immediately return `true`.\n\nIf none of the elements satisfy the condition, it will return `false`.\n\n**When to Use**\n\nThis function allows you to quickly check for a condition in a collection\nwithout having to manually iterate over it.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 2)\n\nconst program = Effect.gen(function*() {\n  const hasLargeNumber = yield* Effect.exists(numbers, predicate)\n  console.log(hasLargeNumber)\n})\n\nEffect.runFork(program)\n// Output: true\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Condition Checking",
    "signature": "declare const exists: { <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<boolean, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<boolean, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1330"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters an iterable using the specified effectful predicate.\n\n**Details**\n\nThis function filters a collection (an iterable) by applying an effectful\npredicate.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nThe function processes each element in the collection and keeps only those\nthat satisfy the condition defined by the predicate.\n\n**Options**\n\nYou can also adjust the behavior with options such as concurrency, batching,\nor whether to negate the condition.\n\n**When to Use**\n\nThis function allows you to selectively keep or remove elements based on a\ncondition that may involve asynchronous or side-effect-causing operations.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.filter(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [2, 4]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "declare const filter: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly negate?: boolean | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly negate?: boolean | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Array<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1398"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Filters and maps elements sequentially in one operation.\n\nThis function processes each element one by one. It applies a function that\nreturns an `Option` to each element. If the function returns `Some`, the\nelement is kept; if it returns `None`, the element is removed. The operation\nis done sequentially for each element.\n\n**Example**\n\n```ts\nimport { Console, Effect, Option } from \"effect\"\n\nconst task = (n: number) =>\n  Effect.succeed(n).pipe(\n    Effect.delay(1000 - (n * 100)),\n    Effect.tap(Console.log(`task${n} done`))\n  )\n\nconst program = Effect.filterMap(\n  [task(1), task(2), task(3), task(4)],\n  (n) => n % 2 === 0 ? Option.some(n) : Option.none()\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// task1 done\n// task2 done\n// task3 done\n// task4 done\n// [ 2, 4 ]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "declare const filterMap: { <Eff extends Effect<any, any, any>, B>(pf: (a: Effect.Success<Eff>) => Option.Option<B>): (elements: Iterable<Eff>) => Effect<Array<B>, Effect.Error<Eff>, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, B>(elements: Iterable<Eff>, pf: (a: Effect.Success<Eff>) => Option.Option<B>): Effect<Array<B>, Effect.Error<Eff>, Effect.Context<Eff>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1456"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Returns the first element that satisfies the effectful predicate.\n\n**Details**\n\nThis function processes a collection of elements and applies an effectful\npredicate to each element.\n\nThe predicate is a function that takes an element and its index in the\ncollection, and it returns an effect that evaluates to a boolean.\n\nThe function stops as soon as it finds the first element for which the\npredicate returns `true` and returns that element wrapped in an `Option`.\n\nIf no element satisfies the predicate, the result will be `None`.\n\n**When to Use**\n\nThis function allows you to efficiently find an element that meets a specific\ncondition, even when the evaluation involves effects like asynchronous\noperations or side effects.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.findFirst(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: { _id: 'Option', _tag: 'Some', value: 4 }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const findFirst: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Option.Option<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Option.Option<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1508"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "Executes an effectful operation for each element in an `Iterable`.\n\n**Details**\n\nThis function applies a provided operation to each element in the iterable,\nproducing a new effect that returns an array of results.\n\nIf any effect fails, the iteration stops immediately (short-circuiting), and\nthe error is propagated.\n\n**Concurrency**\n\nThe `concurrency` option controls how many operations are performed\nconcurrently. By default, the operations are performed sequentially.\n\n**Discarding Results**\n\nIf the `discard` option is set to `true`, the intermediate results are not\ncollected, and the final result of the operation is `void`.\n\n**Example** (Applying Effects to Iterable Elements)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>\n  Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at index 0\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// [ 2, 4, 6, 8, 10 ]\n```\n\n**Example** (Discarding Results)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n// Apply effects but discard the results\nconst result = Effect.forEach(\n  [1, 2, 3, 4, 5],\n  (n, index) =>\n    Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),\n  { discard: true }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at index 0\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// undefined\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Looping",
    "signature": "declare const forEach: { <B, E, R, S extends Iterable<any>>(f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (self: S) => Effect<RA.ReadonlyArray.With<S, B>, E, R>; <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): (self: Iterable<A>) => Effect<void, E, R>; <B, E, R, S extends Iterable<any>>(self: S, f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<RA.ReadonlyArray.With<S, B>, E, R>; <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1586"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "head",
    "description": "Returns the first element of the iterable if the collection is non-empty, or\nfails with the error `NoSuchElementException` if the collection is empty.\n\n**When to Use**\n\nThis function is useful when you need to retrieve the first item from a\ncollection and want to handle the case where the collection might be empty\nwithout causing an unhandled exception.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n// Simulate an async operation\nconst fetchNumbers = Effect.succeed([1, 2, 3]).pipe(Effect.delay(\"100 millis\"))\n\nconst program = Effect.gen(function*() {\n  const firstElement = yield* Effect.head(fetchNumbers)\n  console.log(firstElement)\n})\n\nEffect.runFork(program)\n// Output: 1\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const head: <A, E, R>(self: Effect<Iterable<A>, E, R>) => Effect<A, Cause.NoSuchElementException | E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1659"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "mergeAll",
    "description": "Merges an `Iterable<Effect<A, E, R>>` to a single effect.\n\n**Details**\n\nThis function takes an iterable of effects and combines them into a single\neffect. It does this by iterating over each effect in the collection and\napplying a function that accumulates results into a \"zero\" value, which\nstarts with an initial value and is updated with each effect's success.\n\nThe provided function `f` is called for each element in the iterable,\nallowing you to specify how to combine the results.\n\n**Options**\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]\nconst add = (sum: number, value: number, i: number) => sum + value\nconst zero = 0\n\nconst program = Effect.gen(function*() {\n  const total = yield* Effect.mergeAll(numbers, zero, add)\n  console.log(total)\n})\n\nEffect.runFork(program)\n// Output: 6\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const mergeAll: { <Z, Eff extends Effect<any, any, any>>(zero: Z, f: (z: Z, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<Eff>) => Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, Z>(elements: Iterable<Eff>, zero: Z, f: (z: Z, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1703"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "partition",
    "description": "Processes an iterable and applies an effectful function to each element,\ncategorizing the results into successes and failures.\n\n**Details**\n\nThis function processes each element in the provided iterable by applying an\neffectful function to it. The results are then categorized into two separate\nlists: one for failures and another for successes. This separation allows you\nto handle the two categories differently. Failures are collected in a list\nwithout interrupting the processing of the remaining elements, so the\noperation continues even if some elements fail. This is particularly useful\nwhen you need to handle both successful and failed results separately,\nwithout stopping the entire process on encountering a failure.\n\n**When to Use**\n\nUse this function when you want to process a collection of items and handle\nerrors or failures without interrupting the processing of other items. It's\nuseful when you need to distinguish between successful and failed results and\nprocess them separately, for example, when logging errors while continuing to\nwork with valid data. The function ensures that failures are captured, while\nsuccesses are processed normally.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n//       Effect<[string[], number[]], never, never>\n//      \nconst program = Effect.partition([0, 1, 2, 3, 4], (n) => {\n  if (n % 2 === 0) {\n    return Effect.succeed(n)\n  } else {\n    return Effect.fail(`${n} is not even`)\n  }\n})\n\nEffect.runPromise(program).then(console.log, console.error)\n// Output:\n// [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error Accumulation",
    "signature": "declare const partition: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1779"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "reduce",
    "description": "Reduces an `Iterable<A>` using an effectual function `f`, working\nsequentially from left to right.\n\n**Details**\n\nThis function takes an iterable and applies a function `f` to each element in\nthe iterable. The function works sequentially, starting with an initial value\n`zero` and then combining it with each element in the collection. The\nprovided function `f` is called for each element in the iterable, allowing\nyou to accumulate a result based on the current value and the element being\nprocessed.\n\n**When to Use**\n\nThe function is often used for operations like summing a collection of\nnumbers or combining results from multiple tasks. It ensures that operations\nare performed one after the other, maintaining the order of the elements.\n\n**Example**\n\n```ts\nimport { Console, Effect } from \"effect\"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduce(\n  [1, 2, 3, 4],\n  0,\n  (acc, id, i) =>\n    processOrder(id)\n      .pipe(Effect.map((order) => acc + order.price))\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// Order 4 processed\n// 1000\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const reduce: { <Z, A, E, R>(zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, E, R>(elements: Iterable<A>, zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): Effect<Z, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1854"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "reduceWhile",
    "description": "Reduces an `Iterable<A>` using an effectual function `body`, working\nsequentially from left to right, stopping the process early when the\npredicate `while` is not satisfied.\n\n**Details**\n\nThis function processes a collection of elements, applying a function `body`\nto reduce them to a single value, starting from the first element. It checks\nthe value of the accumulator against a predicate (`while`). If at any point\nthe predicate returns `false`, the reduction stops, and the accumulated\nresult is returned.\n\n**When to Use**\n\nUse this function when you need to reduce a collection of elements, but only\ncontinue the process as long as a certain condition holds true. For example,\nif you want to sum values in a list but stop as soon as the sum exceeds a\ncertain threshold, you can use this function.\n\n**Example**\n\n```ts\nimport { Console, Effect } from \"effect\"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceWhile(\n  [1, 2, 3, 4],\n  0,\n  {\n    body: (acc, id, i) =>\n      processOrder(id)\n        .pipe(Effect.map((order) => acc + order.price)),\n    while: (acc) => acc < 500\n  }\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// 600\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const reduceWhile: { <Z, A, E, R>(zero: Z, options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R>; }): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, E, R>(elements: Iterable<A>, zero: Z, options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R>; }): Effect<Z, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1910"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "reduceRight",
    "description": "Reduces an `Iterable<A>` using an effectual function `f`, working\nsequentially from right to left.\n\n**Details**\n\nThis function takes an iterable and applies a function `f` to each element in\nthe iterable. The function works sequentially, starting with an initial value\n`zero` and then combining it with each element in the collection. The\nprovided function `f` is called for each element in the iterable, allowing\nyou to accumulate a result based on the current value and the element being\nprocessed.\n\n**When to Use**\n\nThe function is often used for operations like summing a collection of\nnumbers or combining results from multiple tasks. It ensures that operations\nare performed one after the other, maintaining the order of the elements.\n\n**Example**\n\n```ts\nimport { Console, Effect } from \"effect\"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceRight(\n  [1, 2, 3, 4],\n  0,\n  (id, acc, i) =>\n    processOrder(id)\n      .pipe(Effect.map((order) => acc + order.price))\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 4 processed\n// Order 3 processed\n// Order 2 processed\n// Order 1 processed\n// 1000\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const reduceRight: { <A, Z, R, E>(zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, R, E>(elements: Iterable<A>, zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): Effect<Z, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L1972"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "reduceEffect",
    "description": "Reduces an `Iterable<Effect<A, E, R>>` to a single effect.\n\n**Details**\n\nThis function processes a collection of effects and combines them into one\nsingle effect. It starts with an initial effect (`zero`) and applies a\nfunction `f` to each element in the collection.\n\n**Options**\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.\n\n**Example**\n\n```ts\nimport { Console, Effect } from \"effect\"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceEffect(\n  [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],\n  Effect.succeed(0),\n  (acc, order, i) => acc + order.price\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// Order 4 processed\n// 1000\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const reduceEffect: { <Z, E, R, Eff extends Effect<any, any, any>>(zero: Effect<Z, E, R>, f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<Eff>) => Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, Z, E, R>(elements: Iterable<Eff>, zero: Effect<Z, E, R>, f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2020"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "replicate",
    "description": "Replicates the given effect `n` times.\n\n**Details**\n\nThis function takes an effect and replicates it a specified number of times\n(`n`). The result is an array of `n` effects, each of which is identical to\nthe original effect.\n\n**Example**\n\n```ts\nimport { Console, Effect } from \"effect\"\n\nconst task = Effect.succeed(\"Hello, World!\").pipe(\n  Effect.tap(Console.log)\n)\n\nconst program = Effect.gen(function*() {\n  // Replicate the task 3 times\n  const tasks = Effect.replicate(task, 3)\n  for (const t of tasks) {\n    // Run each task\n    yield* t\n  }\n})\n\nEffect.runFork(program)\n// Output:\n// Hello, World!\n// Hello, World!\n// Hello, World!\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const replicate: { (n: number): <A, E, R>(self: Effect<A, E, R>) => Array<Effect<A, E, R>>; <A, E, R>(self: Effect<A, E, R>, n: number): Array<Effect<A, E, R>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2082"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "replicateEffect",
    "description": "Performs this effect the specified number of times and collects the results.\n\n**Details**\n\nThis function repeats an effect multiple times and collects the results into\nan array. You specify how many times to execute the effect, and it runs that\nmany times, either in sequence or concurrently depending on the provided\noptions.\n\n**Options**\n\nIf the `discard` option is set to `true`, the intermediate results are not\ncollected, and the final result of the operation is `void`.\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.\n\n**Example**\n\n```ts\nimport { Console, Effect } from \"effect\"\n\nlet counter = 0\n\nconst task = Effect.sync(() => ++counter).pipe(\n  Effect.tap(() => Console.log(`Task completed`))\n)\n\nconst program = Effect.gen(function*() {\n  // Replicate the task 3 times and collect the results\n  const results = yield* Effect.replicateEffect(task, 3)\n  yield* Console.log(`Results: ${results.join(\", \")}`)\n})\n\nEffect.runFork(program)\n// Output:\n// Task completed\n// Task completed\n// Task completed\n// Results: 1, 2, 3\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const replicateEffect: { (n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<Array<A>, E, R>; (n: number, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<Array<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2135"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "validateAll",
    "description": "Applies an effectful operation to each element in a collection while\ncollecting both successes and failures.\n\n**Details**\n\nThis function allows you to apply an effectful operation to every item in a\ncollection.\n\nUnlike {@link forEach}, which would stop at the first error, this function\ncontinues processing all elements, accumulating both successes and failures.\n\n**When to Use**\n\nUse this function when you want to process every item in a collection, even\nif some items fail. This is particularly useful when you need to perform\noperations on all elements without halting due to an error.\n\nKeep in mind that if there are any failures, **all successes will be lost**,\nso this function is not suitable when you need to keep the successful results\nin case of errors.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n//       Effect<number[], [string, ...string[]], never>\n//      \nconst program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {\n  if (n < 4) {\n    return Console.log(`item ${n}`).pipe(Effect.as(n))\n  } else {\n    return Effect.fail(`${n} is not less that 4`)\n  }\n})\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// item 1\n// item 2\n// item 3\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: [ '4 is not less that 4', '5 is not less that 4' ]\n//   }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error Accumulation",
    "signature": "declare const validateAll: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<Array<B>, RA.NonEmptyArray<E>, R>; <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): (elements: Iterable<A>) => Effect<void, RA.NonEmptyArray<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Array<B>, RA.NonEmptyArray<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, RA.NonEmptyArray<E>, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2236"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "validateFirst",
    "description": "This function is similar to {@link validateAll} but with a key difference: it\nreturns the first successful result or all errors if none of the operations\nsucceed.\n\n**Details**\n\nThis function processes a collection of elements and applies an effectful\noperation to each. Unlike {@link validateAll}, which accumulates both\nsuccesses and failures, `Effect.validateFirst` stops and returns the first\nsuccess it encounters. If no success occurs, it returns all accumulated\nerrors. This can be useful when you are interested in the first successful\nresult and want to avoid processing further once a valid result is found.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n//       Effect<number, string[], never>\n//      \nconst program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {\n  if (n < 4) {\n    return Effect.fail(`${n} is not less that 4`)\n  } else {\n    return Console.log(`item ${n}`).pipe(Effect.as(n))\n  }\n})\n\nEffect.runPromise(program).then(console.log, console.error)\n// Output:\n// item 4\n// 4\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error Accumulation",
    "signature": "declare const validateFirst: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<B, Array<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<B, Array<E>, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2319"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "async",
    "description": "Creates an `Effect` from a callback-based asynchronous function.\n\n**Details**\n\nThe `resume` function:\n- Must be called exactly once. Any additional calls will be ignored.\n- Can return an optional `Effect` that will be run if the `Fiber` executing\n  this `Effect` is interrupted. This can be useful in scenarios where you\n  need to handle resource cleanup if the operation is interrupted.\n- Can receive an `AbortSignal` to handle interruption if needed.\n\nThe `FiberId` of the fiber that may complete the async callback may also be\nspecified using the `blockingOn` argument. This is called the \"blocking\nfiber\" because it suspends the fiber executing the `async` effect (i.e.\nsemantically blocks the fiber from making progress). Specifying this fiber id\nin cases where it is known will improve diagnostics, but not affect the\nbehavior of the returned effect.\n\n**When to Use**\n\nUse `Effect.async` when dealing with APIs that use callback-style instead of\n`async/await` or `Promise`.\n\n**Example** (Wrapping a Callback API)\n\n```ts\nimport { Effect } from \"effect\"\nimport * as NodeFS from \"node:fs\"\n\nconst readFile = (filename: string) =>\n  Effect.async<Buffer, Error>((resume) => {\n    NodeFS.readFile(filename, (error, data) => {\n      if (error) {\n        // Resume with a failed Effect if an error occurs\n        resume(Effect.fail(error))\n      } else {\n        // Resume with a succeeded Effect if successful\n        resume(Effect.succeed(data))\n      }\n    })\n  })\n\n//       Effect<Buffer, Error, never>\n//      \nconst program = readFile(\"example.txt\")\n```\n\n**Example** (Handling Interruption with Cleanup)\n\n```ts\nimport { Effect, Fiber } from \"effect\"\nimport * as NodeFS from \"node:fs\"\n\n// Simulates a long-running operation to write to a file\nconst writeFileWithCleanup = (filename: string, data: string) =>\n  Effect.async<void, Error>((resume) => {\n    const writeStream = NodeFS.createWriteStream(filename)\n\n    // Start writing data to the file\n    writeStream.write(data)\n\n    // When the stream is finished, resume with success\n    writeStream.on(\"finish\", () => resume(Effect.void))\n\n    // In case of an error during writing, resume with failure\n    writeStream.on(\"error\", (err) => resume(Effect.fail(err)))\n\n    // Handle interruption by returning a cleanup effect\n    return Effect.sync(() => {\n      console.log(`Cleaning up ${filename}`)\n      NodeFS.unlinkSync(filename)\n    })\n  })\n\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(\n    writeFileWithCleanup(\"example.txt\", \"Some long data...\")\n  )\n  // Simulate interrupting the fiber after 1 second\n  yield* Effect.sleep(\"1 second\")\n  yield* Fiber.interrupt(fiber) // This will trigger the cleanup\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Cleaning up example.txt\n```\n\n**Example** (Handling Interruption with AbortSignal)\n\n```ts\nimport { Effect, Fiber } from \"effect\"\n\n// A task that supports interruption using AbortSignal\nconst interruptibleTask = Effect.async<void, Error>((resume, signal) => {\n  // Handle interruption\n  signal.addEventListener(\"abort\", () => {\n    console.log(\"Abort signal received\")\n    clearTimeout(timeoutId)\n  })\n\n  // Simulate a long-running task\n  const timeoutId = setTimeout(() => {\n    console.log(\"Operation completed\")\n    resume(Effect.void)\n  }, 2000)\n})\n\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(interruptibleTask)\n  // Simulate interrupting the fiber after 1 second\n  yield* Effect.sleep(\"1 second\")\n  yield* Fiber.interrupt(fiber)\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Abort signal received\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const async: <A, E = never, R = never>(resume: (callback: (_: Effect<A, E, R>) => void, signal: AbortSignal) => void | Effect<void, never, R>, blockingOn?: FiberId.FiberId) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2469"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "asyncEffect",
    "description": "A variant of {@link async} where the registration function may return an `Effect`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const asyncEffect: <A, E, R, R3, E2, R2>(register: (callback: (_: Effect<A, E, R>) => void) => Effect<Effect<void, never, R3> | void, E2, R2>) => Effect<A, E | E2, R | R2 | R3>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2480"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "custom",
    "description": "Low level constructor that enables for custom stack tracing cutpoints.\n\nIt is meant to be called with a bag of instructions that become available in\nthe \"this\" of the effect.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst throwingFunction = () => { throw new Error() }\nconst blowUp = Effect.custom(throwingFunction, function() {\n  return Effect.succeed(this.effect_instruction_i0())\n})\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const custom: { <X, A, E, R>(i0: X, body: (this: { effect_instruction_i0: X; }) => Effect<A, E, R>): Effect<A, E, R>; <X, Y, A, E, R>(i0: X, i1: Y, body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; }) => Effect<A, E, R>): Effect<A, E, R>; <X, Y, Z, A, E, R>(i0: X, i1: Y, i2: Z, body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; effect_instruction_i2: Z; }) => Effect<A, E, R>): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2504"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withFiberRuntime",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const withFiberRuntime: <A, E = never, R = never>(withRuntime: (fiber: Fiber.RuntimeFiber<A, E>, status: FiberStatus.Running) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2523"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "fail",
    "description": "Creates an `Effect` that represents a recoverable error.\n\n**When to Use**\n\nUse this function to explicitly signal an error in an `Effect`. The error\nwill keep propagating unless it is handled. You can handle the error with\nfunctions like {@link catchAll} or {@link catchTag}.\n\n**Example** (Creating a Failed Effect)\n\n```ts\nimport { Effect } from \"effect\"\n\n//       Effect<never, Error, never>\n//      \nconst failure = Effect.fail(\n  new Error(\"Operation failed due to network error\")\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const fail: <E>(error: E) => Effect<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2556"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "failSync",
    "description": "Creates an `Effect` that fails with the specified error, evaluated lazily.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const failSync: <E>(evaluate: LazyArg<E>) => Effect<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2564"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "failCause",
    "description": "Creates an `Effect` that fails with the specified `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const failCause: <E>(cause: Cause.Cause<E>) => Effect<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2572"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "failCauseSync",
    "description": "Creates an `Effect` that fails with the specified `Cause`, evaluated lazily.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Effect<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2580"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "die",
    "description": "Creates an effect that terminates a fiber with a specified error.\n\n**Details**\n\nThis function is used to signal a defect, which represents a critical and\nunexpected error in the code. When invoked, it produces an effect that does\nnot handle the error and instead terminates the fiber.\n\nThe error channel of the resulting effect is of type `never`, indicating that\nit cannot recover from this failure.\n\n**When to Use**\n\nUse this function when encountering unexpected conditions in your code that\nshould not be handled as regular errors but instead represent unrecoverable\ndefects.\n\n**Example** (Terminating on Division by Zero with a Specified Error)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.die(new Error(\"Cannot divide by zero\"))\n    : Effect.succeed(a / b)\n\n//       Effect<number, never, never>\n//      \nconst program = divide(1, 0)\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: Cannot divide by zero\n//   ...stack trace...\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const die: (defect: unknown) => Effect<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2628"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "dieMessage",
    "description": "Creates an effect that terminates a fiber with a `RuntimeException`\ncontaining the specified message.\n\n**Details**\n\nThis function is used to signal a defect, representing a critical and\nunexpected error in the code. When invoked, it produces an effect that\nterminates the fiber with a `RuntimeException` carrying the given message.\n\nThe resulting effect has an error channel of type `never`, indicating it does\nnot handle or recover from the error.\n\n**When to Use**\n\nUse this function when you want to terminate a fiber due to an unrecoverable\ndefect and include a clear explanation in the message.\n\n**Example** (Terminating on Division by Zero with a Specified Message)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.dieMessage(\"Cannot divide by zero\")\n    : Effect.succeed(a / b)\n\n//       Effect<number, never, never>\n//      \nconst program = divide(1, 0)\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) RuntimeException: Cannot divide by zero\n//   ...stack trace...\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const dieMessage: (message: string) => Effect<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2675"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "dieSync",
    "description": "Creates an effect that dies with the specified error, evaluated lazily.\n\n**Details**\n\nThis function allows you to create an effect that will terminate with a fatal error.\nThe error is provided as a lazy argument, meaning it will only be evaluated when the effect runs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const dieSync: (evaluate: LazyArg<unknown>) => Effect<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2690"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "gen",
    "description": "Provides a way to write effectful code using generator functions, simplifying\ncontrol flow and error handling.\n\n**When to Use**\n\n`Effect.gen` allows you to write code that looks and behaves like synchronous\ncode, but it can handle asynchronous tasks, errors, and complex control flow\n(like loops and conditions). It helps make asynchronous code more readable\nand easier to manage.\n\nThe generator functions work similarly to `async/await` but with more\nexplicit control over the execution of effects. You can `yield*` values from\neffects and return the final result at the end.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst addServiceCharge = (amount: number) => amount + 1\n\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst fetchDiscountRate = Effect.promise(() => Promise.resolve(5))\n\nexport const program = Effect.gen(function* () {\n  const transactionAmount = yield* fetchTransactionAmount\n  const discountRate = yield* fetchDiscountRate\n  const discountedAmount = yield* applyDiscount(\n    transactionAmount,\n    discountRate\n  )\n  const finalAmount = addServiceCharge(discountedAmount)\n  return `Final amount to charge: ${finalAmount}`\n})\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const gen: { <Eff extends YieldWrap<Effect<any, any, any>>, AEff>(f: (resume: Adapter) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never>; <Self, Eff extends YieldWrap<Effect<any, any, any>>, AEff>(self: Self, f: (this: Self, resume: Adapter) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2741"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "never",
    "description": "An effect that that runs indefinitely and never produces any result. The\nmoral equivalent of `while(true) {}`, only without the wasted CPU cycles.\n\n**When to Use**\n\nIt could be useful for long-running background tasks or to simulate waiting\nbehavior without actually consuming resources. This effect is ideal for cases\nwhere you want to keep the program alive or in a certain state without\nperforming any active work.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const never: Effect<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3039"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "none",
    "description": "Ensures the `Option` is `None`, returning `void`. Otherwise, raises a\n`NoSuchElementException`.\n\n**Details**\n\nThis function checks if the provided `Option` is `None`. If it is, it returns\nan effect that produces no result (i.e., `void`). If the `Option` is not\n`None` (i.e., it contains a value), the function will raise a\n`NoSuchElementException` error.\n\n**When to Use**\n\nThis is useful when you want to ensure that a certain value is absent (i.e.,\n`None`) before continuing execution, and to handle cases where the value is\nunexpectedly present.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const none: <A, E, R>(self: Effect<Option.Option<A>, E, R>) => Effect<void, E | Cause.NoSuchElementException, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3060"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "promise",
    "description": "Creates an `Effect` that represents an asynchronous computation guaranteed to\nsucceed.\n\n**Details**\n\nThe provided function (`thunk`) returns a `Promise` that should never reject; if it does, the error\nwill be treated as a \"defect\".\n\nThis defect is not a standard error but indicates a flaw in the logic that\nwas expected to be error-free. You can think of it similar to an unexpected\ncrash in the program, which can be further managed or logged using tools like\n{@link catchAllDefect}.\n\n**Interruptions**\n\nAn optional `AbortSignal` can be provided to allow for interruption of the\nwrapped `Promise` API.\n\n**When to Use**\n\nUse this function when you are sure the operation will not reject.\n\n**Example** (Delayed Message)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst delay = (message: string) =>\n  Effect.promise<string>(\n    () =>\n      new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(message)\n        }, 2000)\n      })\n  )\n\n//       Effect<string, never, never>\n//      \nconst program = delay(\"Async operation completed successfully!\")\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const promise: <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>) => Effect<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3112"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "succeed",
    "description": "Creates an `Effect` that always succeeds with a given value.\n\n**When to Use**\n\nUse this function when you need an effect that completes successfully with a\nspecific value without any errors or external dependencies.\n\n**Example** (Creating a Successful Effect)\n\n```ts\nimport { Effect } from \"effect\"\n\n// Creating an effect that represents a successful scenario\n//\n//       Effect<number, never, never>\n//      \nconst success = Effect.succeed(42)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const succeed: <A>(value: A) => Effect<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3141"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "succeedNone",
    "description": "Returns an effect which succeeds with `None`.\n\n**When to Use**\n\nUse this function when you need to represent the absence of a value in your\ncode, especially when working with optional data. This can be helpful when\nyou want to indicate that no result is available without throwing an error or\nperforming additional logic.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const succeedNone: Effect<Option.Option<never>, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3158"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "succeedSome",
    "description": "Returns an effect which succeeds with the value wrapped in a `Some`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const succeedSome: <A>(value: A) => Effect<Option.Option<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3168"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "suspend",
    "description": "Delays the creation of an `Effect` until it is actually needed.\n\n**Details**\n\nThe `Effect.suspend` function takes a thunk that represents the effect and\nwraps it in a suspended effect. This means the effect will not be created\nuntil it is explicitly needed, which is helpful in various scenarios:\n- **Lazy Evaluation**: Helps optimize performance by deferring computations,\n  especially when the effect might not be needed, or when its computation is\n  expensive. This also ensures that any side effects or scoped captures are\n  re-executed on each invocation.\n- **Handling Circular Dependencies**: Useful in managing circular\n  dependencies, such as recursive functions that need to avoid eager\n  evaluation to prevent stack overflow.\n- **Unifying Return Types**: Can help TypeScript unify return types in\n  situations where multiple branches of logic return different effects,\n  simplifying type inference.\n\n**When to Use**\n\nUse this function when you need to defer the evaluation of an effect until it\nis required. This is particularly useful for optimizing expensive\ncomputations, managing circular dependencies, or resolving type inference\nissues.\n\n**Example** (Lazy Evaluation with Side Effects)\n\n```ts\nimport { Effect } from \"effect\"\n\nlet i = 0\n\nconst bad = Effect.succeed(i++)\n\nconst good = Effect.suspend(() => Effect.succeed(i++))\n\nconsole.log(Effect.runSync(bad)) // Output: 0\nconsole.log(Effect.runSync(bad)) // Output: 0\n\nconsole.log(Effect.runSync(good)) // Output: 1\nconsole.log(Effect.runSync(good)) // Output: 2\n```\n\n**Example** (Recursive Fibonacci)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst blowsUp = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(1)\n    : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)\n\nconsole.log(Effect.runSync(blowsUp(32)))\n// crash: JavaScript heap out of memory\n\nconst allGood = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(1)\n    : Effect.zipWith(\n        Effect.suspend(() => allGood(n - 1)),\n        Effect.suspend(() => allGood(n - 2)),\n        (a, b) => a + b\n      )\n\nconsole.log(Effect.runSync(allGood(32)))\n// Output: 3524578\n```\n\n**Example** (Using Effect.suspend to Help TypeScript Infer Types)\n\n```ts\nimport { Effect } from \"effect\"\n\n//   Without suspend, TypeScript may struggle with type inference.\n//   Inferred type:\n//     (a: number, b: number) =>\n//       Effect<never, Error, never> | Effect<number, never, never>\nconst withoutSuspend = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error(\"Cannot divide by zero\"))\n    : Effect.succeed(a / b)\n\n//   Using suspend to unify return types.\n//   Inferred type:\n//     (a: number, b: number) => Effect<number, Error, never>\nconst withSuspend = (a: number, b: number) =>\n  Effect.suspend(() =>\n    b === 0\n      ? Effect.fail(new Error(\"Cannot divide by zero\"))\n      : Effect.succeed(a / b)\n  )\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const suspend: <A, E, R>(effect: LazyArg<Effect<A, E, R>>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3268"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "sync",
    "description": "Creates an `Effect` that represents a synchronous side-effectful computation.\n\n**Details**\n\nThe provided function (`thunk`) must not throw errors; if it does, the error\nwill be treated as a \"defect\".\n\nThis defect is not a standard error but indicates a flaw in the logic that\nwas expected to be error-free. You can think of it similar to an unexpected\ncrash in the program, which can be further managed or logged using tools like\n{@link catchAllDefect}.\n\n**When to Use**\n\nUse this function when you are sure the operation will not fail.\n\n**Example** (Logging a Message)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst log = (message: string) =>\n  Effect.sync(() => {\n    console.log(message) // side effect\n  })\n\n//       Effect<void, never, never>\n//      \nconst program = log(\"Hello, World!\")\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const sync: <A>(thunk: LazyArg<A>) => Effect<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3307"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "yieldNow",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const yieldNow: (options?: { readonly priority?: number | undefined; }) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3333"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "catchAll",
    "description": "Handles all errors in an effect by providing a fallback effect.\n\n**Details**\n\nThis function catches any errors that may occur during the execution of an\neffect and allows you to handle them by specifying a fallback effect. This\nensures that the program continues without failing by recovering from errors\nusing the provided fallback logic.\n\n**Note**: This function only handles recoverable errors. It will not recover\nfrom unrecoverable defects.\n\n**Example** (Providing Recovery Logic for Recoverable Errors)\n\n```ts\nimport { Effect, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//       Effect<string, HttpError | ValidationError, never>\n//      \nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//       Effect<string, never, never>\n//      \nconst recovered = program.pipe(\n  Effect.catchAll((error) =>\n    Effect.succeed(`Recovering from ${error._tag}`)\n  )\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const catchAll: { <E, A2, E2, R2>(f: (e: E) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<A2, E2, R2>): Effect<A2 | A, E2, R2 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3453"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "catchAllCause",
    "description": "Handles both recoverable and unrecoverable errors by providing a recovery\neffect.\n\n**When to Use**\n\nThe `catchAllCause` function allows you to handle all errors, including\nunrecoverable defects, by providing a recovery effect. The recovery logic is\nbased on the `Cause` of the error, which provides detailed information about\nthe failure.\n\n**When to Recover from Defects**\n\nDefects are unexpected errors that typically shouldn't be recovered from, as\nthey often indicate serious issues. However, in some cases, such as\ndynamically loaded plugins, controlled recovery might be needed.\n\n**Example** (Recovering from All Errors)\n\n```ts\nimport { Cause, Effect } from \"effect\"\n\n// Define an effect that may fail with a recoverable or unrecoverable error\nconst program = Effect.fail(\"Something went wrong!\")\n\n// Recover from all errors by examining the cause\nconst recovered = program.pipe(\n  Effect.catchAllCause((cause) =>\n    Cause.isFailType(cause)\n      ? Effect.succeed(\"Recovered from a regular error\")\n      : Effect.succeed(\"Recovered from a defect\")\n  )\n)\n\nEffect.runPromise(recovered).then(console.log)\n// Output: \"Recovered from a regular error\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const catchAllCause: { <E, A2, E2, R2>(f: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3499"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "catchAllDefect",
    "description": "Recovers from all defects using a provided recovery function.\n\n**When to Use**\n\nThere is no sensible way to recover from defects. This method should be used\nonly at the boundary between Effect and an external system, to transmit\ninformation on a defect for diagnostic or explanatory purposes.\n\n**Details**\n\n`catchAllDefect` allows you to handle defects, which are unexpected errors\nthat usually cause the program to terminate. This function lets you recover\nfrom these defects by providing a function that handles the error. However,\nit does not handle expected errors (like those from {@link fail}) or\nexecution interruptions (like those from {@link interrupt}).\n\n**When to Recover from Defects**\n\nDefects are unexpected errors that typically shouldn't be recovered from, as\nthey often indicate serious issues. However, in some cases, such as\ndynamically loaded plugins, controlled recovery might be needed.\n\n**Example** (Handling All Defects)\n\n```ts\nimport { Effect, Cause, Console } from \"effect\"\n\n// Simulating a runtime error\nconst task = Effect.dieMessage(\"Boom!\")\n\nconst program = Effect.catchAllDefect(task, (defect) => {\n  if (Cause.isRuntimeException(defect)) {\n    return Console.log(\n      `RuntimeException defect caught: ${defect.message}`\n    )\n  }\n  return Console.log(\"Unknown defect caught.\")\n})\n\n// We get an Exit.Success because we caught all defects\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// RuntimeException defect caught: Boom!\n// {\n//   _id: \"Exit\",\n//   _tag: \"Success\",\n//   value: undefined\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const catchAllDefect: { <A2, E2, R2>(f: (defect: unknown) => Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (defect: unknown) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3563"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "catchIf",
    "description": "Recovers from specific errors based on a predicate.\n\n**When to Use**\n\n`catchIf` works similarly to {@link catchSome}, but it allows you to\nrecover from errors by providing a predicate function. If the predicate\nmatches the error, the recovery effect is applied. This function doesn't\nalter the error type, so the resulting effect still carries the original\nerror type unless a user-defined type guard is used to narrow the type.\n\n**Example** (Catching Specific Errors with a Predicate)\n\n```ts\nimport { Effect, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//       Effect<string, HttpError | ValidationError, never>\n//      \nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//       Effect<string, ValidationError, never>\n//      \nconst recovered = program.pipe(\n  Effect.catchIf(\n    // Only handle HttpError errors\n    (error) => error._tag === \"HttpError\",\n    () => Effect.succeed(\"Recovering from HttpError\")\n  )\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const catchIf: { <E, EB extends E, A2, E2, R2>(refinement: Refinement<NoInfer<E>, EB>, f: (e: EB) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>; <E, A2, E2, R2>(predicate: Predicate<NoInfer<E>>, f: (e: NoInfer<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, EB extends E, A2, E2, R2>(self: Effect<A, E, R>, refinement: Refinement<E, EB>, f: (e: EB) => Effect<A2, E2, R2>): Effect<A | A2, E2 | Exclude<E, EB>, R | R2>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, predicate: Predicate<E>, f: (e: E) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3625"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "catchSome",
    "description": "Catches and recovers from specific types of errors, allowing you to attempt\nrecovery only for certain errors.\n\n**Details**\n\n`catchSome` lets you selectively catch and handle errors of certain\ntypes by providing a recovery effect for specific errors. If the error\nmatches a condition, recovery is attempted; if not, it doesn't affect the\nprogram. This function doesn't alter the error type, meaning the error type\nremains the same as in the original effect.\n\n**Example** (Handling Specific Errors with Effect.catchSome)\n\n```ts\nimport { Effect, Random, Option } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//       Effect<string, HttpError | ValidationError, never>\n//      \nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//       Effect<string, HttpError | ValidationError, never>\n//      \nconst recovered = program.pipe(\n  Effect.catchSome((error) => {\n    // Only handle HttpError errors\n    if (error._tag === \"HttpError\") {\n      return Option.some(Effect.succeed(\"Recovering from HttpError\"))\n    } else {\n      return Option.none()\n    }\n  })\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const catchSome: { <E, A2, E2, R2>(pf: (e: NoInfer<E>) => Option.Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, pf: (e: NoInfer<E>) => Option.Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3704"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "catchSomeCause",
    "description": "Recovers from specific causes using a provided partial function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const catchSomeCause: { <E, A2, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect<A2, E2, R2>>): Effect<A2 | A, E | E2, R2 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3723"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "catchSomeDefect",
    "description": "Recovers from specific defects using a provided partial function.\n\n**Details**\n\n`catchSomeDefect` allows you to handle specific defects, which are\nunexpected errors that can cause the program to stop. It uses a partial\nfunction to catch only certain defects and ignores others. The function does\nnot handle expected errors (such as those caused by {@link fail}) or\ninterruptions in execution (like those caused by {@link interrupt}).\n\nThis function provides a way to handle certain types of defects while\nallowing others to propagate and cause failure in the program.\n\n**Note**: There is no sensible way to recover from defects. This method\nshould be used only at the boundary between Effect and an external system, to\ntransmit information on a defect for diagnostic or explanatory purposes.\n\n**How the Partial Function Works**\n\nThe function provided to `catchSomeDefect` acts as a filter and a handler for defects:\n- It receives the defect as an input.\n- If the defect matches a specific condition (e.g., a certain error type), the function returns\n  an `Option.some` containing the recovery logic.\n- If the defect does not match, the function returns `Option.none`, allowing the defect to propagate.\n\n**Example** (Handling Specific Defects)\n\n```ts\nimport { Effect, Cause, Option, Console } from \"effect\"\n\n// Simulating a runtime error\nconst task = Effect.dieMessage(\"Boom!\")\n\nconst program = Effect.catchSomeDefect(task, (defect) => {\n  if (Cause.isIllegalArgumentException(defect)) {\n    return Option.some(\n      Console.log(\n        `Caught an IllegalArgumentException defect: ${defect.message}`\n      )\n    )\n  }\n  return Option.none()\n})\n\n// Since we are only catching IllegalArgumentException\n// we will get an Exit.Failure because we simulated a runtime error.\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Die',\n//     defect: { _tag: 'RuntimeException' }\n//   }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const catchSomeDefect: { <A2, E2, R2>(pf: (defect: unknown) => Option.Option<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, pf: (defect: unknown) => Option.Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3796"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "catchTag",
    "description": "Catches and handles specific errors by their `_tag` field, which is used as a\ndiscriminator.\n\n**When to Use**\n\n`catchTag` is useful when your errors are tagged with a readonly `_tag` field\nthat identifies the error type. You can use this function to handle specific\nerror types by matching the `_tag` value. This allows for precise error\nhandling, ensuring that only specific errors are caught and handled.\n\nThe error type must have a readonly `_tag` field to use `catchTag`. This\nfield is used to identify and match errors.\n\n**Example** (Handling Errors by Tag)\n\n```ts\nimport { Effect, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//       Effect<string, HttpError | ValidationError, never>\n//      \nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//       Effect<string, ValidationError, never>\n//      \nconst recovered = program.pipe(\n  // Only handle HttpError errors\n  Effect.catchTag(\"HttpError\", (_HttpError) =>\n    Effect.succeed(\"Recovering from HttpError\")\n  )\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const catchTag: { <K extends E extends { _tag: string; } ? E[\"_tag\"] : never, E, A1, E1, R1>(k: K, f: (e: NoInfer<Extract<E, { _tag: K; }>>) => Effect<A1, E1, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E[\"_tag\"] : never, R1, E1, A1>(self: Effect<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Effect<A1, E1, R1>): Effect<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3863"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "catchTags",
    "description": "Handles multiple errors in a single block of code using their `_tag` field.\n\n**When to Use**\n\n`catchTags` is a convenient way to handle multiple error types at\nonce. Instead of using {@link catchTag} multiple times, you can pass an\nobject where each key is an error type's `_tag`, and the value is the handler\nfor that specific error. This allows you to catch and recover from multiple\nerror types in a single call.\n\nThe error type must have a readonly `_tag` field to use `catchTag`. This\nfield is used to identify and match errors.\n\n**Example** (Handling Multiple Tagged Error Types at Once)\n\n```ts\nimport { Effect, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//       Effect<string, HttpError | ValidationError, never>\n//      \nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//       Effect<string, never, never>\n//      \nconst recovered = program.pipe(\n  Effect.catchTags({\n    HttpError: (_HttpError) =>\n      Effect.succeed(`Recovering from HttpError`),\n    ValidationError: (_ValidationError) =>\n      Effect.succeed(`Recovering from ValidationError`)\n  })\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const catchTags: { <E, Cases extends { [K in Extract<E, { _tag: string; }>[\"_tag\"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>[\"_tag\"]>]: never; })>(cases: Cases): <A, R>(self: Effect<A, E, R>) => Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; <R, E, A, Cases extends { [K in Extract<E, { _tag: string; }>[\"_tag\"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>[\"_tag\"]>]: never; })>(self: Effect<A, E, R>, cases: Cases): Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L3931"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "cause",
    "description": "Retrieves the cause of a failure in an effect.\n\n**Details**\n\nThis function allows you to expose the detailed cause of an effect, which\nincludes a more precise representation of failures, such as error messages\nand defects.\n\n**When to Use**\n\nThis function is helpful when you need to inspect the cause of a failure in\nan effect, giving you more information than just the error message. It can be\nused to log, handle, or analyze failures in more detail, including\ndistinguishing between different types of defects (e.g., runtime exceptions,\ninterruptions, etc.).\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n//       Effect<number, string, never>\n//      \nconst program = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n\n//       Effect<void, never, never>\n//      \nconst recovered = Effect.gen(function* () {\n  const cause = yield* Effect.cause(program)\n  yield* Console.log(cause)\n})\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const cause: <A, E, R>(self: Effect<A, E, R>) => Effect<Cause.Cause<E>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4018"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "eventually",
    "description": "Runs an effect repeatedly until it succeeds, ignoring errors.\n\n**Details**\n\nThis function takes an effect and runs it repeatedly until the effect\nsuccessfully completes. If the effect fails, it will ignore the error and\nretry the operation. This is useful when you need to perform a task that may\nfail occasionally, but you want to keep trying until it eventually succeeds.\nIt works by repeatedly executing the effect until it no longer throws an\nerror.\n\n**When to Use**\n\nUse this function when you want to retry an operation multiple times until it\nsucceeds. It is helpful in cases where the operation may fail temporarily\n(e.g., a network request), and you want to keep trying without handling or\nworrying about the errors.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nlet counter = 0\n\nconst effect = Effect.try(() => {\n  counter++\n  if (counter < 3) {\n    console.log(\"running effect\")\n    throw new Error(\"error\")\n  } else {\n    console.log(\"effect done\")\n    return \"some result\"\n  }\n})\n\nconst program = Effect.eventually(effect)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// running effect\n// running effect\n// effect done\n// some result\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const eventually: <A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4070"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "ignore",
    "description": "Discards both the success and failure values of an effect.\n\n**When to Use**\n\n`ignore` allows you to run an effect without caring about its result, whether\nit succeeds or fails. This is useful when you only care about the side\neffects of the effect and do not need to handle or process its outcome.\n\n**Example** (Using Effect.ignore to Discard Values)\n\n```ts\nimport { Effect } from \"effect\"\n\n//       Effect<number, string, never>\n//      \nconst task = Effect.fail(\"Uh oh!\").pipe(Effect.as(5))\n\n//       Effect<void, never, never>\n//      \nconst program = Effect.ignore(task)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const ignore: <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4100"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "ignoreLogged",
    "description": "Ignores the result of an effect but logs any failures.\n\n**Details**\n\nThis function takes an effect and returns a new effect that ignores whether\nthe original effect succeeds or fails. However, if the effect fails, it will\nlog the failure at the Debug level, so you can keep track of any issues that\narise.\n\n**When to Use**\n\nThis is useful in scenarios where you want to continue with your program\nregardless of the result of the effect, but you still want to be aware of\npotential failures that may need attention later.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const ignoreLogged: <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4121"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "parallelErrors",
    "description": "Combines all errors from concurrent operations into a single error.\n\n**Details**\n\nThis function is used when you have multiple operations running at the same\ntime, and you want to capture all the errors that occur across those\noperations. Instead of handling each error separately, it combines all the\nerrors into one unified error.\n\n**When to Use**\n\nWhen using this function, any errors that occur in the concurrently running\noperations will be grouped together into a single error. This helps simplify\nerror handling in cases where you don't need to differentiate between each\nfailure, but simply want to know that multiple failures occurred.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst fail1 = Effect.fail(\"Oh uh!\")\nconst fail2 = Effect.fail(\"Oh no!\")\nconst die = Effect.dieMessage(\"Boom!\")\n\n// Run all effects concurrently and capture all errors\nconst program = Effect.all([fail1, fail2, die], {\n  concurrency: \"unbounded\"\n}).pipe(Effect.asVoid, Effect.parallelErrors)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: [ 'Oh uh!', 'Oh no!' ] }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const parallelErrors: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Array<E>, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4166"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "sandbox",
    "description": "Transforms an effect to expose detailed error causes.\n\n**Details**\n\nThis function enhances an effect by providing detailed information about any\nerror, defect, or interruption that may occur during its execution. It\nmodifies the error channel of the effect so that it includes a full cause of\nthe failure, wrapped in a `Cause<E>` type.\n\nAfter applying this function, you can use operators like {@link catchAll} and\n{@link catchTags} to handle specific types of errors.\n\nIf you no longer need the detailed cause information, you can revert the\nchanges using {@link unsandbox} to return to the original error-handling\nbehavior.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n//       Effect<string, Error, never>\n//      \nconst task = Effect.fail(new Error(\"Oh uh!\")).pipe(\n  Effect.as(\"primary result\")\n)\n\n//       Effect<string, Cause<Error>, never>\n//      \nconst sandboxed = Effect.sandbox(task)\n\nconst program = Effect.catchTags(sandboxed, {\n  Die: (cause) =>\n    Console.log(`Caught a defect: ${cause.defect}`).pipe(\n      Effect.as(\"fallback result on defect\")\n    ),\n  Interrupt: (cause) =>\n    Console.log(`Caught a defect: ${cause.fiberId}`).pipe(\n      Effect.as(\"fallback result on fiber interruption\")\n    ),\n  Fail: (cause) =>\n    Console.log(`Caught a defect: ${cause.error}`).pipe(\n      Effect.as(\"fallback result on failure\")\n    )\n})\n\n// Restore the original error handling with unsandbox\nconst main = Effect.unsandbox(program)\n\nEffect.runPromise(main).then(console.log)\n// Output:\n// Caught a defect: Oh uh!\n// fallback result on failure\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const sandbox: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Cause.Cause<E>, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4229"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "retry",
    "description": "Retries a failing effect based on a defined retry policy.\n\n**Details**\n\nThe `Effect.retry` function takes an effect and a {@link Schedule} policy,\nand will automatically retry the effect if it fails, following the rules of\nthe policy.\n\nIf the effect ultimately succeeds, the result will be returned.\n\nIf the maximum retries are exhausted and the effect still fails, the failure\nis propagated.\n\n**When to Use**\n\nThis can be useful when dealing with intermittent failures, such as network\nissues or temporary resource unavailability. By defining a retry policy, you\ncan control the number of retries, the delay between them, and when to stop\nretrying.\n\n**Example** (Retrying with a Fixed Delay)\n\n```ts\nimport { Effect, Schedule } from \"effect\"\n\nlet count = 0\n\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\n  if (count <= 2) {\n    count++\n    console.log(\"failure\")\n    resume(Effect.fail(new Error()))\n  } else {\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\n// Define a repetition policy using a fixed delay between retries\nconst policy = Schedule.fixed(\"100 millis\")\n\nconst repeated = Effect.retry(task, policy)\n\nEffect.runPromise(repeated).then(console.log)\n// Output:\n// failure\n// failure\n// failure\n// success\n// yay!\n```\n\n**Example** (Retrying a Task up to 5 times)\n\n```ts\nimport { Effect } from \"effect\"\n\nlet count = 0\n\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\n  if (count <= 2) {\n    count++\n    console.log(\"failure\")\n    resume(Effect.fail(new Error()))\n  } else {\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\n// Retry the task up to 5 times\nEffect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)\n// Output:\n// failure\n// failure\n// failure\n// success\n```\n\n**Example** (Retrying Until a Specific Condition is Met)\n\n```ts\nimport { Effect } from \"effect\"\n\nlet count = 0\n\n// Define an effect that simulates varying error on each invocation\nconst action = Effect.failSync(() => {\n  console.log(`Action called ${++count} time(s)`)\n  return `Error ${count}`\n})\n\n// Retry the action until a specific condition is met\nconst program = Effect.retry(action, {\n  until: (err) => err === \"Error 3\"\n})\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Action called 1 time(s)\n// Action called 2 time(s)\n// Action called 3 time(s)\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const retry: { <E, O extends NoExcessProperties<Retry.Options<E>, O>>(options: O): <A, R>(self: Effect<A, E, R>) => Retry.Return<R, E, A, O>; <B, E, R1>(policy: Schedule.Schedule<B, NoInfer<E>, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, O extends NoExcessProperties<Retry.Options<E>, O>>(self: Effect<A, E, R>, options: O): Retry.Return<R, E, A, O>; <A, E, R, B, R1>(self: Effect<A, E, R>, policy: Schedule.Schedule<B, E, R1>): Effect<A, E, R1 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4383"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "retryOrElse",
    "description": "Retries a failing effect and runs a fallback effect if retries are exhausted.\n\n**Details**\n\nThe `Effect.retryOrElse` function attempts to retry a failing effect multiple\ntimes according to a defined {@link Schedule} policy.\n\nIf the retries are exhausted and the effect still fails, it runs a fallback\neffect instead.\n\n**When to Use**\n\nThis function is useful when you want to handle failures gracefully by\nspecifying an alternative action after repeated failures.\n\n**Example** (Retrying with Fallback)\n\n```ts\nimport { Effect, Schedule, Console } from \"effect\"\n\nlet count = 0\n\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\n  if (count <= 2) {\n    count++\n    console.log(\"failure\")\n    resume(Effect.fail(new Error()))\n  } else {\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\n// Retry the task with a delay between retries and a maximum of 2 retries\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n\n// If all retries fail, run the fallback effect\nconst repeated = Effect.retryOrElse(\n  task,\n  policy,\n  // fallback\n  () => Console.log(\"orElse\").pipe(Effect.as(\"default value\"))\n)\n\nEffect.runPromise(repeated).then(console.log)\n// Output:\n// failure\n// failure\n// failure\n// orElse\n// default value\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const retryOrElse: { <A1, E, R1, A2, E2, R2>(policy: Schedule.Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R1 | R2 | R>; <A, E, R, A1, R1, A2, E2, R2>(self: Effect<A, E, R>, policy: Schedule.Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R1 | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4462"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "tryMap",
    "description": "Returns an effect that maps its success using the specified side-effecting\n`try` function, converting any errors into typed failed effects using the\n`catch` function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const tryMap: { <A, B, E1>(options: { readonly try: (a: A) => B; readonly catch: (error: unknown) => E1; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>; <A, E, R, B, E1>(self: Effect<A, E, R>, options: { readonly try: (a: A) => B; readonly catch: (error: unknown) => E1; }): Effect<B, E | E1, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4552"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "tryMapPromise",
    "description": "Returns an effect that maps its success using the specified side-effecting\n`try` function, converting any promise rejections into typed failed effects\nusing the `catch` function.\n\nAn optional `AbortSignal` can be provided to allow for interruption of the\nwrapped `Promise` API.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const tryMapPromise: { <A, B, E1>(options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>; <A, E, R, B, E1>(self: Effect<A, E, R>, options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1; }): Effect<B, E | E1, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4575"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "tryPromise",
    "description": "Creates an `Effect` that represents an asynchronous computation that might\nfail.\n\n**When to Use**\n\nIn situations where you need to perform asynchronous operations that might\nfail, such as fetching data from an API, you can use the `tryPromise`\nconstructor. This constructor is designed to handle operations that could\nthrow exceptions by capturing those exceptions and transforming them into\nmanageable errors.\n\n**Error Handling**\n\nThere are two ways to handle errors with `tryPromise`:\n\n1. If you don't provide a `catch` function, the error is caught and the\n   effect fails with an `UnknownException`.\n2. If you provide a `catch` function, the error is caught and the `catch`\n   function maps it to an error of type `E`.\n\n**Interruptions**\n\nAn optional `AbortSignal` can be provided to allow for interruption of the\nwrapped `Promise` API.\n\n**Example** (Fetching a TODO Item)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst getTodo = (id: number) =>\n  // Will catch any errors and propagate them as UnknownException\n  Effect.tryPromise(() =>\n    fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)\n  )\n\n//       Effect<Response, UnknownException, never>\n//      \nconst program = getTodo(1)\n```\n\n**Example** (Custom Error Handling)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst getTodo = (id: number) =>\n  Effect.tryPromise({\n    try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),\n    // remap the error\n    catch: (unknown) => new Error(`something went wrong ${unknown}`)\n  })\n\n//       Effect<Response, Error, never>\n//      \nconst program = getTodo(1)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const tryPromise: { <A, E>(options: { readonly try: (signal: AbortSignal) => PromiseLike<A>; readonly catch: (error: unknown) => E; }): Effect<A, E>; <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect<A, Cause.UnknownException>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4649"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "unsandbox",
    "description": "The `unsandbox` function is used to revert an effect that has been\nsandboxed by {@link sandbox}. When you apply `unsandbox`, the\neffect's error channel is restored to its original state, without the\ndetailed `Cause<E>` information. This means that any underlying causes of\nerrors, defects, or fiber interruptions are no longer exposed in the error\nchannel.\n\nThis function is useful when you want to remove the detailed error tracking\nprovided by `sandbox` and return to the standard error handling for\nyour effect. Once unsandboxed, the effect behaves as if `sandbox` was\nnever applied.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const unsandbox: <A, E, R>(self: Effect<A, Cause.Cause<E>, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4677"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "allowInterrupt",
    "description": "Allows interruption of the current fiber, even in uninterruptible regions.\n\n**Details**\n\nThis effect checks whether any other fibers are attempting to interrupt the\ncurrent fiber. If so, it allows the current fiber to perform a\nself-interruption.\n\n**When to Use**\n\nThis is useful in situations where you want to allow interruption to happen\neven in regions of the code that are normally uninterruptible.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "declare const allowInterrupt: Effect<void, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4696"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "checkInterruptible",
    "description": "Checks if interruption is allowed and executes a callback accordingly.\n\n**Details**\n\nThis function checks the current interrupt status of the running fiber. It\nthen calls the provided callback, passing a boolean indicating whether\ninterruption is allowed.\n\n**When to Use**\n\nThis is useful for handling specific logic based on whether the current\noperation can be interrupted, such as when performing asynchronous operations\nor handling cancellation.\n\n**Example**\n\n```ts\nimport { Console, Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.checkInterruptible((isInterruptible) => {\n    if (isInterruptible) {\n      return Console.log(\"You can interrupt this operation.\")\n    } else {\n      return Console.log(\"This operation cannot be interrupted.\")\n    }\n  })\n})\n\nEffect.runPromise(program)\n// Output: You can interrupt this operation.\n\nEffect.runPromise(program.pipe(Effect.uninterruptible))\n// Output: This operation cannot be interrupted.\n\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "declare const checkInterruptible: <A, E, R>(f: (isInterruptible: boolean) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4739"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "disconnect",
    "description": "Provides a way to handle timeouts in uninterruptible effects, allowing them\nto continue in the background while the main control flow proceeds with the\ntimeout error.\n\n**Details**\n\nThe `disconnect` function allows an uninterruptible effect to continue\nrunning in the background, while enabling the main control flow to\nimmediately recognize a timeout condition. This is useful when you want to\navoid blocking the program due to long-running tasks, especially when those\ntasks do not need to affect the flow of the rest of the program.\n\nWithout `disconnect`, an uninterruptible effect will ignore the\ntimeout and continue executing until it completes. The timeout error will\nonly be assessed after the effect finishes, which can cause delays in\nrecognizing a timeout.\n\nWith `disconnect`, the uninterruptible effect proceeds in the\nbackground while the main program flow can immediately handle the timeout\nerror or trigger alternative logic. This enables faster timeout handling\nwithout waiting for the completion of the long-running task.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst longRunningTask = Effect.gen(function* () {\n  console.log(\"Start heavy processing...\")\n  yield* Effect.sleep(\"5 seconds\") // Simulate a long process\n  console.log(\"Heavy processing done.\")\n  return \"Data processed\"\n})\n\nconst timedEffect = longRunningTask.pipe(\n  Effect.uninterruptible,\n  // Allows the task to finish in the background if it times out\n  Effect.disconnect,\n  Effect.timeout(\"1 second\")\n)\n\nEffect.runPromiseExit(timedEffect).then(console.log)\n// Output:\n// Start heavy processing...\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: { _tag: 'TimeoutException' }\n//   }\n// }\n// Heavy processing done.\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "declare const disconnect: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4805"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "interrupt",
    "description": "Represents an effect that interrupts the current fiber.\n\n**Details**\n\nThis effect models the explicit interruption of the fiber in which it runs.\nWhen executed, it causes the fiber to stop its operation immediately,\ncapturing the interruption details such as the fiber's ID and its start time.\nThe resulting interruption can be observed in the `Exit` type if the effect\nis run with functions like {@link runPromiseExit}.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst program = Effect.gen(function* () {\n  console.log(\"start\")\n  yield* Effect.sleep(\"2 seconds\")\n  yield* Effect.interrupt\n  console.log(\"done\")\n  return \"some result\"\n})\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// start\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Interrupt',\n//     fiberId: {\n//       _id: 'FiberId',\n//       _tag: 'Runtime',\n//       id: 0,\n//       startTimeMillis: ...\n//     }\n//   }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "declare const interrupt: Effect<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4853"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "interruptWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "declare const interruptWith: (fiberId: FiberId.FiberId) => Effect<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4859"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "interruptible",
    "description": "Marks an effect as interruptible.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "declare const interruptible: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4867"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "interruptibleMask",
    "description": "This function behaves like {@link interruptible}, but it also provides a\n`restore` function. This function can be used to restore the interruptibility\nof any specific region of code.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "declare const interruptibleMask: <A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4877"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "onInterrupt",
    "description": "Registers a cleanup effect to run when an effect is interrupted.\n\n**Details**\n\nThis function allows you to specify an effect to run when the fiber is\ninterrupted. This effect will be executed when the fiber is interrupted,\nallowing you to perform cleanup or other actions.\n\n**Example** (Running a Cleanup Action on Interruption)\n\n```ts\nimport { Console, Effect } from \"effect\"\n\n// This handler is executed when the fiber is interrupted\nconst handler = Effect.onInterrupt((_fibers) => Console.log(\"Cleanup completed\"))\n\nconst success = Console.log(\"Task completed\").pipe(Effect.as(\"some result\"), handler)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n\nconst failure = Console.log(\"Task failed\").pipe(Effect.andThen(Effect.fail(\"some error\")), handler)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n\nconst interruption = Console.log(\"Task interrupted\").pipe(Effect.andThen(Effect.interrupt), handler)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "declare const onInterrupt: { <X, R2>(cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4921"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "uninterruptible",
    "description": "Marks an effect as uninterruptible.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "declare const uninterruptible: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4937"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "uninterruptibleMask",
    "description": "This function behaves like {@link uninterruptible}, but it also provides a\n`restore` function. This function can be used to restore the interruptibility\nof any specific region of code.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "declare const uninterruptibleMask: <A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4947"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "liftPredicate",
    "description": "Transforms a `Predicate` function into an `Effect` returning the input value if the predicate returns `true`\nor failing with specified error if the predicate fails\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst isPositive = (n: number): boolean => n > 0\n\n// succeeds with `1`\nEffect.liftPredicate(1, isPositive, n => `${n} is not positive`)\n\n// fails with `\"0 is not positive\"`\nEffect.liftPredicate(0, isPositive, n => `${n} is not positive`)\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "Condition Checking",
    "signature": "declare const liftPredicate: { <A, B extends A, E>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E): (a: A) => Effect<B, E>; <A, E>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E): (a: A) => Effect<A, E>; <A, E, B extends A>(self: A, refinement: Refinement<A, B>, orFailWith: (a: A) => E): Effect<B, E>; <A, E>(self: A, predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E): Effect<A, E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4972"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "as",
    "description": "Replaces the value inside an effect with a constant value.\n\n**Details**\n\nThis function allows you to ignore the original value inside an effect and\nreplace it with a constant value.\n\n**When to Use**\n\nIt is useful when you no longer need the value produced by an effect but want\nto ensure that the effect completes successfully with a specific constant\nresult instead. For instance, you can replace the value produced by a\ncomputation with a predefined value, ignoring what was calculated before.\n\n**Example** (Replacing a Value)\n\n```ts\nimport { pipe, Effect } from \"effect\"\n\n// Replaces the value 5 with the constant \"new value\"\nconst program = pipe(Effect.succeed(5), Effect.as(\"new value\"))\n\nEffect.runPromise(program).then(console.log)\n// Output: \"new value\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const as: { <B>(value: B): <A, E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A, E, R, B>(self: Effect<A, E, R>, value: B): Effect<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5012"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "asSome",
    "description": "This function maps the success value of an `Effect` value to a `Some` value\nin an `Option` value. If the original `Effect` value fails, the returned\n`Effect` value will also fail.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const asSome: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5025"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "asSomeError",
    "description": "This function maps the error value of an `Effect` value to a `Some` value\nin an `Option` value. If the original `Effect` value succeeds, the returned\n`Effect` value will also succeed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const asSomeError: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Option.Option<E>, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5035"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "asVoid",
    "description": "This function maps the success value of an `Effect` value to `void`. If the\noriginal `Effect` value succeeds, the returned `Effect` value will also\nsucceed. If the original `Effect` value fails, the returned `Effect` value\nwill fail with the same error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const asVoid: <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5046"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "flip",
    "description": "Swaps the success and error channels of an effect.\n\n**Details**\n\nThis function reverses the flow of an effect by swapping its success and\nerror channels. The success value becomes an error, and the error value\nbecomes a success.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n//       Effect<number, string, never>\n//      \nconst program = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n\n//       Effect<string, number, never>\n//      \nconst flipped = Effect.flip(program)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const flip: <A, E, R>(self: Effect<A, E, R>) => Effect<E, A, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5074"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "flipWith",
    "description": "Swaps the error/value parameters, applies the function `f` and flips the\nparameters back",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const flipWith: { <E, A, R, E2, A2, R2>(f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): (self: Effect<A, E, R>) => Effect<A2, E2, R2>; <A, E, R, E2, A2, R2>(self: Effect<A, E, R>, f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): Effect<A2, E2, R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5083"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms the value inside an effect by applying a function to it.\n\n**Syntax**\n\n```ts skip-type-checking\nconst mappedEffect = pipe(myEffect, Effect.map(transformation))\n// or\nconst mappedEffect = Effect.map(myEffect, transformation)\n// or\nconst mappedEffect = myEffect.pipe(Effect.map(transformation))\n```\n\n**Details**\n\n`map` takes a function and applies it to the value contained within an\neffect, creating a new effect with the transformed value.\n\nIt's important to note that effects are immutable, meaning that the original\neffect is not modified. Instead, a new effect is returned with the updated\nvalue.\n\n**Example** (Adding a Service Charge)\n\n```ts\nimport { pipe, Effect } from \"effect\"\n\nconst addServiceCharge = (amount: number) => amount + 1\n\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  Effect.map(addServiceCharge)\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output: 101\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A, E, R, B>(self: Effect<A, E, R>, f: (a: A) => B): Effect<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5140"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "mapAccum",
    "description": "Applies a stateful transformation to each element of a collection, producing\nnew elements along with an updated state.\n\n**When to Use**\n\nUse `mapAccum` when you need to process each element of a collection while\nkeeping track of some state across iterations.\n\n**Details**\n\n`mapAccum` takes an initial state (`initial`) and a function (`f`) that is\napplied to each element. This function returns a new state and a transformed\nelement. The final effect produces both the accumulated state and the\ntransformed collection.\n\nIf the input collection is a non-empty array, the return type will match the\ninput collection type.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n// Define an initial state and a transformation function\nconst initialState = 0\n\nconst transformation = (state: number, element: string) =>\n  Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])\n\n// Apply mapAccum to transform an array of strings\nconst program = Effect.mapAccum([\"a\", \"bb\", \"ccc\"], initialState, transformation)\n\nEffect.runPromise(program).then(([finalState, transformedCollection]) => {\n  console.log(finalState)\n  console.log(transformedCollection)\n})\n// Output:\n// 6\n// [ 'A', 'BB', 'CCC' ]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const mapAccum: { <S, A, B, E, R, I extends Iterable<A> = Iterable<A>>(initial: S, f: (state: S, a: RA.ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>): (elements: I) => Effect<[S, RA.ReadonlyArray.With<I, B>], E, R>; <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(elements: I, initial: S, f: (state: S, a: RA.ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>): Effect<[S, RA.ReadonlyArray.With<I, B>], E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5190"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "mapBoth",
    "description": "Applies transformations to both the success and error channels of an effect.\n\n**Details**\n\nThis function takes two map functions as arguments: one for the error channel\nand one for the success channel. You can use it when you want to modify both\nthe error and the success values without altering the overall success or\nfailure status of the effect.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n//       Effect<number, string, never>\n//      \nconst simulatedTask = Effect.fail(\"Oh no!\").pipe(Effect.as(1))\n\n//       Effect<boolean, Error, never>\n//      \nconst modified = Effect.mapBoth(simulatedTask, {\n  onFailure: (message) => new Error(message),\n  onSuccess: (n) => n > 0\n})\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Effect<A, E, R>) => Effect<A2, E2, R>; <A, E, R, E2, A2>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Effect<A2, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5235"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "mapError",
    "description": "Transforms or modifies the error produced by an effect without affecting its\nsuccess value.\n\n**When to Use**\n\nThis function is helpful when you want to enhance the error with additional\ninformation, change the error type, or apply custom error handling while\nkeeping the original behavior of the effect's success values intact. It only\noperates on the error channel and leaves the success channel unchanged.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n//       Effect<number, string, never>\n//      \nconst simulatedTask = Effect.fail(\"Oh no!\").pipe(Effect.as(1))\n\n//       Effect<number, Error, never>\n//      \nconst mapped = Effect.mapError(\n  simulatedTask,\n  (message) => new Error(message)\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const mapError: { <E, E2>(f: (e: E) => E2): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, f: (e: E) => E2): Effect<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5280"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "mapErrorCause",
    "description": "Maps the cause of failure of an effect using a specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const mapErrorCause: { <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Effect<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5294"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "merge",
    "description": "Combines both success and error channels of an effect into a single outcome.\n\n**Details**\n\nThis function transforms an effect that may fail into one that always returns\na value, where both success and failure outcomes are handled as values in the\nsuccess channel.\n\n**When to Use**\n\nThis can be useful when you want to continue execution regardless of the\nerror type and still capture both successful results and errors as part of\nthe outcome.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n//       Effect<number, string, never>\n//      \nconst program = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n\n//       Effect<number | string, never, never>\n//      \nconst recovered = Effect.merge(program)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const merge: <A, E, R>(self: Effect<A, E, R>) => Effect<E | A, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5331"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "negate",
    "description": "Returns a new effect with the boolean value of this effect negated.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const negate: <E, R>(self: Effect<boolean, E, R>) => Effect<boolean, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5339"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "acquireRelease",
    "description": "Creates a scoped resource using an `acquire` and `release` effect.\n\n**Details**\n\nThis function helps manage resources by combining two `Effect` values: one\nfor acquiring the resource and one for releasing it.\n\n`acquireRelease` does the following:\n\n  1. Ensures that the effect that acquires the resource will not be\n     interrupted. Note that acquisition may still fail due to internal\n     reasons (such as an uncaught exception).\n  2. Ensures that the `release` effect will not be interrupted, and will be\n     executed as long as the acquisition effect successfully acquires the\n     resource.\n\nIf the `acquire` function succeeds, the `release` function is added to the\nlist of finalizers for the scope. This ensures that the release will happen\nautomatically when the scope is closed.\n\nBoth `acquire` and `release` run uninterruptibly, meaning they cannot be\ninterrupted while they are executing.\n\nAdditionally, the `release` function can be influenced by the exit value when\nthe scope closes, allowing for custom handling of how the resource is\nreleased based on the execution outcome.\n\n**When to Use**\n\nThis function is used to ensure that an effect that represents the\nacquisition of a resource (for example, opening a file, launching a thread,\netc.) will not be interrupted, and that the resource will always be released\nwhen the `Effect` completes execution.\n\n**Example** (Defining a Simple Resource)\n\n```ts\nimport { Effect } from \"effect\"\n\n// Define an interface for a resource\ninterface MyResource {\n  readonly contents: string\n  readonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\n  Promise.resolve({\n    contents: \"lorem ipsum\",\n    close: () =>\n      new Promise((resolve) => {\n        console.log(\"Resource released\")\n        resolve()\n      })\n  })\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\n  try: () =>\n    getMyResource().then((res) => {\n      console.log(\"Resource acquired\")\n      return res\n    }),\n  catch: () => new Error(\"getMyResourceError\")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\n// Create the resource management workflow\n//\n//       Effect<MyResource, Error, Scope>\n//      \nconst resource = Effect.acquireRelease(acquire, release)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const acquireRelease: { <A, X, R2>(release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): <E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope.Scope | R2 | R>; <A, E, R, X, R2>(acquire: Effect<A, E, R>, release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): Effect<A, E, Scope.Scope | R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5423"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "acquireReleaseInterruptible",
    "description": "Creates a scoped resource with an interruptible acquire action.\n\n**Details**\n\nThis function is similar to {@link acquireRelease}, but it allows the\nacquisition of the resource to be interrupted. The `acquire` effect, which\nrepresents the process of obtaining the resource, can be interrupted if\nnecessary.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const acquireReleaseInterruptible: { <X, R2>(release: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): <A, E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope.Scope | R2 | R>; <A, E, R, X, R2>(acquire: Effect<A, E, R>, release: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): Effect<A, E, Scope.Scope | R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5446"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "acquireUseRelease",
    "description": "Many real-world operations involve working with resources that must be released when no longer needed, such as:\n\n- Database connections\n- File handles\n- Network requests\n\nThis function ensures that a resource is:\n\n1. **Acquired** properly.\n2. **Used** for its intended purpose.\n3. **Released** even if an error occurs.\n\n**Example** (Automatically Managing Resource Lifetime)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n// Define an interface for a resource\ninterface MyResource {\n  readonly contents: string\n  readonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\n  Promise.resolve({\n    contents: \"lorem ipsum\",\n    close: () =>\n      new Promise((resolve) => {\n        console.log(\"Resource released\")\n        resolve()\n      })\n  })\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\n  try: () =>\n    getMyResource().then((res) => {\n      console.log(\"Resource acquired\")\n      return res\n    }),\n  catch: () => new Error(\"getMyResourceError\")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\nconst use = (res: MyResource) => Console.log(`content is ${res.contents}`)\n\n//       Effect<void, Error, never>\n//      \nconst program = Effect.acquireUseRelease(acquire, use, release)\n\nEffect.runPromise(program)\n// Output:\n// Resource acquired\n// content is lorem ipsum\n// Resource released\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const acquireUseRelease: { <A2, E2, R2, A, X, R3>(use: (a: A) => Effect<A2, E2, R2>, release: (a: A, exit: Exit.Exit<A2, E2>) => Effect<X, never, R3>): <E, R>(acquire: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, X, R3>(acquire: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>, release: (a: A, exit: Exit.Exit<A2, E2>) => Effect<X, never, R3>): Effect<A2, E | E2, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5520"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "addFinalizer",
    "description": "Ensures a finalizer is added to the scope of the calling effect, guaranteeing\nit runs when the scope is closed.\n\n**Details**\n\nThis function adds a finalizer that will execute whenever the scope of the\neffect is closed, regardless of whether the effect succeeds, fails, or is\ninterrupted. The finalizer receives the `Exit` value of the effect's scope,\nallowing it to react differently depending on how the effect concludes.\n\nFinalizers are a reliable way to manage resource cleanup, ensuring that\nresources such as file handles, network connections, or database transactions\nare properly closed even in the event of an unexpected interruption or error.\n\nFinalizers operate in conjunction with Effect's scoped resources. If an\neffect with a finalizer is wrapped in a scope, the finalizer will execute\nautomatically when the scope ends.\n\n**Example** (Adding a Finalizer on Success)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n//       Effect<string, never, Scope>\n//      \nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return \"some result\"\n})\n\n// Wrapping the effect in a scope\n//\n//       Effect<string, never, never>\n//      \nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Success\n// { _id: 'Exit', _tag: 'Success', value: 'some result' }\n```\n\n**Example** (Adding a Finalizer on Failure)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n//       Effect<never, string, Scope>\n//      \nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return yield* Effect.fail(\"Uh oh!\")\n})\n\n// Wrapping the effect in a scope\n//\n//       Effect<never, string, never>\n//      \nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }\n// }\n```\n\n**Example** (Adding a Finalizer on Interruption)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n//       Effect<never, never, Scope>\n//      \nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return yield* Effect.interrupt\n})\n\n// Wrapping the effect in a scope\n//\n//       Effect<never, never, never>\n//      \nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Interrupt',\n//     fiberId: {\n//       _id: 'FiberId',\n//       _tag: 'Runtime',\n//       id: 0,\n//       startTimeMillis: ...\n//     }\n//   }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const addFinalizer: <X, R>(finalizer: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R>) => Effect<void, never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5651"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "ensuring",
    "description": "Guarantees the execution of a finalizer when an effect starts execution.\n\n**Details**\n\nThis function allows you to specify a `finalizer` effect that will always be\nrun once the effect starts execution, regardless of whether the effect\nsucceeds, fails, or is interrupted.\n\n**When to Use**\n\nThis is useful when you need to ensure that certain cleanup or final steps\nare executed in all cases, such as releasing resources or performing\nnecessary logging.\n\nWhile this function provides strong guarantees about executing the finalizer,\nit is considered a low-level tool, which may not be ideal for more complex\nresource management. For higher-level resource management with automatic\nacquisition and release, see the {@link acquireRelease} family of functions.\nFor use cases where you need access to the result of an effect, consider\nusing {@link onExit}.\n\n**Example** (Running a Finalizer in All Outcomes)\n\n```ts\nimport { Console, Effect } from \"effect\"\n\n// Define a cleanup effect\nconst handler = Effect.ensuring(Console.log(\"Cleanup completed\"))\n\n// Define a successful effect\nconst success = Console.log(\"Task completed\").pipe(\n  Effect.as(\"some result\"),\n  handler\n)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n// Cleanup completed\n\n// Define a failing effect\nconst failure = Console.log(\"Task failed\").pipe(\n  Effect.andThen(Effect.fail(\"some error\")),\n  handler\n)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed\n\n// Define an interrupted effect\nconst interruption = Console.log(\"Task interrupted\").pipe(\n  Effect.andThen(Effect.interrupt),\n  handler\n)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const ensuring: { <X, R1>(finalizer: Effect<X, never, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, X, R1>(self: Effect<A, E, R>, finalizer: Effect<X, never, R1>): Effect<A, E, R1 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5725"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "onError",
    "description": "Ensures a cleanup effect runs whenever the calling effect fails, providing\nthe failure cause to the cleanup effect.\n\n**Details**\n\nThis function allows you to attach a cleanup effect that runs whenever the\ncalling effect fails. The cleanup effect receives the cause of the failure,\nallowing you to perform actions such as logging, releasing resources, or\nexecuting additional recovery logic based on the error. The cleanup effect\nwill execute even if the failure is due to interruption.\n\nImportantly, the cleanup effect itself is uninterruptible, ensuring that it\ncompletes regardless of external interruptions.\n\n**Example** (Running Cleanup Only on Failure)\n\n```ts\nimport { Console, Effect } from \"effect\"\n\n// This handler logs the failure cause when the effect fails\nconst handler = Effect.onError((cause) =>\n  Console.log(`Cleanup completed: ${cause}`)\n)\n\n// Define a successful effect\nconst success = Console.log(\"Task completed\").pipe(\n  Effect.as(\"some result\"),\n  handler\n)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n\n// Define a failing effect\nconst failure = Console.log(\"Task failed\").pipe(\n  Effect.andThen(Effect.fail(\"some error\")),\n  handler\n)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed: Error: some error\n\n// Define a failing effect\nconst defect = Console.log(\"Task failed with defect\").pipe(\n  Effect.andThen(Effect.die(\"Boom!\")),\n  handler\n)\n\nEffect.runFork(defect)\n// Output:\n// Task failed with defect\n// Cleanup completed: Error: Boom!\n\n// Define an interrupted effect\nconst interruption = Console.log(\"Task interrupted\").pipe(\n  Effect.andThen(Effect.interrupt),\n  handler\n)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed: All fibers interrupted without errors.\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const onError: { <E, X, R2>(cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>): Effect<A, E, R2 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5805"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "onExit",
    "description": "Guarantees that a cleanup function runs regardless of whether the effect\nsucceeds, fails, or is interrupted.\n\n**Details**\n\nThis function ensures that a provided cleanup function is executed after the\neffect completes, regardless of the outcome. The cleanup function is given\nthe `Exit` value of the effect, which provides detailed information about the\nresult:\n- If the effect succeeds, the `Exit` contains the success value.\n- If the effect fails, the `Exit` contains the error or failure cause.\n- If the effect is interrupted, the `Exit` reflects the interruption.\n\nThe cleanup function is guaranteed to run uninterruptibly, ensuring reliable\nresource management even in complex or high-concurrency scenarios.\n\n**Example** (Running a Cleanup Function with the Effects Result)\n\n```ts\nimport { Console, Effect, Exit } from \"effect\"\n\n// Define a cleanup effect that logs the result\nconst handler = Effect.onExit((exit) =>\n  Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)\n)\n\n// Define a successful effect\nconst success = Console.log(\"Task completed\").pipe(\n  Effect.as(\"some result\"),\n  handler\n)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n// Cleanup completed: some result\n\n// Define a failing effect\nconst failure = Console.log(\"Task failed\").pipe(\n  Effect.andThen(Effect.fail(\"some error\")),\n  handler\n)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed: Error: some error\n\n// Define an interrupted effect\nconst interruption = Console.log(\"Task interrupted\").pipe(\n  Effect.andThen(Effect.interrupt),\n  handler\n)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed: All fibers interrupted without errors.\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const onExit: { <A, E, X, R2>(cleanup: (exit: Exit.Exit<A, E>) => Effect<X, never, R2>): <R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (exit: Exit.Exit<A, E>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5879"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "parallelFinalizers",
    "description": "Ensures that finalizers are run concurrently when the scope of an effect is\nclosed.\n\n**Details**\n\nThis function modifies the behavior of finalizers within a scoped workflow to\nallow them to run concurrently when the scope is closed.\n\nBy default, finalizers are executed sequentially in reverse order of their\naddition, but this function changes that behavior to execute all finalizers\nconcurrently.\n\n**When to Use**\n\nRunning finalizers concurrently can improve performance when multiple\nindependent cleanup tasks need to be performed. However, it requires that\nthese tasks do not depend on the order of execution or introduce race\nconditions.\n\n**Example**\n\n```ts\nimport { Console, Effect } from \"effect\"\n\n// Define a program that adds multiple finalizers\nconst program = Effect.gen(function*() {\n  yield* Effect.addFinalizer(() => Console.log(\"Finalizer 1 executed\").pipe(Effect.delay(\"300 millis\")))\n  yield* Effect.addFinalizer(() => Console.log(\"Finalizer 2 executed\").pipe(Effect.delay(\"100 millis\")))\n  yield* Effect.addFinalizer(() => Console.log(\"Finalizer 3 executed\").pipe(Effect.delay(\"200 millis\")))\n  return \"some result\"\n})\n\n// Modify the program to ensure finalizers run in parallel\nconst modified = program.pipe(Effect.parallelFinalizers)\n\nconst runnable = Effect.scoped(modified)\n\nEffect.runFork(runnable)\n// Output:\n// Finalizer 2 executed\n// Finalizer 3 executed\n// Finalizer 1 executed\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const parallelFinalizers: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5939"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "sequentialFinalizers",
    "description": "Ensures that finalizers are run sequentially in reverse order of their\naddition.\n\n**Details**\n\nThis function modifies the behavior of finalizers within a scoped workflow to\nensure they are run sequentially in reverse order when the scope is closed.\n\nBy default, finalizers are executed sequentially, so this only changes the\nbehavior if the scope is configured to run finalizers concurrently.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const sequentialFinalizers: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5958"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "finalizersMask",
    "description": "Applies a custom execution strategy to finalizers within a scoped workflow.\n\n**Details**\n\nThis function allows you to control how finalizers are executed in a scope by\napplying a specified `ExecutionStrategy`. The `strategy` can dictate whether\nfinalizers run (e.g., sequentially or in parallel).\n\nAdditionally, the function provides a `restore` operation, which ensures that\nthe effect passed to it is executed under the default execution strategy.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const finalizersMask: (strategy: ExecutionStrategy) => <A, E, R>(self: (restore: <A1, E1, R1>(self: Effect<A1, E1, R1>) => Effect<A1, E1, R1>) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5976"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "scope",
    "description": "Provides access to the current scope in a scoped workflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const scope: Effect<Scope.Scope, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5988"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "scopeWith",
    "description": "Accesses the current scope and uses it to perform the specified effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const scopeWith: <A, E, R>(f: (scope: Scope.Scope) => Effect<A, E, R>) => Effect<A, E, R | Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L5996"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "scopedWith",
    "description": "Creates a `Scope`, passes it to the specified effectful function, and closes\nthe scope when the effect completes (whether through success, failure, or\ninterruption).",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6007"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "scoped",
    "description": "Scopes all resources used in an effect to the lifetime of the effect.\n\n**Details**\n\nThis function ensures that all resources used within an effect are tied to\nits lifetime. Finalizers for these resources are executed automatically when\nthe effect completes, whether through success, failure, or interruption. This\nguarantees proper resource cleanup without requiring explicit management.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const scoped: <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, Scope.Scope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6023"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "using",
    "description": "Scopes all resources acquired by one effect to the lifetime of another\neffect.\n\n**Details**\n\nThis function allows you to scope the resources acquired by one effect\n(`self`) to the lifetime of another effect (`use`). This ensures that the\nresources are cleaned up as soon as the `use` effect completes, regardless of\nhow the `use` effect ends (success, failure, or interruption).\n\n**Example**\n\n```ts\nimport { Console, Effect } from \"effect\"\n\nconst acquire = Console.log(\"Acquiring resource\").pipe(\n  Effect.as(1),\n  Effect.tap(Effect.addFinalizer(() => Console.log(\"Releasing resource\")))\n)\nconst use = (resource: number) => Console.log(`Using resource: ${resource}`)\n\nconst program = acquire.pipe(Effect.using(use))\n\nEffect.runFork(program)\n// Output:\n// Acquiring resource\n// Using resource: 1\n// Releasing resource\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const using: { <A, A2, E2, R2>(use: (a: A) => Effect<A2, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | Exclude<R, Scope.Scope>>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>): Effect<A2, E | E2, R2 | Exclude<R, Scope.Scope>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6062"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withEarlyRelease",
    "description": "Returns the result of the effect and a finalizer to close its scope.\n\n**Details**\n\nThis function allows you to retrieve both the result of an effect and a\nfinalizer that can be used to manually close its scope. This is useful for\nworkflows where you need early access to the result while retaining control\nover the resource cleanup process.\n\n**Example**\n\n```ts\nimport { Console, Effect } from \"effect\"\n\nconst acquire = Console.log(\"Acquiring resource\").pipe(\n  Effect.as(1),\n  Effect.tap(Effect.addFinalizer(() => Console.log(\"Releasing resource\")))\n)\nconst program = Effect.gen(function*() {\n  const [finalizer, resource] = yield* Effect.withEarlyRelease(acquire)\n  console.log(`Using resource: ${resource}`)\n  yield* Effect.sleep(\"1 second\")\n  yield* finalizer\n})\n\nEffect.runFork(program.pipe(Effect.scoped))\n// Output:\n// Acquiring resource\n// Using resource: 1\n// Releasing resource\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "declare const withEarlyRelease: <A, E, R>(self: Effect<A, E, R>) => Effect<[finalizer: Effect<void>, result: A], E, R | Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6108"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "awaitAllChildren",
    "description": "Returns a new effect that will not succeed with its value before first\nwaiting for the end of all child fibers forked by the effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const awaitAllChildren: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6119"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "daemonChildren",
    "description": "Returns a new workflow that will not supervise any fibers forked by this\nworkflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const daemonChildren: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6128"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "descriptor",
    "description": "Constructs an effect with information about the current `Fiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const descriptor: Effect<Fiber.Fiber.Descriptor, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6136"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "descriptorWith",
    "description": "Constructs an effect based on information about the current `Fiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const descriptorWith: <A, E, R>(f: (descriptor: Fiber.Fiber.Descriptor) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6144"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "diffFiberRefs",
    "description": "Returns a new workflow that executes this one and captures the changes in\n`FiberRef` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const diffFiberRefs: <A, E, R>(self: Effect<A, E, R>) => Effect<[FiberRefsPatch.FiberRefsPatch, A], E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6154"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "ensuringChild",
    "description": "Acts on the children of this fiber (collected into a single fiber),\nguaranteeing the specified callback will be invoked, whether or not this\neffect succeeds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const ensuringChild: { <X, R2>(f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6166"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "ensuringChildren",
    "description": "Acts on the children of this fiber, guaranteeing the specified callback\nwill be invoked, whether or not this effect succeeds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const ensuringChildren: { <X, R2>(children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6183"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "fiberId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const fiberId: Effect<FiberId.FiberId, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6197"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "fiberIdWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const fiberIdWith: <A, E, R>(f: (descriptor: FiberId.Runtime) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6203"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "fork",
    "description": "Creates a new fiber to run an effect concurrently.\n\n**Details**\n\nThis function takes an effect and forks it into a separate fiber, allowing it\nto run concurrently without blocking the original effect. The new fiber\nstarts execution immediately after being created, and the fiber object is\nreturned immediately without waiting for the effect to begin. This is useful\nwhen you want to run tasks concurrently while continuing other tasks in the\nparent fiber.\n\nThe forked fiber is attached to the parent fiber's scope. This means that\nwhen the parent fiber terminates, the child fiber will also be terminated\nautomatically. This feature, known as \"auto supervision,\" ensures that no\nfibers are left running unintentionally. If you prefer not to have this auto\nsupervision behavior, you can use {@link forkDaemon} or {@link forkIn}.\n\n**When to Use**\n\nUse this function when you need to run an effect concurrently without\nblocking the current execution flow. For example, you might use it to launch\nbackground tasks or concurrent computations. However, working with fibers can\nbe complex, so before using this function directly, you might want to explore\nhigher-level functions like {@link raceWith}, {@link zip}, or others that can\nmanage concurrency for you.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst fib = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(n)\n    : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)\n\n//       Effect<RuntimeFiber<number, never>, never, never>\n//      \nconst fib10Fiber = Effect.fork(fib(10))\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const fork: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6253"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "forkDaemon",
    "description": "Creates a long-running background fiber that is independent of its parent.\n\n**Details**\n\nThis function creates a \"daemon\" fiber that runs in the background and is not\ntied to the lifecycle of its parent fiber. Unlike normal fibers that stop\nwhen the parent fiber terminates, a daemon fiber will continue running until\nthe global scope closes or the fiber completes naturally. This makes it\nuseful for tasks that need to run in the background independently, such as\nperiodic logging, monitoring, or background data processing.\n\n**Example** (Creating a Daemon Fiber)\n\n```ts\nimport { Effect, Console, Schedule } from \"effect\"\n\n// Daemon fiber that logs a message repeatedly every second\nconst daemon = Effect.repeat(\n  Console.log(\"daemon: still running!\"),\n  Schedule.fixed(\"1 second\")\n)\n\nconst parent = Effect.gen(function* () {\n  console.log(\"parent: started!\")\n  // Daemon fiber running independently\n  yield* Effect.forkDaemon(daemon)\n  yield* Effect.sleep(\"3 seconds\")\n  console.log(\"parent: finished!\")\n})\n\nEffect.runFork(parent)\n// Output:\n// parent: started!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// parent: finished!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// ...etc...\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const forkDaemon: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6304"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "forkAll",
    "description": "Returns an effect that forks all of the specified values, and returns a\ncomposite fiber that produces a list of their results, in order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const forkAll: { (options?: { readonly discard?: false | undefined; } | undefined): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Fiber.Fiber<Array<Effect.Success<Eff>>, Effect.Error<Eff>>, never, Effect.Context<Eff>>; (options: { readonly discard: true; }): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<void, never, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options?: { readonly discard?: false | undefined; } | undefined): Effect<Fiber.Fiber<Array<Effect.Success<Eff>>, Effect.Error<Eff>>, never, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options: { readonly discard: true; }): Effect<void, never, Effect.Context<Eff>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6314"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "forkIn",
    "description": "Forks an effect in a specific scope, allowing finer control over its\nexecution.\n\n**Details**\n\nThere are some cases where we need more fine-grained control, so we want to\nfork a fiber in a specific scope. We can use the `Effect.forkIn` operator\nwhich takes the target scope as an argument.\n\nThe fiber will be interrupted when the scope is closed.\n\n**Example** (Forking a Fiber in a Specific Scope)\n\nIn this example, the child fiber is forked into the outerScope,\nallowing it to outlive the inner scope but still be terminated\nwhen the outerScope is closed.\n\n```ts\nimport { Console, Effect, Schedule } from \"effect\"\n\n// Child fiber that logs a message repeatedly every second\nconst child = Effect.repeat(\n  Console.log(\"child: still running!\"),\n  Schedule.fixed(\"1 second\")\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function* () {\n    yield* Effect.addFinalizer(() =>\n      Console.log(\"The outer scope is about to be closed!\")\n    )\n\n    // Capture the outer scope\n    const outerScope = yield* Effect.scope\n\n    // Create an inner scope\n    yield* Effect.scoped(\n      Effect.gen(function* () {\n        yield* Effect.addFinalizer(() =>\n          Console.log(\"The inner scope is about to be closed!\")\n        )\n        // Fork the child fiber in the outer scope\n        yield* Effect.forkIn(child, outerScope)\n        yield* Effect.sleep(\"3 seconds\")\n      })\n    )\n\n    yield* Effect.sleep(\"5 seconds\")\n  })\n)\n\nEffect.runFork(program)\n// Output:\n// child: still running!\n// child: still running!\n// child: still running!\n// The inner scope is about to be closed!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// The outer scope is about to be closed!\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const forkIn: { (scope: Scope.Scope): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>; <A, E, R>(self: Effect<A, E, R>, scope: Scope.Scope): Effect<Fiber.RuntimeFiber<A, E>, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6403"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "forkScoped",
    "description": "Forks a fiber in a local scope, ensuring it outlives its parent.\n\n**Details**\n\nThis function is used to create fibers that are tied to a local scope,\nmeaning they are not dependent on their parent fiber's lifecycle. Instead,\nthey will continue running until the scope they were created in is closed.\nThis is particularly useful when you need a fiber to run independently of the\nparent fiber, but still want it to be terminated when the scope ends.\n\nFibers created with this function are isolated from the parent fibers\ntermination, so they can run for a longer period. This behavior is different\nfrom fibers created with {@link fork}, which are terminated when the parent fiber\nterminates. With `forkScoped`, the child fiber will keep running until the\nlocal scope ends, regardless of the state of the parent fiber.\n\n**Example** (Forking a Fiber in a Local Scope)\n\nIn this example, the child fiber continues to run beyond the lifetime of the parent fiber.\nThe child fiber is tied to the local scope and will be terminated only when the scope ends.\n\n```ts\nimport { Effect, Console, Schedule } from \"effect\"\n\n// Child fiber that logs a message repeatedly every second\nconst child = Effect.repeat(\n  Console.log(\"child: still running!\"),\n  Schedule.fixed(\"1 second\")\n)\n\n//       Effect<void, never, Scope>\n//      \nconst parent = Effect.gen(function* () {\n  console.log(\"parent: started!\")\n  // Child fiber attached to local scope\n  yield* Effect.forkScoped(child)\n  yield* Effect.sleep(\"3 seconds\")\n  console.log(\"parent: finished!\")\n})\n\n// Program runs within a local scope\nconst program = Effect.scoped(\n  Effect.gen(function* () {\n    console.log(\"Local scope started!\")\n    yield* Effect.fork(parent)\n    // Scope lasts for 5 seconds\n    yield* Effect.sleep(\"5 seconds\")\n    console.log(\"Leaving the local scope!\")\n  })\n)\n\nEffect.runFork(program)\n// Output:\n// Local scope started!\n// parent: started!\n// child: still running!\n// child: still running!\n// child: still running!\n// parent: finished!\n// child: still running!\n// child: still running!\n// Leaving the local scope!\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const forkScoped: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6476"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "forkWithErrorHandler",
    "description": "Like {@link fork} but handles an error with the provided handler.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const forkWithErrorHandler: { <E, X>(handler: (e: E) => Effect<X>): <A, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>; <A, E, R, X>(self: Effect<A, E, R>, handler: (e: E) => Effect<X>): Effect<Fiber.RuntimeFiber<A, E>, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6485"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "fromFiber",
    "description": "Creates an `Effect` value that represents the exit value of the specified\nfiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const fromFiber: <A, E>(fiber: Fiber.Fiber<A, E>) => Effect<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6504"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "fromFiberEffect",
    "description": "Creates an `Effect` value that represents the exit value of a fiber obtained\nfrom an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const fromFiberEffect: <A, E, R>(fiber: Effect<Fiber.Fiber<A, E>, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6515"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "supervised",
    "description": "Supervises child fibers by reporting them to a specified supervisor.\n\n**Details**\n\nThis function takes a supervisor as an argument and returns an effect where\nall child fibers forked within it are supervised by the provided supervisor.\nThis enables you to capture detailed information about these child fibers,\nsuch as their status, through the supervisor.\n\n**Example** (Monitoring Fiber Count)\n\n```ts\nimport { Effect, Supervisor, Schedule, Fiber, FiberStatus } from \"effect\"\n\n// Main program that monitors fibers while calculating a Fibonacci number\nconst program = Effect.gen(function* () {\n  // Create a supervisor to track child fibers\n  const supervisor = yield* Supervisor.track\n\n  // Start a Fibonacci calculation, supervised by the supervisor\n  const fibFiber = yield* fib(20).pipe(\n    Effect.supervised(supervisor),\n    // Fork the Fibonacci effect into a fiber\n    Effect.fork\n  )\n\n  // Define a schedule to periodically monitor the fiber count every 500ms\n  const policy = Schedule.spaced(\"500 millis\").pipe(\n    Schedule.whileInputEffect((_) =>\n      Fiber.status(fibFiber).pipe(\n        // Continue while the Fibonacci fiber is not done\n        Effect.andThen((status) => status !== FiberStatus.done)\n      )\n    )\n  )\n\n  // Start monitoring the fibers, using the supervisor to track the count\n  const monitorFiber = yield* monitorFibers(supervisor).pipe(\n    // Repeat the monitoring according to the schedule\n    Effect.repeat(policy),\n    // Fork the monitoring into its own fiber\n    Effect.fork\n  )\n\n  // Join the monitor and Fibonacci fibers to ensure they complete\n  yield* Fiber.join(monitorFiber)\n  const result = yield* Fiber.join(fibFiber)\n\n  console.log(`fibonacci result: ${result}`)\n})\n\n// Function to monitor and log the number of active fibers\nconst monitorFibers = (\n  supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    const fibers = yield* supervisor.value // Get the current set of fibers\n    console.log(`number of fibers: ${fibers.length}`)\n  })\n\n// Recursive Fibonacci calculation, spawning fibers for each recursive step\nconst fib = (n: number): Effect.Effect<number> =>\n  Effect.gen(function* () {\n    if (n <= 1) {\n      return 1\n    }\n    yield* Effect.sleep(\"500 millis\") // Simulate work by delaying\n\n    // Fork two fibers for the recursive Fibonacci calls\n    const fiber1 = yield* Effect.fork(fib(n - 2))\n    const fiber2 = yield* Effect.fork(fib(n - 1))\n\n    // Join the fibers to retrieve their results\n    const v1 = yield* Fiber.join(fiber1)\n    const v2 = yield* Fiber.join(fiber2)\n\n    return v1 + v2 // Combine the results\n  })\n\nEffect.runPromise(program)\n// Output:\n// number of fibers: 0\n// number of fibers: 2\n// number of fibers: 6\n// number of fibers: 14\n// number of fibers: 30\n// number of fibers: 62\n// number of fibers: 126\n// number of fibers: 254\n// number of fibers: 510\n// number of fibers: 1022\n// number of fibers: 2034\n// number of fibers: 3795\n// number of fibers: 5810\n// number of fibers: 6474\n// number of fibers: 4942\n// number of fibers: 2515\n// number of fibers: 832\n// number of fibers: 170\n// number of fibers: 18\n// number of fibers: 0\n// fibonacci result: 10946\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const supervised: { <X>(supervisor: Supervisor.Supervisor<X>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, X>(self: Effect<A, E, R>, supervisor: Supervisor.Supervisor<X>): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6626"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "transplant",
    "description": "Transplants specified effects so that when those effects fork other\neffects, the forked effects will be governed by the scope of the fiber that\nexecutes this effect.\n\nThis can be used to \"graft\" deep grandchildren onto a higher-level scope,\neffectively extending their lifespans into the parent scope.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const transplant: <A, E, R>(f: (grafter: <A2, E2, R2>(effect: Effect<A2, E2, R2>) => Effect<A2, E2, R2>) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6642"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withConcurrency",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "declare const withConcurrency: { (concurrency: number | \"unbounded\"): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, concurrency: number | \"unbounded\"): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6650"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withScheduler",
    "description": "Sets the provided scheduler for usage in the wrapped effect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scheduler",
    "signature": "declare const withScheduler: { (scheduler: Scheduler.Scheduler): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, scheduler: Scheduler.Scheduler): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6661"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withSchedulingPriority",
    "description": "Sets the scheduling priority used when yielding",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scheduler",
    "signature": "declare const withSchedulingPriority: { (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6672"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withMaxOpsBeforeYield",
    "description": "Sets the maximum number of operations before yield by the default schedulers",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scheduler",
    "signature": "declare const withMaxOpsBeforeYield: { (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6683"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "clock",
    "description": "Retrieves the `Clock` service from the context.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  const clock = yield* Effect.clock\n  const currentTime = yield* clock.currentTimeMillis\n  console.log(`Current time in milliseconds: ${currentTime}`)\n})\n\nEffect.runFork(program)\n// Example Output:\n// Current time in milliseconds: 1735484796134\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Clock",
    "signature": "declare const clock: Effect<Clock.Clock, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6710"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "clockWith",
    "description": "Retrieves the `Clock` service from the context and provides it to the\nspecified effectful function.\n\n**Example**\n\n```ts\nimport { Console, Effect } from \"effect\"\n\nconst program = Effect.clockWith((clock) =>\n  clock.currentTimeMillis.pipe(\n    Effect.map((currentTime) => `Current time is: ${currentTime}`),\n    Effect.tap(Console.log)\n  )\n)\n\nEffect.runFork(program)\n// Example Output:\n// Current time is: 1735484929744\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Clock",
    "signature": "declare const clockWith: <A, E, R>(f: (clock: Clock.Clock) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6736"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withClockScoped",
    "description": "Sets the implementation of the `Clock` service to the specified value and\nrestores it to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Clock",
    "signature": "declare const withClockScoped: <C extends Clock.Clock>(clock: C) => Effect<void, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6745"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withClock",
    "description": "Executes the specified workflow with the specified implementation of the\n`Clock` service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Clock",
    "signature": "declare const withClock: { <C extends Clock.Clock>(clock: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <C extends Clock.Clock, A, E, R>(effect: Effect<A, E, R>, clock: C): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6755"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "console",
    "description": "Retreives the `Console` service from the context",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Console",
    "signature": "declare const console: Effect<Console, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6766"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "consoleWith",
    "description": "Retreives the `Console` service from the context and provides it to the\nspecified effectful function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Console",
    "signature": "declare const consoleWith: <A, E, R>(f: (console: Console) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6775"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withConsoleScoped",
    "description": "Sets the implementation of the console service to the specified value and\nrestores it to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "declare const withConsoleScoped: <A extends Console>(console: A) => Effect<void, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6784"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withConsole",
    "description": "Executes the specified workflow with the specified implementation of the\nconsole service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Console",
    "signature": "declare const withConsole: { <C extends Console>(console: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, C extends Console>(effect: Effect<A, E, R>, console: C): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6794"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "delay",
    "description": "Delays the execution of an effect by a specified `Duration`.\n\n**Details\n\nThis function postpones the execution of the provided effect by the specified\nduration. The duration can be provided in various formats supported by the\n`Duration` module.\n\nInternally, this function does not block the thread; instead, it uses an\nefficient, non-blocking mechanism to introduce the delay.\n\n**Example**\n\n```ts\nimport { Console, Effect } from \"effect\"\n\nconst task = Console.log(\"Task executed\")\n\nconst program = Console.log(\"start\").pipe(\n  Effect.andThen(\n    // Delays the log message by 2 seconds\n    task.pipe(Effect.delay(\"2 seconds\"))\n  )\n)\n\nEffect.runFork(program)\n// Output:\n// start\n// Task executed\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "declare const delay: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6834"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "sleep",
    "description": "Suspends the execution of an effect for a specified `Duration`.\n\n**Details**\n\nThis function pauses the execution of an effect for a given duration. It is\nasynchronous, meaning that it does not block the fiber executing the effect.\nInstead, the fiber is suspended during the delay period and can resume once\nthe specified time has passed.\n\nThe duration can be specified using various formats supported by the\n`Duration` module, such as a string (`\"2 seconds\"`) or numeric value\nrepresenting milliseconds.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  console.log(\"Starting task...\")\n  yield* Effect.sleep(\"3 seconds\") // Waits for 3 seconds\n  console.log(\"Task completed!\")\n})\n\nEffect.runFork(program)\n// Output:\n// Starting task...\n// Task completed!\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "declare const sleep: (duration: Duration.DurationInput) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6873"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "timed",
    "description": "Executes an effect and measures the time it takes to complete.\n\n**Details**\n\nThis function wraps the provided effect and returns a new effect that, when\nexecuted, performs the original effect and calculates its execution duration.\n\nThe result of the new effect includes both the execution time (as a\n`Duration`) and the original effect's result. This is useful for monitoring\nperformance or gaining insights into the time taken by specific operations.\n\nThe original effect's behavior (success, failure, or interruption) remains\nunchanged, and the timing information is provided alongside the result in a\ntuple.\n\n**Example**\n\n```ts\nimport { Duration, Effect } from \"effect\"\n\nconst task = Effect.gen(function*() {\n  yield* Effect.sleep(\"2 seconds\") // Simulates some work\n  return \"some result\"\n})\n\nconst timedTask = task.pipe(Effect.timed)\n\nconst program = Effect.gen(function*() {\n  const [duration, result] = yield* timedTask\n  console.log(`Task completed in ${Duration.toMillis(duration)} ms with result: ${result}`)\n})\n\nEffect.runFork(program)\n// Output: Task completed in 2003.749125 ms with result: some result\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "declare const timed: <A, E, R>(self: Effect<A, E, R>) => Effect<[duration: Duration.Duration, result: A], E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6915"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "timedWith",
    "description": "Executes an effect and measures its execution time using a custom clock.\n\n**Details**\n\nThis function extends the functionality of {@link timed} by allowing you to\nspecify a custom clock for measuring the execution duration. The provided\neffect (`nanoseconds`) represents the clock and should return the current\ntime in nanoseconds. The timing information is computed using this custom\nclock instead of the default system clock.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "declare const timedWith: { <E1, R1>(nanoseconds: Effect<bigint, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<[Duration.Duration, A], E1 | E, R1 | R>; <A, E, R, E1, R1>(self: Effect<A, E, R>, nanoseconds: Effect<bigint, E1, R1>): Effect<[Duration.Duration, A], E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6932"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "timeout",
    "description": "Adds a time limit to an effect, triggering a timeout if the effect exceeds\nthe duration.\n\n**Details**\n\nThis function allows you to enforce a time limit on the execution of an\neffect. If the effect does not complete within the given duration, it fails\nwith a `TimeoutException`. This is useful for preventing tasks from hanging\nindefinitely, especially in scenarios where responsiveness or resource limits\nare critical.\n\nThe returned effect will either:\n- Succeed with the original effect's result if it completes within the\n  specified duration.\n- Fail with a `TimeoutException` if the time limit is exceeded.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\n// Output will show a TimeoutException as the task takes longer\n// than the specified timeout duration\nconst timedEffect = task.pipe(Effect.timeout(\"1 second\"))\n\nEffect.runPromiseExit(timedEffect).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: { _tag: 'TimeoutException' }\n//   }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "declare const timeout: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | Cause.TimeoutException, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<A, Cause.TimeoutException | E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L6997"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "timeoutOption",
    "description": "Gracefully handles timeouts by returning an `Option` that represents either\nthe result or a timeout.\n\n**Details**\n\nThis function wraps the outcome of an effect in an `Option` type. If the\neffect completes within the specified duration, it returns a `Some`\ncontaining the result. If the effect times out, it returns a `None`. Unlike\nother timeout methods, this approach does not raise errors or exceptions;\ninstead, it allows you to treat timeouts as a regular outcome, simplifying\nthe logic for handling delays.\n\n**When to Use**\n\nThis is useful when you want to handle timeouts without causing the program\nto fail, making it easier to manage situations where you expect tasks might\ntake too long but want to continue executing other tasks.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\nconst timedOutEffect = Effect.all([\n  task.pipe(Effect.timeoutOption(\"3 seconds\")),\n  task.pipe(Effect.timeoutOption(\"1 second\"))\n])\n\nEffect.runPromise(timedOutEffect).then(console.log)\n// Output:\n// Start processing...\n// Processing complete.\n// Start processing...\n// [\n//   { _id: 'Option', _tag: 'Some', value: 'Result' },\n//   { _id: 'Option', _tag: 'None' }\n// ]\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.1.0",
    "category": "Delays & Timeouts",
    "signature": "declare const timeoutOption: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<Option.Option<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7058"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "timeoutFail",
    "description": "Specifies a custom error to be produced when a timeout occurs.\n\n**Details**\n\nThis function allows you to handle timeouts in a customized way by defining a\nspecific error to be raised when an effect exceeds the given duration. Unlike\ndefault timeout behaviors that use generic exceptions, this function gives\nyou the flexibility to specify a meaningful error type that aligns with your\napplication's needs.\n\nWhen you apply this function, you provide:\n- A `duration`: The time limit for the effect.\n- An `onTimeout` function: A lazy evaluation function that generates the\n  custom error if the timeout occurs.\n\nIf the effect completes within the time limit, its result is returned\nnormally. Otherwise, the `onTimeout` function is triggered, and its output is\nused as the error for the effect.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\nclass MyTimeoutError {\n  readonly _tag = \"MyTimeoutError\"\n}\n\nconst program = task.pipe(\n  Effect.timeoutFail({\n    duration: \"1 second\",\n    onTimeout: () => new MyTimeoutError() // Custom timeout error\n  })\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: MyTimeoutError { _tag: 'MyTimeoutError' }\n//   }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "declare const timeoutFail: { <E1>(options: { readonly onTimeout: LazyArg<E1>; readonly duration: Duration.DurationInput; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>; <A, E, R, E1>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<E1>; readonly duration: Duration.DurationInput; }): Effect<A, E | E1, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7128"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "timeoutFailCause",
    "description": "Specifies a custom defect to be thrown when a timeout occurs.\n\n**Details**\n\nThis function allows you to handle timeouts as exceptional cases by\ngenerating a custom defect when an effect exceeds the specified duration. You\nprovide:\n- A `duration`: The time limit for the effect.\n- An `onTimeout` function: A lazy evaluation function that generates the\n  custom defect (typically created using `Cause.die`).\n\nIf the effect completes within the time limit, its result is returned\nnormally. Otherwise, the custom defect is triggered, and the effect fails\nwith that defect.\n\n**When to Use**\n\nThis is especially useful when you need to treat timeouts as critical\nfailures in your application and wish to include meaningful information in\nthe defect.\n\n**Example**\n\n```ts\nimport { Effect, Cause } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\nconst program = task.pipe(\n  Effect.timeoutFailCause({\n    duration: \"1 second\",\n    onTimeout: () => Cause.die(\"Timed out!\") // Custom defect for timeout\n  })\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "declare const timeoutFailCause: { <E1>(options: { readonly onTimeout: LazyArg<Cause.Cause<E1>>; readonly duration: Duration.DurationInput; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>; <A, E, R, E1>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<Cause.Cause<E1>>; readonly duration: Duration.DurationInput; }): Effect<A, E | E1, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7197"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "timeoutTo",
    "description": "Provides custom behavior for successful and timed-out operations.\n\n**Details**\n\nThis function allows you to define distinct outcomes for an effect depending\non whether it completes within a specified time frame or exceeds the timeout\nduration. You can provide:\n- `onSuccess`: A handler for processing the result of the effect if it\n  completes successfully within the time limit.\n- `onTimeout`: A handler for generating a result when the effect times out.\n- `duration`: The maximum allowed time for the effect to complete.\n\n**When to Use**\n\nUnlike {@link timeout}, which raises an exception for timeouts, this function\ngives you full control over the behavior for both success and timeout\nscenarios. It is particularly useful when you want to encapsulate timeouts\nand successes into a specific data structure, like an `Either` type, to\nrepresent these outcomes in a meaningful way.\n\n**Example**\n\n```ts\nimport { Effect, Either } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\nconst program = task.pipe(\n  Effect.timeoutTo({\n    duration: \"1 second\",\n    onSuccess: (result): Either.Either<string, string> =>\n      Either.right(result),\n    onTimeout: (): Either.Either<string, string> =>\n      Either.left(\"Timed out!\")\n  })\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: \"Either\",\n//   _tag: \"Left\",\n//   left: \"Timed out!\"\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "declare const timeoutTo: { <A, B, B1>(options: { readonly onTimeout: LazyArg<B1>; readonly onSuccess: (a: A) => B; readonly duration: Duration.DurationInput; }): <E, R>(self: Effect<A, E, R>) => Effect<B | B1, E, R>; <A, E, R, B1, B>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<B1>; readonly onSuccess: (a: A) => B; readonly duration: Duration.DurationInput; }): Effect<B1 | B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7267"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "configProviderWith",
    "description": "Allows working with the default configuration provider.\n\n**Details**\n\nThis function retrieves the default configuration provider and passes it to\nthe provided function, which can use it to perform computations or retrieve\nconfiguration values. The function can return an effect that leverages the\nconfiguration provider for its operations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Config",
    "signature": "declare const configProviderWith: <A, E, R>(f: (provider: ConfigProvider) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7298"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withConfigProvider",
    "description": "Executes an effect using a specific configuration provider.\n\n**Details**\n\nThis function lets you run an effect with a specified configuration provider.\nThe custom provider will override the default configuration provider for the\nduration of the effect's execution.\n\n**When to Use**\n\nThis is particularly useful when you need to use a different set of\nconfiguration values or sources for specific parts of your application.\n\n**Example**\n\n```ts\nimport { Config, ConfigProvider, Effect } from \"effect\"\n\nconst customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(\n  new Map([[\"custom-key\", \"custom-value\"]])\n)\n\nconst program = Effect.withConfigProvider(customProvider)(\n  Effect.gen(function*() {\n    const value = yield* Config.string(\"custom-key\")\n    console.log(`Config value: ${value}`)\n  })\n)\n\nEffect.runPromise(program)\n// Output:\n// Config value: custom-value\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Config",
    "signature": "declare const withConfigProvider: { (provider: ConfigProvider): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, provider: ConfigProvider): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7339"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withConfigProviderScoped",
    "description": "Sets a configuration provider within a scope.\n\n**Details**\n\nThis function sets the configuration provider to a specified value and\nensures that it is restored to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Config",
    "signature": "declare const withConfigProviderScoped: (provider: ConfigProvider) => Effect<void, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7355"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "context",
    "description": "Accesses the full context of the effect.\n\n**Details**\n\nThis function provides the ability to access the entire context required by\nan effect. The context is a container that holds dependencies or environment\nvalues needed by an effect to run. By using this function, you can retrieve\nand work with the context directly within an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const context: <R>() => Effect<Context.Context<R>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7371"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "contextWith",
    "description": "Accesses the context and applies a transformation function.\n\n**Details**\n\nThis function retrieves the context of the effect and applies a pure\ntransformation function to it. The result of the transformation is then\nreturned within the effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const contextWith: <R, A>(f: (context: Context.Context<R>) => A) => Effect<A, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7387"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "contextWithEffect",
    "description": "Accesses the context and performs an effectful transformation.\n\n**Details**\n\nThis function retrieves the context and allows you to transform it\neffectually using another effect. It is useful when the transformation\ninvolves asynchronous or effectful operations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const contextWithEffect: <R2, A, E, R>(f: (context: Context.Context<R2>) => Effect<A, E, R>) => Effect<A, E, R | R2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7403"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "mapInputContext",
    "description": "Provides part of the required context while leaving the rest unchanged.\n\n**Details**\n\nThis function allows you to transform the context required by an effect,\nproviding part of the context and leaving the rest to be fulfilled later.\n\n**Example**\n\n```ts\nimport { Context, Effect } from \"effect\"\n\nclass Service1 extends Context.Tag(\"Service1\")<Service1, { readonly port: number }>() {}\nclass Service2 extends Context.Tag(\"Service2\")<Service2, { readonly connection: string }>() {}\n\nconst program = Effect.gen(function*() {\n  const service1 = yield* Service1\n  console.log(service1.port)\n  const service2 = yield* Service2\n  console.log(service2.connection)\n  return \"some result\"\n})\n\n//       Effect<string, never, Service2>\n//      \nconst programWithService1 = Effect.mapInputContext(\n  program,\n  (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })\n)\n\nconst runnable = programWithService1.pipe(\n  Effect.provideService(Service2, { connection: \"localhost\" }),\n  Effect.provideService(Service1, { port: 3001 })\n)\n\nEffect.runPromise(runnable)\n// Output:\n// 3000\n// localhost\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const mapInputContext: { <R2, R>(f: (context: Context.Context<R2>) => Context.Context<R>): <A, E>(self: Effect<A, E, R>) => Effect<A, E, R2>; <A, E, R, R2>(self: Effect<A, E, R>, f: (context: Context.Context<R2>) => Context.Context<R>): Effect<A, E, R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7452"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "provide",
    "description": "Provides necessary dependencies to an effect, removing its environmental\nrequirements.\n\n**Details**\n\nThis function allows you to supply the required environment for an effect.\nThe environment can be provided in the form of one or more `Layer`s, a\n`Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\nprovided, the effect can run without requiring external dependencies.\n\nYou can compose layers to create a modular and reusable way of setting up the\nenvironment for effects. For example, layers can be used to configure\ndatabases, logging services, or any other required dependencies.\n\n**Example**\n\n```ts\nimport { Context, Effect, Layer } from \"effect\"\n\nclass Database extends Context.Tag(\"Database\")<\n  Database,\n  { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n>() {}\n\nconst DatabaseLive = Layer.succeed(\n  Database,\n  {\n    // Simulate a database query\n    query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n  }\n)\n\n//       Effect<unknown[], never, Database>\n//      \nconst program = Effect.gen(function*() {\n  const database = yield* Database\n  const result = yield* database.query(\"SELECT * FROM users\")\n  return result\n})\n\n//       Effect<unknown[], never, never>\n//      \nconst runnable = Effect.provide(program, DatabaseLive)\n\nEffect.runPromise(runnable).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"Executing query: SELECT * FROM users\"\n// []\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const provide: { <const Layers extends [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(layers: Layers): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]>; }[number]>>; <ROut, E2, RIn>(layer: Layer.Layer<ROut, E2, RIn>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, RIn | Exclude<R, ROut>>; <R2>(context: Context.Context<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; <R2>(runtime: Runtime.Runtime<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; <E2, R2>(managedRuntime: ManagedRuntime.ManagedRuntime<R2, E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, Exclude<R, R2>>; <A, E, R, const Layers extends [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(self: Effect<A, E, R>, layers: Layers): Effect<A, E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]>; }[number]>>; <A, E, R, ROut, E2, RIn>(self: Effect<A, E, R>, layer: Layer.Layer<ROut, E2, RIn>): Effect<A, E | E2, RIn | Exclude<R, ROut>>; <A, E, R, R2>(self: Effect<A, E, R>, context: Context.Context<R2>): Effect<A, E, Exclude<R, R2>>; <A, E, R, R2>(self: Effect<A, E, R>, runtime: Runtime.Runtime<R2>): Effect<A, E, Exclude<R, R2>>; <A, E, E2, R, R2>(self: Effect<A, E, R>, runtime: ManagedRuntime.ManagedRuntime<R2, E2>): Effect<A, E | E2, Exclude<R, R2>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7513"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "provideService",
    "description": "Provides an implementation for a service in the context of an effect.\n\n**Details**\n\nThis function allows you to supply a specific implementation for a service\nrequired by an effect. Services are typically defined using `Context.Tag`,\nwhich acts as a unique identifier for the service. By using this function,\nyou link the service to its concrete implementation, enabling the effect to\nexecute successfully without additional requirements.\n\nFor example, you can use this function to provide a random number generator,\na logger, or any other service your effect depends on. Once the service is\nprovided, all parts of the effect that rely on the service will automatically\nuse the implementation you supplied.\n\n**Example**\n\n```ts\nimport { Effect, Context } from \"effect\"\n\n// Declaring a tag for a service that generates random numbers\nclass Random extends Context.Tag(\"MyRandomService\")<\n  Random,\n  { readonly next: Effect.Effect<number> }\n>() {}\n\n// Using the service\nconst program = Effect.gen(function* () {\n  const random = yield* Random\n  const randomNumber = yield* random.next\n  console.log(`random number: ${randomNumber}`)\n})\n\n// Providing the implementation\n//\n//       Effect<void, never, never>\n//      \nconst runnable = Effect.provideService(program, Random, {\n  next: Effect.sync(() => Math.random())\n})\n\n// Run successfully\nEffect.runPromise(runnable)\n// Example Output:\n// random number: 0.8241872233134417\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, service: NoInfer<S>): Effect<A, E, Exclude<R, I>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7606"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "provideServiceEffect",
    "description": "Dynamically provides an implementation for a service using an effect.\n\n**Details**\n\nThis function allows you to provide an implementation for a service\ndynamically by using another effect. The provided effect is executed to\nproduce the service implementation, which is then made available to the\nconsuming effect. This is particularly useful when the service implementation\nitself requires asynchronous or resource-intensive initialization.\n\nFor example, you can use this function to lazily initialize a database\nconnection or fetch configuration values from an external source before\nmaking the service available to your effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const provideServiceEffect: { <I, S, E1, R1>(tag: Context.Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | Exclude<R, I>>; <A, E, R, I, S, E1, R1>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): Effect<A, E | E1, R1 | Exclude<R, I>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7629"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "serviceFunction",
    "description": "Creates a function that uses a service from the context to produce a value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const serviceFunction: <T extends Effect<any, any, any>, Args extends Array<any>, A>(getService: T, f: (_: Effect.Success<T>) => (...args: Args) => A) => (...args: Args) => Effect<A, Effect.Error<T>, Effect.Context<T>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7649"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "serviceFunctionEffect",
    "description": "Creates a function that uses a service from the context to produce an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const serviceFunctionEffect: <T extends Effect<any, any, any>, Args extends Array<any>, A, E, R>(getService: T, f: (_: Effect.Success<T>) => (...args: Args) => Effect<A, E, R>) => (...args: Args) => Effect<A, E | Effect.Error<T>, R | Effect.Context<T>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7662"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "serviceFunctions",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const serviceFunctions: <S, SE, SR>(getService: Effect<S, SE, SR>) => { [k in keyof S as S[k] extends (...args: Array<any>) => Effect<any, any, any> ? k : never]: S[k] extends (...args: infer Args) => Effect<infer A, infer E, infer R> ? (...args: Args) => Effect<A, SE | E, SR | R> : never; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7671"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "serviceConstants",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const serviceConstants: <S, SE, SR>(getService: Effect<S, SE, SR>) => { [k in { [k in keyof S]: k; }[keyof S]]: S[k] extends Effect<infer A, infer E, infer R> ? Effect<A, SE | E, SR | R> : Effect<S[k], SE, SR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7683"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "serviceMembers",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const serviceMembers: <S, SE, SR>(getService: Effect<S, SE, SR>) => { functions: { [k in keyof S as S[k] extends (...args: Array<any>) => Effect<any, any, any> ? k : never]: S[k] extends (...args: infer Args) => Effect<infer A, infer E, infer R> ? (...args: Args) => Effect<A, SE | E, SR | R> : never; }; constants: { [k in { [k in keyof S]: k; }[keyof S]]: S[k] extends Effect<infer A, infer E, infer R> ? Effect<A, SE | E, SR | R> : Effect<S[k], SE, SR>; }; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7694"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "serviceOption",
    "description": "Retrieves an optional service from the context as an `Option`.\n\n**Details**\n\nThis function retrieves a service from the context and wraps it in an\n`Option`. If the service is available, it returns a `Some` containing the\nservice. If the service is not found, it returns a `None`. This approach is\nuseful when you want to handle the absence of a service gracefully without\ncausing an error.\n\n**When to Use**\n\nUse this function when:\n- You need to access a service that may or may not be present in the context.\n- You want to handle the absence of a service using the `Option` type instead\n  of throwing an error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const serviceOption: <I, S>(tag: Context.Tag<I, S>) => Effect<Option.Option<S>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7731"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "serviceOptional",
    "description": "Retrieves a service from the context, throwing an error if it is missing.\n\n**Details**\n\nThis function retrieves a required service from the context. If the service\nis available, it returns the service. If the service is missing, it throws a\n`NoSuchElementException`, which can be handled using Effect's error-handling\nmechanisms. This is useful for services that are critical to the execution of\nyour effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const serviceOptional: <I, S>(tag: Context.Tag<I, S>) => Effect<S, Cause.NoSuchElementException>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7749"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "updateService",
    "description": "Updates a service in the context with a new implementation.\n\n**Details**\n\nThis function modifies the existing implementation of a service in the\ncontext. It retrieves the current service, applies the provided\ntransformation function `f`, and replaces the old service with the\ntransformed one.\n\n**When to Use**\n\nThis is useful for adapting or extending a service's behavior during the\nexecution of an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const updateService: { <I, S>(tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R | I>; <A, E, R, I, S>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): Effect<A, E, R | I>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7770"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Do",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n\n**Example**\n\n```ts\nimport * as assert from \"node:assert\"\nimport { Effect, pipe } from \"effect\"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind(\"x\", () => Effect.succeed(2)),\n  Effect.bind(\"y\", () => Effect.succeed(3)),\n  Effect.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Do notation",
    "signature": "declare const Do: Effect<{}, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7814"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "bind",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n\n**Example**\n\n```ts\nimport * as assert from \"node:assert\"\nimport { Effect, pipe } from \"effect\"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind(\"x\", () => Effect.succeed(2)),\n  Effect.bind(\"y\", () => Effect.succeed(3)),\n  Effect.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Do notation",
    "signature": "declare const bind: { <N extends string, A extends object, B, E2, R2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): <E1, R1>(self: Effect<A, E1, R1>) => Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E1, R2 | R1>; <A extends object, N extends string, E1, R1, B, E2, R2>(self: Effect<A, E1, R1>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E1 | E2, R1 | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7848"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "bindAll",
    "description": "`bindAll` combines `all` with `bind`. It is useful\nwhen you want to concurrently run multiple effects and then combine their\nresults in a Do notation pipeline.\n\n**Example**\n\n```ts\nimport * as assert from \"node:assert\"\nimport { Effect, Either, pipe } from \"effect\"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind(\"x\", () => Effect.succeed(2)),\n  Effect.bindAll(({ x }) => ({\n    a: Effect.succeed(x),\n    b: Effect.fail(\"oops\"),\n  }), { concurrency: 2, mode: \"either\" })\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left(\"oops\") })\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.7.0",
    "category": "Do notation",
    "signature": "declare const bindAll: { <A extends object, X extends Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`, options?: undefined | O): <E1, R1>(self: Effect<A, E1, R1>) => [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>] ? Effect<{ [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never; }, E1 | Error, R1 | Context> : never; <A extends object, X extends Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>, E1, R1>(self: Effect<A, E1, R1>, f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`, options?: undefined | { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>] ? Effect<{ [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never; }, E1 | Error, R1 | Context> : never; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7885"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "bindTo",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n\n**Example**\n\n```ts\nimport * as assert from \"node:assert\"\nimport { Effect, pipe } from \"effect\"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind(\"x\", () => Effect.succeed(2)),\n  Effect.bind(\"y\", () => Effect.succeed(3)),\n  Effect.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Do notation",
    "signature": "declare const bindTo: { <N extends string>(name: N): <A, E, R>(self: Effect<A, E, R>) => Effect<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Effect<A, E, R>, name: N): Effect<{ [K in N]: A; }, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L7968"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "option",
    "description": "Encapsulates the result of an effect in an `Option`.\n\n**Details**\n\nThis function wraps the outcome of an effect in an `Option` type. If the\noriginal effect succeeds, the success value is wrapped in `Option.some`. If\nthe effect fails, the failure is converted to `Option.none`.\n\nThis is particularly useful for scenarios where you want to represent the\nabsence of a value explicitly, without causing the resulting effect to fail.\nThe resulting effect has an error type of `never`, meaning it cannot fail\ndirectly. However, unrecoverable errors, also referred to as defects, are\nnot captured and will still result in failure.\n\n**Example** (Using Effect.option to Handle Errors)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst maybe1 = Effect.option(Effect.succeed(1))\n\nEffect.runPromiseExit(maybe1).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: { _id: 'Option', _tag: 'Some', value: 1 }\n// }\n\nconst maybe2 = Effect.option(Effect.fail(\"Uh oh!\"))\n\nEffect.runPromiseExit(maybe2).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: { _id: 'Option', _tag: 'None' }\n// }\n\nconst maybe3 = Effect.option(Effect.die(\"Boom!\"))\n\nEffect.runPromiseExit(maybe3).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Boom!' }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Outcome Encapsulation",
    "signature": "declare const option: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8079"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "either",
    "description": "Encapsulates both success and failure of an `Effect` into an `Either` type.\n\n**Details**\n\nThis function converts an effect that may fail into an effect that always\nsucceeds, wrapping the outcome in an `Either` type. The result will be\n`Either.Left` if the effect fails, containing the recoverable error, or\n`Either.Right` if it succeeds, containing the result.\n\nUsing this function, you can handle recoverable errors explicitly without\ncausing the effect to fail. This is particularly useful in scenarios where\nyou want to chain effects and manage both success and failure in the same\nlogical flow.\n\nIt's important to note that unrecoverable errors, often referred to as\n\"defects,\" are still thrown and not captured within the `Either` type. Only\nfailures that are explicitly represented as recoverable errors in the effect\nare encapsulated.\n\nThe resulting effect cannot fail directly because all recoverable failures\nare represented inside the `Either` type.\n\n**Example**\n\n```ts\nimport { Effect, Either, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//       Effect<string, HttpError | ValidationError, never>\n//      \nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//       Effect<string, never, never>\n//      \nconst recovered = Effect.gen(function* () {\n  //       Either<string, HttpError | ValidationError>\n  //      \n  const failureOrSuccess = yield* Effect.either(program)\n  return Either.match(failureOrSuccess, {\n    onLeft: (error) => `Recovering from ${error._tag}`,\n    onRight: (value) => value // Do nothing in case of success\n  })\n})\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Outcome Encapsulation",
    "signature": "declare const either: <A, E, R>(self: Effect<A, E, R>) => Effect<Either.Either<A, E>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8150"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "exit",
    "description": "Encapsulates both success and failure of an `Effect` using the `Exit` type.\n\n**Details**\n\nThis function converts an effect into one that always succeeds, wrapping its\noutcome in the `Exit` type. The `Exit` type provides explicit handling of\nboth success (`Exit.Success`) and failure (`Exit.Failure`) cases, including\ndefects (unrecoverable errors).\n\nUnlike {@link either} or {@link option}, this function also encapsulates\ndefects, which are typically unrecoverable and would otherwise terminate the\neffect. With the `Exit` type, defects are represented in `Exit.Failure`,\nallowing for detailed introspection and structured error handling.\n\nThis makes the resulting effect robust and incapable of direct failure (its\nerror type is `never`). It is particularly useful for workflows where all\noutcomes, including unexpected defects, must be managed and analyzed.\n\n**Example**\n\n```ts\nimport { Effect, Cause, Console, Exit } from \"effect\"\n\n// Simulating a runtime error\nconst task = Effect.dieMessage(\"Boom!\")\n\nconst program = Effect.gen(function* () {\n  const exit = yield* Effect.exit(task)\n  if (Exit.isFailure(exit)) {\n    const cause = exit.cause\n    if (\n      Cause.isDieType(cause) &&\n      Cause.isRuntimeException(cause.defect)\n    ) {\n      yield* Console.log(\n        `RuntimeException defect caught: ${cause.defect.message}`\n      )\n    } else {\n      yield* Console.log(\"Unknown failure caught.\")\n    }\n  }\n})\n\n// We get an Exit.Success because we caught all failures\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// RuntimeException defect caught: Boom!\n// {\n//   _id: \"Exit\",\n//   _tag: \"Success\",\n//   value: undefined\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Outcome Encapsulation",
    "signature": "declare const exit: <A, E, R>(self: Effect<A, E, R>) => Effect<Exit.Exit<A, E>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8213"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "intoDeferred",
    "description": "Converts an `Effect` into an operation that completes a `Deferred` with its result.\n\n**Details**\n\nThe `intoDeferred` function takes an effect and a `Deferred` and ensures that the `Deferred`\nis completed based on the outcome of the effect. If the effect succeeds, the `Deferred` is\ncompleted with the success value. If the effect fails, the `Deferred` is completed with the\nfailure. Additionally, if the effect is interrupted, the `Deferred` will also be interrupted.\n\n**Example**\n\n```ts\nimport { Deferred, Effect } from \"effect\"\n\n// Define an effect that succeeds\nconst successEffect = Effect.succeed(42)\n\nconst program = Effect.gen(function*() {\n  // Create a deferred\n  const deferred = yield* Deferred.make<number, string>()\n\n  // Complete the deferred using the successEffect\n  const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)\n\n  // Access the value of the deferred\n  const value = yield* Deferred.await(deferred)\n  console.log(value)\n\n  return isCompleted\n})\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// 42\n// true\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Synchronization Utilities",
    "signature": "declare const intoDeferred: { <A, E>(deferred: Deferred.Deferred<A, E>): <R>(self: Effect<A, E, R>) => Effect<boolean, never, R>; <A, E, R>(self: Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect<boolean, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8256"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "filterOrDie",
    "description": "Filters an effect, dying with a custom defect if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect dies with a custom defect\ngenerated by the `orDieWith` function.\n\n**When to Use**\n\nThis is useful for enforcing constraints on values and treating violations as\nfatal program errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "declare const filterOrDie: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, orDieWith: (a: NoInfer<A>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, orDieWith: (a: NoInfer<A>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orDieWith: (a: A) => unknown): Effect<B, E, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, orDieWith: (a: A) => unknown): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8315"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "filterOrDieMessage",
    "description": "Filters an effect, dying with a custom message if the predicate fails.\n\n**Details**\n\nThis function works like {@link filterOrDie} but allows you to specify a\ncustom error message to describe the reason for the failure. The message is\nincluded in the defect when the predicate evaluates to `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "declare const filterOrDieMessage: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, message: string): Effect<B, E, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, message: string): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8344"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "filterOrElse",
    "description": "Filters an effect, providing an alternative effect if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, it executes the `orElse` effect instead. The\n`orElse` effect can produce an alternative value or perform additional\ncomputations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "declare const filterOrElse: { <A, B extends A, C, E2, R2>(refinement: Refinement<NoInfer<A>, B>, orElse: (a: NoInfer<A>) => Effect<C, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<B | C, E2 | E, R2 | R>; <A, B, E2, R2>(predicate: Predicate<NoInfer<A>>, orElse: (a: NoInfer<A>) => Effect<B, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A | B, E2 | E, R2 | R>; <A, E, R, B extends A, C, E2, R2>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orElse: (a: A) => Effect<C, E2, R2>): Effect<B | C, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Effect<A, E, R>, predicate: Predicate<A>, orElse: (a: A) => Effect<B, E2, R2>): Effect<A | B, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8367"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "filterOrFail",
    "description": "Filters an effect, failing with a custom error if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect fails with a custom error\ngenerated by the `orFailWith` function.\n\n**When to Use**\n\nThis is useful for enforcing constraints and treating violations as\nrecoverable errors.\n\n**Providing a Guard**\n\nIn addition to the filtering capabilities discussed earlier, you have the\noption to further refine and narrow down the type of the success channel by\nproviding a [user-defined type\nguard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).\nLet's explore this concept through an example:\n\n**Example**\n\n```ts\nimport { Effect, pipe } from \"effect\"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterOrFail with a custom type guard to ensure user is not null\n  Effect.filterOrFail(\n    (user): user is User => user !== null, // Type guard\n    () => new Error(\"Unauthorized\")\n  ),\n  // 'user' now has the type `User` (not `User | null`)\n  Effect.andThen((user) => user.name)\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "declare const filterOrFail: { <A, B extends A, E2>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R>; <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Effect<A, E, R>) => Effect<B, Cause.NoSuchElementException | E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Effect<A, E, R>) => Effect<A, Cause.NoSuchElementException | E, R>; <A, E, R, B extends A, E2>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): Effect<B, E | E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Effect<A, E | E2, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>): Effect<B, E | Cause.NoSuchElementException, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>): Effect<A, E | Cause.NoSuchElementException, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8438"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "filterEffectOrElse",
    "description": "Filters an effect with an effectful predicate, falling back to an alternative\neffect if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect falls back to the `orElse`\neffect. The `orElse` effect can produce an alternative value or perform\nadditional computations.\n\n**Example**\n\n```ts\nimport { Effect, pipe } from \"effect\"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterEffectOrElse with an effectful predicate\n  Effect.filterEffectOrElse({\n    predicate: (user) => Effect.succeed(user !== null),\n    orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))\n  }),\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "Filtering",
    "signature": "declare const filterEffectOrElse: { <A, E2, R2, A2, E3, R3>(options: { readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>; readonly orElse: (a: NoInfer<A>) => Effect<A2, E3, R3>; }): <E, R>(self: Effect<A, E, R>) => Effect<A | A2, E | E2 | E3, R | R2 | R3>; <A, E, R, E2, R2, A2, E3, R3>(self: Effect<A, E, R>, options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orElse: (a: A) => Effect<A2, E3, R3>; }): Effect<A | A2, E | E2 | E3, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8501"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "filterEffectOrFail",
    "description": "Filters an effect with an effectful predicate, failing with a custom error if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect fails with a custom error\ngenerated by the `orFailWith` function.\n\n**When to Use**\n\nThis is useful for enforcing constraints and treating violations as\nrecoverable errors.\n\n**Example**\n\n```ts\nimport { Effect, pipe } from \"effect\"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterEffectOrFail with an effectful predicate\n  Effect.filterEffectOrFail({\n    predicate: (user) => Effect.succeed(user !== null),\n    orFailWith: () => new Error(\"Unauthorized\")\n  }),\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "Filtering",
    "signature": "declare const filterEffectOrFail: { <A, E2, R2, E3>(options: { readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>; readonly orFailWith: (a: NoInfer<A>) => E3; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R | R2>; <A, E, R, E2, R2, E3>(self: Effect<A, E, R>, options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orFailWith: (a: A) => E3; }): Effect<A, E | E2 | E3, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8557"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "unless",
    "description": "Executes an effect only if the condition is `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Conditional Operators",
    "signature": "declare const unless: { (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option.Option<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8582"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "unlessEffect",
    "description": "Conditionally execute an effect based on the result of another effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Conditional Operators",
    "signature": "declare const unlessEffect: { <E2, R2>(condition: Effect<boolean, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Effect<A, E, R>, condition: Effect<boolean, E2, R2>): Effect<Option.Option<A>, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8596"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "when",
    "description": "Conditionally executes an effect based on a boolean condition.\n\n**Details**\n\nThis function allows you to run an effect only if a given condition evaluates\nto `true`. If the condition is `true`, the effect is executed, and its result\nis wrapped in an `Option.some`. If the condition is `false`, the effect is\nskipped, and the result is `Option.none`.\n\n**When to Use**\n\nThis function is useful for scenarios where you need to dynamically decide\nwhether to execute an effect based on runtime logic, while also representing\nthe skipped case explicitly.\n\n**Example** (Conditional Effect Execution)\n\n```ts\nimport { Effect, Option } from \"effect\"\n\nconst validateWeightOption = (\n  weight: number\n): Effect.Effect<Option.Option<number>> =>\n  // Conditionally execute the effect if the weight is non-negative\n  Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))\n\n// Run with a valid weight\nEffect.runPromise(validateWeightOption(100)).then(console.log)\n// Output:\n// {\n//   _id: \"Option\",\n//   _tag: \"Some\",\n//   value: 100\n// }\n\n// Run with an invalid weight\nEffect.runPromise(validateWeightOption(-5)).then(console.log)\n// Output:\n// {\n//   _id: \"Option\",\n//   _tag: \"None\"\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Conditional Operators",
    "signature": "declare const when: { (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option.Option<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8654"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "whenEffect",
    "description": "Conditionally executes an effect based on the result of another effect.\n\n**Details**\n\nThis function allows you to run an effect only if a conditional effect\nevaluating to a boolean resolves to `true`. If the conditional effect\nevaluates to `true`, the specified effect is executed, and its result is\nwrapped in `Option.some`. If the conditional effect evaluates to `false`, the\neffect is skipped, and the result is `Option.none`.\n\n**When to Use**\n\nThis function is particularly useful when the decision to execute an effect\ndepends on the result of another effect, such as a random value, a\nuser-provided input, or a network request result.\n\n**Example** (Using an Effect as a Condition)\n\n```ts\nimport { Effect, Random } from \"effect\"\n\nconst randomIntOption = Random.nextInt.pipe(\n  Effect.whenEffect(Random.nextBoolean)\n)\n\nconsole.log(Effect.runSync(randomIntOption))\n// Example Output:\n// { _id: 'Option', _tag: 'Some', value: 8609104974198840 }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Conditional Operators",
    "signature": "declare const whenEffect: { <E, R>(condition: Effect<boolean, E, R>): <A, E2, R2>(effect: Effect<A, E2, R2>) => Effect<Option.Option<A>, E | E2, R | R2>; <A, E2, R2, E, R>(self: Effect<A, E2, R2>, condition: Effect<boolean, E, R>): Effect<Option.Option<A>, E2 | E, R2 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8696"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "whenFiberRef",
    "description": "Executes an effect conditionally based on the value of a `FiberRef` that\nsatisfies a predicate.\n\n**Details**\n\nThis function enables you to execute an effect only when the value of a\nspecified `FiberRef` meets a certain condition defined by a predicate. If the\nvalue satisfies the predicate, the effect is executed, and the result is\nwrapped in an `Option.some`. If the predicate is not satisfied, the effect is\nskipped, and the result is `Option.none`. In both cases, the current value of\nthe `FiberRef` is included in the result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Conditional Operators",
    "signature": "declare const whenFiberRef: { <S>(fiberRef: FiberRef.FiberRef<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option.Option<A>], E, R>; <A, E, R, S>(self: Effect<A, E, R>, fiberRef: FiberRef.FiberRef<S>, predicate: Predicate<S>): Effect<[S, Option.Option<A>], E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8719"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "whenRef",
    "description": "Executes an effect conditionally based on the value of a `Ref` that satisfies\na predicate.\n\n**Details**\n\nThis function allows you to execute an effect only when the value of a\nspecified `Ref` meets a condition defined by a predicate. If the value\nsatisfies the predicate, the effect is executed, and the result is wrapped in\nan `Option.some`. If the predicate is not satisfied, the effect is skipped,\nand the result is `Option.none`. In both cases, the current value of the\n`Ref` is included in the result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Conditional Operators",
    "signature": "declare const whenRef: { <S>(ref: Ref.Ref<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option.Option<A>], E, R>; <A, E, R, S>(self: Effect<A, E, R>, ref: Ref.Ref<S>, predicate: Predicate<S>): Effect<[S, Option.Option<A>], E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8747"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Chains effects to produce new `Effect` instances, useful for combining\noperations that depend on previous results.\n\n**Syntax**\n\n```ts skip-type-checking\nconst flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))\n// or\nconst flatMappedEffect = Effect.flatMap(myEffect, transformation)\n// or\nconst flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))\n```\n\n**Details**\n\n`flatMap` lets you sequence effects so that the result of one effect can be\nused in the next step. It is similar to `flatMap` used with arrays but works\nspecifically with `Effect` instances, allowing you to avoid deeply nested\neffect structures.\n\nSince effects are immutable, `flatMap` always returns a new effect instead of\nchanging the original one.\n\n**When to Use**\n\nUse `flatMap` when you need to chain multiple effects, ensuring that each\nstep produces a new `Effect` while flattening any nested effects that may\noccur.\n\n**Example**\n\n```ts\nimport { pipe, Effect } from \"effect\"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\n// Chaining the fetch and discount application using `flatMap`\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output: 95\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const flatMap: { <A, B, E1, R1>(f: (a: A) => Effect<B, E1, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect<A, E, R>, f: (a: A) => Effect<B, E1, R1>): Effect<B, E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8814"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "andThen",
    "description": "Chains two actions, where the second action can depend on the result of the\nfirst.\n\n**Syntax**\n\n```ts skip-type-checking\nconst transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))\n// or\nconst transformedEffect = Effect.andThen(myEffect, anotherEffect)\n// or\nconst transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))\n```\n\n**When to Use**\n\nUse `andThen` when you need to run multiple actions in sequence, with the\nsecond action depending on the result of the first. This is useful for\ncombining effects or handling computations that must happen in order.\n\n**Details**\n\nThe second action can be:\n\n- A constant value (similar to {@link as})\n- A function returning a value (similar to {@link map})\n- A `Promise`\n- A function returning a `Promise`\n- An `Effect`\n- A function returning an `Effect` (similar to {@link flatMap})\n\n**Note:** `andThen` works well with both `Option` and `Either` types,\ntreating them as effects.\n\n**Example** (Applying a Discount Based on Fetched Amount)\n\n```ts\nimport { pipe, Effect } from \"effect\"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\n// Using Effect.map and Effect.flatMap\nconst result1 = pipe(\n  fetchTransactionAmount,\n  Effect.map((amount) => amount * 2),\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(result1).then(console.log)\n// Output: 190\n\n// Using Effect.andThen\nconst result2 = pipe(\n  fetchTransactionAmount,\n  Effect.andThen((amount) => amount * 2),\n  Effect.andThen((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(result2).then(console.log)\n// Output: 190\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const andThen: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8894"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "flatten",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const flatten: <A, E1, R1, E, R>(self: Effect<Effect<A, E1, R1>, E, R>) => Effect<A, E | E1, R | R1>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L8927"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "race",
    "description": "Races two effects and returns the result of the first successful one.\n\n**Details**\n\nThis function takes two effects and runs them concurrently. The first effect\nthat successfully completes will determine the result of the race, and the\nother effect will be interrupted.\n\nIf neither effect succeeds, the function will fail with a `Cause`\ncontaining all the errors.\n\n**When to Use**\n\nThis is useful when you want to run two effects concurrently, but only care\nabout the first one to succeed. It is commonly used in cases like timeouts,\nretries, or when you want to optimize for the faster response without\nworrying about the other effect.\n\n**Handling Success or Failure with Either**\n\nIf you want to handle the result of whichever task completes first, whether\nit succeeds or fails, you can use the `Effect.either` function. This function\nwraps the result in an `Either` type, allowing you to see if the result\nwas a success (`Right`) or a failure (`Left`).\n\n**Example** (Both Tasks Succeed)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted\n```\n\n**Example** (One Task Fails, One Succeeds)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task2 done\n```\n\n**Example** (Both Tasks Fail)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.fail(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Parallel',\n//     left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },\n//     right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }\n//   }\n// }\n```\n\n**Example** (Handling Success or Failure with Either)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\n// Run both tasks concurrently, wrapping the result\n// in Either to capture success or failure\nconst program = Effect.race(Effect.either(task1), Effect.either(task2))\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// task2 interrupted\n// { _id: 'Either', _tag: 'Left', left: 'task1' }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Racing",
    "signature": "declare const race: { <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9067"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "raceAll",
    "description": "Races multiple effects and returns the first successful result.\n\n**Details**\n\nThis function runs multiple effects concurrently and returns the result of\nthe first one to succeed. If one effect succeeds, the others will be\ninterrupted.\n\nIf none of the effects succeed, the function will fail with the last error\nencountered.\n\n**When to Use**\n\nThis is useful when you want to race multiple effects, but only care about\nthe first one to succeed. It is commonly used in cases like timeouts,\nretries, or when you want to optimize for the faster response without\nworrying about the other effects.\n\n**Example** (All Tasks Succeed)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst task3 = Effect.succeed(\"task3\").pipe(\n  Effect.delay(\"150 millis\"),\n  Effect.tap(Console.log(\"task3 done\")),\n  Effect.onInterrupt(() => Console.log(\"task3 interrupted\"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted\n// task3 interrupted\n```\n\n**Example** (One Task Fails, Two Tasks Succeed)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst task3 = Effect.succeed(\"task3\").pipe(\n  Effect.delay(\"150 millis\"),\n  Effect.tap(Console.log(\"task3 done\")),\n  Effect.onInterrupt(() => Console.log(\"task3 interrupted\"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runFork(program)\n// Output:\n// task3 done\n// task2 interrupted\n```\n\n**Example** (All Tasks Fail)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.fail(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst task3 = Effect.fail(\"task3\").pipe(\n  Effect.delay(\"150 millis\"),\n  Effect.tap(Console.log(\"task3 done\")),\n  Effect.onInterrupt(() => Console.log(\"task3 interrupted\"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Racing",
    "signature": "declare const raceAll: <Eff extends Effect<any, any, any>>(all: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9190"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "raceFirst",
    "description": "Races two effects and returns the result of the first one to complete.\n\n**Details**\n\nThis function takes two effects and runs them concurrently, returning the\nresult of the first one that completes, regardless of whether it succeeds or\nfails.\n\n**When to Use**\n\nThis function is useful when you want to race two operations, and you want to\nproceed with whichever one finishes first, regardless of whether it succeeds\nor fails.\n\n**Disconnecting Effects**\n\nThe `Effect.raceFirst` function safely interrupts the loser effect once the other completes, but it will not resume until the loser is cleanly terminated.\n\nIf you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling:\n\n```ts skip-type-checking\nEffect.raceFirst(task1, task2)\n```\n\nYou can use:\n\n```ts skip-type-checking\nEffect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))\n```\n\nThis allows both effects to complete independently while still terminating the losing effect in the background.\n\n**Example** (Both Tasks Succeed)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\n\nconst program = Effect.raceFirst(task1, task2).pipe(\n  Effect.tap(Console.log(\"more work...\"))\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1 done\n// task2 interrupted\n// more work...\n// { _id: 'Exit', _tag: 'Success', value: 'task1' }\n```\n\n**Example** (One Task Fails, One Succeeds)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\n\nconst program = Effect.raceFirst(task1, task2).pipe(\n  Effect.tap(Console.log(\"more work...\"))\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task2 interrupted\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }\n// }\n```\n\n**Example** (Using Effect.disconnect for Quicker Return)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\n\n// Race the two tasks with disconnect to allow quicker return\nconst program = Effect.raceFirst(\n  Effect.disconnect(task1),\n  Effect.disconnect(task2)\n).pipe(Effect.tap(Console.log(\"more work...\")))\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1 done\n// more work...\n// { _id: 'Exit', _tag: 'Success', value: 'task1' }\n// task2 interrupted\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Racing",
    "signature": "declare const raceFirst: { <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9330"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "raceWith",
    "description": "Races two effects and calls a finisher when the first one completes.\n\n**Details**\n\nThis function runs two effects concurrently and calls a specified finisher\nfunction once one of the effects completes, regardless of whether it succeeds\nor fails.\n\nThe finisher functions for each effect allow you to handle the results of\neach effect as soon as they complete.\n\nThe function takes two finisher callbacks, one for each effect, and allows\nyou to specify how to handle the result of the race.\n\n**When to Use**\n\nThis function is useful when you need to react to the completion of either\neffect without waiting for both to finish. It can be used whenever you want\nto take action based on the first available result.\n\n**Example** (Handling Results of Concurrent Tasks)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\n\nconst program = Effect.raceWith(task1, task2, {\n  onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),\n  onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)\n})\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task1 exited with {\n//   \"_id\": \"Exit\",\n//   \"_tag\": \"Success\",\n//   \"value\": \"task1\"\n// }\n// task2 interrupted\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Racing",
    "signature": "declare const raceWith: { <A1, E1, R1, E, A, A2, E2, R2, A3, E3, R3>(other: Effect<A1, E1, R1>, options: { readonly onSelfDone: (exit: Exit.Exit<A, E>, fiber: Fiber.Fiber<A1, E1>) => Effect<A2, E2, R2>; readonly onOtherDone: (exit: Exit.Exit<A1, E1>, fiber: Fiber.Fiber<A, E>) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R1 | R2 | R3 | R>; <A, E, R, A1, E1, R1, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, other: Effect<A1, E1, R1>, options: { readonly onSelfDone: (exit: Exit.Exit<A, E>, fiber: Fiber.Fiber<A1, E1>) => Effect<A2, E2, R2>; readonly onOtherDone: (exit: Exit.Exit<A1, E1>, fiber: Fiber.Fiber<A, E>) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R | R1 | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9395"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "summarized",
    "description": "Summarizes a effect by computing some value before and after execution, and\nthen combining the values to produce a summary, together with the result of\nexecution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const summarized: { <B, E2, R2, C>(summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): <A, E, R>(self: Effect<A, E, R>) => Effect<[C, A], E2 | E, R2 | R>; <A, E, R, B, E2, R2, C>(self: Effect<A, E, R>, summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): Effect<[C, A], E2 | E, R2 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9421"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "tap",
    "description": "Runs a side effect with the result of an effect without changing the original\nvalue.\n\n**Details**\n\nThis function works similarly to `flatMap`, but it ignores the result of the\nfunction passed to it. The value from the previous effect remains available\nfor the next part of the chain. Note that if the side effect fails, the\nentire chain will fail too.\n\n**When to Use**\n\nUse this function when you want to perform a side effect, like logging or\ntracking, without modifying the main value. This is useful when you need to\nobserve or record an action but want the original value to be passed to the\nnext step.\n\n**Example** (Logging a step in a pipeline)\n\n```ts\nimport { Console, Effect, pipe } from \"effect\"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  // Log the fetched transaction amount\n  Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n  // `amount` is still available!\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output:\n// Apply a discount to: 100\n// 95\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const tap: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, X, E1, R1>(f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R | R1>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <X, E1, R1>(f: Effect<X, E1, R1>, options: { onlyEffect: true; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R | R1>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9487"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "tapBoth",
    "description": "Allows you to inspect both success and failure outcomes of an effect and\nperform side effects for each.\n\n**Details**\n\nThis function enables you to handle both success and failure cases\nseparately, without modifying the main effect's result. It is particularly\nuseful for scenarios where you need to log, monitor, or perform additional\nactions depending on whether the effect succeeded or failed.\n\nWhen the effect succeeds, the `onSuccess` handler is executed with the\nsuccess value. When the effect fails, the `onFailure` handler is executed\nwith the failure value. Both handlers can include side effects such as\nlogging or analytics, and neither modifies the original effect's output.\n\nIf either the success or failure handler fails, the overall effect will also\nfail.\n\n**Example**\n\n```ts\nimport { Effect, Random, Console } from \"effect\"\n\n// Simulate a task that might fail\nconst task = Effect.filterOrFail(\n  Random.nextRange(-1, 1),\n  (n) => n >= 0,\n  () => \"random number is negative\"\n)\n\n// Use tapBoth to log both success and failure outcomes\nconst tapping = Effect.tapBoth(task, {\n  onFailure: (error) => Console.log(`failure: ${error}`),\n  onSuccess: (randomNumber) =>\n    Console.log(`random number: ${randomNumber}`)\n})\n\nEffect.runFork(tapping)\n// Example Output:\n// failure: random number is negative\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const tapBoth: { <E, X, E2, R2, A, X1, E3, R3>(options: { readonly onFailure: (e: NoInfer<E>) => Effect<X, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect<X1, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, X, E2, R2, X1, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<X, E2, R2>; readonly onSuccess: (a: A) => Effect<X1, E3, R3>; }): Effect<A, E | E2 | E3, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9584"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "tapDefect",
    "description": "Inspect severe errors or defects (non-recoverable failures) in an effect.\n\n**Details**\n\nThis function is specifically designed to handle and inspect defects, which\nare critical failures in your program, such as unexpected runtime exceptions\nor system-level errors. Unlike normal recoverable errors, defects typically\nindicate serious issues that cannot be addressed through standard error\nhandling.\n\nWhen a defect occurs in an effect, the function you provide to this function\nwill be executed, allowing you to log, monitor, or handle the defect in some\nway. Importantly, this does not alter the main result of the effect. If no\ndefect occurs, the effect behaves as if this function was not used.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n// Simulate a task that fails with a recoverable error\nconst task1: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n\n// tapDefect won't log anything because NetworkError is not a defect\nconst tapping1 = Effect.tapDefect(task1, (cause) =>\n  Console.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping1)\n// No Output\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n  \"Something went wrong\"\n)\n\n// Log the defect using tapDefect\nconst tapping2 = Effect.tapDefect(task2, (cause) =>\n  Console.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping2)\n// Output:\n// defect: RuntimeException: Something went wrong\n//   ... stack trace ...\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const tapDefect: { <X, E2, R2>(f: (cause: Cause.Cause<never>) => Effect<X, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<never>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9651"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "tapError",
    "description": "Execute a side effect on failure without modifying the original effect.\n\n**Details**\n\nThis function allows you to inspect and react to the failure of an effect by\nexecuting an additional effect. The failure value is passed to the provided\nfunction, enabling you to log it, track it, or perform any other operation.\nImportantly, the original failure remains intact and is re-propagated, so the\neffect's behavior is unchanged.\n\nThe side effect you provide is only executed when the effect fails. If the\neffect succeeds, the function is ignored, and the success value is propagated\nas usual.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n// Simulate a task that fails with an error\nconst task: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n\n// Use tapError to log the error message when the task fails\nconst tapping = Effect.tapError(task, (error) =>\n  Console.log(`expected error: ${error}`)\n)\n\nEffect.runFork(tapping)\n// Output:\n// expected error: NetworkError\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const tapError: { <E, X, E2, R2>(f: (e: NoInfer<E>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9697"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "tapErrorTag",
    "description": "Inspect errors matching a specific tag without altering the original effect.\n\n**Details**\n\nThis function allows you to inspect and handle specific error types based on\ntheir `_tag` property. It is particularly useful in applications where errors\nare modeled with tagged types (e.g., union types with discriminating tags).\nBy targeting errors with a specific `_tag`, you can log or perform actions on\nthem while leaving the error channel and overall effect unchanged.\n\nIf the error doesn't match the specified tag, this function does nothing, and\nthe effect proceeds as usual.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nclass NetworkError {\n  readonly _tag = \"NetworkError\"\n  constructor(readonly statusCode: number) {}\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n  constructor(readonly field: string) {}\n}\n\n// Create a task that fails with a NetworkError\nconst task: Effect.Effect<number, NetworkError | ValidationError> =\n  Effect.fail(new NetworkError(504))\n\n// Use tapErrorTag to inspect only NetworkError types and log the status code\nconst tapping = Effect.tapErrorTag(task, \"NetworkError\", (error) =>\n  Console.log(`expected error: ${error.statusCode}`)\n)\n\nEffect.runFork(tapping)\n// Output:\n// expected error: 504\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const tapErrorTag: { <K extends E extends { _tag: string; } ? E[\"_tag\"] : never, E, A1, E1, R1>(k: K, f: (e: NoInfer<Extract<E, { _tag: K; }>>) => Effect<A1, E1, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E[\"_tag\"] : never, A1, E1, R1>(self: Effect<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Effect<A1, E1, R1>): Effect<A, E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9750"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "tapErrorCause",
    "description": "Inspect the complete cause of an error, including failures and defects.\n\n**Details**\n\nThis function provides access to the full cause of an error, including both\nrecoverable failures and irrecoverable defects. It allows you to handle, log,\nor monitor specific error causes without modifying the result of the effect.\nThe full `Cause` object encapsulates the error and its contextual\ninformation, making it useful for debugging and understanding failure\nscenarios in complex workflows.\n\nThe effect itself is not modified, and any errors or defects remain in the\nerror channel of the original effect.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n// Create a task that fails with a NetworkError\nconst task1: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n\nconst tapping1 = Effect.tapErrorCause(task1, (cause) =>\n  Console.log(`error cause: ${cause}`)\n)\n\nEffect.runFork(tapping1)\n// Output:\n// error cause: Error: NetworkError\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n  \"Something went wrong\"\n)\n\nconst tapping2 = Effect.tapErrorCause(task2, (cause) =>\n  Console.log(`error cause: ${cause}`)\n)\n\nEffect.runFork(tapping2)\n// Output:\n// error cause: RuntimeException: Something went wrong\n//   ... stack trace ...\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const tapErrorCause: { <E, X, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9811"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "forever",
    "description": "Repeats an effect indefinitely until an error occurs.\n\n**Details**\n\nThis function executes an effect repeatedly in an infinite loop. Each\niteration is executed sequentially, and the loop continues until the first\nerror occurs. If the effect succeeds, it starts over from the beginning. If\nthe effect fails, the error is propagated, and the loop stops.\n\nBe cautious when using this function, as it will run indefinitely unless an\nerror interrupts it. This makes it suitable for long-running processes or\ncontinuous polling tasks, but you should ensure proper error handling or\ncombine it with other operators like `timeout` or `schedule` to prevent\nunintentional infinite loops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "declare const forever: <A, E, R>(self: Effect<A, E, R>) => Effect<never, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9840"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "iterate",
    "description": "Repeatedly updates a state through an effectful operation until a condition\nis no longer met.\n\n**Details**\n\nThis function provides a way to implement effectful loops, similar to a\n`while` loop in JavaScript.\n\n```ts skip-type-checking\nlet result = initial\n\nwhile (options.while(result)) {\n  result = options.body(result)\n}\n\nreturn result\n```\n\nIt starts with an initial state, checks a\ncondition (`while`), and executes a body operation to update the state if the\ncondition evaluates to `true`. The process repeats until the condition\nreturns `false`.\n\nThe state is passed between iterations, allowing the body operation to modify\nit dynamically. The final state after the loop ends is returned as the result\nof the effect.\n\n**When to Use**\n\nThis is particularly useful for scenarios where looping logic involves\nasynchronous or side-effectful operations, such as polling or iterative\ncomputations that depend on external factors.\n\n**Example** (Effectful Iteration)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst result = Effect.iterate(\n  // Initial result\n  1,\n  {\n    // Condition to continue iterating\n    while: (result) => result <= 5,\n    // Operation to change the result\n    body: (result) => Effect.succeed(result + 1)\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output: 6\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Looping",
    "signature": "declare const iterate: { <A, B extends A, R, E>(initial: A, options: { readonly while: Refinement<A, B>; readonly body: (b: B) => Effect<A, E, R>; }): Effect<A, E, R>; <A, R, E>(initial: A, options: { readonly while: Predicate<A>; readonly body: (a: A) => Effect<A, E, R>; }): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L9899"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "loop",
    "description": "Repeatedly executes a loop with a state, collecting results or discarding\nthem based on configuration.\n\n**Details**\n\nThis function performs an effectful loop, starting with an initial state and\niterating as long as the `while` condition evaluates to `true`, similar to a\n`while` loop in JavaScript.\n\n```ts skip-type-checking\nlet state = initial\nconst result = []\n\nwhile (options.while(state)) {\n  result.push(options.body(state)) // Perform the effectful operation\n  state = options.step(state) // Update the state\n}\n\nreturn result\n```\n\nDuring each iteration, the `step` function updates the state, and the `body`\neffect is executed.\n\nThe results of the body effect can be collected in an array or discarded\nbased on the `discard` option.\n\n**Discarding Intermediate Results**\n\n- If `discard` is `false` or not provided, the intermediate results are\n  collected into an array and returned as the final result.\n- If `discard` is `true`, the intermediate results are ignored, and the\n  effect returns `void`.\n\n**When to Use**\n\nThis is useful for implementing loops where you need to perform effectful\ncomputations repeatedly, such as processing items in a list, generating\nvalues, or performing iterative updates.\n\n**Example** (Looping with Collected Results)\n\n```ts\nimport { Effect } from \"effect\"\n\n// A loop that runs 5 times, collecting each iteration's result\nconst result = Effect.loop(\n  // Initial state\n  1,\n  {\n    // Condition to continue looping\n    while: (state) => state <= 5,\n    // State update function\n    step: (state) => state + 1,\n    // Effect to be performed on each iteration\n    body: (state) => Effect.succeed(state)\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output: [1, 2, 3, 4, 5]\n```\n\n**Example** (Loop with Discarded Results)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst result = Effect.loop(\n  // Initial state\n  1,\n  {\n    // Condition to continue looping\n    while: (state) => state <= 5,\n    // State update function\n    step: (state) => state + 1,\n    // Effect to be performed on each iteration\n    body: (state) => Console.log(`Currently at state ${state}`),\n    // Discard intermediate results\n    discard: true\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at state 1\n// Currently at state 2\n// Currently at state 3\n// Currently at state 4\n// Currently at state 5\n// undefined\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Looping",
    "signature": "declare const loop: { <A, B extends A, C, E, R>(initial: A, options: { readonly while: Refinement<A, B>; readonly step: (b: B) => A; readonly body: (b: B) => Effect<C, E, R>; readonly discard?: false | undefined; }): Effect<Array<C>, E, R>; <A, C, E, R>(initial: A, options: { readonly while: (a: A) => boolean; readonly step: (a: A) => A; readonly body: (a: A) => Effect<C, E, R>; readonly discard?: false | undefined; }): Effect<Array<C>, E, R>; <A, B extends A, C, E, R>(initial: A, options: { readonly while: Refinement<A, B>; readonly step: (b: B) => A; readonly body: (b: B) => Effect<C, E, R>; readonly discard: true; }): Effect<void, E, R>; <A, C, E, R>(initial: A, options: { readonly while: (a: A) => boolean; readonly step: (a: A) => A; readonly body: (a: A) => Effect<C, E, R>; readonly discard: true; }): Effect<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10013"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "repeat",
    "description": "Repeats an effect based on a specified schedule or until the first failure.\n\n**Details**\n\nThis function executes an effect repeatedly according to the given schedule.\nEach repetition occurs after the initial execution of the effect, meaning\nthat the schedule determines the number of additional repetitions. For\nexample, using `Schedule.once` will result in the effect being executed twice\n(once initially and once as part of the repetition).\n\nIf the effect succeeds, it is repeated according to the schedule. If it\nfails, the repetition stops immediately, and the failure is returned.\n\nThe schedule can also specify delays between repetitions, making it useful\nfor tasks like retrying operations with backoff, periodic execution, or\nperforming a series of dependent actions.\n\nYou can combine schedules for more advanced repetition logic, such as adding\ndelays, limiting recursions, or dynamically adjusting based on the outcome of\neach execution.\n\n**Example** (Success Example)\n\n```ts\nimport { Effect, Schedule, Console } from \"effect\"\n\nconst action = Console.log(\"success\")\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n```\n\n**Example** (Failure Example)\n\n```ts\nimport { Effect, Schedule } from \"effect\"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\n  if (count > 1) {\n    console.log(\"failure\")\n    resume(Effect.fail(\"Uh oh!\"))\n  } else {\n    count++\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromiseExit(program).then(console.log)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "declare const repeat: { <O extends NoExcessProperties<Repeat.Options<A>, O>, A>(options: O): <E, R>(self: Effect<A, E, R>) => Repeat.Return<R, E, A, O>; <B, A, R1>(schedule: Schedule.Schedule<B, A, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R1 | R>; <A, E, R, O extends NoExcessProperties<Repeat.Options<A>, O>>(self: Effect<A, E, R>, options: O): Repeat.Return<R, E, A, O>; <A, E, R, B, R1>(self: Effect<A, E, R>, schedule: Schedule.Schedule<B, A, R1>): Effect<B, E, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10148"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "repeatN",
    "description": "Repeats an effect a specified number of times or until the first failure.\n\n**Details**\n\nThis function executes an effect initially and then repeats it the specified\nnumber of times, as long as it succeeds. For example, calling\n`repeatN(action, 2)` will execute `action` once initially and then repeat it\ntwo additional times if there are no failures.\n\nIf the effect fails during any repetition, the failure is returned, and no\nfurther repetitions are attempted.\n\n**When to Use**\n\nThis function is useful for tasks that need to be retried a fixed number of\ntimes or for performing repeated actions without requiring a schedule.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst action = Console.log(\"success\")\nconst program = Effect.repeatN(action, 2)\n\nEffect.runPromise(program)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "declare const repeatN: { (n: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10196"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "repeatOrElse",
    "description": "Repeats an effect with a schedule, handling failures using a custom handler.\n\n**Details**\n\nThis function allows you to execute an effect repeatedly based on a specified\nschedule. If the effect fails at any point, a custom failure handler is\ninvoked. The handler is provided with both the failure value and the output\nof the schedule at the time of failure. This enables advanced error recovery\nor alternative fallback logic while maintaining flexibility in how\nrepetitions are handled.\n\nFor example, using a schedule with `recurs(2)` will allow for two additional\nrepetitions after the initial execution, provided the effect succeeds. If a\nfailure occurs during any iteration, the failure handler is invoked to handle\nthe situation.\n\n**Example**\n\n```ts\nimport { Effect, Schedule } from \"effect\"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\n  if (count > 1) {\n    console.log(\"failure\")\n    resume(Effect.fail(\"Uh oh!\"))\n  } else {\n    count++\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\nconst policy = Schedule.addDelay(\n  Schedule.recurs(2), // Repeat for a maximum of 2 times\n  () => \"100 millis\" // Add a delay of 100 milliseconds between repetitions\n)\n\nconst program = Effect.repeatOrElse(action, policy, () =>\n  Effect.sync(() => {\n    console.log(\"orElse\")\n    return count - 1\n  })\n)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "declare const repeatOrElse: { <R2, A, B, E, E2, R3>(schedule: Schedule.Schedule<B, A, R2>, orElse: (error: E, option: Option.Option<B>) => Effect<B, E2, R3>): <R>(self: Effect<A, E, R>) => Effect<B, E2, R2 | R3 | R>; <A, E, R, R2, B, E2, R3>(self: Effect<A, E, R>, schedule: Schedule.Schedule<B, A, R2>, orElse: (error: E, option: Option.Option<B>) => Effect<B, E2, R3>): Effect<B, E2, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10255"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "schedule",
    "description": "Repeats an effect based on a specified schedule.\n\n**Details**\n\nThis function allows you to execute an effect repeatedly according to a given\nschedule. The schedule determines the timing and number of repetitions. Each\nrepetition can also depend on the decision of the schedule, providing\nflexibility for complex workflows. This function does not modify the effect's\nsuccess or failure; it only controls its repetition.\n\nFor example, you can use a schedule that recurs a specific number of times,\nadds delays between repetitions, or customizes repetition behavior based on\nexternal inputs. The effect runs initially and is repeated according to the\nschedule.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "declare const schedule: { <A, R2, Out>(schedule: Schedule.Schedule<Out, NoInfer<A> | undefined, R2>): <E, R>(self: Effect<A, E, R>) => Effect<Out, E, R2 | R>; <A, E, R, R2, Out>(self: Effect<A, E, R>, schedule: Schedule.Schedule<Out, A | undefined, R2>): Effect<Out, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10289"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "scheduleForked",
    "description": "Runs an effect repeatedly on a new fiber according to a given schedule.\n\n**Details**\n\nThis function starts the provided effect on a new fiber and runs it\nrepeatedly based on the specified schedule. The repetitions are managed by\nthe schedule's rules, which define the timing and number of iterations. The\nfiber is attached to the current scope, meaning it is automatically managed\nand cleaned up when the scope is closed.\n\nThe function returns a `RuntimeFiber` that allows you to monitor or interact\nwith the running fiber.\n\n**When to Use**\n\nThis is particularly useful for concurrent execution of scheduled tasks or\nwhen you want to continue processing without waiting for the repetitions to\ncomplete.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "declare const scheduleForked: { <Out, R2>(schedule: Schedule.Schedule<Out, unknown, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<Out, E>, never, Scope.Scope | R2 | R>; <A, E, R, Out, R2>(self: Effect<A, E, R>, schedule: Schedule.Schedule<Out, unknown, R2>): Effect<Fiber.RuntimeFiber<Out, E>, never, Scope.Scope | R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10322"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "scheduleFrom",
    "description": "Runs an effect repeatedly according to a schedule, starting from a specified\ninput value.\n\n**Details**\n\nThis function allows you to repeatedly execute an effect based on a schedule.\nThe schedule starts with the given `initial` input value, which is passed to\nthe first execution. Subsequent executions of the effect are controlled by\nthe schedule's rules, using the output of the previous iteration as the input\nfor the next one.\n\nThe returned effect will complete when the schedule ends or the effect fails,\npropagating the error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "declare const scheduleFrom: { <R2, In, Out>(initial: In, schedule: Schedule.Schedule<Out, In, R2>): <E, R>(self: Effect<In, E, R>) => Effect<Out, E, R2 | R>; <In, E, R, R2, Out>(self: Effect<In, E, R>, initial: In, schedule: Schedule.Schedule<Out, In, R2>): Effect<Out, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10350"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "whileLoop",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "declare const whileLoop: <A, E, R>(options: { readonly while: LazyArg<boolean>; readonly body: LazyArg<Effect<A, E, R>>; readonly step: (a: A) => void; }) => Effect<void, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10366"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "getFiberRefs",
    "description": "Returns a collection of all `FiberRef` values for the fiber running this\neffect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "declare const getFiberRefs: Effect<FiberRefs.FiberRefs, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10381"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "inheritFiberRefs",
    "description": "Inherits values from all `FiberRef` instances into current fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "declare const inheritFiberRefs: (childFiberRefs: FiberRefs.FiberRefs) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10389"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "locally",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "declare const locally: { <A>(self: FiberRef.FiberRef<A>, value: A): <B, E, R>(use: Effect<B, E, R>) => Effect<B, E, R>; <B, E, R, A>(use: Effect<B, E, R>, self: FiberRef.FiberRef<A>, value: A): Effect<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10395"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "locallyWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "declare const locallyWith: { <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A): <B, E, R>(use: Effect<B, E, R>) => Effect<B, E, R>; <B, E, R, A>(use: Effect<B, E, R>, self: FiberRef.FiberRef<A>, f: (a: A) => A): Effect<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10404"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "locallyScoped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "declare const locallyScoped: { <A>(value: A): (self: FiberRef.FiberRef<A>) => Effect<void, never, Scope.Scope>; <A>(self: FiberRef.FiberRef<A>, value: A): Effect<void, never, Scope.Scope>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10413"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "locallyScopedWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "declare const locallyScopedWith: { <A>(f: (a: A) => A): (self: FiberRef.FiberRef<A>) => Effect<void, never, Scope.Scope>; <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A): Effect<void, never, Scope.Scope>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10422"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "patchFiberRefs",
    "description": "Applies the specified changes to the `FiberRef` values for the fiber\nrunning this workflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "declare const patchFiberRefs: (patch: FiberRefsPatch.FiberRefsPatch) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10434"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "setFiberRefs",
    "description": "Sets the `FiberRef` values for the fiber running this effect to the values\nin the specified collection of `FiberRef` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "declare const setFiberRefs: (fiberRefs: FiberRefs.FiberRefs) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10443"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "updateFiberRefs",
    "description": "Updates the `FiberRef` values for the fiber running this effect using the\nspecified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "declare const updateFiberRefs: (f: (fiberId: FiberId.Runtime, fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10452"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "isFailure",
    "description": "Checks if an effect has failed.\n\n**Details**\n\nThis function evaluates whether an effect has resulted in a failure. It\nreturns a boolean value wrapped in an effect, with `true` indicating the\neffect failed and `false` otherwise.\n\nThe resulting effect cannot fail (`never` in the error channel) but retains\nthe context of the original effect.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst failure = Effect.fail(\"Uh oh!\")\n\nconsole.log(Effect.runSync(Effect.isFailure(failure)))\n// Output: true\n\nconst defect = Effect.dieMessage(\"BOOM!\")\n\nEffect.runSync(Effect.isFailure(defect))\n// throws: BOOM!\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Condition Checking",
    "signature": "declare const isFailure: <A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10487"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "isSuccess",
    "description": "Checks if an effect has succeeded.\n\n**Details**\n\nThis function evaluates whether an effect has resulted in a success. It\nreturns a boolean value wrapped in an effect, with `true` indicating the\neffect succeeded and `false` otherwise.\n\nThe resulting effect cannot fail (`never` in the error channel) but retains\nthe context of the original effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Condition Checking",
    "signature": "declare const isSuccess: <A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10504"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Handles both success and failure cases of an effect without performing side\neffects.\n\n**Details**\n\n`match` lets you define custom handlers for both success and failure\nscenarios. You provide separate functions to handle each case, allowing you\nto process the result if the effect succeeds, or handle the error if the\neffect fails.\n\n**When to Use**\n\nThis is useful for structuring your code to respond differently to success or\nfailure without triggering side effects.\n\n**Example** (Handling Both Success and Failure Cases)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst success: Effect.Effect<number, Error> = Effect.succeed(42)\n\nconst program1 = Effect.match(success, {\n  onFailure: (error) => `failure: ${error.message}`,\n  onSuccess: (value) => `success: ${value}`\n})\n\n// Run and log the result of the successful effect\nEffect.runPromise(program1).then(console.log)\n// Output: \"success: 42\"\n\nconst failure: Effect.Effect<number, Error> = Effect.fail(\n  new Error(\"Uh oh!\")\n)\n\nconst program2 = Effect.match(failure, {\n  onFailure: (error) => `failure: ${error.message}`,\n  onSuccess: (value) => `success: ${value}`\n})\n\n// Run and log the result of the failed effect\nEffect.runPromise(program2).then(console.log)\n// Output: \"failure: Uh oh!\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Matching",
    "signature": "declare const match: { <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): Effect<A2 | A3, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10557"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "matchCause",
    "description": "Handles failures by matching the cause of failure.\n\n**Details**\n\nThe `matchCause` function allows you to handle failures with access to the\nfull cause of the failure within a fiber.\n\n**When to Use**\n\nThis is useful for differentiating between different types of errors, such as\nregular failures, defects, or interruptions. You can provide specific\nhandling logic for each failure type based on the cause.\n\n**Example** (Handling Different Failure Causes)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst task: Effect.Effect<number, Error> = Effect.die(\"Uh oh!\")\n\nconst program = Effect.matchCause(task, {\n  onFailure: (cause) => {\n    switch (cause._tag) {\n      case \"Fail\":\n        // Handle standard failure\n        return `Fail: ${cause.error.message}`\n      case \"Die\":\n        // Handle defects (unexpected errors)\n        return `Die: ${cause.defect}`\n      case \"Interrupt\":\n        // Handle interruption\n        return `${cause.fiberId} interrupted!`\n    }\n    // Fallback for other causes\n    return \"failed due to other causes\"\n  },\n  onSuccess: (value) =>\n    // task completes successfully\n    `succeeded with ${value} value`\n})\n\nEffect.runPromise(program).then(console.log)\n// Output: \"Die: Uh oh!\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Matching",
    "signature": "declare const matchCause: { <E, A2, A, A3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): Effect<A2 | A3, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10626"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "matchCauseEffect",
    "description": "Handles failures with access to the cause and allows performing side effects.\n\n**Details**\n\nThe `matchCauseEffect` function works similarly to {@link matchCause}, but it\nalso allows you to perform additional side effects based on the failure\ncause. This function provides access to the complete cause of the failure,\nmaking it possible to differentiate between various failure types, and allows\nyou to respond accordingly while performing side effects (like logging or\nother operations).\n\n**Example** (Handling Different Failure Causes with Side Effects)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task: Effect.Effect<number, Error> = Effect.die(\"Uh oh!\")\n\nconst program = Effect.matchCauseEffect(task, {\n  onFailure: (cause) => {\n    switch (cause._tag) {\n      case \"Fail\":\n        // Handle standard failure with a logged message\n        return Console.log(`Fail: ${cause.error.message}`)\n      case \"Die\":\n        // Handle defects (unexpected errors) by logging the defect\n        return Console.log(`Die: ${cause.defect}`)\n      case \"Interrupt\":\n        // Handle interruption and log the fiberId that was interrupted\n        return Console.log(`${cause.fiberId} interrupted!`)\n    }\n    // Fallback for other causes\n    return Console.log(\"failed due to other causes\")\n  },\n  onSuccess: (value) =>\n    // Log success if the task completes successfully\n    Console.log(`succeeded with ${value} value`)\n})\n\nEffect.runPromise(program)\n// Output: \"Die: Uh oh!\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Matching",
    "signature": "declare const matchCauseEffect: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R2 | R3 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10692"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "matchEffect",
    "description": "Handles both success and failure cases of an effect, allowing for additional\nside effects.\n\n**Details**\n\nThe `matchEffect` function is similar to {@link match}, but it enables you to\nperform side effects in the handlers for both success and failure outcomes.\n\n**When to Use**\n\nThis is useful when you need to execute additional actions, like logging or\nnotifying users, based on whether an effect succeeds or fails.\n\n**Example** (Handling Both Success and Failure Cases with Side Effects)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst success: Effect.Effect<number, Error> = Effect.succeed(42)\nconst failure: Effect.Effect<number, Error> = Effect.fail(\n  new Error(\"Uh oh!\")\n)\n\nconst program1 = Effect.matchEffect(success, {\n  onFailure: (error) =>\n    Effect.succeed(`failure: ${error.message}`).pipe(\n      Effect.tap(Effect.log)\n    ),\n  onSuccess: (value) =>\n    Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n})\n\nconsole.log(Effect.runSync(program1))\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"success: 42\"\n// success: 42\n\nconst program2 = Effect.matchEffect(failure, {\n  onFailure: (error) =>\n    Effect.succeed(`failure: ${error.message}`).pipe(\n      Effect.tap(Effect.log)\n    ),\n  onSuccess: (value) =>\n    Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n})\n\nconsole.log(Effect.runSync(program2))\n// Output:\n// timestamp=... level=INFO fiber=#1 message=\"failure: Uh oh!\"\n// failure: Uh oh!\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Matching",
    "signature": "declare const matchEffect: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R2 | R3 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10767"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "log",
    "description": "Logs one or more messages or error causes at the current log level.\n\n**Details**\n\nThis function provides a simple way to log messages or error causes during\nthe execution of your effects. By default, logs are recorded at the `INFO`\nlevel, but this can be adjusted using other logging utilities\n(`Logger.withMinimumLogLevel`). Multiple items, including `Cause` instances,\ncan be logged in a single call. When logging `Cause` instances, detailed\nerror information is included in the log output.\n\nThe log output includes useful metadata like the current timestamp, log\nlevel, and fiber ID, making it suitable for debugging and tracking purposes.\nThis function does not interrupt or alter the effect's execution flow.\n\n**Example**\n\n```ts\nimport { Cause, Effect } from \"effect\"\n\nconst program = Effect.log(\n  \"message1\",\n  \"message2\",\n  Cause.die(\"Oh no!\"),\n  Cause.die(\"Oh uh!\")\n)\n\nEffect.runFork(program)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause=\"Error: Oh no!\n// Error: Oh uh!\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "declare const log: (...message: ReadonlyArray<any>) => Effect<void, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10820"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "logTrace",
    "description": "Logs messages at the TRACE log level.\n\n**Details**\n\nThis function logs the specified messages at the TRACE level. TRACE logs are\ntypically used for very detailed diagnostic information. These messages are\nnot displayed by default. To view them, you must adjust the logging\nconfiguration by setting the minimum log level to `LogLevel.Trace` using\n`Logger.withMinimumLogLevel`.\n\n**Example**\n\n```ts\nimport { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.logTrace(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Trace))\n\nEffect.runFork(program)\n// timestamp=... level=TRACE fiber=#0 message=message1\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "declare const logTrace: (...message: ReadonlyArray<any>) => Effect<void, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10881"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "logDebug",
    "description": "Logs messages at the DEBUG log level.\n\n**Details**\n\nThis function logs messages at the DEBUG level, which is typically used for\ndiagnosing application behavior during development. DEBUG messages provide\nless detailed information than TRACE logs but are still not shown by default.\nTo view these logs, adjust the log level using `Logger.withMinimumLogLevel`.\n\n**Example**\n\n```ts\nimport { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.logDebug(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message1\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "declare const logDebug: (...message: ReadonlyArray<any>) => Effect<void, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10907"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "logInfo",
    "description": "Logs messages at the INFO log level.\n\n**Details**\n\nThis function logs messages at the INFO level, suitable for general\napplication events or operational messages. INFO logs are shown by default\nand are commonly used for highlighting normal, non-error operations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "declare const logInfo: (...message: ReadonlyArray<any>) => Effect<void, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10921"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "logWarning",
    "description": "Logs messages at the WARNING log level.\n\n**Details**\n\nThis function logs messages at the WARNING level, suitable for highlighting\npotential issues that are not errors but may require attention. These\nmessages indicate that something unexpected occurred or might lead to errors\nin the future.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "declare const logWarning: (...message: ReadonlyArray<any>) => Effect<void, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10936"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "logError",
    "description": "Logs messages at the ERROR log level.\n\n**Details**\n\nThis function logs messages at the ERROR level, suitable for reporting\napplication errors or failures. These logs are typically used for unexpected\nissues that need immediate attention.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "declare const logError: (...message: ReadonlyArray<any>) => Effect<void, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10950"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "logFatal",
    "description": "Logs messages at the FATAL log level.\n\n**Details**\n\nThis function logs messages at the FATAL level, suitable for reporting\ncritical errors that cause the application to terminate or stop functioning.\nThese logs are typically used for unrecoverable errors that require immediate\nattention.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "declare const logFatal: (...message: ReadonlyArray<any>) => Effect<void, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10965"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withLogSpan",
    "description": "Adds a log span to an effect for tracking and logging its execution duration.\n\n**Details**\n\nThis function wraps an effect with a log span, providing performance\nmonitoring and debugging capabilities. The log span tracks the duration of\nthe wrapped effect and logs it with the specified label. This is particularly\nuseful when analyzing time-sensitive operations or understanding the\nexecution time of specific tasks in your application.\n\nThe logged output will include the label and the total time taken for the\noperation. The span information is included in the log metadata, making it\neasy to trace performance metrics in logs.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.sleep(\"1 second\")\n  yield* Effect.log(\"The job is finished!\")\n}).pipe(Effect.withLogSpan(\"myspan\"))\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=\"The job is finished!\" myspan=1011ms\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "declare const withLogSpan: { (label: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, label: string): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10999"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "annotateLogs",
    "description": "Adds custom annotations to log entries generated within an effect.\n\n**Details**\n\nThis function allows you to enhance log messages by appending additional\ncontext in the form of key-value pairs. These annotations are included in\nevery log message created during the execution of the effect, making the logs\nmore informative and easier to trace.\n\nThe annotations can be specified as a single key-value pair or as a record of\nmultiple key-value pairs. This is particularly useful for tracking\noperations, debugging, or associating specific metadata with logs for better\nobservability.\n\nThe annotated key-value pairs will appear alongside the log message in the\noutput.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"message1\")\n  yield* Effect.log(\"message2\")\n}).pipe(Effect.annotateLogs(\"taskId\", \"1234\")) // Annotation as key/value pair\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=message1 taskId=1234\n// timestamp=... level=INFO fiber=#0 message=message2 taskId=1234\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "declare const annotateLogs: { (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11042"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "annotateLogsScoped",
    "description": "Adds log annotations with a limited scope to enhance contextual logging.\n\n**Details**\n\nThis function allows you to apply key-value annotations to log entries\ngenerated within a specific scope of your effect computations. The\nannotations are restricted to the defined `Scope`, ensuring that they are\nonly applied to logs produced during that scope. Once the scope ends, the\nannotations are automatically removed, making it easier to manage\ncontext-specific logging without affecting other parts of your application.\n\nThe annotations can be provided as a single key-value pair or as a record of\nmultiple key-value pairs. This flexibility enables fine-grained control over\nthe additional metadata included in logs for specific tasks or operations.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"no annotations\")\n  yield* Effect.annotateLogsScoped({ key: \"value\" })\n  yield* Effect.log(\"message1\") // Annotation is applied to this log\n  yield* Effect.log(\"message2\") // Annotation is applied to this log\n}).pipe(Effect.scoped, Effect.andThen(Effect.log(\"no annotations again\")))\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=\"no annotations\"\n// timestamp=... level=INFO fiber=#0 message=message1 key=value\n// timestamp=... level=INFO fiber=#0 message=message2 key=value\n// timestamp=... level=INFO fiber=#0 message=\"no annotations again\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.1.0",
    "category": "Logging",
    "signature": "declare const annotateLogsScoped: { (key: string, value: unknown): Effect<void, never, Scope.Scope>; (values: Record<string, unknown>): Effect<void, never, Scope.Scope>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11089"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "logAnnotations",
    "description": "Retrieves the current log annotations for the current scope.\n\n**Details**\n\nThis function provides access to the log annotations associated with the\ncurrent scope. Log annotations are key-value pairs that provide additional\ncontext to log entries. They are often used to add metadata such as tags,\nidentifiers, or extra debugging information to logs.\n\nBy using this function, you can inspect or utilize the annotations applied to\nthe current scope, making it easier to trace and debug specific sections of\nyour application.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "declare const logAnnotations: Effect<HashMap.HashMap<string, unknown>, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11114"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withUnhandledErrorLogLevel",
    "description": "Configures whether child fibers will log unhandled errors and at what log\nlevel.\n\n**Details**\n\nThis function allows you to control whether unhandled errors from child\nfibers are logged and to specify the log level for these errors. By default,\nunhandled errors are reported via the logger. However, using this function,\nyou can choose to suppress these logs by passing `Option.none` or adjust the\nlog level to a specific severity, such as `Error`, `Warning`, or `Info`.\n\nThis configuration is scoped to the effect it is applied to, meaning the\nchanges only apply to the child fibers created within that effect's context.\nIt is especially useful when you want to reduce noise in logs or prioritize\ncertain types of errors.\n\n**Example**\n\n```ts\nimport { Effect, Fiber, LogLevel, Option } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  const fiber = yield* Effect.fork(Effect.fail(\"Unhandled error!\"))\n  yield* Fiber.join(fiber)\n})\n\nEffect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))\n// Output:\n// timestamp=... level=ERROR fiber=#1 message=\"Fiber terminated with an unhandled error\" cause=\"Error: Unhandled error!\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "declare const withUnhandledErrorLogLevel: { (level: Option.Option<LogLevel.LogLevel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, level: Option.Option<LogLevel.LogLevel>): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11151"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "whenLogLevel",
    "description": "Conditionally executes an effect based on the specified log level and currently enabled log level.\n\n**Details**\n\nThis function runs the provided effect only if the specified log level is\nenabled. If the log level is enabled, the effect is executed and its result\nis wrapped in `Some`. If the log level is not enabled, the effect is not\nexecuted and `None` is returned.\n\nThis function is useful for conditionally executing logging-related effects\nor other operations that depend on the current log level configuration.\n\n**Example**\n\n```ts\nimport { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.gen(function* () {\n  yield* Effect.whenLogLevel(Effect.logTrace(\"message1\"), LogLevel.Trace); // returns `None`\n  yield* Effect.whenLogLevel(Effect.logDebug(\"message2\"), LogLevel.Debug); // returns `Some`\n}).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message2\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "Logging",
    "signature": "declare const whenLogLevel: { (level: LogLevel.LogLevel | LogLevel.Literal): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, level: LogLevel.LogLevel | LogLevel.Literal): Effect<Option.Option<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11188"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "orDie",
    "description": "Converts an effect's failure into a fiber termination, removing the error\nfrom the effect's type.\n\n**Details**\n\nThe `orDie` function is used when you encounter errors that you do not want\nto handle or recover from. It removes the error type from the effect and\nensures that any failure will terminate the fiber. This is useful for\npropagating failures as defects, signaling that they should not be handled\nwithin the effect.\n\n**When to Use*\n\nUse `orDie` when failures should be treated as unrecoverable defects and no\nerror handling is required.\n\n**Example** (Propagating an Error as a Defect)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error(\"Cannot divide by zero\"))\n    : Effect.succeed(a / b)\n\n//       Effect<number, never, never>\n//      \nconst program = Effect.orDie(divide(1, 0))\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: Cannot divide by zero\n//   ...stack trace...\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Converting Failures to Defects",
    "signature": "declare const orDie: <A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11235"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "orDieWith",
    "description": "Converts an effect's failure into a fiber termination with a custom error.\n\n**Details**\n\nThe `orDieWith` function behaves like {@link orDie}, but it allows you to provide a mapping\nfunction to transform the error before terminating the fiber. This is useful for cases where\nyou want to include a more detailed or user-friendly error when the failure is propagated\nas a defect.\n\n**When to Use**\n\nUse `orDieWith` when failures should terminate the fiber as defects, and you want to customize\nthe error for clarity or debugging purposes.\n\n**Example** (Customizing Defect)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error(\"Cannot divide by zero\"))\n    : Effect.succeed(a / b)\n\n//       Effect<number, never, never>\n//      \nconst program = Effect.orDieWith(\n  divide(1, 0),\n  (error) => new Error(`defect: ${error.message}`)\n)\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: defect: Cannot divide by zero\n//   ...stack trace...\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Converting Failures to Defects",
    "signature": "declare const orDieWith: { <E>(f: (error: E) => unknown): <A, R>(self: Effect<A, E, R>) => Effect<A, never, R>; <A, E, R>(self: Effect<A, E, R>, f: (error: E) => unknown): Effect<A, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11280"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "orElse",
    "description": "Attempts one effect, and if it fails, falls back to another effect.\n\n**Details**\n\nThis function allows you to try executing an effect, and if it fails\n(produces an error), a fallback effect is executed instead. The fallback\neffect is defined as a lazy argument, meaning it will only be evaluated if\nthe first effect fails. This provides a way to recover from errors by\nspecifying an alternative path of execution.\n\nThe error type of the resulting effect will be that of the fallback effect,\nas the first effect's error is replaced when the fallback is executed.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst success = Effect.succeed(\"success\")\nconst failure = Effect.fail(\"failure\")\nconst fallback = Effect.succeed(\"fallback\")\n\n// Try the success effect first, fallback is not used\nconst program1 = Effect.orElse(success, () => fallback)\nconsole.log(Effect.runSync(program1))\n// Output: \"success\"\n\n// Try the failure effect first, fallback is used\nconst program2 = Effect.orElse(failure, () => fallback)\nconsole.log(Effect.runSync(program2))\n// Output: \"fallback\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fallback",
    "signature": "declare const orElse: { <A2, E2, R2>(that: LazyArg<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: LazyArg<Effect<A2, E2, R2>>): Effect<A2 | A, E2, R2 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11324"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "orElseFail",
    "description": "Replaces the failure of an effect with a custom failure value.\n\n**Details**\n\nThis function allows you to handle the failure of an effect by replacing it\nwith a predefined failure value. If the effect fails, the new failure value\nprovided by the `evaluate` function will be returned instead of the original\nfailure. If the effect succeeds, the original success value is returned\nunchanged.\n\n**When to Use**\n\nThis is particularly useful when you want to standardize error handling or\nprovide a consistent failure value for specific operations. It simplifies\nerror management by ensuring that all failures are replaced with a controlled\nalternative.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst validate = (age: number): Effect.Effect<number, string> => {\n  if (age < 0) {\n    return Effect.fail(\"NegativeAgeError\")\n  } else if (age < 18) {\n    return Effect.fail(\"IllegalAgeError\")\n  } else {\n    return Effect.succeed(age)\n  }\n}\n\nconst program = Effect.orElseFail(validate(-1), () => \"invalid age\")\n\nconsole.log(Effect.runSyncExit(program))\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fallback",
    "signature": "declare const orElseFail: { <E2>(evaluate: LazyArg<E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, evaluate: LazyArg<E2>): Effect<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11378"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "orElseSucceed",
    "description": "Ensures the effect always succeeds by replacing failures with a default\nsuccess value.\n\n**Details**\n\nThis function transforms an effect that may fail into one that cannot fail by\nreplacing any failure with a provided success value. If the original effect\nfails, the failure is \"swallowed,\" and the specified success value is\nreturned instead. If the original effect succeeds, its value remains\nunchanged.\n\n**When to Use**\n\nThis is especially useful for providing default values in case of failure,\nensuring that an effect always completes successfully. By using this\nfunction, you can avoid the need for complex error handling and guarantee a\nfallback result.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst validate = (age: number): Effect.Effect<number, string> => {\n  if (age < 0) {\n    return Effect.fail(\"NegativeAgeError\")\n  } else if (age < 18) {\n    return Effect.fail(\"IllegalAgeError\")\n  } else {\n    return Effect.succeed(age)\n  }\n}\n\nconst program = Effect.orElseSucceed(validate(-1), () => 18)\n\nconsole.log(Effect.runSyncExit(program))\n// Output:\n// { _id: 'Exit', _tag: 'Success', value: 18 }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fallback",
    "signature": "declare const orElseSucceed: { <A2>(evaluate: LazyArg<A2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, never, R>; <A, E, R, A2>(self: Effect<A, E, R>, evaluate: LazyArg<A2>): Effect<A | A2, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11427"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "firstSuccessOf",
    "description": "Runs a sequence of effects and returns the result of the first successful\none.\n\n**Details**\n\nThis function allows you to execute a collection of effects in sequence,\nstopping at the first success. If an effect succeeds, its result is\nimmediately returned, and no further effects in the sequence are executed.\nHowever, if all the effects fail, the function will return the error of the\nlast effect.\n\nThe execution is sequential, meaning that effects are evaluated one at a time\nin the order they are provided. This ensures predictable behavior and avoids\nunnecessary computations.\n\nIf the collection of effects is empty, an `IllegalArgumentException` is\nthrown, indicating that the operation is invalid without any effects to try.\n\n**When to Use**\n\nThis is particularly useful when you have multiple fallback strategies or\nalternative sources to obtain a result, such as attempting multiple APIs,\nretrieving configurations, or accessing resources in a prioritized manner.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\ninterface Config {\n  host: string\n  port: number\n  apiKey: string\n}\n\n// Create a configuration object with sample values\nconst makeConfig = (name: string): Config => ({\n  host: `${name}.example.com`,\n  port: 8080,\n  apiKey: \"12345-abcde\"\n})\n\n// Simulate retrieving configuration from a remote node\nconst remoteConfig = (name: string): Effect.Effect<Config, Error> =>\n  Effect.gen(function* () {\n    // Simulate node3 being the only one with available config\n    if (name === \"node3\") {\n      yield* Console.log(`Config for ${name} found`)\n      return makeConfig(name)\n    } else {\n      yield* Console.log(`Unavailable config for ${name}`)\n      return yield* Effect.fail(new Error(`Config not found for ${name}`))\n    }\n  })\n\n// Define the master configuration and potential fallback nodes\nconst masterConfig = remoteConfig(\"master\")\nconst nodeConfigs = [\"node1\", \"node2\", \"node3\", \"node4\"].map(remoteConfig)\n\n// Attempt to find a working configuration,\n// starting with the master and then falling back to other nodes\nconst config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])\n\n// Run the effect to retrieve the configuration\nconst result = Effect.runSync(config)\n\nconsole.log(result)\n// Output:\n// Unavailable config for master\n// Unavailable config for node1\n// Unavailable config for node2\n// Config for node3 found\n// { host: 'node3.example.com', port: 8080, apiKey: '12345-abcde' }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fallback",
    "signature": "declare const firstSuccessOf: <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11511"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "random",
    "description": "Retrieves the `Random` service from the context.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Random",
    "signature": "declare const random: Effect<Random.Random, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11521"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "randomWith",
    "description": "Retrieves the `Random` service from the context and uses it to run the\nspecified effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Random",
    "signature": "declare const randomWith: <A, E, R>(f: (random: Random.Random) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11530"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withRandom",
    "description": "Executes the specified effect with the specified implementation of the\n`Random` service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Random",
    "signature": "declare const withRandom: { <X extends Random.Random>(value: X): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <X extends Random.Random, A, E, R>(effect: Effect<A, E, R>, value: X): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11540"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withRandomScoped",
    "description": "Sets the implementation of the `Random` service to the specified value and\nrestores it to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Random",
    "signature": "declare const withRandomScoped: <A extends Random.Random>(value: A) => Effect<void, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11552"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "runtime",
    "description": "Returns an effect that accesses the runtime, which can be used to (unsafely)\nexecute tasks.\n\n**When to Use**\n\nThis is useful for integration with legacy code that must call back into\nEffect code.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Runtime",
    "signature": "declare const runtime: <R = never>() => Effect<Runtime.Runtime<R>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11567"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "getRuntimeFlags",
    "description": "Retrieves an effect that succeeds with the current runtime flags, which\ngovern behavior and features of the runtime system.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Runtime",
    "signature": "declare const getRuntimeFlags: Effect<RuntimeFlags.RuntimeFlags, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11576"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "patchRuntimeFlags",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Runtime",
    "signature": "declare const patchRuntimeFlags: (patch: RuntimeFlagsPatch.RuntimeFlagsPatch) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11582"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withRuntimeFlagsPatch",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Runtime",
    "signature": "declare const withRuntimeFlagsPatch: { (update: RuntimeFlagsPatch.RuntimeFlagsPatch): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, update: RuntimeFlagsPatch.RuntimeFlagsPatch): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11588"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withRuntimeFlagsPatchScoped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Runtime",
    "signature": "declare const withRuntimeFlagsPatchScoped: (update: RuntimeFlagsPatch.RuntimeFlagsPatch) => Effect<void, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11597"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "tagMetrics",
    "description": "Tags each metric in an effect with specific key-value pairs.\n\n**Details**\n\nThis function allows you to tag all metrics in an effect with a set of\nkey-value pairs or a single key-value pair. Tags help you add metadata to\nmetrics, making it easier to filter and categorize them in monitoring\nsystems. The provided tags will apply to all metrics generated within the\neffect's scope.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Metrics",
    "signature": "declare const tagMetrics: { (key: string, value: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, string>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: string): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, string>): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11615"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "labelMetrics",
    "description": "Adds labels to metrics within an effect using `MetricLabel` objects.\n\n**Details**\n\nThis function allows you to label metrics using `MetricLabel` objects. Labels\nhelp add structured metadata to metrics for categorization and filtering in\nmonitoring systems. The provided labels will apply to all metrics within the\neffect's execution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Metrics",
    "signature": "declare const labelMetrics: { (labels: Iterable<MetricLabel.MetricLabel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, labels: Iterable<MetricLabel.MetricLabel>): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11635"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "tagMetricsScoped",
    "description": "Tags metrics within a scope with a specific key-value pair.\n\n**Details**\n\nThis function tags all metrics within a scope with the provided key-value\npair. Once the scope is closed, the tag is automatically removed. This is\nuseful for applying temporary context-specific tags to metrics during scoped\noperations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Metrics",
    "signature": "declare const tagMetricsScoped: (key: string, value: string) => Effect<void, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11653"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "labelMetricsScoped",
    "description": "Adds labels to metrics within a scope using `MetricLabel` objects.\n\n**Details**\n\nThis function allows you to apply labels to all metrics generated within a\nspecific scope using an array of `MetricLabel` objects. These labels provide\nadditional metadata to metrics, which can be used for categorization,\nfiltering, or monitoring purposes. The labels are scoped and will be removed\nautomatically once the scope is closed, ensuring they are only applied\ntemporarily within the defined context.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Metrics",
    "signature": "declare const labelMetricsScoped: (labels: ReadonlyArray<MetricLabel.MetricLabel>) => Effect<void, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11671"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "metricLabels",
    "description": "Retrieves the metric labels associated with the current scope.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Metrics",
    "signature": "declare const metricLabels: Effect<ReadonlyArray<MetricLabel.MetricLabel>, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11681"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withMetric",
    "description": "Associates a metric with the current effect, updating it as the effect progresses.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Metrics",
    "signature": "declare const withMetric: { <Type, In, Out>(metric: Metric.Metric<Type, In, Out>): <A extends In, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A extends In, E, R, Type, In, Out>(self: Effect<A, E, R>, metric: Metric.Metric<Type, In, Out>): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11689"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "unsafeMakeSemaphore",
    "description": "Unsafely creates a new Semaphore.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Semaphore",
    "signature": "declare const unsafeMakeSemaphore: (permits: number) => Semaphore",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11767"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "makeSemaphore",
    "description": "Creates a new semaphore with the specified number of permits.\n\n**Details**\n\nThis function initializes a semaphore that controls concurrent access to a\nshared resource. The number of permits determines how many tasks can access\nthe resource concurrently.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n// Create a semaphore with 3 permits\nconst mutex = Effect.makeSemaphore(3)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Semaphore",
    "signature": "declare const makeSemaphore: (permits: number) => Effect<Semaphore>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11790"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "unsafeMakeLatch",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "Latch",
    "signature": "declare const unsafeMakeLatch: (open?: boolean | undefined) => Latch",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11907"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "makeLatch",
    "description": "Creates a new `Latch`, starting in the specified state.\n\n**Details**\n\nThis function initializes a `Latch` safely, ensuring proper runtime\nguarantees. By default, the latch starts in the closed state.\n\n**Example**\n\n```ts\nimport { Console, Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  // Create a latch, starting in the closed state\n  const latch = yield* Effect.makeLatch(false)\n\n  // Fork a fiber that logs \"open sesame\" when the latch is opened\n  const fiber = yield* Console.log(\"open sesame\").pipe(\n    latch.whenOpen,\n    Effect.fork\n  )\n\n  yield* Effect.sleep(\"1 second\")\n\n  // Open the latch\n  yield* latch.open\n  yield* fiber.await\n})\n\nEffect.runFork(program)\n// Output: open sesame (after 1 second)\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "Latch",
    "signature": "declare const makeLatch: (open?: boolean | undefined) => Effect<Latch, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11946"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "runFork",
    "description": "Runs an effect in the background, returning a fiber that can be observed or\ninterrupted.\n\nUnless you specifically need a `Promise` or synchronous operation, `runFork`\nis a good default choice.\n\n**Details**\n\nThis function is the foundational way to execute an effect in the background.\nIt creates a \"fiber,\" a lightweight, cooperative thread of execution that can\nbe observed (to access its result), interrupted, or joined. Fibers are useful\nfor concurrent programming and allow effects to run independently of the main\nprogram flow.\n\nOnce the effect is running in a fiber, you can monitor its progress, cancel\nit if necessary, or retrieve its result when it completes. If the effect\nfails, the fiber will propagate the failure, which you can observe and\nhandle.\n\n**When to Use**\n\nUse this function when you need to run an effect in the background,\nespecially if the effect is long-running or performs periodic tasks. It's\nsuitable for tasks that need to run independently but might still need\nobservation or management, like logging, monitoring, or scheduled tasks.\n\nThis function is ideal if you don't need the result immediately or if the\neffect is part of a larger concurrent workflow.\n\n**Example** (Running an Effect in the Background)\n\n```ts\nimport { Effect, Console, Schedule, Fiber } from \"effect\"\n\n//       Effect<number, never, never>\n//      \nconst program = Effect.repeat(\n  Console.log(\"running...\"),\n  Schedule.spaced(\"200 millis\")\n)\n\n//       RuntimeFiber<number, never>\n//      \nconst fiber = Effect.runFork(program)\n\nsetTimeout(() => {\n  Effect.runFork(Fiber.interrupt(fiber))\n}, 500)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Running Effects",
    "signature": "declare const runFork: <A, E>(effect: Effect<A, E>, options?: Runtime.RunForkOptions) => Fiber.RuntimeFiber<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12002"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "runCallback",
    "description": "Executes an effect asynchronously and handles the result using a callback.\n\n**Details**\n\nThis function runs an effect asynchronously and passes the result (`Exit`) to\na specified callback. The callback is invoked with the outcome of the effect:\n- On success, the callback receives the successful result.\n- On failure, the callback receives the failure information.\n\n**When to Use**\n\nThis function is effectful and should only be invoked at the edges of your\nprogram.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Running Effects",
    "signature": "declare const runCallback: <A, E>(effect: Effect<A, E>, options?: Runtime.RunCallbackOptions<A, E> | undefined) => Runtime.Cancel<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12025"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "runPromise",
    "description": "Executes an effect and returns the result as a `Promise`.\n\n**Details**\n\nThis function runs an effect and converts its result into a `Promise`. If the\neffect succeeds, the `Promise` will resolve with the successful result. If\nthe effect fails, the `Promise` will reject with an error, which includes the\nfailure details of the effect.\n\nThe optional `options` parameter allows you to pass an `AbortSignal` for\ncancellation, enabling more fine-grained control over asynchronous tasks.\n\n**When to Use**\n\nUse this function when you need to execute an effect and work with its result\nin a promise-based system, such as when integrating with third-party\nlibraries that expect `Promise` results.\n\n**Example** (Running a Successful Effect as a Promise)\n\n```ts\nimport { Effect } from \"effect\"\n\nEffect.runPromise(Effect.succeed(1)).then(console.log)\n// Output: 1\n```\n\n**Example** (Handling a Failing Effect as a Rejected Promise)\n\n```ts\nimport { Effect } from \"effect\"\n\nEffect.runPromise(Effect.fail(\"my error\")).catch(console.error)\n// Output:\n// (FiberFailure) Error: my error\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Running Effects",
    "signature": "declare const runPromise: <A, E>(effect: Effect<A, E, never>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12074"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "runPromiseExit",
    "description": "Runs an effect and returns a `Promise` that resolves to an `Exit`,\nrepresenting the outcome.\n\n**Details**\n\nThis function executes an effect and resolves to an `Exit` object. The `Exit`\ntype provides detailed information about the result of the effect:\n- If the effect succeeds, the `Exit` will be of type `Success` and include\n  the value produced by the effect.\n- If the effect fails, the `Exit` will be of type `Failure` and contain a\n  `Cause` object, detailing the failure.\n\nUsing this function allows you to examine both successful results and failure\ncases in a unified way, while still leveraging `Promise` for handling the\nasynchronous behavior of the effect.\n\n**When to Use**\n\nUse this function when you need to understand the outcome of an effect,\nwhether it succeeded or failed, and want to work with this result using\n`Promise` syntax. This is particularly useful when integrating with systems\nthat rely on promises but need more detailed error handling than a simple\nrejection.\n\n**Example** (Handling Results as Exit)\n\n```ts\nimport { Effect } from \"effect\"\n\n// Execute a successful effect and get the Exit result as a Promise\nEffect.runPromiseExit(Effect.succeed(1)).then(console.log)\n// Output:\n// {\n//   _id: \"Exit\",\n//   _tag: \"Success\",\n//   value: 1\n// }\n\n// Execute a failing effect and get the Exit result as a Promise\nEffect.runPromiseExit(Effect.fail(\"my error\")).then(console.log)\n// Output:\n// {\n//   _id: \"Exit\",\n//   _tag: \"Failure\",\n//   cause: {\n//     _id: \"Cause\",\n//     _tag: \"Fail\",\n//     failure: \"my error\"\n//   }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Running Effects",
    "signature": "declare const runPromiseExit: <A, E>(effect: Effect<A, E, never>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<Exit.Exit<A, E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12135"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "runSync",
    "description": "Executes an effect synchronously, running it immediately and returning the\nresult.\n\n**Details**\n\nThis function evaluates the provided effect synchronously, returning its\nresult directly. It is ideal for effects that do not fail or include\nasynchronous operations. If the effect does fail or involves async tasks, it\nwill throw an error. Execution stops at the point of failure or asynchronous\noperation, making it unsuitable for effects that require asynchronous\nhandling.\n\n**Important**: Attempting to run effects that involve asynchronous operations\nor failures will result in exceptions being thrown, so use this function with\ncare for purely synchronous and error-free effects.\n\n**When to Use**\n\nUse this function when:\n- You are sure that the effect will not fail or involve asynchronous\n  operations.\n- You need a direct, synchronous result from the effect.\n- You are working within a context where asynchronous effects are not\n  allowed.\n\nAvoid using this function for effects that can fail or require asynchronous\nhandling. For such cases, consider using {@link runPromise} or\n{@link runSyncExit}.\n\n**Example** (Synchronous Logging)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst program = Effect.sync(() => {\n  console.log(\"Hello, World!\")\n  return 1\n})\n\nconst result = Effect.runSync(program)\n// Output: Hello, World!\n\nconsole.log(result)\n// Output: 1\n```\n\n**Example** (Incorrect Usage with Failing or Async Effects)\n\n```ts\nimport { Effect } from \"effect\"\n\ntry {\n  // Attempt to run an effect that fails\n  Effect.runSync(Effect.fail(\"my error\"))\n} catch (e) {\n  console.error(e)\n}\n// Output:\n// (FiberFailure) Error: my error\n\ntry {\n  // Attempt to run an effect that involves async work\n  Effect.runSync(Effect.promise(() => Promise.resolve(1)))\n} catch (e) {\n  console.error(e)\n}\n// Output:\n// (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Running Effects",
    "signature": "declare const runSync: <A, E>(effect: Effect<A, E>) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12217"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "runSyncExit",
    "description": "Runs an effect synchronously and returns the result as an `Exit` type.\n\n**Details**\n\nThis function executes the provided effect synchronously and returns an `Exit`\ntype that encapsulates the outcome of the effect:\n- If the effect succeeds, the result is wrapped in a `Success`.\n- If the effect fails, it returns a `Failure` containing a `Cause` that explains\n  the failure.\n\nIf the effect involves asynchronous operations, this function will return a `Failure`\nwith a `Die` cause, indicating that it cannot resolve the effect synchronously.\nThis makes the function suitable for use only with effects that are synchronous\nin nature.\n\n**When to Use**\n\nUse this function when:\n- You want to handle both success and failure outcomes in a structured way using the `Exit` type.\n- You are working with effects that are purely synchronous and do not involve asynchronous operations.\n- You need to debug or inspect failures, including their causes, in a detailed manner.\n\nAvoid using this function for effects that involve asynchronous operations, as it will fail with a `Die` cause.\n\n**Example** (Handling Results as Exit)\n\n```ts\nimport { Effect } from \"effect\"\n\nconsole.log(Effect.runSyncExit(Effect.succeed(1)))\n// Output:\n// {\n//   _id: \"Exit\",\n//   _tag: \"Success\",\n//   value: 1\n// }\n\nconsole.log(Effect.runSyncExit(Effect.fail(\"my error\")))\n// Output:\n// {\n//   _id: \"Exit\",\n//   _tag: \"Failure\",\n//   cause: {\n//     _id: \"Cause\",\n//     _tag: \"Fail\",\n//     failure: \"my error\"\n//   }\n// }\n```\n\n**Example** (Asynchronous Operation Resulting in Die)\n\n```ts\nimport { Effect } from \"effect\"\n\nconsole.log(Effect.runSyncExit(Effect.promise(() => Promise.resolve(1))))\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Die',\n//     defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {\n//       fiber: [FiberRuntime],\n//       _tag: 'AsyncFiberException',\n//       name: 'AsyncFiberException'\n//     }\n//   }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Running Effects",
    "signature": "declare const runSyncExit: <A, E>(effect: Effect<A, E>) => Exit.Exit<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12295"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "validate",
    "description": "Combines multiple effects and accumulates both successes and failures.\n\n**Details**\n\nThis function allows you to combine multiple effects, continuing through all\neffects even if some of them fail. Unlike other functions that stop execution\nupon encountering an error, this function collects all errors into a `Cause`.\nThe final result includes all successes and the accumulated failures.\n\nBy default, effects are executed sequentially, but you can control\nconcurrency and batching behavior using the `options` parameter. This\nprovides flexibility in scenarios where you want to maximize performance or\nensure specific ordering.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Console.log(\"task1\").pipe(Effect.as(1))\nconst task2 = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\nconst task3 = Console.log(\"task2\").pipe(Effect.as(3))\nconst task4 = Effect.fail(\"Oh no!\").pipe(Effect.as(4))\n\nconst program = task1.pipe(\n  Effect.validate(task2),\n  Effect.validate(task3),\n  Effect.validate(task4)\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1\n// task2\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Sequential',\n//     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },\n//     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }\n//   }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error Accumulation",
    "signature": "declare const validate: { <B, E1, R1>(that: Effect<B, E1, R1>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, B], E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect<A, E, R>, that: Effect<B, E1, R1>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[A, B], E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12349"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "validateWith",
    "description": "Sequentially combines two effects using a specified combiner function while\naccumulating errors.\n\n**Details**\n\nThis function combines two effects, `self` and `that`, into a single effect\nby applying the provided combiner function to their results. If both effects\nsucceed, the combiner function is applied to their results to produce the\nfinal value. If either effect fails, the failures are accumulated into a\ncombined `Cause`.\n\nBy default, effects are executed sequentially. However, the execution mode\ncan be controlled using the `options` parameter to enable concurrency,\nbatching, or customized finalizer behavior.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error Accumulation",
    "signature": "declare const validateWith: { <B, E1, R1, A, C>(that: Effect<B, E1, R1>, f: (a: A, b: B) => C, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <E, R>(self: Effect<A, E, R>) => Effect<C, E1 | E, R1 | R>; <A, E, R, B, E1, R1, C>(self: Effect<A, E, R>, that: Effect<B, E1, R1>, f: (a: A, b: B) => C, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<C, E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12390"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Combines two effects into a single effect, producing a tuple of their\nresults.\n\n**Details**\n\nThis function combines two effects, `self` and `that`, into one. It executes\nthe first effect (`self`) and then the second effect (`that`), collecting\ntheir results into a tuple. Both effects must succeed for the resulting\neffect to succeed. If either effect fails, the entire operation fails.\n\nBy default, the effects are executed sequentially. If the `concurrent` option\nis set to `true`, the effects will run concurrently, potentially improving\nperformance for independent operations.\n\n**Example** (Combining Two Effects Sequentially)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\n// Combine the two effects together\n//\n//       Effect<[number, string], never, never>\n//      \nconst program = Effect.zip(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n// timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n// [ 1, 'hello' ]\n```\n\n**Example** (Combining Two Effects Concurrently)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\n// Run both effects concurrently using the concurrent option\nconst program = Effect.zip(task1, task2, { concurrent: true })\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n// timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n// [ 1, 'hello' ]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "declare const zip: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[A, A2], E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12489"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Executes two effects sequentially, returning the result of the first effect\nand ignoring the result of the second.\n\n**Details**\n\nThis function allows you to run two effects in sequence, where the result of\nthe first effect is preserved, and the result of the second effect is\ndiscarded. By default, the two effects are executed sequentially. If you need\nthem to run concurrently, you can pass the `{ concurrent: true }` option.\n\nThe second effect will always be executed, even though its result is ignored.\nThis makes it useful for cases where you want to execute an effect for its\nside effects while keeping the result of another effect.\n\n**When to Use**\n\nUse this function when you are only interested in the result of the first\neffect but still need to run the second effect for its side effects, such as\nlogging or performing a cleanup action.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\nconst program = Effect.zipLeft(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n// timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n// 1\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "declare const zipLeft: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12563"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Executes two effects sequentially, returning the result of the second effect\nwhile ignoring the result of the first.\n\n**Details**\n\nThis function allows you to run two effects in sequence, keeping the result\nof the second effect and discarding the result of the first. By default, the\ntwo effects are executed sequentially. If you need them to run concurrently,\nyou can pass the `{ concurrent: true }` option.\n\nThe first effect will always be executed, even though its result is ignored.\nThis makes it useful for scenarios where the first effect is needed for its\nside effects, but only the result of the second effect is important.\n\n**When to Use**\n\nUse this function when you are only interested in the result of the second\neffect but still need to run the first effect for its side effects, such as\ninitialization or setup tasks.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\nconst program = Effect.zipRight(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n// timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n// hello\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "declare const zipRight: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<A2, E2 | E, R2 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12637"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Combines two effects sequentially and applies a function to their results to\nproduce a single value.\n\n**Details**\n\nThis function runs two effects in sequence (or concurrently, if the `{\nconcurrent: true }` option is provided) and combines their results using a\nprovided function. Unlike {@link zip}, which returns a tuple of the results,\nthis function processes the results with a custom function to produce a\nsingle output.\n\n**Example** (Combining Effects with a Custom Function)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\nconst task3 = Effect.zipWith(\n  task1,\n  task2,\n  // Combines results into a single value\n  (number, string) => number + string.length\n)\n\nEffect.runPromise(task3).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#3 message=\"task1 done\"\n// timestamp=... level=INFO fiber=#2 message=\"task2 done\"\n// 6\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "declare const zipWith: { <A2, E2, R2, A, B>(that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, B>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<B, E2 | E, R2 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12700"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "ap",
    "description": "Applies the function produced by one effect to the value produced by another effect.\n\n**Details**\n\nThis function combines two effects:\n- The first effect produces a function of type `(a: A) => B`.\n- The second effect produces a value of type `A`.\n\nOnce both effects complete successfully, the function is applied to the value, resulting in an effect that produces a value of type `B`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const ap: { <A, E2, R2>(that: Effect<A, E2, R2>): <B, R, E>(self: Effect<(a: A) => B, E, R>) => Effect<B, E | E2, R | R2>; <A, B, E, R, E2, R2>(self: Effect<(a: A) => B, E, R>, that: Effect<A, E2, R2>): Effect<B, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12735"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "blocked",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "declare const blocked: <A, E>(blockedRequests: RequestBlock, _continue: Effect<A, E>) => Blocked<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12748"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "runRequestBlock",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "declare const runRequestBlock: (blockedRequests: RequestBlock) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12754"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "step",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "declare const step: <A, E, R>(self: Effect<A, E, R>) => Effect<Exit.Exit<A, E> | Blocked<A, E>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12760"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "request",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "declare const request: { <A extends Request.Request<any, any>, Ds extends RequestResolver<A> | Effect<RequestResolver<A>, any, any>>(dataSource: Ds): (self: A) => Effect<Request.Request.Success<A>, Request.Request.Error<A>, [Ds] extends [Effect<any, any, any>] ? Effect.Context<Ds> : never>; <Ds extends RequestResolver<A> | Effect<RequestResolver<A>, any, any>, A extends Request.Request<any, any>>(self: A, dataSource: Ds): Effect<Request.Request.Success<A>, Request.Request.Error<A>, [Ds] extends [Effect<any, any, any>] ? Effect.Context<Ds> : never>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12766"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "cacheRequestResult",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "declare const cacheRequestResult: <A extends Request.Request<any, any>>(request: A, result: Request.Request.Result<A>) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12793"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withRequestBatching",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "declare const withRequestBatching: { (requestBatching: boolean): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, requestBatching: boolean): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12802"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withRequestCaching",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "declare const withRequestCaching: { (strategy: boolean): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, strategy: boolean): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12811"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withRequestCache",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "declare const withRequestCache: { (cache: Request.Cache): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, cache: Request.Cache): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12820"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "tracer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const tracer: Effect<Tracer.Tracer, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12829"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "tracerWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const tracerWith: <A, E, R>(f: (tracer: Tracer.Tracer) => Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12835"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withTracer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const withTracer: { (value: Tracer.Tracer): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, value: Tracer.Tracer): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12842"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withTracerScoped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const withTracerScoped: (value: Tracer.Tracer) => Effect<void, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12851"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withTracerEnabled",
    "description": "Disable the tracer for the given Effect.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nEffect.succeed(42).pipe(\n  Effect.withSpan(\"my-span\"),\n  // the span will not be registered with the tracer\n  Effect.withTracerEnabled(false)\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const withTracerEnabled: { (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12872"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withTracerTiming",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const withTracerTiming: { (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12881"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "annotateSpans",
    "description": "Adds annotations to each span in the effect for enhanced traceability.\n\n**Details**\n\nThis function lets you attach key-value annotations to all spans generated\nduring the execution of an effect. Annotations provide additional context,\nsuch as metadata or labels, which can help you understand and debug\nasynchronous workflows more effectively.\n\nYou can either pass a single key-value pair or a record of key-value pairs to\nannotate the spans. These annotations can then be visualized in tracing tools\nthat support span annotations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const annotateSpans: { (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12903"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "annotateCurrentSpan",
    "description": "Adds annotations to the currently active span for traceability.\n\n**Details**\n\nThis function adds key-value annotations to the currently active span in the\neffect's trace. These annotations help provide more context about the\noperation being executed at a specific point in time. Unlike\n{@link annotateSpans}, which applies to all spans in an effect, this function\nfocuses solely on the active span.\n\nYou can either pass a single key-value pair or a record of key-value pairs to\nannotate the span. These annotations are useful for adding metadata to\noperations, especially in systems with detailed observability requirements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const annotateCurrentSpan: { (key: string, value: unknown): Effect<void>; (values: Record<string, unknown>): Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12928"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "currentSpan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const currentSpan: Effect<Tracer.Span, Cause.NoSuchElementException, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12937"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "currentParentSpan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const currentParentSpan: Effect<Tracer.AnySpan, Cause.NoSuchElementException, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12943"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "spanAnnotations",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const spanAnnotations: Effect<HashMap.HashMap<string, unknown>, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12949"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "spanLinks",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const spanLinks: Effect<Chunk.Chunk<Tracer.SpanLink>, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12955"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "linkSpans",
    "description": "For all spans in this effect, add a link with the provided span.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const linkSpans: { (span: Tracer.AnySpan, attributes?: Record<string, unknown>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, span: Tracer.AnySpan, attributes?: Record<string, unknown>): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12963"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "linkSpanCurrent",
    "description": "Add span links to the current span.",
    "deprecated": false,
    "examples": [],
    "since": "3.14.0",
    "category": "Tracing",
    "signature": "declare const linkSpanCurrent: { (span: Tracer.AnySpan, attributes?: Readonly<Record<string, unknown>> | undefined): Effect<void>; (links: ReadonlyArray<Tracer.SpanLink>): Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12981"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "makeSpan",
    "description": "Create a new span for tracing.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const makeSpan: (name: string, options?: Tracer.SpanOptions) => Effect<Tracer.Span>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L12992"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "makeSpanScoped",
    "description": "Create a new span for tracing, and automatically close it when the Scope\nfinalizes.\n\nThe span is not added to the current span stack, so no child spans will be\ncreated for it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const makeSpanScoped: (name: string, options?: Tracer.SpanOptions | undefined) => Effect<Tracer.Span, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13007"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "useSpan",
    "description": "Create a new span for tracing, and automatically close it when the effect\ncompletes.\n\nThe span is not added to the current span stack, so no child spans will be\ncreated for it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const useSpan: { <A, E, R>(name: string, evaluate: (span: Tracer.Span) => Effect<A, E, R>): Effect<A, E, R>; <A, E, R>(name: string, options: Tracer.SpanOptions, evaluate: (span: Tracer.Span) => Effect<A, E, R>): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13022"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withSpan",
    "description": "Wraps the effect with a new span for tracing.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const withSpan: { (name: string, options?: Tracer.SpanOptions | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Effect<A, E, R>, name: string, options?: Tracer.SpanOptions | undefined): Effect<A, E, Exclude<R, Tracer.ParentSpan>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13037"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "functionWithSpan",
    "description": "Wraps a function that returns an effect with a new span for tracing.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst getTodo = Effect.functionWithSpan({\n  body: (id: number) => Effect.succeed(`Got todo ${id}!`),\n  options: (id) => ({\n    name: `getTodo-${id}`,\n    attributes: { id }\n  })\n})\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": "Tracing",
    "signature": "declare const functionWithSpan: <Args extends Array<any>, Ret extends Effect<any, any, any>>(options: { readonly body: (...args: Args) => Ret; readonly options: FunctionWithSpanOptions | ((...args: Args) => FunctionWithSpanOptions); readonly captureStackTrace?: boolean | undefined; }) => (...args: Args) => Unify.Unify<Ret>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13085"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withSpanScoped",
    "description": "Wraps the effect with a new span for tracing.\n\nThe span is ended when the Scope is finalized.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const withSpanScoped: { (name: string, options?: Tracer.SpanOptions): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan> | Scope.Scope>; <A, E, R>(self: Effect<A, E, R>, name: string, options?: Tracer.SpanOptions): Effect<A, E, Exclude<R, Tracer.ParentSpan> | Scope.Scope>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13101"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "withParentSpan",
    "description": "Adds the provided span to the current span stack.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "declare const withParentSpan: { (span: Tracer.AnySpan): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Effect<A, E, R>, span: Tracer.AnySpan): Effect<A, E, Exclude<R, Tracer.ParentSpan>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13119"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "fromNullable",
    "description": "Safely handles nullable values by creating an effect that fails for `null` or\n`undefined`.\n\n**Details**\n\nThis function ensures that an input value is non-null and non-undefined\nbefore processing it. If the value is valid, the effect succeeds with the\nvalue. If the value is `null` or `undefined`, the effect fails with a\n`NoSuchElementException`. This is particularly useful for avoiding\nnull-related errors by clearly separating valid values from invalid ones in\neffectful computations.\n\nThe failure with `NoSuchElementException` allows you to explicitly handle\ncases where a value is expected but not provided, leading to safer and more\npredictable code.\n\n**When to Use**\n\nUse this function when working with values that may be `null` or `undefined`\nand you want to ensure that only non-null values are processed. It helps\nenforce null-safety and makes error handling more explicit.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n//       Effect<number, NoSuchElementException, never>\n//      \nconst maybe1 = Effect.fromNullable(1)\n\nEffect.runPromiseExit(maybe1).then(console.log)\n// Output:\n// { _id: 'Exit', _tag: 'Success', value: 1 }\n\n//       Effect<number, NoSuchElementException, never>\n//      \nconst maybe2 = Effect.fromNullable(null as number | null)\n\nEffect.runPromiseExit(maybe2).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: { _tag: 'NoSuchElementException' }\n//   }\n// }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Optional Wrapping & Unwrapping",
    "signature": "declare const fromNullable: <A>(value: A) => Effect<NonNullable<A>, Cause.NoSuchElementException>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13180"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "optionFromOptional",
    "description": "Converts an effect that may fail with a `NoSuchElementException` into an\neffect that succeeds with an `Option`.\n\n**Details**\n\nThis function transforms an effect that might fail with\n`Cause.NoSuchElementException` into an effect that succeeds with an `Option`\ntype. If the original effect succeeds, its value is wrapped in `Option.some`.\nIf it fails specifically due to a `NoSuchElementException`, the failure is\nmapped to `Option.none`. Other types of failures remain unchanged and are\npassed through as they are.\n\nThis is useful when working with effects where you want to gracefully handle\nthe absence of a value while preserving other potential failures.\n\n**When to Use**\n\nUse this function when you need to handle missing values as `Option.none`\nrather than throwing or propagating errors like `NoSuchElementException`.\nIts ideal for scenarios where you want to explicitly represent optionality\nin a type-safe way while retaining other failure information.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n//       Effect<number, NoSuchElementException, never>\n//      \nconst maybe1 = Effect.fromNullable(1)\n\n//       Effect<Option<number>, never, never>\n//      \nconst option1 = Effect.optionFromOptional(maybe1)\n\nEffect.runPromise(option1).then(console.log)\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\n//       Effect<number, NoSuchElementException, never>\n//      \nconst maybe2 = Effect.fromNullable(null as number | null)\n\n//       Effect<Option<number>, never, never>\n//      \nconst option2 = Effect.optionFromOptional(maybe2)\n\nEffect.runPromise(option2).then(console.log)\n// Output: { _tag: 'None' }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Optional Wrapping & Unwrapping",
    "signature": "declare const optionFromOptional: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, Exclude<E, Cause.NoSuchElementException>, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13236"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "transposeMapOption",
    "description": "Applies an `Effect` on an `Option` and transposes the result.\n\n**Details**\n\nIf the `Option` is `None`, the resulting `Effect` will immediately succeed with a `None` value.\nIf the `Option` is `Some`, the effectful operation will be executed on the inner value, and its result wrapped in a `Some`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Option, pipe } from \"effect\"\n\n//           Effect<Option<number>, never, never>>\n//          \nconst noneResult = pipe(\n  Option.none(),\n  Effect.transposeMapOption(() => Effect.succeed(42)) // will not be executed\n)\nconsole.log(Effect.runSync(noneResult))\n// Output: { _id: 'Option', _tag: 'None' }\n\n//           Effect<Option<number>, never, never>>\n//          \nconst someSuccessResult = pipe(\n  Option.some(42),\n  Effect.transposeMapOption((value) => Effect.succeed(value * 2))\n)\nconsole.log(Effect.runSync(someSuccessResult))\n// Output: { _id: 'Option', _tag: 'Some', value: 84 }\n```"
    ],
    "since": "3.14.0",
    "category": "Optional Wrapping & Unwrapping",
    "signature": "declare const transposeMapOption: (<A, B, E = never, R = never>(f: (self: A) => Effect<B, E, R>) => (self: Option.Option<A>) => Effect<Option.Option<B>, E, R>) & (<A, B, E = never, R = never>(self: Option.Option<A>, f: (self: A) => Effect<B, E, R>) => Effect<Option.Option<B>, E, R>)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13310"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Service",
    "description": "Simplifies the creation and management of services in Effect by defining both\na `Tag` and a `Layer`.\n\n**Details**\n\nThis function allows you to streamline the creation of services by combining\nthe definition of a `Context.Tag` and a `Layer` in a single step. It supports\nvarious ways of providing the service implementation:\n- Using an `effect` to define the service dynamically.\n- Using `sync` or `succeed` to define the service statically.\n- Using `scoped` to create services with lifecycle management.\n\nIt also allows you to specify dependencies for the service, which will be\nprovided automatically when the service is used. Accessors can be optionally\ngenerated for the service, making it more convenient to use.\n\n**Example**\n\n```ts\nimport { Effect } from 'effect';\n\nclass Prefix extends Effect.Service<Prefix>()(\"Prefix\", {\n sync: () => ({ prefix: \"PRE\" })\n}) {}\n\nclass Logger extends Effect.Service<Logger>()(\"Logger\", {\n accessors: true,\n effect: Effect.gen(function* () {\n   const { prefix } = yield* Prefix\n   return {\n     info: (message: string) =>\n       Effect.sync(() => {\n         console.log(`[${prefix}][${message}]`)\n       })\n   }\n }),\n dependencies: [Prefix.Default]\n}) {}\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "Context",
    "signature": "declare const Service: <Self = never>() => [Self] extends [never] ? MissingSelfGeneric : { <const Key extends string, const Make extends { readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly _: never; } | { readonly effect: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly _: never; } | { readonly sync: LazyArg<Service.AllowedType<Key, Make>>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly _: never; } | { readonly succeed: Service.AllowedType<Key, Make>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly _: never; }>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly effect: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly sync: LazyArg<Service.AllowedType<Key, Make>>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly succeed: Service.AllowedType<Key, Make>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13509"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "fn",
    "description": "The `Effect.fn` function allows you to create traced functions that return an\neffect. It provides two key features:\n\n- **Stack traces with location details** if an error occurs.\n- **Automatic span creation** for tracing when a span name is provided.\n\nIf a span name is passed as the first argument, the function's execution is\ntracked using that name. If no name is provided, stack tracing still works,\nbut spans are not created.\n\nA function can be defined using either:\n\n- A generator function, allowing the use of `yield*` for effect composition.\n- A regular function that returns an `Effect`.\n\n**Example** (Creating a Traced Function with a Span Name)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst myfunc = Effect.fn(\"myspan\")(function* <N extends number>(n: N) {\n  yield* Effect.annotateCurrentSpan(\"n\", n) // Attach metadata to the span\n  console.log(`got: ${n}`)\n  yield* Effect.fail(new Error(\"Boom!\")) // Simulate failure\n})\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause=\"Error: Boom!\n//     at <anonymous> (/.../index.ts:6:22) <= Raise location\n//     at myspan (/.../index.ts:3:23)  <= Definition location\n//     at myspan (/.../index.ts:9:16)\" <= Call location\n```\n\n`Effect.fn` automatically creates spans. The spans capture information about\nthe function execution, including metadata and error details.\n\n**Example** (Exporting Spans to the Console)\n\n```ts skip-type-checking\nimport { Effect } from \"effect\"\nimport { NodeSdk } from \"@effect/opentelemetry\"\nimport {\n  ConsoleSpanExporter,\n  BatchSpanProcessor\n} from \"@opentelemetry/sdk-trace-base\"\n\nconst myfunc = Effect.fn(\"myspan\")(function* <N extends number>(n: N) {\n  yield* Effect.annotateCurrentSpan(\"n\", n)\n  console.log(`got: ${n}`)\n  yield* Effect.fail(new Error(\"Boom!\"))\n})\n\nconst program = myfunc(100)\n\nconst NodeSdkLive = NodeSdk.layer(() => ({\n  resource: { serviceName: \"example\" },\n  // Export span data to the console\n  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())\n}))\n\nEffect.runFork(program.pipe(Effect.provide(NodeSdkLive)))\n// Output:\n// got: 100\n// {\n//   resource: {\n//     attributes: {\n//       'service.name': 'example',\n//       'telemetry.sdk.language': 'nodejs',\n//       'telemetry.sdk.name': '@effect/opentelemetry',\n//       'telemetry.sdk.version': '1.30.1'\n//     }\n//   },\n//   instrumentationScope: { name: 'example', version: undefined, schemaUrl: undefined },\n//   traceId: '22801570119e57a6e2aacda3dec9665b',\n//   parentId: undefined,\n//   traceState: undefined,\n//   name: 'myspan',\n//   id: '7af530c1e01bc0cb',\n//   kind: 0,\n//   timestamp: 1741182277518402.2,\n//   duration: 4300.416,\n//   attributes: {\n//     n: 100,\n//     'code.stacktrace': 'at <anonymous> (/.../index.ts:8:23)\\n' +\n//       'at <anonymous> (/.../index.ts:14:17)'\n//   },\n//   status: { code: 2, message: 'Boom!' },\n//   events: [\n//     {\n//       name: 'exception',\n//       attributes: {\n//         'exception.type': 'Error',\n//         'exception.message': 'Boom!',\n//         'exception.stacktrace': 'Error: Boom!\\n' +\n//           '    at <anonymous> (/.../index.ts:11:22)\\n' +\n//           '    at myspan (/.../index.ts:8:23)\\n' +\n//           '    at myspan (/.../index.ts:14:17)'\n//       },\n//       time: [ 1741182277, 522702583 ],\n//       droppedAttributesCount: 0\n//     }\n//   ],\n//   links: []\n// }\n```\n\n`Effect.fn` also acts as a pipe function, allowing you to create a pipeline\nafter the function definition using the effect returned by the generator\nfunction as the starting value of the pipeline.\n\n**Example** (Creating a Traced Function with a Delay)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst myfunc = Effect.fn(\n  function* (n: number) {\n    console.log(`got: ${n}`)\n    yield* Effect.fail(new Error(\"Boom!\"))\n  },\n  // You can access both the created effect and the original arguments\n  (effect, n) => Effect.delay(effect, `${n / 100} seconds`)\n)\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause=\"Error: Boom! (<= after 1 second)\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "Tracing",
    "signature": "declare const fn: fn.Gen & fn.NonGen & ((name: string, options?: Tracer.SpanOptions) => fn.Gen & fn.NonGen)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L14472"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "fnUntraced",
    "description": "Same as {@link fn}, but allows you to create a function that is not traced, for when performance is critical.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "Tracing",
    "signature": "declare const fnUntraced: fn.Untraced",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L14594"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "logWithLevel",
    "description": "Logs messages or error causes at a specified log level.\n\n**Details**\n\nThis function allows you to log one or more messages or error causes while\nspecifying the desired log level (e.g., DEBUG, INFO, ERROR). It provides\nflexibility in categorizing logs based on their importance or severity,\nmaking it easier to filter logs during debugging or production monitoring.\n\n**Example**\n\n```ts\nimport { Cause, Effect, LogLevel } from \"effect\"\n\nconst program = Effect.logWithLevel(\n  LogLevel.Error,\n  \"Critical error encountered\",\n  Cause.die(\"System failure!\")\n)\n\nEffect.runFork(program)\n// Output:\n// timestamp=... level=ERROR fiber=#0 message=Critical error encountered cause=\"Error: System failure!\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "declare const logWithLevel: (level: LogLevel.LogLevel, ...message: ReadonlyArray<any>) => Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10851"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "transposeOption",
    "description": "Converts an `Option` of an `Effect` into an `Effect` of an `Option`.\n\n**Details**\n\nThis function transforms an `Option<Effect<A, E, R>>` into an\n`Effect<Option<A>, E, R>`. If the `Option` is `None`, the resulting `Effect`\nwill immediately succeed with a `None` value. If the `Option` is `Some`, the\ninner `Effect` will be executed, and its result wrapped in a `Some`.\n\n**Example**\n\n```ts\nimport { Effect, Option } from \"effect\"\n\n//       Option<Effect<number, never, never>>\n//      \nconst maybe = Option.some(Effect.succeed(42))\n\n//       Effect<Option<number>, never, never>\n//      \nconst result = Effect.transposeOption(maybe)\n\nconsole.log(Effect.runSync(result))\n// Output: { _id: 'Option', _tag: 'Some', value: 42 }\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "Optional Wrapping & Unwrapping",
    "signature": "declare const transposeOption: <A = never, E = never, R = never>(self: Option.Option<Effect<A, E, R>>) => Effect<Option.Option<A>, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13270"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Tag",
    "description": "Creates a unique tag for a dependency, embedding the service's methods as\nstatic properties.\n\n**Details**\n\nThis function allows you to define a `Tag` for a service or dependency in\nyour application. The `Tag` not only acts as an identifier but also provides\ndirect access to the service's methods via static properties. This makes it\neasier to access and use the service in your code without manually managing\ncontexts.\n\nIn the example below, the fields of the service (in this case, the `notify`\nmethod) are turned into static properties of the Notifications class, making\nit easier to access them.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nclass Notifications extends Effect.Tag(\"Notifications\")<\n  Notifications,\n  { readonly notify: (message: string) => Effect.Effect<void> }\n>() {}\n\n// Create an effect that depends on the Notifications service\nconst action = Notifications.notify(\"Hello, world!\")\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const Tag: <const Id extends string>(id: Id) => <Self, Type extends Tag.AllowedType>() => Context.TagClass<Self, Id, Type> & (Type extends Record<PropertyKey, any> ? Tag.Proxy<Self, Type> : {}) & { use: <X>(body: (_: Type) => X) => [X] extends [Effect<infer A, infer E, infer R>] ? Effect<A, E, R | Self> : [X] extends [PromiseLike<infer A>] ? Effect<A, Cause.UnknownException, Self> : Effect<X, never, Self>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13429"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Effect",
    "description": "The `Effect` interface defines a value that describes a workflow or job,\nwhich can succeed or fail.\n\n**Details**\n\nThe `Effect` interface represents a computation that can model a workflow\ninvolving various types of operations, such as synchronous, asynchronous,\nconcurrent, and parallel interactions. It operates within a context of type\n`R`, and the result can either be a success with a value of type `A` or a\nfailure with an error of type `E`. The `Effect` is designed to handle complex\ninteractions with external resources, offering advanced features such as\nfiber-based concurrency, scheduling, interruption handling, and scalability.\nThis makes it suitable for tasks that require fine-grained control over\nconcurrency and error management.\n\nTo execute an `Effect` value, you need a `Runtime`, which provides the\nenvironment necessary to run and manage the computation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Effect<out A, out E = never, out R = never> extends Effect.Variance<A, E, R>, Pipeable {\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: EffectUnify<this>\n  readonly [Unify.ignoreSymbol]?: EffectUnifyIgnore\n  [Symbol.iterator](): EffectGenerator<Effect<A, E, R>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L101"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "EffectGenerator",
    "deprecated": false,
    "examples": [],
    "since": "3.0.0",
    "category": "Models",
    "signature": "export interface EffectGenerator<T extends Effect<any, any, any>> {\n  next(...args: ReadonlyArray<any>): IteratorResult<YieldWrap<T>, Effect.Success<T>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L112"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "EffectUnify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface EffectUnify<A extends { [Unify.typeSymbol]?: any }>\n  extends Either.EitherUnify<A>, Option.OptionUnify<A>, Context.TagUnify<A>\n{\n  Effect?: () => A[Unify.typeSymbol] extends Effect<infer A0, infer E0, infer R0> | infer _ ? Effect<A0, E0, R0> : never\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L120"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "EffectUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface EffectUnifyIgnore {\n  Tag?: true\n  Option?: true\n  Either?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L130"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "EffectTypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Type lambdas",
    "signature": "export interface EffectTypeLambda extends TypeLambda {\n  readonly type: Effect<this[\"Target\"], this[\"Out1\"], this[\"Out2\"]>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L140"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Blocked",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Blocked<out A, out E> extends Effect<A, E> {\n  readonly _op: \"Blocked\"\n  readonly effect_instruction_i0: RequestBlock\n  readonly effect_instruction_i1: Effect<A, E>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L148"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Adapter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Adapter {\n  <A, E, R>(self: Effect<A, E, R>): Effect<A, E, R>\n  <A, _A, _E, _R>(a: A, ab: (a: A) => Effect<_A, _E, _R>): Effect<_A, _E, _R>\n  <A, B, _A, _E, _R>(a: A, ab: (a: A) => B, bc: (b: B) => Effect<_A, _E, _R>): Effect<_A, _E, _R>\n  <A, B, C, _A, _E, _R>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => Effect<_A, _E, _R>): Effect<_A, _E, _R>\n  <A, B, C, D, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (g: H) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => T,\n    tu: (s: T) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L2763"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Permit",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Semaphore",
    "signature": "export interface Permit {\n  readonly index: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11698"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Semaphore",
    "description": "A semaphore is a synchronization mechanism used to manage access to a shared\nresource. In Effect, semaphores help control resource access or coordinate\ntasks within asynchronous, concurrent operations.\n\nA semaphore acts as a generalized mutex, allowing a set number of permits to\nbe held and released concurrently. Permits act like tickets, giving tasks or\nfibers controlled access to a shared resource. When no permits are available,\ntasks trying to acquire one will wait until a permit is released.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Semaphore",
    "signature": "export interface Semaphore {\n  /**\n   * Runs an effect with the given number of permits and releases the permits\n   * when the effect completes.\n   *\n   * **Details**\n   *\n   * This function acquires the specified number of permits before executing\n   * the provided effect. Once the effect finishes, the permits are released.\n   * If insufficient permits are available, the function will wait until they\n   * are released by other tasks.\n   */\n  withPermits(permits: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n\n  /**\n   * Runs an effect only if the specified number of permits are immediately\n   * available.\n   *\n   * **Details**\n   *\n   * This function attempts to acquire the specified number of permits. If they\n   * are available, it runs the effect and releases the permits after the effect\n   * completes. If permits are not available, the effect does not execute, and\n   * the result is `Option.none`.\n   */\n  withPermitsIfAvailable(permits: number): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>\n\n  /**\n   * Acquires the specified number of permits and returns the resulting\n   * available permits, suspending the task if they are not yet available.\n   * Concurrent pending `take` calls are processed in a first-in, first-out manner.\n   */\n  take(permits: number): Effect<number>\n\n  /**\n   * Releases the specified number of permits and returns the resulting\n   * available permits.\n   */\n  release(permits: number): Effect<number>\n\n  /**\n   * Releases all permits held by this semaphore and returns the resulting available permits.\n   */\n  releaseAll: Effect<number>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11715"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Latch",
    "description": "A `Latch` is a synchronization primitive that allows you to control the\nexecution of fibers based on an open or closed state. It acts as a gate,\nwhere fibers can wait for the latch to open before proceeding.\n\n**Details**\n\nA `Latch` can be in one of two states: open or closed. Fibers can:\n- Wait for the latch to open using `await`.\n- Proceed only when the latch is open using `whenOpen`.\n- Open the latch to release all waiting fibers using `open`.\n- Close the latch to block fibers using `close`.\n\nAdditionally, fibers can be released without changing the state of the latch\nusing `release`.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "Latch",
    "signature": "export interface Latch extends Effect<void> {\n  /**\n   * Opens the latch, releasing all fibers waiting on it.\n   *\n   * **Details**\n   *\n   * Once the latch is opened, it remains open. Any fibers waiting on `await`\n   * will be released and can continue execution.\n   */\n  readonly open: Effect<void>\n\n  /**\n   * Opens the latch, releasing all fibers waiting on it.\n   *\n   * **Details**\n   *\n   * Once the latch is opened, it remains open. Any fibers waiting on `await`\n   * will be released and can continue execution.\n   */\n  readonly unsafeOpen: () => void\n\n  /**\n   * Releases all fibers waiting on the latch without opening it.\n   *\n   * **Details**\n   *\n   * This function lets waiting fibers proceed without permanently changing the\n   * state of the latch.\n   */\n  readonly release: Effect<void>\n\n  /**\n   * Waits for the latch to be opened.\n   *\n   * **Details**\n   *\n   * If the latch is already open, this effect completes immediately. Otherwise,\n   * it suspends the fiber until the latch is opened.\n   */\n  readonly await: Effect<void>\n\n  /**\n   * Closes the latch, blocking fibers from proceeding.\n   *\n   * **Details**\n   *\n   * This operation puts the latch into a closed state, requiring it to be\n   * reopened before waiting fibers can proceed.\n   */\n  readonly close: Effect<void>\n\n  /**\n   * Unsafely closes the latch, blocking fibers without effect guarantees.\n   *\n   * **Details**\n   *\n   * Use this operation cautiously, as it does not run within an effect context\n   * and bypasses runtime guarantees.\n   */\n  readonly unsafeClose: () => void\n\n  /**\n   * Runs the given effect only when the latch is open.\n   *\n   * **Details**\n   *\n   * This function ensures that the provided effect executes only if the latch\n   * is open. If the latch is closed, the fiber will wait until it opens.\n   */\n  readonly whenOpen: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: LatchUnify<this>\n  readonly [Unify.ignoreSymbol]?: LatchUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11811"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "LatchUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "Models",
    "signature": "export interface LatchUnify<A extends { [Unify.typeSymbol]?: any }> extends EffectUnify<A> {\n  Latch?: () => Latch\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11891"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "LatchUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "Models",
    "signature": "export interface LatchUnifyIgnore extends EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L11899"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "FunctionWithSpanOptions",
    "description": "Wraps a function that returns an effect with a new span for tracing.",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": "Models",
    "signature": "export interface FunctionWithSpanOptions {\n  readonly name: string\n  readonly attributes?: Record<string, unknown> | undefined\n  readonly links?: ReadonlyArray<Tracer.SpanLink> | undefined\n  readonly parent?: Tracer.AnySpan | undefined\n  readonly root?: boolean | undefined\n  readonly context?: Context.Context<never> | undefined\n  readonly kind?: Tracer.SpanKind | undefined\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13055"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "EffectTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "type EffectTypeId = typeof EffectTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L77"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Effect.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Variance<out A, out E, out R> {\n    readonly [EffectTypeId]: VarianceStruct<A, E, R>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L220"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Effect.VarianceStruct",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface VarianceStruct<out A, out E, out R> {\n    readonly _V: string\n    readonly _A: Covariant<A>\n    readonly _E: Covariant<E>\n    readonly _R: Covariant<R>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L227"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Effect.Context",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Effect Type Extractors",
    "signature": "type Context<T> = [T] extends [Effect<infer _A, infer _E, infer _R>] ? _R : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L237"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Effect.Error",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Effect Type Extractors",
    "signature": "type Error<T> = [T] extends [Effect<infer _A, infer _E, infer _R>] ? _E : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L242"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Effect.Success",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Effect Type Extractors",
    "signature": "type Success<T> = [T] extends [Effect<infer _A, infer _E, infer _R>] ? _A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L247"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "All.EffectAny",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type EffectAny = Effect<any, any, any>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L878"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "All.ReturnIterable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type ReturnIterable<T, Discard, Mode> = [T] extends\n    [Iterable<Effect.Variance<infer R0, infer L0, infer R>>] ? Effect<\n      Discard extends true ? void : Mode extends \"either\" ? Array<Either.Either<R0, L0>> : Array<R0>,\n      Mode extends \"either\" ? never\n        : Mode extends \"validate\" ? Array<Option.Option<L0>>\n        : L0,\n      R\n    >\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L883"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "All.ReturnTuple",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Effect<Discard extends true ? void : T[number] extends never ? [] : Mode extends \"either\" ? { -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ? Either.Either<_A, _E> : never; } : { -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ? _A : never; }, Mode extends \"either\" ? never : T[number] extends never ? never : Mode extends \"validate\" ? { -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ? Option.Option<_E> : never; } : [T[number]] extends [{ [EffectTypeId]: { _E: (_: never) => infer E; }; }] ? E : never, T[number] extends never ? never : [T[number]] extends [{ [EffectTypeId]: { _R: (_: never) => infer R; }; }] ? R : never> = Effect<\n    Discard extends true ? void\n      : T[number] extends never ? []\n      : Mode extends \"either\" ? {\n          -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ?\n            Either.Either<_A, _E>\n            : never\n        }\n      : { -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ? _A : never },\n    Mode extends \"either\" ? never\n      : T[number] extends never ? never\n      : Mode extends \"validate\" ? {\n          -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ? Option.Option<_E>\n            : never\n        }\n      : [T[number]] extends [{ [EffectTypeId]: { _E: (_: never) => infer E } }] ? E\n      : never,\n    T[number] extends never ? never\n      : [T[number]] extends [{ [EffectTypeId]: { _R: (_: never) => infer R } }] ? R\n      : never\n  > extends infer X ? X : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L896"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "All.ReturnObject",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type ReturnObject<T, Discard, Mode> = [T] extends [{ [K: string]: EffectAny }] ? Effect<\n      Discard extends true ? void\n        : Mode extends \"either\" ? {\n            -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ?\n              Either.Either<_A, _E>\n              : never\n          }\n        : { -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ? _A : never },\n      Mode extends \"either\" ? never\n        : keyof T extends never ? never\n        : Mode extends \"validate\" ? {\n            -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ? Option.Option<_E>\n              : never\n          }\n        : [T[keyof T]] extends [{ [EffectTypeId]: { _E: (_: never) => infer E } }] ? E\n        : never,\n      keyof T extends never ? never\n        : [T[keyof T]] extends [{ [EffectTypeId]: { _R: (_: never) => infer R } }] ? R\n        : never\n    >\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L921"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "All.IsDiscard",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type IsDiscard<A> = [Extract<A, { readonly discard: true }>] extends [never] ? false : true",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L946"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "All.ExtractMode",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type ExtractMode<A> = [A] extends [{ mode: infer M }] ? M : \"default\"",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L951"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "All.Return",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Return<Arg, O> = [Arg] extends [ReadonlyArray<EffectAny>] ? ReturnTuple<Arg, IsDiscard<O>, ExtractMode<O>>\n    : [Arg] extends [Iterable<EffectAny>] ? ReturnIterable<Arg, IsDiscard<O>, ExtractMode<O>>\n    : [Arg] extends [Record<string, EffectAny>] ? ReturnObject<Arg, IsDiscard<O>, ExtractMode<O>>\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L956"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Retry.Options",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export interface Options<E> {\n    while?: ((error: E) => boolean | Effect<boolean, any, any>) | undefined\n    until?: ((error: E) => boolean | Effect<boolean, any, any>) | undefined\n    times?: number | undefined\n    schedule?: Schedule.Schedule<any, E, any> | undefined\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4257"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Retry.Return",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "type Effect<A, (O extends { schedule: Schedule.Schedule<infer _O, infer _I, infer _R>; } ? E : O extends { until: Refinement<E, infer E2>; } ? E2 : E) | (O extends { while: (...args: Array<any>) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: Array<any>) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule.Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: Array<any>) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: Array<any>) => Effect<infer _A, infer _E, infer R>; } ? R : never)> = Effect<\n    A,\n    | (O extends { schedule: Schedule.Schedule<infer _O, infer _I, infer _R> } ? E\n      : O extends { until: Refinement<E, infer E2> } ? E2\n      : E)\n    | (O extends { while: (...args: Array<any>) => Effect<infer _A, infer E, infer _R> } ? E : never)\n    | (O extends { until: (...args: Array<any>) => Effect<infer _A, infer E, infer _R> } ? E : never),\n    | R\n    | (O extends { schedule: Schedule.Schedule<infer _O, infer _I, infer R> } ? R : never)\n    | (O extends { while: (...args: Array<any>) => Effect<infer _A, infer _E, infer R> } ? R : never)\n    | (O extends { until: (...args: Array<any>) => Effect<infer _A, infer _E, infer R> } ? R : never)\n  > extends infer Z ? Z : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L4240"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Repeat.Options",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "export interface Options<A> {\n    while?: ((_: A) => boolean | Effect<boolean, any, any>) | undefined\n    until?: ((_: A) => boolean | Effect<boolean, any, any>) | undefined\n    times?: number | undefined\n    schedule?: Schedule.Schedule<any, A, any> | undefined\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10078"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Repeat.Return",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "type Effect<O extends { schedule: Schedule.Schedule<infer Out, infer _I, infer _R>; } ? Out : O extends { until: Refinement<A, infer B>; } ? B : A, E | (O extends { while: (...args: Array<any>) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: Array<any>) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule.Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: Array<any>) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: Array<any>) => Effect<infer _A, infer _E, infer R>; } ? R : never)> = Effect<\n    (O extends { schedule: Schedule.Schedule<infer Out, infer _I, infer _R> } ? Out\n      : O extends { until: Refinement<A, infer B> } ? B\n      : A),\n    | E\n    | (O extends { while: (...args: Array<any>) => Effect<infer _A, infer E, infer _R> } ? E : never)\n    | (O extends { until: (...args: Array<any>) => Effect<infer _A, infer E, infer _R> } ? E : never),\n    | R\n    | (O extends { schedule: Schedule.Schedule<infer _O, infer _I, infer R> } ? R : never)\n    | (O extends { while: (...args: Array<any>) => Effect<infer _A, infer _E, infer R> } ? R : never)\n    | (O extends { until: (...args: Array<any>) => Effect<infer _A, infer _E, infer R> } ? R : never)\n  > extends infer Z ? Z : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L10061"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Tag.ProhibitedType",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface ProhibitedType {\n    Service?: `property \"Service\" is forbidden`\n    Identifier?: `property \"Identifier\" is forbidden`\n    _op?: `property \"_op\" is forbidden`\n    of?: `property \"of\" is forbidden`\n    context?: `property \"context\" is forbidden`\n    key?: `property \"key\" is forbidden`\n    stack?: `property \"stack\" is forbidden`\n    name?: `property \"name\" is forbidden`\n    pipe?: `property \"pipe\" is forbidden`\n    use?: `property \"use\" is forbidden`\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13329"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Tag.AllowedType",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "type AllowedType = (Record<PropertyKey, any> & ProhibitedType) | string | number | symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13346"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Tag.Proxy",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "Models",
    "signature": "type Proxy<Self, Type> = {\n    [\n      k in keyof Type as Type[k] extends ((...args: infer Args extends ReadonlyArray<any>) => infer Ret) ?\n        ((...args: Readonly<Args>) => Ret) extends Type[k] ? k : never\n        : k\n    ]: Type[k] extends (...args: infer Args extends ReadonlyArray<any>) => Effect<infer A, infer E, infer R> ?\n      (...args: Readonly<Args>) => Effect<A, E, Self | R>\n      : Type[k] extends (...args: infer Args extends ReadonlyArray<any>) => Promise<infer A> ?\n        (...args: Readonly<Args>) => Effect<A, Cause.UnknownException, Self>\n      : Type[k] extends (...args: infer Args extends ReadonlyArray<any>) => infer A ?\n        (...args: Readonly<Args>) => Effect<A, never, Self>\n      : Type[k] extends Effect<infer A, infer E, infer R> ? Effect<A, E, Self | R>\n      : Effect<Type[k], never, Self>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13352"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Service.ProhibitedType",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": null,
    "signature": "export interface ProhibitedType {\n    Service?: `property \"Service\" is forbidden`\n    Identifier?: `property \"Identifier\" is forbidden`\n    Default?: `property \"Default\" is forbidden`\n    DefaultWithoutDependencies?: `property \"DefaultWithoutDependencies\" is forbidden`\n    _op_layer?: `property \"_op_layer\" is forbidden`\n    _op?: `property \"_op\" is forbidden`\n    of?: `property \"of\" is forbidden`\n    make?: `property \"make\" is forbidden`\n    context?: `property \"context\" is forbidden`\n    key?: `property \"key\" is forbidden`\n    stack?: `property \"stack\" is forbidden`\n    name?: `property \"name\" is forbidden`\n    pipe?: `property \"pipe\" is forbidden`\n    use?: `property \"use\" is forbidden`\n    _tag?: `property \"_tag\" is forbidden`\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13692"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Service.AllowedType",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": null,
    "signature": "type AllowedType<Key, Make> = MakeAccessors<Make> extends true ?\n      & Record<PropertyKey, any>\n      & {\n        readonly [K in Extract<keyof MakeService<Make>, keyof ProhibitedType>]: K extends \"_tag\" ? Key\n          : ProhibitedType[K]\n      }\n    : Record<PropertyKey, any> & { readonly _tag?: Key }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13713"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Service.Class",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": null,
    "signature": "type Class<Self, Key, Make> = & {\n      new(_: MakeService<Make>): MakeService<Make> & {\n        readonly _tag: Key\n      }\n      readonly use: <X>(\n        body: (_: Self) => X\n      ) => [X] extends [Effect<infer A, infer E, infer R>] ? Effect<A, E, R | Self>\n        : [X] extends [PromiseLike<infer A>] ? Effect<A, Cause.UnknownException, Self>\n        : Effect<X, never, Self>\n      readonly make: (_: MakeService<Make>) => Self\n    }\n    & Context.Tag<Self, Self>\n    & { key: Key }\n    & (MakeAccessors<Make> extends true ? Tag.Proxy<Self, MakeService<Make>> : {})\n    & (MakeDeps<Make> extends never ? {\n        readonly Default: Layer.Layer<Self, MakeError<Make>, MakeContext<Make>>\n      } :\n      {\n        readonly DefaultWithoutDependencies: Layer.Layer<Self, MakeError<Make>, MakeContext<Make>>\n        readonly Default: Layer.Layer<\n          Self,\n          MakeError<Make> | MakeDepsE<Make>,\n          | Exclude<MakeContext<Make>, MakeDepsOut<Make>>\n          | MakeDepsIn<Make>\n        >\n      })",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13724"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Service.MakeService",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": null,
    "signature": "type MakeService<Make> = Make extends { readonly effect: Effect<infer _A, infer _E, infer _R> } ? _A\n    : Make extends { readonly scoped: Effect<infer _A, infer _E, infer _R> } ? _A\n    : Make extends { readonly sync: LazyArg<infer A> } ? A\n    : Make extends { readonly succeed: infer A } ? A\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13759"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Service.MakeError",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": null,
    "signature": "type MakeError<Make> = Make extends { readonly effect: Effect<infer _A, infer _E, infer _R> } ? _E\n    : Make extends { readonly scoped: Effect<infer _A, infer _E, infer _R> } ? _E\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13768"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Service.MakeContext",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": null,
    "signature": "type MakeContext<Make> = Make extends { readonly effect: Effect<infer _A, infer _E, infer _R> } ? _R\n    : Make extends { readonly scoped: Effect<infer _A, infer _E, infer _R> } ? Exclude<_R, Scope.Scope>\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13775"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Service.MakeDeps",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": null,
    "signature": "type MakeDeps<Make> = Make extends { readonly dependencies: ReadonlyArray<Layer.Layer.Any> }\n    ? Make[\"dependencies\"][number]\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13782"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Service.MakeDepsOut",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": null,
    "signature": "type MakeDepsOut<Make> = Contravariant.Type<MakeDeps<Make>[Layer.LayerTypeId][\"_ROut\"]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13789"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Service.MakeDepsE",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": null,
    "signature": "type MakeDepsE<Make> = Covariant.Type<MakeDeps<Make>[Layer.LayerTypeId][\"_E\"]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13794"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Service.MakeDepsIn",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": null,
    "signature": "type MakeDepsIn<Make> = Covariant.Type<MakeDeps<Make>[Layer.LayerTypeId][\"_RIn\"]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13799"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "Service.MakeAccessors",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": null,
    "signature": "type MakeAccessors<Make> = Make extends { readonly accessors: true } ? true\n    : false",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13804"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "fn.Gen",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "Models",
    "signature": "type Gen = {\n    <Eff extends YieldWrap<Effect<any, any, any>>, AEff, Args extends Array<any>>(\n      body: (...args: Args) => Generator<Eff, AEff, never>\n    ): (...args: Args) => Effect<\n      AEff,\n      [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n      [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n    >\n    <Eff extends YieldWrap<Effect<any, any, any>>, AEff, Args extends Array<any>, A extends Effect<any, any, any>>(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A\n    ): (...args: Args) => A\n    <Eff extends YieldWrap<Effect<any, any, any>>, AEff, Args extends Array<any>, A, B extends Effect<any, any, any>>(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B\n    ): (...args: Args) => B\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B,\n      c: (_: B, ...args: Args) => C\n    ): (...args: Args) => C\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B,\n      c: (_: B, ...args: Args) => C,\n      d: (_: C, ...args: Args) => D\n    ): (...args: Args) => D\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B,\n      c: (_: B, ...args: Args) => C,\n      d: (_: C, ...args: Args) => D,\n      e: (_: D, ...args: Args) => E\n    ): (...args: Args) => E\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B,\n      c: (_: B, ...args: Args) => C,\n      d: (_: C, ...args: Args) => D,\n      e: (_: D, ...args: Args) => E,\n      f: (_: E, ...args: Args) => F\n    ): (...args: Args) => F\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B,\n      c: (_: B, ...args: Args) => C,\n      d: (_: C, ...args: Args) => D,\n      e: (_: D, ...args: Args) => E,\n      f: (_: E, ...args: Args) => F,\n      g: (_: F, ...args: Args) => G\n    ): (...args: Args) => G\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B,\n      c: (_: B, ...args: Args) => C,\n      d: (_: C, ...args: Args) => D,\n      e: (_: D, ...args: Args) => E,\n      f: (_: E, ...args: Args) => F,\n      g: (_: F, ...args: Args) => G,\n      h: (_: G, ...args: Args) => H\n    ): (...args: Args) => H\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H,\n      I extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B,\n      c: (_: B, ...args: Args) => C,\n      d: (_: C, ...args: Args) => D,\n      e: (_: D, ...args: Args) => E,\n      f: (_: E, ...args: Args) => F,\n      g: (_: F, ...args: Args) => G,\n      h: (_: G, ...args: Args) => H,\n      i: (_: H, ...args: Args) => I\n    ): (...args: Args) => I\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L13817"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "fn.NonGen",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "Models",
    "signature": "type NonGen = {\n    <Eff extends Effect<any, any, any>, Args extends Array<any>>(\n      body: (...args: Args) => Eff\n    ): (...args: Args) => Eff\n    <Eff extends Effect<any, any, any>, A, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: Args) => Eff\n    ): (...args: Args) => Eff\n    <Eff extends Effect<any, any, any>, A, B, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: Args) => B,\n      b: (_: B, ...args: Args) => Eff\n    ): (...args: Args) => Eff\n    <Eff extends Effect<any, any, any>, A, B, C, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: Args) => B,\n      b: (_: B, ...args: Args) => C,\n      c: (_: C, ...args: Args) => Eff\n    ): (...args: Args) => Eff\n    <Eff extends Effect<any, any, any>, A, B, C, D, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: Args) => B,\n      b: (_: B, ...args: Args) => C,\n      c: (_: C, ...args: Args) => D,\n      d: (_: D, ...args: Args) => Eff\n    ): (...args: Args) => Eff\n    <Eff extends Effect<any, any, any>, A, B, C, D, E, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: Args) => B,\n      b: (_: B, ...args: Args) => C,\n      c: (_: C, ...args: Args) => D,\n      d: (_: D, ...args: Args) => E,\n      e: (_: E, ...args: Args) => Eff\n    ): (...args: Args) => Eff\n    <Eff extends Effect<any, any, any>, A, B, C, D, E, F, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: Args) => B,\n      b: (_: B, ...args: Args) => C,\n      c: (_: C, ...args: Args) => D,\n      d: (_: D, ...args: Args) => E,\n      e: (_: E, ...args: Args) => F,\n      f: (_: F, ...args: Args) => Eff\n    ): (...args: Args) => Eff\n    <Eff extends Effect<any, any, any>, A, B, C, D, E, F, G, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: Args) => B,\n      b: (_: B, ...args: Args) => C,\n      c: (_: C, ...args: Args) => D,\n      d: (_: D, ...args: Args) => E,\n      e: (_: E, ...args: Args) => F,\n      f: (_: F, ...args: Args) => G,\n      g: (_: G, ...args: Args) => Eff\n    ): (...args: Args) => Eff\n    <Eff extends Effect<any, any, any>, A, B, C, D, E, F, G, H, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: Args) => B,\n      b: (_: B, ...args: Args) => C,\n      c: (_: C, ...args: Args) => D,\n      d: (_: D, ...args: Args) => E,\n      e: (_: E, ...args: Args) => F,\n      f: (_: F, ...args: Args) => G,\n      g: (_: G, ...args: Args) => H,\n      h: (_: H, ...args: Args) => Eff\n    ): (...args: Args) => Eff\n    <Eff extends Effect<any, any, any>, A, B, C, D, E, F, G, H, I, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: Args) => B,\n      b: (_: B, ...args: Args) => C,\n      c: (_: C, ...args: Args) => D,\n      d: (_: D, ...args: Args) => E,\n      e: (_: E, ...args: Args) => F,\n      f: (_: F, ...args: Args) => G,\n      g: (_: G, ...args: Args) => H,\n      h: (_: H, ...args: Args) => I,\n      i: (_: H, ...args: Args) => Eff\n    ): (...args: Args) => Eff\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L14036"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect.ts",
      "path": "src/Effect.ts"
    },
    "project": "effect",
    "name": "fn.Untraced",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "Models",
    "signature": "type Untraced = {\n    <Eff extends YieldWrap<Effect<any, any, any>>, AEff, Args extends Array<any>>(\n      body: (...args: Args) => Generator<Eff, AEff, never>\n    ): (...args: Args) => Effect<\n      AEff,\n      [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n      [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n    >\n    <Eff extends YieldWrap<Effect<any, any, any>>, AEff, Args extends Array<any>, A>(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A\n    ): (...args: Args) => A\n    <Eff extends YieldWrap<Effect<any, any, any>>, AEff, Args extends Array<any>, A, B>(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B\n    ): (...args: Args) => B\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B,\n      c: (_: B, ...args: Args) => C\n    ): (...args: Args) => C\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B,\n      c: (_: B, ...args: Args) => C,\n      d: (_: C, ...args: Args) => D\n    ): (...args: Args) => D\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B,\n      c: (_: B, ...args: Args) => C,\n      d: (_: C, ...args: Args) => D,\n      e: (_: D, ...args: Args) => E\n    ): (...args: Args) => E\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B,\n      c: (_: B, ...args: Args) => C,\n      d: (_: C, ...args: Args) => D,\n      e: (_: D, ...args: Args) => E,\n      f: (_: E, ...args: Args) => F\n    ): (...args: Args) => F\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B,\n      c: (_: B, ...args: Args) => C,\n      d: (_: C, ...args: Args) => D,\n      e: (_: D, ...args: Args) => E,\n      f: (_: E, ...args: Args) => F,\n      g: (_: F, ...args: Args) => G\n    ): (...args: Args) => G\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B,\n      c: (_: B, ...args: Args) => C,\n      d: (_: C, ...args: Args) => D,\n      e: (_: D, ...args: Args) => E,\n      f: (_: E, ...args: Args) => F,\n      g: (_: F, ...args: Args) => G,\n      h: (_: G, ...args: Args) => H\n    ): (...args: Args) => H\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H,\n      I\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: Args\n      ) => A,\n      b: (_: A, ...args: Args) => B,\n      c: (_: B, ...args: Args) => C,\n      d: (_: C, ...args: Args) => D,\n      e: (_: D, ...args: Args) => E,\n      f: (_: E, ...args: Args) => F,\n      g: (_: F, ...args: Args) => G,\n      h: (_: G, ...args: Args) => H,\n      i: (_: H, ...args: Args) => I\n    ): (...args: Args) => I\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effect.ts#L14118"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Effectable.ts",
      "path": "src/Effectable.ts"
    },
    "project": "effect",
    "name": "Class",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare class Class<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effectable.ts#L91"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Effectable.ts",
      "path": "src/Effectable.ts"
    },
    "project": "effect",
    "name": "StructuralClass",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare class StructuralClass<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effectable.ts#L102"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effectable.ts",
      "path": "src/Effectable.ts"
    },
    "project": "effect",
    "name": "EffectTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "declare const EffectTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effectable.ts#L14"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effectable.ts",
      "path": "src/Effectable.ts"
    },
    "project": "effect",
    "name": "StreamTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "declare const StreamTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effectable.ts#L26"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effectable.ts",
      "path": "src/Effectable.ts"
    },
    "project": "effect",
    "name": "SinkTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "declare const SinkTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effectable.ts#L38"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effectable.ts",
      "path": "src/Effectable.ts"
    },
    "project": "effect",
    "name": "ChannelTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "declare const ChannelTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effectable.ts#L50"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effectable.ts",
      "path": "src/Effectable.ts"
    },
    "project": "effect",
    "name": "EffectPrototype",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "prototypes",
    "signature": "declare const EffectPrototype: Effect.Effect<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effectable.ts#L70"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effectable.ts",
      "path": "src/Effectable.ts"
    },
    "project": "effect",
    "name": "CommitPrototype",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "prototypes",
    "signature": "declare const CommitPrototype: Effect.Effect<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effectable.ts#L76"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effectable.ts",
      "path": "src/Effectable.ts"
    },
    "project": "effect",
    "name": "StructuralCommitPrototype",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "prototypes",
    "signature": "declare const StructuralCommitPrototype: Effect.Effect<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effectable.ts#L82"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effectable.ts",
      "path": "src/Effectable.ts"
    },
    "project": "effect",
    "name": "CommitPrimitive",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface CommitPrimitive {\n  new<A, E = never, R = never>(): Effect.Effect<A, E, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effectable.ts#L62"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effectable.ts",
      "path": "src/Effectable.ts"
    },
    "project": "effect",
    "name": "EffectTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "type EffectTypeId = Effect.EffectTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effectable.ts#L20"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effectable.ts",
      "path": "src/Effectable.ts"
    },
    "project": "effect",
    "name": "StreamTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "type StreamTypeId = Stream.StreamTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effectable.ts#L32"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effectable.ts",
      "path": "src/Effectable.ts"
    },
    "project": "effect",
    "name": "SinkTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "type SinkTypeId = Sink.SinkTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effectable.ts#L44"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effectable.ts",
      "path": "src/Effectable.ts"
    },
    "project": "effect",
    "name": "ChannelTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "type ChannelTypeId = Channel.ChannelTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Effectable.ts#L56"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L31"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "right",
    "description": "Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\nof this structure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const right: <R>(right: R) => Either<R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L120"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "left",
    "description": "Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\nstructure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const left: <L>(left: L) => Either<never, L>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L138"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "fromNullable",
    "description": "Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\nthe provided default as a `Left`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))\nassert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromNullable: { <R, L>(onNullable: (right: R) => L): (self: R) => Either<NonNullable<R>, L>; <R, L>(self: R, onNullable: (right: R) => L): Either<NonNullable<R>, L>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L156"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "fromOption",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either, Option } from \"effect\"\n\nassert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))\nassert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromOption: { <L>(onNone: () => L): <R>(self: Option<R>) => Either<R, L>; <R, L>(self: Option<R>, onNone: () => L): Either<R, L>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L178"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "isEither",
    "description": "Tests if a value is a `Either`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.isEither(Either.right(1)), true)\nassert.deepStrictEqual(Either.isEither(Either.left(\"a\")), true)\nassert.deepStrictEqual(Either.isEither({ right: 1 }), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isEither: (input: unknown) => input is Either<unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L239"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "isLeft",
    "description": "Determine if a `Either` is a `Left`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.isLeft(Either.right(1)), false)\nassert.deepStrictEqual(Either.isLeft(Either.left(\"a\")), true)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isLeft: <R, L>(self: Either<R, L>) => self is Left<L, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L256"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "isRight",
    "description": "Determine if a `Either` is a `Right`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.isRight(Either.right(1)), true)\nassert.deepStrictEqual(Either.isRight(Either.left(\"a\")), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isRight: <R, L>(self: Either<R, L>) => self is Right<L, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L273"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "getRight",
    "description": "Converts a `Either` to an `Option` discarding the `Left`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either, Option } from \"effect\"\n\nassert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))\nassert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const getRight: <R, L>(self: Either<R, L>) => Option<R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L290"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "getLeft",
    "description": "Converts a `Either` to an `Option` discarding the value.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either, Option } from \"effect\"\n\nassert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())\nassert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const getLeft: <R, L>(self: Either<R, L>) => Option<L>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L307"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "mapBoth",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapBoth: { <L, L2, R, R2>(options: { readonly onLeft: (left: L) => L2; readonly onRight: (right: R) => R2; }): (self: Either<R, L>) => Either<R2, L2>; <L, R, L2, R2>(self: Either<R, L>, options: { readonly onLeft: (left: L) => L2; readonly onRight: (right: R) => R2; }): Either<R2, L2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L327"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "mapLeft",
    "description": "Maps the `Left` side of an `Either` value to a new `Either` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapLeft: { <L, L2>(f: (left: L) => L2): <R>(self: Either<R, L>) => Either<R, L2>; <R, L, L2>(self: Either<R, L>, f: (left: L) => L2): Either<R, L2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L350"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Maps the `Right` side of an `Either` value to a new `Either` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <R, R2>(f: (right: R) => R2): <L>(self: Either<R, L>) => Either<R2, L>; <R, L, R2>(self: Either<R, L>, f: (right: R) => R2): Either<R2, L>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L365"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\nif the value is a `Right` the inner value is applied to the `onRight` function.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, Either } from \"effect\"\n\nconst onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n\nconst onRight = (value: number): string => `Ok: ${value}`\n\nassert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')\nassert.deepStrictEqual(\n  pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),\n  'strings: string 1, string 2'\n)\n```"
    ],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "declare const match: { <L, B, R, C = B>(options: { readonly onLeft: (left: L) => B; readonly onRight: (right: R) => C; }): (self: Either<R, L>) => B | C; <R, L, B, C = B>(self: Either<R, L>, options: { readonly onLeft: (left: L) => B; readonly onRight: (right: R) => C; }): B | C; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L397"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "liftPredicate",
    "description": "Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\nor `Left` of the result of the provided function if the predicate returns false",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, Either } from \"effect\"\n\nconst isPositive = (n: number): boolean => n > 0\n\nassert.deepStrictEqual(\n  pipe(\n    1,\n    Either.liftPredicate(isPositive, n => `${n} is not positive`)\n  ),\n  Either.right(1)\n)\nassert.deepStrictEqual(\n  pipe(\n    0,\n    Either.liftPredicate(isPositive, n => `${n} is not positive`)\n  ),\n  Either.left(\"0 is not positive\")\n)\n```"
    ],
    "since": "3.4.0",
    "category": "lifting",
    "signature": "declare const liftPredicate: { <A, B extends A, E>(refinement: Refinement<NoInfer<A>, B>, orLeftWith: (a: NoInfer<A>) => E): (a: A) => Either<B, E>; <A, E>(predicate: Predicate<NoInfer<A>>, orLeftWith: (a: NoInfer<A>) => E): (a: A) => Either<A, E>; <A, E, B extends A>(self: A, refinement: Refinement<A, B>, orLeftWith: (a: A) => E): Either<B, E>; <A, E>(self: A, predicate: Predicate<NoInfer<A>>, orLeftWith: (a: NoInfer<A>) => E): Either<A, E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L444"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "filterOrLeft",
    "description": "Filter the right value with the provided function.\nIf the predicate fails, set the left value with the result of the provided function.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, Either } from \"effect\"\n\nconst isPositive = (n: number): boolean => n > 0\n\nassert.deepStrictEqual(\n  pipe(\n    Either.right(1),\n    Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n  ),\n  Either.right(1)\n)\nassert.deepStrictEqual(\n  pipe(\n    Either.right(0),\n    Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n  ),\n  Either.left(\"0 is not positive\")\n)\n```"
    ],
    "since": "2.0.0",
    "category": "filtering & conditionals",
    "signature": "declare const filterOrLeft: { <R, B extends R, L2>(refinement: Refinement<NoInfer<R>, B>, orLeftWith: (right: NoInfer<R>) => L2): <L>(self: Either<R, L>) => Either<B, L2 | L>; <R, L2>(predicate: Predicate<NoInfer<R>>, orLeftWith: (right: NoInfer<R>) => L2): <L>(self: Either<R, L>) => Either<R, L2 | L>; <R, L, B extends R, L2>(self: Either<R, L>, refinement: Refinement<R, B>, orLeftWith: (right: R) => L2): Either<B, L | L2>; <R, L, E2>(self: Either<R, L>, predicate: Predicate<R>, orLeftWith: (right: R) => E2): Either<R, L | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L496"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "merge",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const merge: <R, L>(self: Either<R, L>) => L | R",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L521"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "getOrElse",
    "description": "Returns the wrapped value if it's a `Right` or a default value if is a `Left`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + \"!\"), 1)\nassert.deepStrictEqual(Either.getOrElse(Either.left(\"not a number\"), (error) => error + \"!\"), \"not a number!\")\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const getOrElse: { <L, R2>(onLeft: (left: L) => R2): <R>(self: Either<R, L>) => R2 | R; <R, L, R2>(self: Either<R, L>, onLeft: (left: L) => R2): R | R2; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L541"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "getOrNull",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.getOrNull(Either.right(1)), 1)\nassert.deepStrictEqual(Either.getOrNull(Either.left(\"a\")), null)\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const getOrNull: <R, L>(self: Either<R, L>) => R | null",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L562"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "getOrUndefined",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.getOrUndefined(Either.right(1)), 1)\nassert.deepStrictEqual(Either.getOrUndefined(Either.left(\"a\")), undefined)\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const getOrUndefined: <R, L>(self: Either<R, L>) => R | undefined",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L577"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "getOrThrowWith",
    "description": "Extracts the value of an `Either` or throws if the `Either` is `Left`.\n\nIf a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),\n  1\n)\nassert.throws(() => Either.getOrThrowWith(Either.left(\"error\"), () => new Error('Unexpected Left')))\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const getOrThrowWith: { <L>(onLeft: (left: L) => unknown): <A>(self: Either<A, L>) => A; <R, L>(self: Either<R, L>, onLeft: (left: L) => unknown): R; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L599"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "getOrThrow",
    "description": "Extracts the value of an `Either` or throws if the `Either` is `Left`.\n\nThe thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)\nassert.throws(() => Either.getOrThrow(Either.left(\"error\")))\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const getOrThrow: <R, L>(self: Either<R, L>) => R",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L629"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "orElse",
    "description": "Returns `self` if it is a `Right` or `that` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElse: { <L, R2, L2>(that: (left: L) => Either<R2, L2>): <R>(self: Either<R, L>) => Either<R | R2, L2>; <R, L, R2, L2>(self: Either<R, L>, that: (left: L) => Either<R2, L2>): Either<R | R2, L2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L639"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMap: { <R, R2, L2>(f: (right: R) => Either<R2, L2>): <L>(self: Either<R, L>) => Either<R2, L | L2>; <R, L, R2, L2>(self: Either<R, L>, f: (right: R) => Either<R2, L2>): Either<R2, L | L2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L652"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "andThen",
    "description": "Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const andThen: { <R, R2, L2>(f: (right: R) => Either<R2, L2>): <L>(self: Either<R, L>) => Either<R2, L | L2>; <R2, L2>(f: Either<R2, L2>): <L, R1>(self: Either<R1, L>) => Either<R2, L | L2>; <R, R2>(f: (right: R) => R2): <L>(self: Either<R, L>) => Either<R2, L>; <R2>(right: NotFunction<R2>): <R1, L>(self: Either<R1, L>) => Either<R2, L>; <R, L, R2, L2>(self: Either<R, L>, f: (right: R) => Either<R2, L2>): Either<R2, L | L2>; <R, L, R2, L2>(self: Either<R, L>, f: Either<R2, L2>): Either<R2, L | L2>; <R, L, R2>(self: Either<R, L>, f: (right: R) => R2): Either<R2, L>; <R, L, R2>(self: Either<R, L>, f: NotFunction<R2>): Either<R2, L>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L667"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWith: { <R2, L2, R, B>(that: Either<R2, L2>, f: (right: R, right2: R2) => B): <L>(self: Either<R, L>) => Either<B, L2 | L>; <R, L, R2, L2, B>(self: Either<R, L>, that: Either<R2, L2>, f: (right: R, right2: R2) => B): Either<B, L | L2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L689"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "ap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const ap: { <R, L2>(that: Either<R, L2>): <R2, L>(self: Either<(right: R) => R2, L>) => Either<R2, L | L2>; <R, R2, L, L2>(self: Either<(right: R) => R2, L>, that: Either<R, L2>): Either<R2, L | L2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L709"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "Do",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either, pipe } from \"effect\"\n\nconst result = pipe(\n  Either.Do,\n  Either.bind(\"x\", () => Either.right(2)),\n  Either.bind(\"y\", () => Either.right(3)),\n  Either.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n```"
    ],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "declare const Do: Either<{}, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L840"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "bind",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either, pipe } from \"effect\"\n\nconst result = pipe(\n  Either.Do,\n  Either.bind(\"x\", () => Either.right(2)),\n  Either.bind(\"y\", () => Either.right(3)),\n  Either.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n```"
    ],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "declare const bind: { <N extends string, A extends object, B, L2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Either<B, L2>): <L1>(self: Either<A, L1>) => Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, L1 | L2>; <A extends object, L1, N extends string, B, L2>(self: Either<A, L1>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Either<B, L2>): Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, L1 | L2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L873"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "bindTo",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either, pipe } from \"effect\"\n\nconst result = pipe(\n  Either.Do,\n  Either.bind(\"x\", () => Either.right(2)),\n  Either.bind(\"y\", () => Either.right(3)),\n  Either.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n```"
    ],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "declare const bindTo: { <N extends string>(name: N): <R, L>(self: Either<R, L>) => Either<{ [K in N]: R; }, L>; <R, L, N extends string>(self: Either<R, L>, name: N): Either<{ [K in N]: R; }, L>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L916"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "getEquivalence",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "equivalence",
    "signature": "declare const getEquivalence: <R, L>({ left, right }: { right: Equivalence.Equivalence<R>; left: Equivalence.Equivalence<L>; }) => Equivalence.Equivalence<Either<R, L>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L313"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "all",
    "description": "Takes a structure of `Either`s and returns an `Either` of values with the same structure.\n\n- If a tuple is supplied, then the returned `Either` will contain a tuple with the same length.\n- If a struct is supplied, then the returned `Either` will contain a struct with the same keys.\n- If an iterable is supplied, then the returned `Either` will contain an array.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))\nassert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.right(\"hello\") }), Either.right({ right: 1, b: \"hello\" }))\nassert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left(\"error\") }), Either.left(\"error\"))\n```"
    ],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const all: <const I extends Iterable<Either<any, any>> | Record<string, Either<any, any>>>(input: I) => [I] extends [ReadonlyArray<Either<any, any>>] ? Either<{ -readonly [K in keyof I]: [I[K]] extends [Either<infer R, any>] ? R : never; }, I[number] extends never ? never : [I[number]] extends [Either<any, infer L>] ? L : never> : [I] extends [Iterable<Either<infer R, infer L>>] ? Either<Array<R>, L> : Either<{ -readonly [K in keyof I]: [I[K]] extends [Either<infer R, any>] ? R : never; }, I[keyof I] extends never ? never : [I[keyof I]] extends [Either<any, infer L>] ? L : never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L739"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "flip",
    "description": "Returns an `Either` that swaps the error/success cases. This allows you to\nuse all methods on the error channel, possibly before flipping back.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const flip: <R, L>(self: Either<R, L>) => Either<L, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L781"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "gen",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "generators",
    "signature": "declare const gen: Gen.Gen<EitherTypeLambda, Gen.Adapter<EitherTypeLambda>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L789"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "transposeOption",
    "description": "Converts an `Option` of an `Either` into an `Either` of an `Option`.\n\n**Details**\n\nThis function transforms an `Option<Either<A, E>>` into an\n`Either<Option<A>, E>`. If the `Option` is `None`, the resulting `Either`\nwill be a `Right` with a `None` value. If the `Option` is `Some`, the\ninner `Either` will be executed, and its result wrapped in a `Some`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Either, Option } from \"effect\"\n\n//       Option<Either<number, never>>\n//      \nconst maybe = Option.some(Either.right(42))\n\n//       Either<Option<number>, never, never>\n//      \nconst result = Either.transposeOption(maybe)\n\nconsole.log(Effect.runSync(result))\n// Output: { _id: 'Option', _tag: 'Some', value: 42 }\n```"
    ],
    "since": "3.14.0",
    "category": "Optional Wrapping & Unwrapping",
    "signature": "declare const transposeOption: <A = never, E = never>(self: Option<Either<A, E>>) => Either<Option<A>, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L997"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "Left",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Left<out L, out R> extends Pipeable, Inspectable {\n  readonly _tag: \"Left\"\n  readonly _op: \"Left\"\n  readonly left: L\n  readonly [TypeId]: {\n    readonly _R: Covariant<R>\n    readonly _L: Covariant<L>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: EitherUnify<this>\n  [Unify.ignoreSymbol]?: EitherUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L44"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "Right",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Right<out L, out R> extends Pipeable, Inspectable {\n  readonly _tag: \"Right\"\n  readonly _op: \"Right\"\n  readonly right: R\n  readonly [TypeId]: {\n    readonly _R: Covariant<R>\n    readonly _L: Covariant<L>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: EitherUnify<this>\n  [Unify.ignoreSymbol]?: EitherUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L62"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "EitherUnify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface EitherUnify<A extends { [Unify.typeSymbol]?: any }> {\n  Either?: () => A[Unify.typeSymbol] extends Either<infer R0, infer L0> | infer _ ? Either<R0, L0> : never\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L79"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "EitherUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface EitherUnifyIgnore {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L87"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "EitherTypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface EitherTypeLambda extends TypeLambda {\n  readonly type: Either<this[\"Target\"], this[\"Out1\"]>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L93"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "Either",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Either<R, L> = Left<L, R> | Right<L, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L25"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L37"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "Either.Left",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type-level",
    "signature": "type Left<T> = [T] extends [Either<infer _A, infer _E>] ? _E : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L105"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Either.ts",
      "path": "src/Either.ts"
    },
    "project": "effect",
    "name": "Either.Right",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type-level",
    "signature": "type Right<T> = [T] extends [Either<infer _A, infer _E>] ? _A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Either.ts#L110"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "DecodeExceptionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const DecodeExceptionTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L119"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "DecodeException",
    "description": "Creates a checked exception which occurs when decoding fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "errors",
    "signature": "declare const DecodeException: (input: string, message?: string) => DecodeException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L146"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "isDecodeException",
    "description": "Returns `true` if the specified value is an `DecodeException`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isDecodeException: (u: unknown) => u is DecodeException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L154"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "EncodeExceptionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "symbols",
    "signature": "declare const EncodeExceptionTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L160"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "EncodeException",
    "description": "Creates a checked exception which occurs when encoding fails.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "errors",
    "signature": "declare const EncodeException: (input: string, message?: string) => EncodeException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L187"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "isEncodeException",
    "description": "Returns `true` if the specified value is an `EncodeException`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "refinements",
    "signature": "declare const isEncodeException: (u: unknown) => u is EncodeException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L195"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "encodeBase64",
    "description": "Encodes the given value into a base64 (RFC4648) `string`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "encoding",
    "signature": "declare const encodeBase64: (input: Uint8Array | string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L22"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "decodeBase64",
    "description": "Decodes a base64 (RFC4648) encoded `string` into a `Uint8Array`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "decoding",
    "signature": "declare const decodeBase64: (str: string) => Either.Either<Uint8Array, DecodeException>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L31"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "decodeBase64String",
    "description": "Decodes a base64 (RFC4648) encoded `string` into a UTF-8 `string`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "decoding",
    "signature": "declare const decodeBase64String: (str: string) => Either.Either<string, DecodeException>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L39"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "encodeBase64Url",
    "description": "Encodes the given value into a base64 (URL) `string`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "encoding",
    "signature": "declare const encodeBase64Url: (input: Uint8Array | string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L47"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "decodeBase64Url",
    "description": "Decodes a base64 (URL) encoded `string` into a `Uint8Array`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "decoding",
    "signature": "declare const decodeBase64Url: (str: string) => Either.Either<Uint8Array, DecodeException>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L56"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "decodeBase64UrlString",
    "description": "Decodes a base64 (URL) encoded `string` into a UTF-8 `string`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "decoding",
    "signature": "declare const decodeBase64UrlString: (str: string) => Either.Either<string, DecodeException>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L64"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "encodeHex",
    "description": "Encodes the given value into a hex `string`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "encoding",
    "signature": "declare const encodeHex: (input: Uint8Array | string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L72"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "decodeHex",
    "description": "Decodes a hex encoded `string` into a `Uint8Array`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "decoding",
    "signature": "declare const decodeHex: (str: string) => Either.Either<Uint8Array, DecodeException>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L81"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "decodeHexString",
    "description": "Decodes a hex encoded `string` into a UTF-8 `string`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "decoding",
    "signature": "declare const decodeHexString: (str: string) => Either.Either<string, DecodeException>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L89"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "encodeUriComponent",
    "description": "Encodes a UTF-8 `string` into a URI component `string`.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "encoding",
    "signature": "declare const encodeUriComponent: (str: string) => Either.Either<string, EncodeException>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L97"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "decodeUriComponent",
    "description": "Decodes a URI component `string` into a UTF-8 `string`.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "decoding",
    "signature": "declare const decodeUriComponent: (str: string) => Either.Either<string, DecodeException>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L109"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "DecodeException",
    "description": "Represents a checked exception which occurs when decoding fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface DecodeException {\n  readonly _tag: \"DecodeException\"\n  readonly [DecodeExceptionTypeId]: DecodeExceptionTypeId\n  readonly input: string\n  readonly message?: string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L133"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "EncodeException",
    "description": "Represents a checked exception which occurs when encoding fails.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "models",
    "signature": "export interface EncodeException {\n  readonly _tag: \"EncodeException\"\n  readonly [EncodeExceptionTypeId]: EncodeExceptionTypeId\n  readonly input: string\n  readonly message?: string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L174"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "DecodeExceptionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type DecodeExceptionTypeId = typeof DecodeExceptionTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L125"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Encoding.ts",
      "path": "src/Encoding.ts"
    },
    "project": "effect",
    "name": "EncodeExceptionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "symbols",
    "signature": "type EncodeExceptionTypeId = typeof EncodeExceptionTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Encoding.ts#L166"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equal.ts",
      "path": "src/Equal.ts"
    },
    "project": "effect",
    "name": "symbol",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const symbol: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equal.ts#L13"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equal.ts",
      "path": "src/Equal.ts"
    },
    "project": "effect",
    "name": "equals",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "equality",
    "signature": "declare const equals: { <B>(that: B): <A>(self: A) => boolean; <A, B>(self: A, that: B): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equal.ts#L29"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equal.ts",
      "path": "src/Equal.ts"
    },
    "project": "effect",
    "name": "isEqual",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isEqual: (u: unknown) => u is Equal",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equal.ts#L90"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equal.ts",
      "path": "src/Equal.ts"
    },
    "project": "effect",
    "name": "equivalence",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const equivalence: <A>() => Equivalence<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equal.ts#L96"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Equal.ts",
      "path": "src/Equal.ts"
    },
    "project": "effect",
    "name": "Equal",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Equal extends Hash.Hash {\n  [symbol](that: Equal): boolean\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equal.ts#L19"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "string",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const string: Equivalence<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L48"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "number",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const number: Equivalence<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L54"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "boolean",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const boolean: Equivalence<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L60"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "bigint",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const bigint: Equivalence<bigint>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L66"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "symbol",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const symbol: Equivalence<symbol>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L72"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "combine",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const combine: { <A>(that: Equivalence<A>): (self: Equivalence<A>) => Equivalence<A>; <A>(self: Equivalence<A>, that: Equivalence<A>): Equivalence<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L78"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "combineMany",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const combineMany: { <A>(collection: Iterable<Equivalence<A>>): (self: Equivalence<A>) => Equivalence<A>; <A>(self: Equivalence<A>, collection: Iterable<Equivalence<A>>): Equivalence<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L87"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "mapInput",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapInput: { <B, A>(f: (b: B) => A): (self: Equivalence<A>) => Equivalence<B>; <A, B>(self: Equivalence<A>, f: (b: B) => A): Equivalence<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L116"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "Date",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Date: Equivalence<Date>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L128"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "product",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const product: { <B>(that: Equivalence<B>): <A>(self: Equivalence<A>) => Equivalence<readonly [A, B]>; <A, B>(self: Equivalence<A>, that: Equivalence<B>): Equivalence<readonly [A, B]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L134"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A>(isEquivalent: (self: A, that: A) => boolean) => Equivalence<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L31"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "strict",
    "description": "Return an `Equivalence` that uses strict equality (===) to compare values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const strict: <A>() => Equivalence<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L42"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "combineAll",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const combineAll: <A>(collection: Iterable<Equivalence<A>>) => Equivalence<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L109"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "all",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const all: <A>(collection: Iterable<Equivalence<A>>) => Equivalence<ReadonlyArray<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L147"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "productMany",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const productMany: <A>(self: Equivalence<A>, collection: Iterable<Equivalence<A>>) => Equivalence<readonly [A, ...Array<A>]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L169"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "tuple",
    "description": "Similar to `Promise.all` but operates on `Equivalence`s.\n\n```ts skip-type-checking\n[Equivalence<A>, Equivalence<B>, ...] -> Equivalence<[A, B, ...]>\n```\n\nGiven a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\nby applying each `Equivalence` to the corresponding element of the tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const tuple: <T extends ReadonlyArray<Equivalence<any>>>(...elements: T) => Equivalence<Readonly<{ [I in keyof T]: [T[I]] extends [Equivalence<infer A>] ? A : never; }>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L190"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "array",
    "description": "Creates a new `Equivalence` for an array of values based on a given `Equivalence` for the elements of the array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const array: <A>(item: Equivalence<A>) => Equivalence<ReadonlyArray<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L200"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "struct",
    "description": "Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct\nby applying each `Equivalence` to the corresponding property of the struct.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const struct: <R extends Record<string, Equivalence<any>>>(fields: R) => Equivalence<{ readonly [K in keyof R]: [R[K]] extends [Equivalence<infer A>] ? A : never; }>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L223"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "Equivalence",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type class",
    "signature": "export interface Equivalence<in A> {\n  (self: A, that: A): boolean\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L15"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Equivalence.ts",
      "path": "src/Equivalence.ts"
    },
    "project": "effect",
    "name": "EquivalenceTypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface EquivalenceTypeLambda extends TypeLambda {\n  readonly type: Equivalence<this[\"Target\"]>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Equivalence.ts#L23"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ExecutionStrategy.ts",
      "path": "src/ExecutionStrategy.ts"
    },
    "project": "effect",
    "name": "sequential",
    "description": "Execute effects sequentially.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sequential: ExecutionStrategy",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L56"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ExecutionStrategy.ts",
      "path": "src/ExecutionStrategy.ts"
    },
    "project": "effect",
    "name": "parallel",
    "description": "Execute effects in parallel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const parallel: ExecutionStrategy",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L64"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ExecutionStrategy.ts",
      "path": "src/ExecutionStrategy.ts"
    },
    "project": "effect",
    "name": "parallelN",
    "description": "Execute effects in parallel, up to the specified number of concurrent fibers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const parallelN: (parallelism: number) => ExecutionStrategy",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L72"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ExecutionStrategy.ts",
      "path": "src/ExecutionStrategy.ts"
    },
    "project": "effect",
    "name": "isSequential",
    "description": "Returns `true` if the specified `ExecutionStrategy` is an instance of\n`Sequential`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isSequential: (self: ExecutionStrategy) => self is Sequential",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L81"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ExecutionStrategy.ts",
      "path": "src/ExecutionStrategy.ts"
    },
    "project": "effect",
    "name": "isParallel",
    "description": "Returns `true` if the specified `ExecutionStrategy` is an instance of\n`Sequential`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isParallel: (self: ExecutionStrategy) => self is Parallel",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L90"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ExecutionStrategy.ts",
      "path": "src/ExecutionStrategy.ts"
    },
    "project": "effect",
    "name": "isParallelN",
    "description": "Returns `true` if the specified `ExecutionStrategy` is an instance of\n`Sequential`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isParallelN: (self: ExecutionStrategy) => self is ParallelN",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L99"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ExecutionStrategy.ts",
      "path": "src/ExecutionStrategy.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Folds over the specified `ExecutionStrategy` using the provided case\nfunctions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const match: { <A>(options: { readonly onSequential: LazyArg<A>; readonly onParallel: LazyArg<A>; readonly onParallelN: (n: number) => A; }): (self: ExecutionStrategy) => A; <A>(self: ExecutionStrategy, options: { readonly onSequential: LazyArg<A>; readonly onParallel: LazyArg<A>; readonly onParallelN: (n: number) => A; }): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L108"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ExecutionStrategy.ts",
      "path": "src/ExecutionStrategy.ts"
    },
    "project": "effect",
    "name": "Sequential",
    "description": "Execute effects sequentially.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Sequential {\n  readonly _tag: \"Sequential\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L25"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ExecutionStrategy.ts",
      "path": "src/ExecutionStrategy.ts"
    },
    "project": "effect",
    "name": "Parallel",
    "description": "Execute effects in parallel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Parallel {\n  readonly _tag: \"Parallel\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L35"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ExecutionStrategy.ts",
      "path": "src/ExecutionStrategy.ts"
    },
    "project": "effect",
    "name": "ParallelN",
    "description": "Execute effects in parallel, up to the specified number of concurrent fibers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ParallelN {\n  readonly _tag: \"ParallelN\"\n  readonly parallelism: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L45"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ExecutionStrategy.ts",
      "path": "src/ExecutionStrategy.ts"
    },
    "project": "effect",
    "name": "ExecutionStrategy",
    "description": "Describes a strategy for evaluating multiple effects, potentially in\nparallel.\n\nThere are 3 possible execution strategies: `Sequential`, `Parallel`,\n`ParallelN`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type ExecutionStrategy = Sequential | Parallel | ParallelN",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ExecutionStrategy.ts#L17"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "isExit",
    "description": "Returns `true` if the specified value is an `Exit`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isExit: (u: unknown) => u is Exit<unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L86"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "isFailure",
    "description": "Returns `true` if the specified `Exit` is a `Failure`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isFailure: <A, E>(self: Exit<A, E>) => self is Failure<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L94"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "isSuccess",
    "description": "Returns `true` if the specified `Exit` is a `Success`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isSuccess: <A, E>(self: Exit<A, E>) => self is Success<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L102"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "isInterrupted",
    "description": "Returns `true` if the specified exit is a `Failure` **and** the `Cause` of\nthe failure was due to interruption, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isInterrupted: <A, E>(self: Exit<A, E>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L111"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "as",
    "description": "Maps the `Success` value of the specified exit to the provided constant\nvalue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const as: { <A2>(value: A2): <A, E>(self: Exit<A, E>) => Exit<A2, E>; <A, E, A2>(self: Exit<A, E>, value: A2): Exit<A2, E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L120"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "asVoid",
    "description": "Maps the `Success` value of the specified exit to a void.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const asVoid: <A, E>(self: Exit<A, E>) => Exit<void, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L131"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "causeOption",
    "description": "Returns a `Some<Cause<E>>` if the specified exit is a `Failure`, `None`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const causeOption: <A, E>(self: Exit<A, E>) => Option.Option<Cause.Cause<E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L140"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "all",
    "description": "Collects all of the specified exit values into a `Some<Exit<List<A>, E>>`. If\nthe provided iterable contains no elements, `None` will be returned.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const all: <A, E>(exits: Iterable<Exit<A, E>>, options?: { readonly parallel?: boolean | undefined; } | undefined) => Option.Option<Exit<Array<A>, E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L149"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "die",
    "description": "Constructs a new `Exit.Failure` from the specified unrecoverable defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const die: (defect: unknown) => Exit<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L160"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "exists",
    "description": "Executes the predicate on the value of the specified exit if it is a\n`Success`, otherwise returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const exists: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E>(self: Exit<A, E>) => self is Exit<B>; <A>(predicate: Predicate<NoInfer<A>>): <E>(self: Exit<A, E>) => boolean; <A, E, B extends A>(self: Exit<A, E>, refinement: Refinement<A, B>): self is Exit<B>; <A, E>(self: Exit<A, E>, predicate: Predicate<A>): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L169"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "fail",
    "description": "Constructs a new `Exit.Failure` from the specified recoverable error of type\n`E`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fail: <E>(error: E) => Exit<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L183"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "failCause",
    "description": "Constructs a new `Exit.Failure` from the specified `Cause` of type `E`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failCause: <E>(cause: Cause.Cause<E>) => Exit<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L191"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMap: { <A, A2, E2>(f: (a: A) => Exit<A2, E2>): <E>(self: Exit<A, E>) => Exit<A2, E2 | E>; <A, E, E2, A2>(self: Exit<A, E>, f: (a: A) => Exit<A2, E2>): Exit<A2, E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L197"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "flatMapEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMapEffect: { <A, E, A2, E2, R>(f: (a: A) => Effect.Effect<Exit<A2, E>, E2, R>): (self: Exit<A, E>) => Effect.Effect<Exit<A2, E>, E2, R>; <A, E, A2, E2, R>(self: Exit<A, E>, f: (a: A) => Effect.Effect<Exit<A2, E>, E2, R>): Effect.Effect<Exit<A2, E>, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L206"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "flatten",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatten: <A, E, E2>(self: Exit<Exit<A, E>, E2>) => Exit<A, E | E2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L217"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "forEachEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const forEachEffect: { <A, B, E2, R>(f: (a: A) => Effect.Effect<B, E2, R>): <E>(self: Exit<A, E>) => Effect.Effect<Exit<B, E2 | E>, never, R>; <A, E, B, E2, R>(self: Exit<A, E>, f: (a: A) => Effect.Effect<B, E2, R>): Effect.Effect<Exit<B, E | E2>, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L223"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "fromEither",
    "description": "Converts an `Either<R, L>` into an `Exit<R, L>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const fromEither: <R, L>(either: Either.Either<R, L>) => Exit<R, L>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L234"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "fromOption",
    "description": "Converts an `Option<A>` into an `Exit<void, A>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const fromOption: <A>(option: Option.Option<A>) => Exit<A, void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L242"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "getOrElse",
    "description": "Returns the `A` if specified exit is a `Success`, otherwise returns the\nalternate `A` value computed from the specified function which receives the\n`Cause<E>` of the exit `Failure`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const getOrElse: { <E, A2>(orElse: (cause: Cause.Cause<E>) => A2): <A>(self: Exit<A, E>) => A2 | A; <A, E, A2>(self: Exit<A, E>, orElse: (cause: Cause.Cause<E>) => A2): A | A2; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L252"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "interrupt",
    "description": "Constructs a new `Exit.Failure` from the specified `FiberId` indicating that\nthe `Fiber` running an `Effect` workflow was terminated due to interruption.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const interrupt: (fiberId: FiberId.FiberId) => Exit<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L264"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Maps over the `Success` value of the specified exit using the provided\nfunction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <A, B>(f: (a: A) => B): <E>(self: Exit<A, E>) => Exit<B, E>; <A, E, B>(self: Exit<A, E>, f: (a: A) => B): Exit<B, E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L273"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "mapBoth",
    "description": "Maps over the `Success` and `Failure` cases of the specified exit using the\nprovided functions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapBoth: { <E, A, E2, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): (self: Exit<A, E>) => Exit<A2, E2>; <A, E, E2, A2>(self: Exit<A, E>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Exit<A2, E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L285"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "mapError",
    "description": "Maps over the error contained in the `Failure` of the specified exit using\nthe provided function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapError: { <E, E2>(f: (e: E) => E2): <A>(self: Exit<A, E>) => Exit<A, E2>; <A, E, E2>(self: Exit<A, E>, f: (e: E) => E2): Exit<A, E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L302"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "mapErrorCause",
    "description": "Maps over the `Cause` contained in the `Failure` of the specified exit using\nthe provided function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapErrorCause: { <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A>(self: Exit<A, E>) => Exit<A, E2>; <E, A, E2>(self: Exit<A, E>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Exit<A, E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L314"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "match",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const match: { <E, A, Z1, Z2>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Z1; readonly onSuccess: (a: A) => Z2; }): (self: Exit<A, E>) => Z1 | Z2; <A, E, Z1, Z2>(self: Exit<A, E>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Z1; readonly onSuccess: (a: A) => Z2; }): Z1 | Z2; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L323"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "matchEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const matchEffect: { <E, A2, E2, R, A, A3, E3, R2>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>; readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>; }): (self: Exit<A, E>) => Effect.Effect<A2 | A3, E2 | E3, R | R2>; <A, E, A2, E2, R, A3, E3, R2>(self: Exit<A, E>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>; readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>; }): Effect.Effect<A2 | A3, E2 | E3, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L337"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "succeed",
    "description": "Constructs a new `Exit.Success` containing the specified value of type `A`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const succeed: <A>(value: A) => Exit<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L359"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Sequentially zips the this result with the specified result or else returns\nthe failed `Cause<E | E2>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zip: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L379"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Sequentially zips the this result with the specified result discarding the\nsecond element of the tuple or else returns the failed `Cause<E | E2>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipLeft: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L391"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Sequentially zips the this result with the specified result discarding the\nfirst element of the tuple or else returns the failed `Cause<E | E2>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipRight: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L403"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "zipPar",
    "description": "Parallelly zips the this result with the specified result or else returns\nthe failed `Cause<E | E2>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipPar: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L415"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "zipParLeft",
    "description": "Parallelly zips the this result with the specified result discarding the\nsecond element of the tuple or else returns the failed `Cause<E | E2>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipParLeft: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L427"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "zipParRight",
    "description": "Parallelly zips the this result with the specified result discarding the\nfirst element of the tuple or else returns the failed `Cause<E | E2>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipParRight: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L439"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Zips this exit together with that exit using the specified combination\nfunctions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWith: { <B, E2, A, C, E>(that: Exit<B, E2>, options: { readonly onSuccess: (a: A, b: B) => C; readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<any>; }): (self: Exit<A, E>) => Exit<C, any>; <A, E, B, E2, C>(self: Exit<A, E>, that: Exit<B, E2>, options: { readonly onSuccess: (a: A, b: B) => C; readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>; }): Exit<C, E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L451"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "Failure",
    "description": "Represents a failed `Effect` workflow containing the `Cause` of the failure\nof type `E`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Failure<out A, out E> extends Effect.Effect<A, E>, Pipeable, Inspectable {\n  readonly _tag: \"Failure\"\n  readonly _op: \"Failure\"\n  readonly cause: Cause.Cause<E>\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: ExitUnify<this>\n  [Unify.ignoreSymbol]?: ExitUnifyIgnore\n  /** @internal */\n  readonly effect_instruction_i0: Cause.Cause<E>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L35"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "ExitUnify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ExitUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Exit?: () => A[Unify.typeSymbol] extends Exit<infer A0, infer E0> | infer _ ? Exit<A0, E0> : never\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L50"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "ExitUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ExitUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L58"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "Success",
    "description": "Represents a successful `Effect` workflow and containing the returned value\nof type `A`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Success<out A, out E> extends Effect.Effect<A, E>, Pipeable, Inspectable {\n  readonly _tag: \"Success\"\n  readonly _op: \"Success\"\n  readonly value: A\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: ExitUnify<this>\n  [Unify.ignoreSymbol]?: ExitUnifyIgnore\n  /** @internal */\n  readonly effect_instruction_i0: A\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L69"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Exit.ts",
      "path": "src/Exit.ts"
    },
    "project": "effect",
    "name": "Exit",
    "description": "An `Exit<A, E = never>` describes the result of a executing an `Effect` workflow.\n\nThere are two possible values for an `Exit<A, E>`:\n  - `Exit.Success` contain a success value of type `A`\n  - `Exit.Failure` contains a failure `Cause` of type `E`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Exit<A, E> = Success<A, E> | Failure<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Exit.ts#L26"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "FiberTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const FiberTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L33"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "RuntimeFiberTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const RuntimeFiberTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L45"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "Order",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Order: order.Order<RuntimeFiber<unknown, unknown>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L308"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "isFiber",
    "description": "Returns `true` if the specified value is a `Fiber`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isFiber: (u: unknown) => u is Fiber<unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L316"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "isRuntimeFiber",
    "description": "Returns `true` if the specified `Fiber` is a `RuntimeFiber`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isRuntimeFiber: <A, E>(self: Fiber<A, E>) => self is RuntimeFiber<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L325"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "id",
    "description": "The identity of the fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const id: <A, E>(self: Fiber<A, E>) => FiberId.FiberId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L333"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "awaitAll",
    "description": "Awaits on all fibers to be completed, successfully or not.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const awaitAll: <const T extends Iterable<Fiber<any, any>>>(fibers: T) => Effect.Effect<[T] extends [ReadonlyArray<infer U>] ? number extends T[\"length\"] ? Array<U extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never> : { -readonly [K in keyof T]: T[K] extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never; } : Array<T extends Iterable<infer U> ? U extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never : never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L354"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "children",
    "description": "Retrieves the immediate children of the fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const children: <A, E>(self: Fiber<A, E>) => Effect.Effect<Array<RuntimeFiber<any, any>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L369"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "all",
    "description": "Collects all fibers into a single fiber producing an in-order list of the\nresults.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const all: <A, E>(fibers: Iterable<Fiber<A, E>>) => Fiber<ReadonlyArray<A>, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L378"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "done",
    "description": "A fiber that is done with the specified `Exit` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const done: <A, E>(exit: Exit.Exit<A, E>) => Fiber<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L386"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "dump",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const dump: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<Fiber.Dump>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L392"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "dumpAll",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const dumpAll: (fibers: Iterable<RuntimeFiber<unknown, unknown>>) => Effect.Effect<Array<Fiber.Dump>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L398"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "fail",
    "description": "A fiber that has already failed with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fail: <E>(error: E) => Fiber<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L408"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "failCause",
    "description": "Creates a `Fiber` that has already failed with the specified cause.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failCause: <E>(cause: Cause.Cause<E>) => Fiber<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L416"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "fromEffect",
    "description": "Lifts an `Effect` into a `Fiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const fromEffect: <A, E>(effect: Effect.Effect<A, E>) => Effect.Effect<Fiber<A, E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L424"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "getCurrentFiber",
    "description": "Gets the current fiber if one is running.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utilities",
    "signature": "declare const getCurrentFiber: () => Option.Option<RuntimeFiber<any, any>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L432"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "inheritAll",
    "description": "Inherits values from all `FiberRef` instances into current fiber. This\nwill resume immediately.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const inheritAll: <A, E>(self: Fiber<A, E>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L441"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "interrupt",
    "description": "Interrupts the fiber from whichever fiber is calling this method. If the\nfiber has already exited, the returned effect will resume immediately.\nOtherwise, the effect will resume when the fiber exits.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "interruption",
    "signature": "declare const interrupt: <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L451"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "interrupted",
    "description": "Constructrs a `Fiber` that is already interrupted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const interrupted: (fiberId: FiberId.FiberId) => Fiber<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L459"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "interruptAs",
    "description": "Interrupts the fiber as if interrupted from the specified fiber. If the\nfiber has already exited, the returned effect will resume immediately.\nOtherwise, the effect will resume when the fiber exits.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "interruption",
    "signature": "declare const interruptAs: { (fiberId: FiberId.FiberId): <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>; <A, E>(self: Fiber<A, E>, fiberId: FiberId.FiberId): Effect.Effect<Exit.Exit<A, E>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L469"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "interruptAsFork",
    "description": "Interrupts the fiber as if interrupted from the specified fiber. If the\nfiber has already exited, the returned effect will resume immediately.\nOtherwise, the effect will resume when the fiber exits.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "interruption",
    "signature": "declare const interruptAsFork: { (fiberId: FiberId.FiberId): <A, E>(self: Fiber<A, E>) => Effect.Effect<void>; <A, E>(self: Fiber<A, E>, fiberId: FiberId.FiberId): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L482"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "interruptAll",
    "description": "Interrupts all fibers, awaiting their interruption.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "interruption",
    "signature": "declare const interruptAll: (fibers: Iterable<Fiber<any, any>>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L493"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "interruptAllAs",
    "description": "Interrupts all fibers as by the specified fiber, awaiting their\ninterruption.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "interruption",
    "signature": "declare const interruptAllAs: { (fiberId: FiberId.FiberId): (fibers: Iterable<Fiber<any, any>>) => Effect.Effect<void>; (fibers: Iterable<Fiber<any, any>>, fiberId: FiberId.FiberId): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L502"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "interruptFork",
    "description": "Interrupts the fiber from whichever fiber is calling this method. The\ninterruption will happen in a separate daemon fiber, and the returned\neffect will always resume immediately without waiting.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "interruption",
    "signature": "declare const interruptFork: <A, E>(self: Fiber<A, E>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L515"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "join",
    "description": "Joins the fiber, which suspends the joining fiber until the result of the\nfiber has been determined. Attempting to join a fiber that has erred will\nresult in a catchable error. Joining an interrupted fiber will result in an\n\"inner interruption\" of this fiber, unlike interruption triggered by\nanother fiber, \"inner interruption\" can be caught and recovered.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const join: <A, E>(self: Fiber<A, E>) => Effect.Effect<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L527"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "joinAll",
    "description": "Joins all fibers, awaiting their _successful_ completion. Attempting to\njoin a fiber that has erred will result in a catchable error, _if_ that\nerror does not result from interruption.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const joinAll: <A, E>(fibers: Iterable<Fiber<A, E>>) => Effect.Effect<Array<A>, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L537"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Maps over the value the Fiber computes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <A, B>(f: (a: A) => B): <E>(self: Fiber<A, E>) => Fiber<B, E>; <A, E, B>(self: Fiber<A, E>, f: (a: A) => B): Fiber<B, E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L545"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "mapEffect",
    "description": "Effectually maps over the value the fiber computes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapEffect: { <A, A2, E2>(f: (a: A) => Effect.Effect<A2, E2>): <E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, f: (a: A) => Effect.Effect<A2, E2>): Fiber<A2, E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L556"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "mapFiber",
    "description": "Passes the success of this fiber to the specified callback, and continues\nwith the fiber that it returns.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapFiber: { <E, E2, A, B>(f: (a: A) => Fiber<B, E2>): (self: Fiber<A, E>) => Effect.Effect<Fiber<B, E | E2>>; <A, E, E2, B>(self: Fiber<A, E>, f: (a: A) => Fiber<B, E2>): Effect.Effect<Fiber<B, E | E2>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L568"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Folds over the `Fiber` or `RuntimeFiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const match: { <A, E, Z>(options: { readonly onFiber: (fiber: Fiber<A, E>) => Z; readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z; }): (self: Fiber<A, E>) => Z; <A, E, Z>(self: Fiber<A, E>, options: { readonly onFiber: (fiber: Fiber<A, E>) => Z; readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z; }): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L579"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "never",
    "description": "A fiber that never fails or succeeds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const never: Fiber<never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L601"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "orElse",
    "description": "Returns a fiber that prefers `this` fiber, but falls back to the `that` one\nwhen `this` one fails. Interrupting the returned fiber will interrupt both\nfibers, sequentially, from left to right.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "alternatives",
    "signature": "declare const orElse: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2 | A, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A | A2, E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L611"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "orElseEither",
    "description": "Returns a fiber that prefers `this` fiber, but falls back to the `that` one\nwhen `this` one fails. Interrupting the returned fiber will interrupt both\nfibers, sequentially, from left to right.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "alternatives",
    "signature": "declare const orElseEither: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<Either.Either<A2, A>, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<Either.Either<A2, A>, E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L624"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "poll",
    "description": "Tentatively observes the fiber, but returns immediately if it is not\nalready done.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const poll: <A, E>(self: Fiber<A, E>) => Effect.Effect<Option.Option<Exit.Exit<A, E>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L636"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "pretty",
    "description": "Pretty-prints a `RuntimeFiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const pretty: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L644"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "roots",
    "description": "Returns a chunk containing all root fibers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const roots: Effect.Effect<Array<RuntimeFiber<any, any>>, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L652"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "unsafeRoots",
    "description": "Returns a chunk containing all root fibers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unsafeRoots: (_: void) => Array<RuntimeFiber<any, any>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L660"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "scoped",
    "description": "Converts this fiber into a scoped effect. The fiber is interrupted when the\nscope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const scoped: <A, E>(self: Fiber<A, E>) => Effect.Effect<Fiber<A, E>, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L669"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "status",
    "description": "Returns the `FiberStatus` of a `RuntimeFiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const status: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<FiberStatus.FiberStatus>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L678"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "succeed",
    "description": "Returns a fiber that has already succeeded with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const succeed: <A>(value: A) => Fiber<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L686"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Zips this fiber and the specified fiber together, producing a tuple of\ntheir output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zip: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<[A, A2], E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<[A, A2], E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L706"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Same as `zip` but discards the output of that `Fiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipLeft: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A, E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L717"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Same as `zip` but discards the output of this `Fiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipRight: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A2, E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L728"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Zips this fiber with the specified fiber, combining their results using the\nspecified combiner function. Both joins and interruptions are performed in\nsequential order from left to right.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWith: { <B, E2, A, C>(that: Fiber<B, E2>, f: (a: A, b: B) => C): <E>(self: Fiber<A, E>) => Fiber<C, E2 | E>; <A, E, B, E2, C>(self: Fiber<A, E>, that: Fiber<B, E2>, f: (a: A, b: B) => C): Fiber<C, E | E2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L741"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "Fiber",
    "description": "A fiber is a lightweight thread of execution that never consumes more than a\nwhole thread (but may consume much less, depending on contention and\nasynchronicity). Fibers are spawned by forking effects, which run\nconcurrently with the parent effect.\n\nFibers can be joined, yielding their result to other fibers, or interrupted,\nwhich terminates the fiber, safely releasing all resources.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Fiber<out A, out E = never> extends Effect.Effect<A, E>, Fiber.Variance<A, E> {\n  /**\n   * The identity of the fiber.\n   */\n  id(): FiberId.FiberId\n\n  /**\n   * Awaits the fiber, which suspends the awaiting fiber until the result of the\n   * fiber has been determined.\n   */\n  readonly await: Effect.Effect<Exit.Exit<A, E>>\n\n  /**\n   * Retrieves the immediate children of the fiber.\n   */\n  readonly children: Effect.Effect<Array<Fiber.Runtime<any, any>>>\n\n  /**\n   * Inherits values from all `FiberRef` instances into current fiber. This\n   * will resume immediately.\n   */\n  readonly inheritAll: Effect.Effect<void>\n\n  /**\n   * Tentatively observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  readonly poll: Effect.Effect<Option.Option<Exit.Exit<A, E>>>\n\n  /**\n   * In the background, interrupts the fiber as if interrupted from the\n   * specified fiber. If the fiber has already exited, the returned effect will\n   * resume immediately. Otherwise, the effect will resume when the fiber exits.\n   */\n  interruptAsFork(fiberId: FiberId.FiberId): Effect.Effect<void>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: FiberUnify<this>\n  readonly [Unify.ignoreSymbol]?: FiberUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L65"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "FiberUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface FiberUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Fiber?: () => A[Unify.typeSymbol] extends Fiber<infer A0, infer E0> | infer _ ? Fiber<A0, E0> : never\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L110"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "FiberUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface FiberUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L118"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "RuntimeFiber",
    "description": "A runtime fiber that is executing an effect. Runtime fibers have an\nidentity and a trace.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RuntimeFiber<out A, out E = never> extends Fiber<A, E>, Fiber.RuntimeVariance<A, E> {\n  /**\n   * Reads the current number of ops that have occurred since the last yield\n   */\n  get currentOpCount(): number\n\n  /**\n   * Reads the current value of a fiber ref\n   */\n  getFiberRef<X>(fiberRef: FiberRef<X>): X\n\n  /**\n   * The identity of the fiber.\n   */\n  id(): FiberId.Runtime\n\n  /**\n   * The status of the fiber.\n   */\n  readonly status: Effect.Effect<FiberStatus.FiberStatus>\n\n  /**\n   * Returns the current `RuntimeFlags` the fiber is running with.\n   */\n  readonly runtimeFlags: Effect.Effect<RuntimeFlags.RuntimeFlags>\n\n  /**\n   * Adds an observer to the list of observers.\n   */\n  addObserver(observer: (exit: Exit.Exit<A, E>) => void): void\n\n  /**\n   * Removes the specified observer from the list of observers that will be\n   * notified when the fiber exits.\n   */\n  removeObserver(observer: (exit: Exit.Exit<A, E>) => void): void\n\n  /**\n   * Retrieves all fiber refs of the fiber.\n   */\n  getFiberRefs(): FiberRefs.FiberRefs\n\n  /**\n   * Unsafely observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  unsafePoll(): Exit.Exit<A, E> | null\n\n  /**\n   * In the background, interrupts the fiber as if interrupted from the\n   * specified fiber. If the fiber has already exited, the returned effect will\n   * resume immediately. Otherwise, the effect will resume when the fiber exits.\n   */\n  unsafeInterruptAsFork(fiberId: FiberId.FiberId): void\n\n  /**\n   * Gets the current context\n   */\n  get currentContext(): Context<never>\n\n  /**\n   * Gets the current context\n   */\n  get currentDefaultServices(): Context<DefaultServices>\n\n  /**\n   * Gets the current scheduler\n   */\n  get currentScheduler(): Scheduler\n\n  /**\n   * Gets the current tracer\n   */\n  get currentTracer(): Tracer\n\n  /**\n   * Gets the current span\n   */\n  get currentSpan(): AnySpan | undefined\n\n  /**\n   * Gets the current supervisor\n   */\n  get currentSupervisor(): Supervisor<unknown>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: RuntimeFiberUnify<this>\n  readonly [Unify.ignoreSymbol]?: RuntimeFiberUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L129"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "RuntimeFiberUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface RuntimeFiberUnify<A extends { [Unify.typeSymbol]?: any }> extends FiberUnify<A> {\n  RuntimeFiber?: () => A[Unify.typeSymbol] extends RuntimeFiber<infer A0, infer E0> | infer _ ? RuntimeFiber<A0, E0>\n    : never\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L223"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "RuntimeFiberUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface RuntimeFiberUnifyIgnore extends FiberUnifyIgnore {\n  Fiber?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L232"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "FiberTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type FiberTypeId = typeof FiberTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L39"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "RuntimeFiberTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type RuntimeFiberTypeId = typeof RuntimeFiberTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L51"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "Fiber.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out A, out E> {\n    readonly [FiberTypeId]: {\n      readonly _A: Types.Covariant<A>\n      readonly _E: Types.Covariant<E>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L250"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "Fiber.RuntimeVariance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface RuntimeVariance<out A, out E> {\n    readonly [RuntimeFiberTypeId]: {\n      readonly _A: Types.Covariant<A>\n      readonly _E: Types.Covariant<E>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L260"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "Fiber.Dump",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Dump {\n    /**\n     * The fiber's unique identifier.\n     */\n    readonly id: FiberId.Runtime\n    /**\n     * The status of the fiber.\n     */\n    readonly status: FiberStatus.FiberStatus\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L271"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "Fiber.Descriptor",
    "description": "A record containing information about a `Fiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Descriptor {\n    /**\n     * The fiber's unique identifier.\n     */\n    readonly id: FiberId.FiberId\n    /**\n     * The status of the fiber.\n     */\n    readonly status: FiberStatus.FiberStatus\n    /**\n     * The set of fibers attempting to interrupt the fiber or its ancestors.\n     */\n    readonly interruptors: HashSet.HashSet<FiberId.FiberId>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L288"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Fiber.ts",
      "path": "src/Fiber.ts"
    },
    "project": "effect",
    "name": "Fiber.Runtime",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Runtime<A, E> = RuntimeFiber<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Fiber.ts#L244"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L24"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "unsafeSet",
    "description": "Set the fiber in a FiberHandle. When the fiber completes, it will be removed from the FiberHandle.\nIf a fiber is already running, it will be interrupted unless `options.onlyIfMissing` is set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const unsafeSet: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }): (self: FiberHandle<A, E>) => void; <A, E, XE extends E, XA extends A>(self: FiberHandle<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L187"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "set",
    "description": "Set the fiber in the FiberHandle. When the fiber completes, it will be removed from the FiberHandle.\nIf a fiber already exists in the FiberHandle, it will be interrupted unless `options.onlyIfMissing` is set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const set: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): (self: FiberHandle<A, E>) => Effect.Effect<void>; <A, E, XE extends E, XA extends A>(self: FiberHandle<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L253"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "run",
    "description": "Run an Effect and add the forked fiber to the FiberHandle.\nWhen the fiber completes, it will be removed from the FiberHandle.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const run: { <A, E>(self: FiberHandle<A, E>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <A, E, R, XE extends E, XA extends A>(self: FiberHandle<A, E>, effect: Effect.Effect<XA, XE, R>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L344"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "isFiberHandle",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const isFiberHandle: (u: unknown) => u is FiberHandle",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L52"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "A FiberHandle can be used to store a single fiber.\nWhen the associated Scope is closed, the contained fiber will be interrupted.\n\nYou can add a fiber to the handle using `FiberHandle.run`, and the fiber will\nbe automatically removed from the FiberHandle when it completes.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, FiberHandle } from \"effect\"\n\nEffect.gen(function*() {\n  const handle = yield* FiberHandle.make()\n\n  // run some effects\n  yield* FiberHandle.run(handle, Effect.never)\n  // this will interrupt the previous fiber\n  yield* FiberHandle.run(handle, Effect.never)\n\n  yield* Effect.sleep(1000)\n}).pipe(\n  Effect.scoped // The fiber will be interrupted when the scope is closed\n)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const make: <A = unknown, E = unknown>() => Effect.Effect<FiberHandle<A, E>, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L110"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "makeRuntime",
    "description": "Create an Effect run function that is backed by a FiberHandle.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const makeRuntime: <R, E = unknown, A = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L133"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "makeRuntimePromise",
    "description": "Create an Effect run function that is backed by a FiberHandle.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": "declare const makeRuntimePromise: <R = never, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: Runtime.RunForkOptions | undefined) => Promise<XA>), never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L156"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "unsafeGet",
    "description": "Retrieve the fiber from the FiberHandle.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const unsafeGet: <A, E>(self: FiberHandle<A, E>) => Option.Option<Fiber.RuntimeFiber<A, E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L294"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieve the fiber from the FiberHandle.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const get: <A, E>(self: FiberHandle<A, E>) => Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L303"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "clear",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const clear: <A, E>(self: FiberHandle<A, E>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L310"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "runtime",
    "description": "Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberHandle.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Context, Effect, FiberHandle } from \"effect\"\n\ninterface Users {\n  readonly _: unique symbol\n}\nconst Users = Context.GenericTag<Users, {\n   getAll: Effect.Effect<Array<unknown>>\n}>(\"Users\")\n\nEffect.gen(function*() {\n  const handle = yield* FiberHandle.make()\n  const run = yield* FiberHandle.runtime(handle)<Users>()\n\n  // run an effect and set the fiber in the handle\n  run(Effect.andThen(Users, _ => _.getAll))\n\n  // this will interrupt the previous fiber\n  run(Effect.andThen(Users, _ => _.getAll))\n}).pipe(\n  Effect.scoped // The fiber will be interrupted when the scope is closed\n)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const runtime: <A, E>(self: FiberHandle<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L422"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "runtimePromise",
    "description": "Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberHandle.\n\nThe returned run function will return Promise's that will resolve when the\nfiber completes.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": "declare const runtimePromise: <A, E>(self: FiberHandle<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined; }) | undefined) => Promise<XA>), never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L471"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "join",
    "description": "If any of the Fiber's in the handle terminate with a failure,\nthe returned Effect will terminate with the first failure that occurred.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, FiberHandle } from \"effect\";\n\nEffect.gen(function* (_) {\n  const handle = yield* _(FiberHandle.make());\n  yield* _(FiberHandle.set(handle, Effect.runFork(Effect.fail(\"error\"))));\n\n  // parent fiber will fail with \"error\"\n  yield* _(FiberHandle.join(handle));\n});\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const join: <A, E>(self: FiberHandle<A, E>) => Effect.Effect<void, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L521"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "awaitEmpty",
    "description": "Wait for the fiber in the FiberHandle to complete.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": "declare const awaitEmpty: <A, E>(self: FiberHandle<A, E>) => Effect.Effect<void, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L530"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "FiberHandle",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface FiberHandle<out A = unknown, out E = unknown> extends Pipeable, Inspectable.Inspectable {\n  readonly [TypeId]: TypeId\n  readonly deferred: Deferred.Deferred<void, unknown>\n  /** @internal */\n  state: {\n    readonly _tag: \"Open\"\n    fiber: Fiber.RuntimeFiber<A, E> | undefined\n  } | {\n    readonly _tag: \"Closed\"\n  }\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L36"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberHandle.ts",
      "path": "src/FiberHandle.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberHandle.ts#L30"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "FiberIdTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const FiberIdTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L14"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "none",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const none: None",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L71"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "runtime",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const runtime: (id: number, startTimeMillis: number) => Runtime",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L77"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "composite",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const composite: (left: FiberId, right: FiberId) => Composite",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L83"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "isFiberId",
    "description": "Returns `true` if the specified unknown value is a `FiberId`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isFiberId: (self: unknown) => self is FiberId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L92"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "isNone",
    "description": "Returns `true` if the `FiberId` is a `None`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isNone: (self: FiberId) => self is None",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L100"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "isRuntime",
    "description": "Returns `true` if the `FiberId` is a `Runtime`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isRuntime: (self: FiberId) => self is Runtime",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L108"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "isComposite",
    "description": "Returns `true` if the `FiberId` is a `Composite`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isComposite: (self: FiberId) => self is Composite",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L116"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "combine",
    "description": "Combine two `FiberId`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const combine: { (that: FiberId): (self: FiberId) => FiberId; (self: FiberId, that: FiberId): FiberId; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L124"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "combineAll",
    "description": "Combines a set of `FiberId`s into a single `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const combineAll: (fiberIds: HashSet.HashSet<FiberId>) => FiberId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L135"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "getOrElse",
    "description": "Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getOrElse: { (that: FiberId): (self: FiberId) => FiberId; (self: FiberId, that: FiberId): FiberId; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L143"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "ids",
    "description": "Get the set of identifiers for this `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const ids: (self: FiberId) => HashSet.HashSet<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L154"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (id: number, startTimeSeconds: number) => FiberId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L162"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "threadName",
    "description": "Creates a string representing the name of the current thread of execution\nrepresented by the specified `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const threadName: (self: FiberId) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L171"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "toOption",
    "description": "Convert a `FiberId` into an `Option<FiberId>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toOption: (self: FiberId) => Option.Option<FiberId>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L179"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "toSet",
    "description": "Convert a `FiberId` into a `HashSet<FiberId>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toSet: (self: FiberId) => HashSet.HashSet<Runtime>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L187"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "unsafeMake",
    "description": "Unsafely creates a new `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeMake: (_: void) => Runtime",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L195"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "None",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface None extends Equal.Equal, Inspectable {\n  readonly [FiberIdTypeId]: FiberIdTypeId\n  readonly _tag: \"None\"\n  readonly id: -1\n  readonly startTimeMillis: -1\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L38"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "Runtime",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Runtime extends Equal.Equal, Inspectable {\n  readonly [FiberIdTypeId]: FiberIdTypeId\n  readonly _tag: \"Runtime\"\n  readonly id: number\n  readonly startTimeMillis: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L49"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "Composite",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Composite extends Equal.Equal, Inspectable {\n  readonly [FiberIdTypeId]: FiberIdTypeId\n  readonly _tag: \"Composite\"\n  readonly left: FiberId\n  readonly right: FiberId\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L60"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "FiberIdTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type FiberIdTypeId = typeof FiberIdTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L20"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "Single",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Single = None | Runtime",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L26"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberId.ts",
      "path": "src/FiberId.ts"
    },
    "project": "effect",
    "name": "FiberId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type FiberId = Single | Composite",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberId.ts#L32"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L26"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "unsafeSet",
    "description": "Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.\nIf the key already exists in the FiberMap, the previous fiber will be interrupted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const unsafeSet: { <K, A, E, XE extends E, XA extends A>(key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberMap<K, A, E>) => void; <K, A, E, XE extends E, XA extends A>(self: FiberMap<K, A, E>, key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L207"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "set",
    "description": "Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.\nIf the key already exists in the FiberMap, the previous fiber will be interrupted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const set: { <K, A, E, XE extends E, XA extends A>(key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberMap<K, A, E>) => Effect.Effect<void>; <K, A, E, XE extends E, XA extends A>(self: FiberMap<K, A, E>, key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L282"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "unsafeGet",
    "description": "Retrieve a fiber from the FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const unsafeGet: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Option.Option<Fiber.RuntimeFiber<A, E>>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Option.Option<Fiber.RuntimeFiber<A, E>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L325"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieve a fiber from the FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const get: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L344"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "unsafeHas",
    "description": "Check if a key exists in the FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const unsafeHas: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => boolean; <K, A, E>(self: FiberMap<K, A, E>, key: K): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L363"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "has",
    "description": "Check if a key exists in the FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const has: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<boolean>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L378"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "remove",
    "description": "Remove a fiber from the FiberMap, interrupting it if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const remove: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L392"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "run",
    "description": "Run an Effect and add the forked fiber to the FiberMap.\nWhen the fiber completes, it will be removed from the FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const run: { <K, A, E>(self: FiberMap<K, A, E>, key: K, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <K, A, E, R, XE extends E, XA extends A>(self: FiberMap<K, A, E>, key: K, effect: Effect.Effect<XA, XE, R>, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L448"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "isFiberMap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const isFiberMap: (u: unknown) => u is FiberMap<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L56"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "A FiberMap can be used to store a collection of fibers, indexed by some key.\nWhen the associated Scope is closed, all fibers in the map will be interrupted.\n\nYou can add fibers to the map using `FiberMap.set` or `FiberMap.run`, and the fibers will\nbe automatically removed from the FiberMap when they complete.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, FiberMap } from \"effect\"\n\nEffect.gen(function*() {\n  const map = yield* FiberMap.make<string>()\n\n  // run some effects and add the fibers to the map\n  yield* FiberMap.run(map, \"fiber a\", Effect.never)\n  yield* FiberMap.run(map, \"fiber b\", Effect.never)\n\n  yield* Effect.sleep(1000)\n}).pipe(\n  Effect.scoped // The fibers will be interrupted when the scope is closed\n)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const make: <K, A = unknown, E = unknown>() => Effect.Effect<FiberMap<K, A, E>, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L120"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "makeRuntime",
    "description": "Create an Effect run function that is backed by a FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const makeRuntime: <R, K, E = unknown, A = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L147"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "makeRuntimePromise",
    "description": "Create an Effect run function that is backed by a FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": "declare const makeRuntimePromise: <R, K, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; }) | undefined) => Promise<XA>), never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L171"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "clear",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const clear: <K, A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L420"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "runtime",
    "description": "Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Context, Effect, FiberMap } from \"effect\"\n\ninterface Users {\n  readonly _: unique symbol\n}\nconst Users = Context.GenericTag<Users, {\n   getAll: Effect.Effect<Array<unknown>>\n}>(\"Users\")\n\nEffect.gen(function*() {\n  const map = yield* FiberMap.make<string>()\n  const run = yield* FiberMap.runtime(map)<Users>()\n\n  // run some effects and add the fibers to the map\n  run(\"effect-a\", Effect.andThen(Users, _ => _.getAll))\n  run(\"effect-b\", Effect.andThen(Users, _ => _.getAll))\n}).pipe(\n  Effect.scoped // The fibers will be interrupted when the scope is closed\n)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const runtime: <K, A, E>(self: FiberMap<K, A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L528"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "runtimePromise",
    "description": "Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": "declare const runtimePromise: <K, A, E>(self: FiberMap<K, A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }) | undefined) => Promise<XA>), never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L576"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "size",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const size: <K, A, E>(self: FiberMap<K, A, E>) => Effect.Effect<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L616"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "join",
    "description": "Join all fibers in the FiberMap. If any of the Fiber's in the map terminate with a failure,\nthe returned Effect will terminate with the first failure that occurred.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, FiberMap } from \"effect\";\n\nEffect.gen(function* (_) {\n  const map = yield* _(FiberMap.make());\n  yield* _(FiberMap.set(map, \"a\", Effect.runFork(Effect.fail(\"error\"))));\n\n  // parent fiber will fail with \"error\"\n  yield* _(FiberMap.join(map));\n});\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const join: <K, A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L638"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "awaitEmpty",
    "description": "Wait for the FiberMap to be empty.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": "declare const awaitEmpty: <K, A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L647"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "FiberMap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface FiberMap<in out K, out A = unknown, out E = unknown>\n  extends Pipeable, Inspectable.Inspectable, Iterable<[K, Fiber.RuntimeFiber<A, E>]>\n{\n  readonly [TypeId]: TypeId\n  readonly deferred: Deferred.Deferred<void, unknown>\n  /** @internal */\n  state: {\n    readonly _tag: \"Open\"\n    readonly backing: MutableHashMap.MutableHashMap<K, Fiber.RuntimeFiber<A, E>>\n  } | {\n    readonly _tag: \"Closed\"\n  }\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L38"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberMap.ts",
      "path": "src/FiberMap.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberMap.ts#L32"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "FiberRefTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const FiberRefTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L34"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A>(initial: A, options?: { readonly fork?: ((a: A) => A) | undefined; readonly join?: ((left: A, right: A) => A) | undefined; }) => Effect.Effect<FiberRef<A>, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L94"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "makeWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeWith: <Value>(ref: LazyArg<FiberRef<Value>>) => Effect.Effect<FiberRef<Value>, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L106"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "makeContext",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeContext: <A>(initial: Context.Context<A>) => Effect.Effect<FiberRef<Context.Context<A>>, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L113"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "makeRuntimeFlags",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeRuntimeFlags: (initial: RuntimeFlags.RuntimeFlags) => Effect.Effect<FiberRef<RuntimeFlags.RuntimeFlags>, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L121"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "unsafeMake",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unsafeMake: <Value>(initial: Value, options?: { readonly fork?: ((a: Value) => Value) | undefined; readonly join?: ((left: Value, right: Value) => Value) | undefined; }) => FiberRef<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L129"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "unsafeMakeHashSet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unsafeMakeHashSet: <A>(initial: HashSet.HashSet<A>) => FiberRef<HashSet.HashSet<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L141"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "unsafeMakeContext",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unsafeMakeContext: <A>(initial: Context.Context<A>) => FiberRef<Context.Context<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L148"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "unsafeMakeSupervisor",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unsafeMakeSupervisor: (initial: Supervisor.Supervisor<any>) => FiberRef<Supervisor.Supervisor<any>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L155"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "unsafeMakePatch",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unsafeMakePatch: <Value, Patch>(initial: Value, options: { readonly differ: Differ.Differ<Value, Patch>; readonly fork: Patch; readonly join?: ((oldV: Value, newV: Value) => Value) | undefined; }) => FiberRef<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L162"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "get",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const get: <A>(self: FiberRef<A>) => Effect.Effect<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L175"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "getAndSet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndSet: { <A>(value: A): (self: FiberRef<A>) => Effect.Effect<A>; <A>(self: FiberRef<A>, value: A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L181"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdate",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndUpdate: { <A>(f: (a: A) => A): (self: FiberRef<A>) => Effect.Effect<A>; <A>(self: FiberRef<A>, f: (a: A) => A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L190"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdateSome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndUpdateSome: { <A>(pf: (a: A) => Option.Option<A>): (self: FiberRef<A>) => Effect.Effect<A>; <A>(self: FiberRef<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L199"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "getWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getWith: { <A, B, E, R>(f: (a: A) => Effect.Effect<B, E, R>): (self: FiberRef<A>) => Effect.Effect<B, E, R>; <A, B, E, R>(self: FiberRef<A>, f: (a: A) => Effect.Effect<B, E, R>): Effect.Effect<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L208"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "set",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const set: { <A>(value: A): (self: FiberRef<A>) => Effect.Effect<void>; <A>(self: FiberRef<A>, value: A): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L217"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "reset",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const reset: <A>(self: FiberRef<A>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L236"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "modify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const modify: { <A, B>(f: (a: A) => readonly [B, A]): (self: FiberRef<A>) => Effect.Effect<B>; <A, B>(self: FiberRef<A>, f: (a: A) => readonly [B, A]): Effect.Effect<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L242"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "modifySome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const modifySome: <A, B>(self: FiberRef<A>, def: B, f: (a: A) => Option.Option<readonly [B, A]>) => Effect.Effect<B>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L251"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "update",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const update: { <A>(f: (a: A) => A): (self: FiberRef<A>) => Effect.Effect<void>; <A>(self: FiberRef<A>, f: (a: A) => A): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L261"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "updateSome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateSome: { <A>(pf: (a: A) => Option.Option<A>): (self: FiberRef<A>) => Effect.Effect<void>; <A>(self: FiberRef<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L270"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "updateAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateAndGet: { <A>(f: (a: A) => A): (self: FiberRef<A>) => Effect.Effect<A>; <A>(self: FiberRef<A>, f: (a: A) => A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L279"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "updateSomeAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateSomeAndGet: { <A>(pf: (a: A) => Option.Option<A>): (self: FiberRef<A>) => Effect.Effect<A>; <A>(self: FiberRef<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L288"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentConcurrency",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentConcurrency: FiberRef<number | \"unbounded\">",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L297"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentRequestBatchingEnabled",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentRequestBatchingEnabled: FiberRef<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L303"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentRequestCache",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentRequestCache: FiberRef<Request.Cache>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L309"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentRequestCacheEnabled",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentRequestCacheEnabled: FiberRef<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L315"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentContext",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentContext: FiberRef<Context.Context<never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L321"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentSchedulingPriority",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentSchedulingPriority: FiberRef<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L327"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentMaxOpsBeforeYield",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentMaxOpsBeforeYield: FiberRef<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L333"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "unhandledErrorLogLevel",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const unhandledErrorLogLevel: FiberRef<Option.Option<LogLevel.LogLevel>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L339"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentLogAnnotations",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentLogAnnotations: FiberRef<HashMap.HashMap<string, unknown>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L345"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentLoggers",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentLoggers: FiberRef<HashSet.HashSet<Logger.Logger<unknown, any>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L351"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentLogLevel",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentLogLevel: FiberRef<LogLevel.LogLevel>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L357"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentMinimumLogLevel",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentMinimumLogLevel: FiberRef<LogLevel.LogLevel>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L363"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentLogSpan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentLogSpan: FiberRef<List.List<LogSpan.LogSpan>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L369"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentRuntimeFlags",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentRuntimeFlags: FiberRef<RuntimeFlags.RuntimeFlags>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L375"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentScheduler",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentScheduler: FiberRef<Scheduler.Scheduler>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L381"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentSupervisor",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentSupervisor: FiberRef<Supervisor.Supervisor<any>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L387"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentMetricLabels",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentMetricLabels: FiberRef<ReadonlyArray<MetricLabel.MetricLabel>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L393"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentTracerEnabled",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentTracerEnabled: FiberRef<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L399"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentTracerTimingEnabled",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentTracerTimingEnabled: FiberRef<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L405"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentTracerSpanAnnotations",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentTracerSpanAnnotations: FiberRef<HashMap.HashMap<string, unknown>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L411"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "currentTracerSpanLinks",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const currentTracerSpanLinks: FiberRef<Chunk.Chunk<Tracer.SpanLink>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L418"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "interruptedCause",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "declare const interruptedCause: FiberRef<Cause.Cause<never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L424"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "FiberRef",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface FiberRef<in out A> extends Effect.Effect<A>, Variance<A> {\n  /** @internal */\n  readonly initial: A\n  /** @internal */\n  diff(oldValue: A, newValue: A): unknown\n  /** @internal */\n  combine(first: unknown, second: unknown): unknown\n  /** @internal */\n  patch(patch: unknown): (oldValue: A) => A\n  /** @internal */\n  readonly fork: unknown\n  /** @internal */\n  join(oldValue: A, newValue: A): A\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: FiberRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: FiberRefUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L46"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "FiberRefUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface FiberRefUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  FiberRef?: () => Extract<A[Unify.typeSymbol], FiberRef<any>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L68"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "FiberRefUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface FiberRefUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L76"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out A> {\n  readonly [FiberRefTypeId]: {\n    readonly _A: Types.Invariant<A>\n  }\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L84"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberRef.ts",
      "path": "src/FiberRef.ts"
    },
    "project": "effect",
    "name": "FiberRefTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type FiberRefTypeId = typeof FiberRefTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRef.ts#L40"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs.ts",
      "path": "src/FiberRefs.ts"
    },
    "project": "effect",
    "name": "FiberRefsSym",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const FiberRefsSym: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L17"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs.ts",
      "path": "src/FiberRefs.ts"
    },
    "project": "effect",
    "name": "fiberRefs",
    "description": "Returns a set of each `FiberRef` in this collection.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const fiberRefs: (self: FiberRefs) => HashSet.HashSet<FiberRef.FiberRef<any>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L60"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs.ts",
      "path": "src/FiberRefs.ts"
    },
    "project": "effect",
    "name": "forkAs",
    "description": "Forks this collection of fiber refs as the specified child fiber id. This\nwill potentially modify the value of the fiber refs, as determined by the\nindividual fiber refs that make up the collection.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const forkAs: { (childId: FiberId.Single): (self: FiberRefs) => FiberRefs; (self: FiberRefs, childId: FiberId.Single): FiberRefs; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L70"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs.ts",
      "path": "src/FiberRefs.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Gets the value of the specified `FiberRef` in this collection of `FiberRef`\nvalues if it exists or `None` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const get: { <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => Option.Option<A>; <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): Option.Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L82"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs.ts",
      "path": "src/FiberRefs.ts"
    },
    "project": "effect",
    "name": "getOrDefault",
    "description": "Gets the value of the specified `FiberRef` in this collection of `FiberRef`\nvalues if it exists or the `initial` value of the `FiberRef` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const getOrDefault: { <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => A; <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L94"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs.ts",
      "path": "src/FiberRefs.ts"
    },
    "project": "effect",
    "name": "joinAs",
    "description": "Joins this collection of fiber refs to the specified collection, as the\nspecified fiber id. This will perform diffing and merging to ensure\npreservation of maximum information from both child and parent refs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const joinAs: { (fiberId: FiberId.Single, that: FiberRefs): (self: FiberRefs) => FiberRefs; (self: FiberRefs, fiberId: FiberId.Single, that: FiberRefs): FiberRefs; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L107"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs.ts",
      "path": "src/FiberRefs.ts"
    },
    "project": "effect",
    "name": "setAll",
    "description": "Set each ref to either its value or its default.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const setAll: (self: FiberRefs) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L118"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs.ts",
      "path": "src/FiberRefs.ts"
    },
    "project": "effect",
    "name": "updateAs",
    "description": "Updates the value of the specified `FiberRef` using the provided `FiberId`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateAs: { <A>(options: { readonly fiberId: FiberId.Single; readonly fiberRef: FiberRef.FiberRef<A>; readonly value: A; }): (self: FiberRefs) => FiberRefs; <A>(self: FiberRefs, options: { readonly fiberId: FiberId.Single; readonly fiberRef: FiberRef.FiberRef<A>; readonly value: A; }): FiberRefs; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L126"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs.ts",
      "path": "src/FiberRefs.ts"
    },
    "project": "effect",
    "name": "updateManyAs",
    "description": "Updates the values of the specified `FiberRef` & value pairs using the provided `FiberId`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateManyAs: { (options: { readonly forkAs?: FiberId.Single | undefined; readonly entries: readonly [readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]], ...Array<readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]]>]; }): (self: FiberRefs) => FiberRefs; (self: FiberRefs, options: { readonly forkAs?: FiberId.Single | undefined; readonly entries: readonly [readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]], ...Array<readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]]>]; }): FiberRefs; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L150"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs.ts",
      "path": "src/FiberRefs.ts"
    },
    "project": "effect",
    "name": "unsafeMake",
    "description": "Note: it will not copy the provided Map, make sure to provide a fresh one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeMake: (fiberRefLocals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>) => FiberRefs",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L194"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs.ts",
      "path": "src/FiberRefs.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "The empty collection of `FiberRef` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: () => FiberRefs",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L204"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRefs.ts",
      "path": "src/FiberRefs.ts"
    },
    "project": "effect",
    "name": "FiberRefs",
    "description": "`FiberRefs` is a data type that represents a collection of `FiberRef` values.\n\nThis allows safely propagating `FiberRef` values across fiber boundaries, for\nexample between an asynchronous producer and consumer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface FiberRefs extends Pipeable {\n  readonly [FiberRefsSym]: FiberRefsSym\n  readonly locals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L34"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberRefs.ts",
      "path": "src/FiberRefs.ts"
    },
    "project": "effect",
    "name": "FiberRefsSym",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type FiberRefsSym = typeof FiberRefsSym",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefs.ts#L23"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefsPatch.ts",
      "path": "src/FiberRefsPatch.ts"
    },
    "project": "effect",
    "name": "empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: FiberRefsPatch",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefsPatch.ts#L71"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefsPatch.ts",
      "path": "src/FiberRefsPatch.ts"
    },
    "project": "effect",
    "name": "diff",
    "description": "Constructs a patch that describes the changes between the specified\ncollections of `FiberRef`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const diff: (oldValue: FiberRefs.FiberRefs, newValue: FiberRefs.FiberRefs) => FiberRefsPatch",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefsPatch.ts#L80"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefsPatch.ts",
      "path": "src/FiberRefsPatch.ts"
    },
    "project": "effect",
    "name": "combine",
    "description": "Combines this patch and the specified patch to create a new patch that\ndescribes applying the changes from this patch and the specified patch\nsequentially.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const combine: { (that: FiberRefsPatch): (self: FiberRefsPatch) => FiberRefsPatch; (self: FiberRefsPatch, that: FiberRefsPatch): FiberRefsPatch; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefsPatch.ts#L90"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefsPatch.ts",
      "path": "src/FiberRefsPatch.ts"
    },
    "project": "effect",
    "name": "patch",
    "description": "Applies the changes described by this patch to the specified collection\nof `FiberRef` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const patch: { (fiberId: FiberId.Runtime, oldValue: FiberRefs.FiberRefs): (self: FiberRefsPatch) => FiberRefs.FiberRefs; (self: FiberRefsPatch, fiberId: FiberId.Runtime, oldValue: FiberRefs.FiberRefs): FiberRefs.FiberRefs; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefsPatch.ts#L102"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRefsPatch.ts",
      "path": "src/FiberRefsPatch.ts"
    },
    "project": "effect",
    "name": "Empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Empty {\n  readonly _tag: \"Empty\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefsPatch.ts#L24"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRefsPatch.ts",
      "path": "src/FiberRefsPatch.ts"
    },
    "project": "effect",
    "name": "Add",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Add {\n  readonly _tag: \"Add\"\n  readonly fiberRef: FiberRef.FiberRef<unknown>\n  readonly value: unknown\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefsPatch.ts#L32"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRefsPatch.ts",
      "path": "src/FiberRefsPatch.ts"
    },
    "project": "effect",
    "name": "Remove",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Remove {\n  readonly _tag: \"Remove\"\n  readonly fiberRef: FiberRef.FiberRef<unknown>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefsPatch.ts#L42"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRefsPatch.ts",
      "path": "src/FiberRefsPatch.ts"
    },
    "project": "effect",
    "name": "Update",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Update {\n  readonly _tag: \"Update\"\n  readonly fiberRef: FiberRef.FiberRef<unknown>\n  readonly patch: unknown\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefsPatch.ts#L51"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRefsPatch.ts",
      "path": "src/FiberRefsPatch.ts"
    },
    "project": "effect",
    "name": "AndThen",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface AndThen {\n  readonly _tag: \"AndThen\"\n  readonly first: FiberRefsPatch\n  readonly second: FiberRefsPatch\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefsPatch.ts#L61"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberRefsPatch.ts",
      "path": "src/FiberRefsPatch.ts"
    },
    "project": "effect",
    "name": "FiberRefsPatch",
    "description": "A `FiberRefsPatch` captures the changes in `FiberRef` values made by a single\nfiber as a value. This allows fibers to apply the changes made by a workflow\nwithout inheriting all the `FiberRef` values of the fiber that executed the\nworkflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type FiberRefsPatch = Empty | Add | Remove | Update | AndThen",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberRefsPatch.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L23"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "unsafeAdd",
    "description": "Add a fiber to the FiberSet. When the fiber completes, it will be removed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const unsafeAdd: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberSet<A, E>) => void; <A, E, XE extends E, XA extends A>(self: FiberSet<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L187"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "add",
    "description": "Add a fiber to the FiberSet. When the fiber completes, it will be removed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const add: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberSet<A, E>) => Effect.Effect<void>; <A, E, XE extends E, XA extends A>(self: FiberSet<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L242"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "run",
    "description": "Fork an Effect and add the forked fiber to the FiberSet.\nWhen the fiber completes, it will be removed from the FiberSet.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const run: { <A, E>(self: FiberSet<A, E>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <A, E, R, XE extends E, XA extends A>(self: FiberSet<A, E>, effect: Effect.Effect<XA, XE, R>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L306"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "isFiberSet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const isFiberSet: (u: unknown) => u is FiberSet<unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L53"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "A FiberSet can be used to store a collection of fibers.\nWhen the associated Scope is closed, all fibers in the set will be interrupted.\n\nYou can add fibers to the set using `FiberSet.add` or `FiberSet.run`, and the fibers will\nbe automatically removed from the FiberSet when they complete.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, FiberSet } from \"effect\"\n\nEffect.gen(function*() {\n  const set = yield* FiberSet.make()\n\n  // run some effects and add the fibers to the set\n  yield* FiberSet.run(set, Effect.never)\n  yield* FiberSet.run(set, Effect.never)\n\n  yield* Effect.sleep(1000)\n}).pipe(\n  Effect.scoped // The fibers will be interrupted when the scope is closed\n)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const make: <A = unknown, E = unknown>() => Effect.Effect<FiberSet<A, E>, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L117"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "makeRuntime",
    "description": "Create an Effect run function that is backed by a FiberSet.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const makeRuntime: <R = never, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: Runtime.RunForkOptions | undefined) => Fiber.RuntimeFiber<XA, XE>), never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L138"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "makeRuntimePromise",
    "description": "Create an Effect run function that is backed by a FiberSet.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": "declare const makeRuntimePromise: <R = never, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: Runtime.RunForkOptions | undefined) => Promise<XA>), never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L157"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "clear",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const clear: <A, E>(self: FiberSet<A, E>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L279"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "runtime",
    "description": "Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberSet.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Context, Effect, FiberSet } from \"effect\"\n\ninterface Users {\n  readonly _: unique symbol\n}\nconst Users = Context.GenericTag<Users, {\n   getAll: Effect.Effect<Array<unknown>>\n}>(\"Users\")\n\nEffect.gen(function*() {\n  const set = yield* FiberSet.make()\n  const run = yield* FiberSet.runtime(set)<Users>()\n\n  // run some effects and add the fibers to the set\n  run(Effect.andThen(Users, _ => _.getAll))\n}).pipe(\n  Effect.scoped // The fibers will be interrupted when the scope is closed\n)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const runtime: <A, E>(self: FiberSet<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L380"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "runtimePromise",
    "description": "Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberSet.\n\nThe returned run function will return Promise's.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": "declare const runtimePromise: <A, E>(self: FiberSet<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined; }) | undefined) => Promise<XA>), never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L420"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "size",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const size: <A, E>(self: FiberSet<A, E>) => Effect.Effect<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L455"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "join",
    "description": "Join all fibers in the FiberSet. If any of the Fiber's in the set terminate with a failure,\nthe returned Effect will terminate with the first failure that occurred.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, FiberSet } from \"effect\";\n\nEffect.gen(function* (_) {\n  const set = yield* _(FiberSet.make());\n  yield* _(FiberSet.add(set, Effect.runFork(Effect.fail(\"error\"))));\n\n  // parent fiber will fail with \"error\"\n  yield* _(FiberSet.join(set));\n});\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const join: <A, E>(self: FiberSet<A, E>) => Effect.Effect<void, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L477"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "awaitEmpty",
    "description": "Wait until the fiber set is empty.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": "declare const awaitEmpty: <A, E>(self: FiberSet<A, E>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L486"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "FiberSet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface FiberSet<out A = unknown, out E = unknown>\n  extends Pipeable, Inspectable.Inspectable, Iterable<Fiber.RuntimeFiber<A, E>>\n{\n  readonly [TypeId]: TypeId\n  readonly deferred: Deferred.Deferred<void, unknown>\n  /** @internal */\n  state: {\n    readonly _tag: \"Open\"\n    readonly backing: Set<Fiber.RuntimeFiber<A, E>>\n  } | {\n    readonly _tag: \"Closed\"\n  }\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L35"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberSet.ts",
      "path": "src/FiberSet.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberSet.ts#L29"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus.ts",
      "path": "src/FiberStatus.ts"
    },
    "project": "effect",
    "name": "FiberStatusTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const FiberStatusTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L13"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus.ts",
      "path": "src/FiberStatus.ts"
    },
    "project": "effect",
    "name": "done",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const done: FiberStatus",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L61"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus.ts",
      "path": "src/FiberStatus.ts"
    },
    "project": "effect",
    "name": "running",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const running: (runtimeFlags: RuntimeFlags.RuntimeFlags) => FiberStatus",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L67"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus.ts",
      "path": "src/FiberStatus.ts"
    },
    "project": "effect",
    "name": "suspended",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const suspended: (runtimeFlags: RuntimeFlags.RuntimeFlags, blockingOn: FiberId.FiberId) => FiberStatus",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L73"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus.ts",
      "path": "src/FiberStatus.ts"
    },
    "project": "effect",
    "name": "isFiberStatus",
    "description": "Returns `true` if the specified value is a `FiberStatus`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isFiberStatus: (u: unknown) => u is FiberStatus",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L82"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus.ts",
      "path": "src/FiberStatus.ts"
    },
    "project": "effect",
    "name": "isDone",
    "description": "Returns `true` if the specified `FiberStatus` is `Done`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isDone: (self: FiberStatus) => self is Done",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L90"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus.ts",
      "path": "src/FiberStatus.ts"
    },
    "project": "effect",
    "name": "isRunning",
    "description": "Returns `true` if the specified `FiberStatus` is `Running`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isRunning: (self: FiberStatus) => self is Running",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L99"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus.ts",
      "path": "src/FiberStatus.ts"
    },
    "project": "effect",
    "name": "isSuspended",
    "description": "Returns `true` if the specified `FiberStatus` is `Suspended`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isSuspended: (self: FiberStatus) => self is Suspended",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L108"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberStatus.ts",
      "path": "src/FiberStatus.ts"
    },
    "project": "effect",
    "name": "Done",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Done extends Equal.Equal {\n  readonly _tag: \"Done\"\n  readonly [FiberStatusTypeId]: FiberStatusTypeId\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L31"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberStatus.ts",
      "path": "src/FiberStatus.ts"
    },
    "project": "effect",
    "name": "Running",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Running extends Equal.Equal {\n  readonly _tag: \"Running\"\n  readonly [FiberStatusTypeId]: FiberStatusTypeId\n  readonly runtimeFlags: RuntimeFlags.RuntimeFlags\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L40"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberStatus.ts",
      "path": "src/FiberStatus.ts"
    },
    "project": "effect",
    "name": "Suspended",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Suspended extends Equal.Equal {\n  readonly _tag: \"Suspended\"\n  readonly [FiberStatusTypeId]: FiberStatusTypeId\n  readonly runtimeFlags: RuntimeFlags.RuntimeFlags\n  readonly blockingOn: FiberId.FiberId\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L50"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberStatus.ts",
      "path": "src/FiberStatus.ts"
    },
    "project": "effect",
    "name": "FiberStatusTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type FiberStatusTypeId = typeof FiberStatusTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L19"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberStatus.ts",
      "path": "src/FiberStatus.ts"
    },
    "project": "effect",
    "name": "FiberStatus",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type FiberStatus = Done | Running | Suspended",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/FiberStatus.ts#L25"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "dual",
    "description": "Creates a function that can be used in a data-last (aka `pipe`able) or\ndata-first style.\n\nThe first parameter to `dual` is either the arity of the uncurried function\nor a predicate that determines if the function is being used in a data-first\nor data-last style.\n\nUsing the arity is the most common use case, but there are some cases where\nyou may want to use a predicate. For example, if you have a function that\ntakes an optional argument, you can use a predicate to determine if the\nfunction is being used in a data-first or data-last style.\n\nYou can pass either the arity of the uncurried function or a predicate\nwhich determines if the function is being used in a data-first or\ndata-last style.\n\n**Example** (Using arity to determine data-first or data-last style)\n\n```ts\nimport { dual, pipe } from \"effect/Function\"\n\nconst sum = dual<\n  (that: number) => (self: number) => number,\n  (self: number, that: number) => number\n>(2, (self, that) => self + that)\n\nconsole.log(sum(2, 3)) // 5\nconsole.log(pipe(2, sum(3))) // 5\n```\n\n**Example** (Using call signatures to define the overloads)\n\n```ts\nimport { dual, pipe } from \"effect/Function\"\n\nconst sum: {\n  (that: number): (self: number) => number\n  (self: number, that: number): number\n} = dual(2, (self: number, that: number): number => self + that)\n\nconsole.log(sum(2, 3)) // 5\nconsole.log(pipe(2, sum(3))) // 5\n```\n\n**Example** (Using a predicate to determine data-first or data-last style)\n\n```ts\nimport { dual, pipe } from \"effect/Function\"\n\nconst sum = dual<\n  (that: number) => (self: number) => number,\n  (self: number, that: number) => number\n>(\n  (args) => args.length === 2,\n  (self, that) => self + that\n)\n\nconsole.log(sum(2, 3)) // 5\nconsole.log(pipe(2, sum(3))) // 5\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const dual: { <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(arity: Parameters<DataFirst>[\"length\"], body: DataFirst): DataLast & DataFirst; <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(isDataFirst: (args: IArguments) => boolean, body: DataFirst): DataLast & DataFirst; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L95"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "unsafeCoerce",
    "description": "Casts the result to the specified type.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { unsafeCoerce, identity } from \"effect/Function\"\n\nassert.deepStrictEqual(unsafeCoerce, identity)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const unsafeCoerce: <A, B>(a: A) => B",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L271"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "constTrue",
    "description": "A thunk that returns always `true`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { constTrue } from \"effect/Function\"\n\nassert.deepStrictEqual(constTrue(), true)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const constTrue: LazyArg<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L307"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "constFalse",
    "description": "A thunk that returns always `false`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { constFalse } from \"effect/Function\"\n\nassert.deepStrictEqual(constFalse(), false)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const constFalse: LazyArg<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L322"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "constNull",
    "description": "A thunk that returns always `null`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { constNull } from \"effect/Function\"\n\nassert.deepStrictEqual(constNull(), null)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const constNull: LazyArg<null>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L337"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "constUndefined",
    "description": "A thunk that returns always `undefined`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { constUndefined } from \"effect/Function\"\n\nassert.deepStrictEqual(constUndefined(), undefined)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const constUndefined: LazyArg<undefined>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L352"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "constVoid",
    "description": "A thunk that returns always `void`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { constVoid } from \"effect/Function\"\n\nassert.deepStrictEqual(constVoid(), undefined)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const constVoid: LazyArg<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L367"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "compose",
    "description": "Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\nThe result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { compose } from \"effect/Function\"\n\nconst increment = (n: number) => n + 1;\nconst square = (n: number) => n * n;\n\nassert.strictEqual(compose(increment, square)(2), 9);\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const compose: { <B, C>(bc: (b: B) => C): <A>(self: (a: A) => B) => (a: A) => C; <A, B, C>(self: (a: A) => B, bc: (b: B) => C): (a: A) => C; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L407"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "hole",
    "description": "Type hole simulation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const hole: <T>() => T",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L1204"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "pipe",
    "description": "Pipes the value of an expression into a pipeline of functions.\n\n**Details**\n\nThe `pipe` function is a utility that allows us to compose functions in a\nreadable and sequential manner. It takes the output of one function and\npasses it as the input to the next function in the pipeline. This enables us\nto build complex transformations by chaining multiple functions together.\n\n```ts skip-type-checking\nimport { pipe } from \"effect\"\n\nconst result = pipe(input, func1, func2, ..., funcN)\n```\n\nIn this syntax, `input` is the initial value, and `func1`, `func2`, ...,\n`funcN` are the functions to be applied in sequence. The result of each\nfunction becomes the input for the next function, and the final result is\nreturned.\n\nHere's an illustration of how `pipe` works:\n\n```\n                    \n input  func1  func2   ...   funcN  result \n                    \n```\n\nIt's important to note that functions passed to `pipe` must have a **single\nargument** because they are only called with a single argument.\n\n**When to Use**\n\nThis is useful in combination with data-last functions as a simulation of\nmethods:\n\n```ts skip-type-checking\nas.map(f).filter(g)\n```\n\nbecomes:\n\n```ts skip-type-checking\nimport { pipe, Array } from \"effect\"\n\npipe(as, Array.map(f), Array.filter(g))\n```\n\n**Example** (Chaining Arithmetic Operations)\n\n```ts\nimport { pipe } from \"effect\"\n\n// Define simple arithmetic operations\nconst increment = (x: number) => x + 1\nconst double = (x: number) => x * 2\nconst subtractTen = (x: number) => x - 10\n\n// Sequentially apply these operations using `pipe`\nconst result = pipe(5, increment, double, subtractTen)\n\nconsole.log(result)\n// Output: 2\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const pipe: { <A>(a: A): A; <A, B = never>(a: A, ab: (a: A) => B): B; <A, B = never, C = never>(a: A, ab: (a: A) => B, bc: (b: B) => C): C; <A, B = never, C = never, D = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D): D; <A, B = never, C = never, D = never, E = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E): E; <A, B = never, C = never, D = never, E = never, F = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F): F; <A, B = never, C = never, D = never, E = never, F = never, G = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G): G; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H): H; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I): I; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J): J; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K): K; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L): L; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M): M; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N): N; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O): O; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P): P; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q): Q; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R): R; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never, S = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R, rs: (r: R) => S): S; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never, S = never, T = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R, rs: (r: R) => S, st: (s: S) => T): T; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L974"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "flow",
    "description": "Performs left-to-right function composition. The first argument may have any arity, the remaining arguments must be unary.\n\nSee also [`pipe`](#pipe).",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { flow } from \"effect/Function\"\n\nconst len = (s: string): number => s.length\nconst double = (n: number): number => n * 2\n\nconst f = flow(len, double)\n\nassert.strictEqual(f('aaa'), 6)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const flow: { <A extends ReadonlyArray<unknown>, B = never>(ab: (...a: A) => B): (...a: A) => B; <A extends ReadonlyArray<unknown>, B = never, C = never>(ab: (...a: A) => B, bc: (b: B) => C): (...a: A) => C; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D): (...a: A) => D; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E): (...a: A) => E; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F): (...a: A) => F; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G): (...a: A) => G; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never, H = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H): (...a: A) => H; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I): (...a: A) => I; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J): (...a: A) => J; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L1149"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "isFunction",
    "description": "Tests if a value is a `function`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isFunction } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isFunction(isFunction), true)\nassert.deepStrictEqual(isFunction(\"function\"), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isFunction: (input: unknown) => input is Function",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L29"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "apply",
    "description": "Apply a function to a given value.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, apply } from \"effect/Function\"\nimport { length } from \"effect/String\"\n\nassert.deepStrictEqual(pipe(length, apply(\"hello\")), 5)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const apply: <A>(a: A) => <B>(self: (a: A) => B) => B",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L187"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "identity",
    "description": "The identity function, i.e. A function that returns its input argument.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { identity } from \"effect/Function\"\n\nassert.deepStrictEqual(identity(5), 5)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const identity: <A>(a: A) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L234"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "satisfies",
    "description": "A function that ensures that the type of an expression matches some type,\nwithout changing the resulting type of that expression.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { satisfies } from \"effect/Function\"\n\nconst test1 = satisfies<number>()(5 as const)\n    //^? const test: 5\n    // @ts-expect-error\nconst test2 = satisfies<string>()(5)\n    //^? Argument of type 'number' is not assignable to parameter of type 'string'\n\nassert.deepStrictEqual(satisfies<number>()(5), 5)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const satisfies: <A>() => <B extends A>(b: B) => B",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L256"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "constant",
    "description": "Creates a constant value that never changes.\n\nThis is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)\nand want that inner function to always use the same value, no matter how many times it is called.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { constant } from \"effect/Function\"\n\nconst constNull = constant(null)\n\nassert.deepStrictEqual(constNull(), null)\nassert.deepStrictEqual(constNull(), null)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const constant: <A>(value: A) => LazyArg<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L292"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "flip",
    "description": "Reverses the order of arguments for a curried function.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { flip } from \"effect/Function\"\n\nconst f = (a: number) => (b: string) => a - b.length\n\nassert.deepStrictEqual(flip(f)('aaa')(2), -1)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const flip: <A extends Array<unknown>, B extends Array<unknown>, C>(f: (...a: A) => (...b: B) => C) => (...b: B) => (...a: A) => C",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L384"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "absurd",
    "description": "The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,\nmeaning that it should be impossible for this code to be executed.\n\nThis function is particularly useful when it's necessary to specify that certain cases are impossible.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const absurd: <A>(_: never) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L420"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "tupled",
    "description": "Creates a   version of this function: instead of `n` arguments, it accepts a single tuple argument.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { tupled } from \"effect/Function\"\n\nconst sumTupled = tupled((x: number, y: number): number => x + y)\n\nassert.deepStrictEqual(sumTupled([1, 2]), 3)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const tupled: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B) => (a: A) => B",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L439"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "untupled",
    "description": "Inverse function of `tupled`",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { untupled } from \"effect/Function\"\n\nconst getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])\n\nassert.deepStrictEqual(getFirst(1, 2), 1)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const untupled: <A extends ReadonlyArray<unknown>, B>(f: (a: A) => B) => (...a: A) => B",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L456"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "SK",
    "description": "The SK combinator, also known as the \"S-K combinator\" or \"S-combinator\", is a fundamental combinator in the\nlambda calculus and the SKI combinator calculus.\n\nThis function is useful for discarding the first argument passed to it and returning the second argument.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { SK } from \"effect/Function\";\n\nassert.deepStrictEqual(SK(0, \"hello\"), \"hello\")\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const SK: <A, B>(_: A, b: B) => B",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L1222"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "FunctionTypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface FunctionTypeLambda extends TypeLambda {\n  readonly type: (a: this[\"In\"]) => this[\"Target\"]\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L10"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "LazyArg",
    "description": "A lazy argument.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { LazyArg, constant } from \"effect/Function\"\n\nconst constNull: LazyArg<null> = constant(null)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface LazyArg<A> {\n  (): A\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L202"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Function.ts",
      "path": "src/Function.ts"
    },
    "project": "effect",
    "name": "FunctionN",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { FunctionN } from \"effect/Function\"\n\nconst sum: FunctionN<[number, number], number> = (a, b) => a + b\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface FunctionN<A extends ReadonlyArray<unknown>, B> {\n  (...args: A): B\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Function.ts#L217"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "GlobalValue.ts",
      "path": "src/GlobalValue.ts"
    },
    "project": "effect",
    "name": "globalValue",
    "description": "Retrieves or computes a global value associated with the given `id`. If the value for this `id`\nhas already been computed, it will be returned from the global store. If it does not exist yet,\nthe provided `compute` function will be executed to compute the value, store it, and then return it.\n\nThis ensures that even in cases where the module is imported multiple times (e.g., in mixed environments\nlike CommonJS and ESM, or during hot-reloading in development), the value is computed only once and reused\nthereafter.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { globalValue } from \"effect/GlobalValue\"\n\n// This cache will persist as long as the module is running,\n// even if reloaded or imported elsewhere\nconst myCache = globalValue(\n  Symbol.for(\"myCache\"),\n  () => new WeakMap<object, number>()\n)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const globalValue: <A>(id: unknown, compute: () => A) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GlobalValue.ts#L44"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "GroupBy.ts",
      "path": "src/GroupBy.ts"
    },
    "project": "effect",
    "name": "GroupByTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const GroupByTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GroupBy.ts#L16"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "GroupBy.ts",
      "path": "src/GroupBy.ts"
    },
    "project": "effect",
    "name": "evaluate",
    "description": "Run the function across all groups, collecting the results in an\narbitrary order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const evaluate: { <K, V, E, A, E2, R2>(f: (key: K, stream: Stream.Stream<V, E, never>) => Stream.Stream<A, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <R>(self: GroupBy<K, V, E, R>) => Stream.Stream<A, E | E2, R2 | R>; <K, V, E, R, A, E2, R2>(self: GroupBy<K, V, E, R>, f: (key: K, stream: Stream.Stream<V, E, never>) => Stream.Stream<A, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): Stream.Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GroupBy.ts#L61"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "GroupBy.ts",
      "path": "src/GroupBy.ts"
    },
    "project": "effect",
    "name": "filter",
    "description": "Filter the groups to be processed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const filter: { <K>(predicate: Predicate<NoInfer<K>>): <V, E, R>(self: GroupBy<K, V, E, R>) => GroupBy<K, V, E, R>; <K, V, E, R>(self: GroupBy<K, V, E, R>, predicate: Predicate<K>): GroupBy<K, V, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GroupBy.ts#L79"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "GroupBy.ts",
      "path": "src/GroupBy.ts"
    },
    "project": "effect",
    "name": "first",
    "description": "Only consider the first `n` groups found in the `Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const first: { (n: number): <K, V, E, R>(self: GroupBy<K, V, E, R>) => GroupBy<K, V, E, R>; <K, V, E, R>(self: GroupBy<K, V, E, R>, n: number): GroupBy<K, V, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GroupBy.ts#L90"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "GroupBy.ts",
      "path": "src/GroupBy.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a `GroupBy` from a `Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <K, V, E, R>(grouped: Stream.Stream<readonly [K, Queue.Dequeue<Take.Take<V, E>>], E, R>) => GroupBy<K, V, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GroupBy.ts#L101"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "GroupBy.ts",
      "path": "src/GroupBy.ts"
    },
    "project": "effect",
    "name": "GroupBy",
    "description": "Representation of a grouped stream. This allows to filter which groups will\nbe processed. Once this is applied all groups will be processed in parallel\nand the results will be merged in arbitrary order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface GroupBy<out K, out V, out E = never, out R = never> extends GroupBy.Variance<K, V, E, R>, Pipeable {\n  readonly grouped: Stream.Stream<readonly [K, Queue.Dequeue<Take.Take<V, E>>], E, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GroupBy.ts#L32"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "GroupBy.ts",
      "path": "src/GroupBy.ts"
    },
    "project": "effect",
    "name": "GroupByTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type GroupByTypeId = typeof GroupByTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GroupBy.ts#L22"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "GroupBy.ts",
      "path": "src/GroupBy.ts"
    },
    "project": "effect",
    "name": "GroupBy.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out K, out V, out E, out R> {\n    readonly [GroupByTypeId]: {\n      readonly _K: Covariant<K>\n      readonly _V: Covariant<V>\n      readonly _E: Covariant<E>\n      readonly _R: Covariant<R>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/GroupBy.ts#L44"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Hash.ts",
      "path": "src/Hash.ts"
    },
    "project": "effect",
    "name": "symbol",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const symbol: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Hash.ts#L19"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Hash.ts",
      "path": "src/Hash.ts"
    },
    "project": "effect",
    "name": "cached",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": "declare const cached: { (self: object): (hash: number) => number; (self: object, hash: number): number; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Hash.ts#L166"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash.ts",
      "path": "src/Hash.ts"
    },
    "project": "effect",
    "name": "hash",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": "declare const hash: <A>(self: A) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Hash.ts#L33"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash.ts",
      "path": "src/Hash.ts"
    },
    "project": "effect",
    "name": "random",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": "declare const random: <A extends object>(self: A) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Hash.ts#L76"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash.ts",
      "path": "src/Hash.ts"
    },
    "project": "effect",
    "name": "combine",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": "declare const combine: (b: number) => (self: number) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Hash.ts#L87"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash.ts",
      "path": "src/Hash.ts"
    },
    "project": "effect",
    "name": "optimize",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": "declare const optimize: (n: number) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Hash.ts#L93"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash.ts",
      "path": "src/Hash.ts"
    },
    "project": "effect",
    "name": "isHash",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isHash: (u: unknown) => u is Hash",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Hash.ts#L99"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash.ts",
      "path": "src/Hash.ts"
    },
    "project": "effect",
    "name": "number",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": "declare const number: (n: number) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Hash.ts#L105"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash.ts",
      "path": "src/Hash.ts"
    },
    "project": "effect",
    "name": "string",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": "declare const string: (str: string) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Hash.ts#L123"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash.ts",
      "path": "src/Hash.ts"
    },
    "project": "effect",
    "name": "structureKeys",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": "declare const structureKeys: <A extends object>(o: A, keys: ReadonlyArray<keyof A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Hash.ts#L135"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash.ts",
      "path": "src/Hash.ts"
    },
    "project": "effect",
    "name": "structure",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": "declare const structure: <A extends object>(o: A) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Hash.ts#L147"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash.ts",
      "path": "src/Hash.ts"
    },
    "project": "effect",
    "name": "array",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": "declare const array: <A>(arr: ReadonlyArray<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Hash.ts#L154"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Hash.ts",
      "path": "src/Hash.ts"
    },
    "project": "effect",
    "name": "Hash",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Hash {\n  [symbol](): number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Hash.ts#L25"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "isHashMap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isHashMap: { <K, V>(u: Iterable<readonly [K, V]>): u is HashMap<K, V>; (u: unknown): u is HashMap<unknown, unknown>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L97"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates a new `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <K = never, V = never>() => HashMap<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L108"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new `HashMap` from an array of key/value pairs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Entries extends ReadonlyArray<readonly [any, any]>>(...entries: Entries) => HashMap<Entries[number] extends readonly [infer K, any] ? K : never, Entries[number] extends readonly [any, infer V] ? V : never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L116"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `HashMap` from an iterable collection of key/value pairs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: <K, V>(entries: Iterable<readonly [K, V]>) => HashMap<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L129"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Checks if the `HashMap` contains any entries.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const isEmpty: <K, V>(self: HashMap<K, V>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L137"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Safely lookup the value for the specified key in the `HashMap` using the\ninternal hashing function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const get: { <K1>(key: K1): <K, V>(self: HashMap<K, V>) => Option<V>; <K, V, K1>(self: HashMap<K, V>, key: K1): Option<V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L146"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "getHash",
    "description": "Lookup the value for the specified key in the `HashMap` using a custom hash.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const getHash: { <K1>(key: K1, hash: number): <K, V>(self: HashMap<K, V>) => Option<V>; <K, V, K1>(self: HashMap<K, V>, key: K1, hash: number): Option<V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L157"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "unsafeGet",
    "description": "Unsafely lookup the value for the specified key in the `HashMap` using the\ninternal hashing function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeGet: { <K1>(key: K1): <K, V>(self: HashMap<K, V>) => V; <K, V, K1>(self: HashMap<K, V>, key: K1): V; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L169"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "has",
    "description": "Checks if the specified key has an entry in the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const has: { <K1>(key: K1): <K, V>(self: HashMap<K, V>) => boolean; <K, V, K1>(self: HashMap<K, V>, key: K1): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L180"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "hasHash",
    "description": "Checks if the specified key has an entry in the `HashMap` using a custom\nhash.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const hasHash: { <K1>(key: K1, hash: number): <K, V>(self: HashMap<K, V>) => boolean; <K, V, K1>(self: HashMap<K, V>, key: K1, hash: number): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L192"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "set",
    "description": "Sets the specified key to the specified value using the internal hashing\nfunction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const set: { <K, V>(key: K, value: V): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, value: V): HashMap<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L203"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "keys",
    "description": "Returns an `IterableIterator` of the keys within the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const keys: <K, V>(self: HashMap<K, V>) => IterableIterator<K>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L214"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "keySet",
    "description": "Returns a `HashSet` of keys within the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getter",
    "signature": "declare const keySet: <K, V>(self: HashMap<K, V>) => HashSet<K>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L222"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "values",
    "description": "Returns an `IterableIterator` of the values within the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const values: <K, V>(self: HashMap<K, V>) => IterableIterator<V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L230"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "entries",
    "description": "Returns an `IterableIterator` of the entries within the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const entries: <K, V>(self: HashMap<K, V>) => IterableIterator<[K, V]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L246"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the number of entries within the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <K, V>(self: HashMap<K, V>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L262"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "beginMutation",
    "description": "Marks the `HashMap` as mutable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const beginMutation: <K, V>(self: HashMap<K, V>) => HashMap<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L269"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "endMutation",
    "description": "Marks the `HashMap` as immutable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const endMutation: <K, V>(self: HashMap<K, V>) => HashMap<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L276"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "mutate",
    "description": "Mutates the `HashMap` within the context of the provided function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const mutate: { <K, V>(f: (self: HashMap<K, V>) => void): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, f: (self: HashMap<K, V>) => void): HashMap<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L283"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "modifyAt",
    "description": "Set or remove the specified key in the `HashMap` using the specified\nupdate function. The value of the specified key will be computed using the\nprovided hash.\n\nThe update function will be invoked with the current value of the key if it\nexists, or `None` if no such value exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const modifyAt: { <K, V>(key: K, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, f: HashMap.UpdateFn<V>): HashMap<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L298"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "modifyHash",
    "description": "Alter the value of the specified key in the `HashMap` using the specified\nupdate function. The value of the specified key will be computed using the\nprovided hash.\n\nThe update function will be invoked with the current value of the key if it\nexists, or `None` if no such value exists.\n\nThis function will always either update or insert a value into the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const modifyHash: { <K, V>(key: K, hash: number, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, hash: number, f: HashMap.UpdateFn<V>): HashMap<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L315"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "modify",
    "description": "Updates the value of the specified key within the `HashMap` if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const modify: { <K, V>(key: K, f: (v: V) => V): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, f: (v: V) => V): HashMap<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L325"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "union",
    "description": "Performs a union of this `HashMap` and that `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const union: { <K1, V1>(that: HashMap<K1, V1>): <K0, V0>(self: HashMap<K0, V0>) => HashMap<K1 | K0, V1 | V0>; <K0, V0, K1, V1>(self: HashMap<K0, V0>, that: HashMap<K1, V1>): HashMap<K0 | K1, V0 | V1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L335"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "remove",
    "description": "Remove the entry for the specified key in the `HashMap` using the internal\nhashing function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const remove: { <K>(key: K): <V>(self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K): HashMap<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L346"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "removeMany",
    "description": "Removes all entries in the `HashMap` which have the specified keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const removeMany: { <K>(keys: Iterable<K>): <V>(self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, keys: Iterable<K>): HashMap<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L356"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Maps over the entries of the `HashMap` using the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <A, V, K>(f: (value: V, key: K) => A): (self: HashMap<K, V>) => HashMap<K, A>; <K, V, A>(self: HashMap<K, V>, f: (value: V, key: K) => A): HashMap<K, A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L367"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Chains over the entries of the `HashMap` using the specified function.\n\n**NOTE**: the hash and equal of both maps have to be the same.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMap: { <A, K, B>(f: (value: A, key: K) => HashMap<K, B>): (self: HashMap<K, A>) => HashMap<K, B>; <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => HashMap<K, B>): HashMap<K, B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L380"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "Applies the specified function to the entries of the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const forEach: { <V, K>(f: (value: V, key: K) => void): (self: HashMap<K, V>) => void; <V, K>(self: HashMap<K, V>, f: (value: V, key: K) => void): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L391"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "reduce",
    "description": "Reduces the specified state over the entries of the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduce: { <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: HashMap<K, V>) => Z; <K, V, Z>(self: HashMap<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L402"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters entries out of a `HashMap` using the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filter: { <K, A, B extends A>(f: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => HashMap<K, B>; <K, A>(f: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => HashMap<K, A>; <K, A, B extends A>(self: HashMap<K, A>, f: (a: A, k: K) => a is B): HashMap<K, B>; <K, A>(self: HashMap<K, A>, f: (a: A, k: K) => boolean): HashMap<K, A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L413"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "compact",
    "description": "Filters out `None` values from a `HashMap` of `Options`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const compact: <K, A>(self: HashMap<K, Option<A>>) => HashMap<K, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L426"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Maps over the entries of the `HashMap` using the specified partial function\nand filters out `None` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterMap: { <A, K, B>(f: (value: A, key: K) => Option<B>): (self: HashMap<K, A>) => HashMap<K, B>; <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => Option<B>): HashMap<K, B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L435"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirst: { <K, A, B extends A>(predicate: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => Option<[K, B]>; <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => Option<[K, A]>; <K, A, B extends A>(self: HashMap<K, A>, predicate: (a: A, k: K) => a is B): Option<[K, B]>; <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): Option<[K, A]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L447"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "some",
    "description": "Checks if any entry in a hashmap meets a specific condition.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "elements",
    "signature": "declare const some: { <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => boolean; <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L460"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "every",
    "description": "Checks if all entries in a hashmap meets a specific condition.",
    "deprecated": false,
    "examples": [],
    "since": "3.14.0",
    "category": "elements",
    "signature": "declare const every: { <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => boolean; <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L474"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "toValues",
    "description": "Returns an `Array` of the values within the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "getters",
    "signature": "declare const toValues: <K, V>(self: HashMap<K, V>) => Array<V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L238"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "toEntries",
    "description": "Returns an `Array<[K, V]>` of the entries within the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const toEntries: <K, V>(self: HashMap<K, V>) => Array<[K, V]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L254"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "HashMap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface HashMap<out Key, out Value> extends Iterable<[Key, Value]>, Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L26"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L20"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "HashMap.UpdateFn",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type UpdateFn<V> = (option: Option<V>) => Option<V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L38"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "HashMap.Key",
    "description": "This type-level utility extracts the key type `K` from a `HashMap<K, V>` type.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { HashMap } from \"effect\"\n\ndeclare const hm: HashMap.HashMap<string, number>\n\n// $ExpectType string\ntype K = HashMap.HashMap.Key<typeof hm>\n\n```"
    ],
    "since": "2.0.0",
    "category": "type-level",
    "signature": "type Key<T> = [T] extends [HashMap<infer _K, infer _V>] ? _K : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L55"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "HashMap.Value",
    "description": "This type-level utility extracts the value type `V` from a `HashMap<K, V>` type.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { HashMap } from \"effect\"\n\ndeclare const hm: HashMap.HashMap<string, number>\n\n// $ExpectType number\ntype V = HashMap.HashMap.Value<typeof hm>\n\n```"
    ],
    "since": "2.0.0",
    "category": "type-level",
    "signature": "type Value<T> = [T] extends [HashMap<infer _K, infer _V>] ? _V : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L72"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "HashMap.ts",
      "path": "src/HashMap.ts"
    },
    "project": "effect",
    "name": "HashMap.Entry",
    "description": "This type-level utility extracts the entry type `[K, V]` from a `HashMap<K, V>` type.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { HashMap } from \"effect\"\n\ndeclare const hm: HashMap.HashMap<string, number>\n\n// $ExpectType [string, number]\ntype V = HashMap.HashMap.Entry<typeof hm>\n\n```"
    ],
    "since": "3.9.0",
    "category": "type-level",
    "signature": "type Entry<T> = [Key<T>, Value<T>]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashMap.ts#L90"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "isHashSet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isHashSet: { <A>(u: Iterable<A>): u is HashSet<A>; (u: unknown): u is HashSet<unknown>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L294"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates an empty `HashSet`.\n\nTime complexity: **`O(1)`**",
    "deprecated": false,
    "examples": [
      "```ts\nimport { HashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    // Provide a type argument to create a HashSet of a specific type\n    HashSet.empty<number>(),\n    HashSet.add(1),\n    HashSet.add(1), // Notice the duplicate\n    HashSet.add(2),\n    HashSet.toValues\n  )\n) // Output: [1, 2]\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <A = never>() => HashSet<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L375"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `HashSet` from an iterable collection of values.\n\nTime complexity: **`O(n)`** where n is the number of elements in the iterable",
    "deprecated": false,
    "examples": [
      "```ts\n// Creating a HashSet from an Array\nimport { HashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    [1, 2, 3, 4, 5, 1, 2, 3], // Array<number> is an Iterable<number>;  Note the duplicates.\n    HashSet.fromIterable,\n    HashSet.toValues\n  )\n) // Output: [1, 2, 3, 4, 5]\n```",
      "```ts\n// Creating a HashSet from a Set\nimport { HashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    new Set([\"apple\", \"banana\", \"orange\", \"apple\"]), // Set<string> is an Iterable<string>\n    HashSet.fromIterable,\n    HashSet.toValues\n  )\n) // Output: [\"apple\", \"banana\", \"orange\"]\n```",
      "```ts\n// Creating a HashSet from a Generator\nimport { HashSet } from \"effect\"\n\n// Generator functions return iterables\nfunction* fibonacci(n: number): Generator<number, void, unknown> {\n  let [a, b] = [0, 1]\n  for (let i = 0; i < n; i++) {\n    yield a\n    ;[a, b] = [b, a + b]\n  }\n}\n\n// Create a HashSet from the first 10 Fibonacci numbers\nconst fibonacciSet = HashSet.fromIterable(fibonacci(10))\n\nconsole.log(HashSet.toValues(fibonacciSet))\n// Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order\n```",
      "```ts\n//  Creating a HashSet from another HashSet\nimport { HashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    // since HashSet implements the Iterable interface, we can use it to create a new HashSet\n    HashSet.make(1, 2, 3, 4),\n    HashSet.fromIterable,\n    HashSet.toValues // turns the HashSet back into an array\n  )\n) // Output: [1, 2, 3, 4]\n```",
      "```ts\n// Creating a HashSet from other Effect's data structures like Chunk\nimport { Chunk, HashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    Chunk.make(1, 2, 3, 4), // Iterable<number>\n    HashSet.fromIterable,\n    HashSet.toValues // turns the HashSet back into an array\n  )\n) // Outputs: [1, 2, 3, 4]\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: <A>(elements: Iterable<A>) => HashSet<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L470"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Construct a new `HashSet` from a variable number of values.\n\nTime complexity: **`O(n)`** where n is the number of elements",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Equal, Hash, HashSet, pipe } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nclass Character implements Equal.Equal {\n  readonly name: string\n  readonly trait: string\n\n  constructor(name: string, trait: string) {\n    this.name = name\n    this.trait = trait\n  }\n\n  // Define equality based on name, and trait\n  [Equal.symbol](that: Equal.Equal): boolean {\n    if (that instanceof Character) {\n      return (\n        Equal.equals(this.name, that.name) &&\n        Equal.equals(this.trait, that.trait)\n      )\n    }\n    return false\n  }\n\n  // Generate a hash code based on the sum of the character's name and trait\n  [Hash.symbol](): number {\n    return Hash.hash(this.name + this.trait)\n  }\n\n  static readonly of = (name: string, trait: string): Character => {\n    return new Character(name, trait)\n  }\n}\n\nassert.strictEqual(\n  Equal.equals(\n    HashSet.make(\n      Character.of(\"Alice\", \"Curious\"),\n      Character.of(\"Alice\", \"Curious\"),\n      Character.of(\"White Rabbit\", \"Always late\"),\n      Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n    ),\n    // Is the same as adding each character to an empty set\n    pipe(\n      HashSet.empty(),\n      HashSet.add(Character.of(\"Alice\", \"Curious\")),\n      HashSet.add(Character.of(\"Alice\", \"Curious\")), // Alice tried to attend twice!\n      HashSet.add(Character.of(\"White Rabbit\", \"Always late\")),\n      HashSet.add(Character.of(\"Mad Hatter\", \"Tea enthusiast\"))\n    )\n  ),\n  true,\n  \"`HashSet.make` and `HashSet.empty() + HashSet.add()` should be equal\"\n)\n\nassert.strictEqual(\n  Equal.equals(\n    HashSet.make(\n      Character.of(\"Alice\", \"Curious\"),\n      Character.of(\"Alice\", \"Curious\"),\n      Character.of(\"White Rabbit\", \"Always late\"),\n      Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n    ),\n    HashSet.fromIterable([\n      Character.of(\"Alice\", \"Curious\"),\n      Character.of(\"Alice\", \"Curious\"),\n      Character.of(\"White Rabbit\", \"Always late\"),\n      Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n    ])\n  ),\n  true,\n  \"`HashSet.make` and `HashSet.fromIterable` should be equal\"\n)\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <As extends ReadonlyArray<any>>(...elements: As) => HashSet<As[number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L559"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "has",
    "description": "Checks if the specified value exists in the `HashSet`.\n\nTime complexity: **`O(1)`** average",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.has(3)) // false\n\n// or piped with the pipe function\nHashSet.make(0, 1, 2).pipe(HashSet.has(3)) // false\n\n// or with `data-first` API\nHashSet.has(HashSet.make(0, 1, 2), 3) // false\n```"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const has: { <A>(value: A): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, value: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L588"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "some",
    "description": "Check if a predicate holds true for some `HashSet` element.\n\nTime complexity: **`O(n)`** where n is the number of elements in the set",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\nconst set: HashSet.HashSet<number> = HashSet.make(0, 1, 2)\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  set,\n  HashSet.some((n) => n > 0)\n) // true\n\n// or piped with the pipe function\nset.pipe(HashSet.some((n) => n > 0)) // true\n\n// or with `data-first` API\nHashSet.some(set, (n) => n > 0) // true\n```"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const some: { <A>(f: Predicate<A>): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, f: Predicate<A>): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L657"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "every",
    "description": "Check if a predicate holds true for every `HashSet` element.\n\nTime complexity is **`O(n)`** as it needs to traverse the whole HashSet\ncollection",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax with Refinement\nimport { HashSet, pipe, Predicate } from \"effect\"\n\nconst numberOrString = HashSet.make(1, \"1\", \"one\", \"uno\")\n\n// with `data-last`, a.k.a. `pipeable` API and `Refinement`\npipe(\n  numberOrString, // HashSet.HashSet<number | string>\n  HashSet.every(Predicate.isString)\n) // HashSet.HashSet<string>\n\n// or piped with the pipe function and  `Refinement`\nnumberOrString // HashSet.HashSet<number | string>\n  .pipe(HashSet.every(Predicate.isString)) // HashSet.HashSet<string>\n\n// or with `data-first` API and `Refinement`\nHashSet.every(\n  numberOrString, // HashSet.HashSet<number | string>\n  Predicate.isString\n) // HashSet.HashSet<string>\n```",
      "```ts\n// Syntax with Predicate\nimport { HashSet, pipe } from \"effect\"\n\nconst set = HashSet.make(1, 2, 3)\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  set,\n  HashSet.every((n) => n >= 0)\n) // true\n\n// or piped with the pipe function\nset.pipe(HashSet.every((n) => n >= 0)) // true\n\n// or with `data-first` API\nHashSet.every(set, (n) => n >= 0) // true\n```"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const every: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => self is HashSet<B>; <A>(predicate: Predicate<A>): (self: HashSet<A>) => boolean; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): self is HashSet<B>; <A>(self: HashSet<A>, predicate: Predicate<A>): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L770"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "isSubset",
    "description": "Returns `true` if and only if every element in the this `HashSet` is an\nelement of the second set,\n\n**NOTE**: the hash and equal of both sets must be the same.\n\nTime complexity analysis is of **`O(n)`**",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\nconst set1 = HashSet.make(0, 1)\nconst set2 = HashSet.make(1, 2)\nconst set3 = HashSet.make(0, 1, 2)\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(set1, HashSet.isSubset(set2)) // false\npipe(set1, HashSet.isSubset(set3)) // true\n\n// or piped with the pipe function\nset1.pipe(HashSet.isSubset(set2)) // false\nset1.pipe(HashSet.isSubset(set3)) // true\n\n// or with `data-first` API\nHashSet.isSubset(set1, set2) // false\nHashSet.isSubset(set1, set3) // true)\n```"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const isSubset: { <A>(that: HashSet<A>): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, that: HashSet<A>): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L900"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "values",
    "description": "Returns an `IterableIterator` of the values in the `HashSet`.\n\nTime complexity: **`O(1)`**",
    "deprecated": false,
    "examples": [
      "```ts\nimport { HashSet, pipe } from \"effect\"\n\nconst numberIterable = pipe(\n  HashSet.make(0, 1, 1, 2), // HashSet.HashSet<number>\n  HashSet.values // takes an HashSet<A> and returns an IterableIterator<A>\n)\n\nfor (const number of numberIterable) {\n  console.log(number) // it will logs: 0, 1, 2\n}\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const values: <A>(self: HashSet<A>) => IterableIterator<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L967"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Calculates the number of values in the `HashSet`.\n\nTime complexity: **`O(1)`**",
    "deprecated": false,
    "examples": [
      "```ts\nimport { HashSet, pipe } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nassert.deepStrictEqual(pipe(HashSet.empty(), HashSet.size), 0)\n\nassert.deepStrictEqual(\n  pipe(HashSet.make(1, 2, 2, 3, 4, 3), HashSet.size),\n  4\n)\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <A>(self: HashSet<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1020"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "beginMutation",
    "description": "Creates a new mutable version of the `HashSet`\n\nWhen a `HashSet` is mutable, operations like {@link add} and {@link remove}\nmodify the data structure in place instead of creating a new one, which is\nmore efficient when performing multiple operations.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { HashSet } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nconst UPPER_BOUND = 10_000\n\nconst immutableSet = HashSet.empty<number>().pipe(HashSet.add(0))\n\n// Create a mutable version of the immutableSet\nconst mutableSet = HashSet.beginMutation(immutableSet)\n\nfor (let i = 1; i < UPPER_BOUND; i++) {\n  // Operations now modify the set in place instead of creating new instances\n  // This is more efficient when making multiple changes\n  const pointerToMutableSet = HashSet.add(mutableSet, i)\n\n  // the two sets have the same identity, hence `add` is mutating mutableSet and not returning a new HashSet instance\n  assert(Object.is(mutableSet, pointerToMutableSet))\n  assert.equal(HashSet.has(mutableSet, i), true) // `i` is in the mutableSet\n  assert.equal(HashSet.has(immutableSet, i), false) // `i` is not in the immutableSet\n}\n\nconst next = UPPER_BOUND + 1\n// When done, mark the set as immutable again\nHashSet.endMutation(mutableSet).pipe(\n  HashSet.add(next) // since this returns a new HashSet, it will not be logged as part of the mutableSet\n)\nassert.equal(HashSet.has(mutableSet, next), false)\n\nconsole.log(HashSet.toValues(immutableSet)) // [0]\nconsole.log(HashSet.toValues(mutableSet).sort((a, b) => a - b)) // [0, 1, 2, 3, ...rest]\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const beginMutation: <A>(self: HashSet<A>) => HashSet<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1068"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "endMutation",
    "description": "Makes the `HashSet` immutable again.\n\nAfter calling `endMutation`, operations like {@link add} and {@link remove}\nwill create new instances of the `HashSet` instead of modifying the existing\none.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { HashSet } from \"effect\"\nimport assert from \"node:assert/strict\"\n\n// Create a mutable set\nconst mutableSet = HashSet.beginMutation(HashSet.empty<number>())\n\n// Add some elements to the mutable set\nHashSet.add(mutableSet, 1)\nHashSet.add(mutableSet, 2)\n\n// Before endMutation, operations modify the set in place\nconst sameSet = HashSet.add(mutableSet, 3)\nassert(Object.is(mutableSet, sameSet)) // true - same object reference\nassert.deepStrictEqual(HashSet.toValues(mutableSet).sort(), [1, 2, 3])\n\n// Make the set immutable again\nconst immutableSet = HashSet.endMutation(mutableSet)\n\n// endMutation returns the same set instance, now made immutable\nassert(Object.is(mutableSet, immutableSet)) // true - same object reference\n\n// After endMutation, operations create new instances\nconst newSet = HashSet.add(immutableSet, 4)\nassert(!Object.is(immutableSet, newSet)) // false - different object references\n\n// The original set remains unchanged\nassert.deepStrictEqual(HashSet.toValues(immutableSet).sort(), [1, 2, 3])\n\n// The new set contains the added element\nassert.deepStrictEqual(HashSet.toValues(newSet).sort(), [1, 2, 3, 4])\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const endMutation: <A>(self: HashSet<A>) => HashSet<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1116"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "mutate",
    "description": "Mutates the `HashSet` within the context of the provided function.\n\nYou can consider it a functional abstraction on top of the lower-level\nmutation primitives of {@link module:HashSet.beginMutation} `->` `mutable\ncontext` `->` {@link HashSet.endMutation}.",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with data-last, a.k.a. pipeable API\npipe(\n  HashSet.make(1, 2, 3),\n  HashSet.mutate((set) => {\n    HashSet.add(set, 4)\n    HashSet.remove(set, 1)\n  })\n)\n\n// or piped with the pipe function\nHashSet.make(1, 2, 3).pipe(\n  HashSet.mutate((set) => {\n    HashSet.add(set, 4)\n    HashSet.remove(set, 1)\n  })\n)\n\n// or with data-first API\nHashSet.mutate(HashSet.make(1, 2, 3), (set) => {\n  HashSet.add(set, 4)\n  HashSet.remove(set, 1)\n})\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const mutate: { <A>(f: (set: HashSet<A>) => void): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, f: (set: HashSet<A>) => void): HashSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1159"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "add",
    "description": "Adds a value to the `HashSet`.\n\nTime complexity: **`O(1)`** average",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with data-last, a.k.a. pipeable API\npipe(HashSet.empty(), HashSet.add(0), HashSet.add(0))\n\n// or piped with the pipe function\nHashSet.empty().pipe(HashSet.add(0))\n\n// or with data-first API\nHashSet.add(HashSet.empty(), 0)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const add: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1261"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "remove",
    "description": "Removes a value from the `HashSet`.\n\nTime complexity: **`O(1)`** average",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.remove(0))\n\n// or piped with the pipe function\nHashSet.make(0, 1, 2).pipe(HashSet.remove(0))\n\n// or with `data-first` API\nHashSet.remove(HashSet.make(0, 1, 2), 0)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const remove: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1330"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "difference",
    "description": "Computes the set difference `(A - B)` between this `HashSet` and the\nspecified `Iterable<A>`.\n\nTime complexity: **`O(n)`** where n is the number of elements in the set\n\n**NOTE**: the hash and equal of the values in both the set and the iterable\nmust be the same; meaning we cannot compute a difference between a `HashSet\nof bananas` and a `HashSet of elephants` as they are not the same type and\nwon't implement the Equal trait in the same way.",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with data-last, a.k.a. pipeable API\npipe(HashSet.make(1, 2, 3), HashSet.difference(HashSet.make(3, 4, 5)))\n\n// or piped with the pipe function\nHashSet.make(1, 2, 3).pipe(HashSet.difference(HashSet.make(3, 4, 5)))\n\n// or with data-first API\nHashSet.difference(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const difference: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1401"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "intersection",
    "description": "Returns a `HashSet` of values which are present in both this set and that\n`Iterable<A>`. Computes set intersection (A  B)\n\nTime complexity: **`O(n)`** where n is the number of elements in the smaller\nset\n\n**NOTE**: the hash and equal of the values in both the set and the iterable\nmust be the same.",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with data-last, a.k.a. pipeable API\npipe(HashSet.make(1, 2, 3), HashSet.intersection(HashSet.make(2, 3, 4)))\n\n// or piped with the pipe function\nHashSet.make(1, 2, 3).pipe(HashSet.intersection(HashSet.make(2, 3, 4)))\n\n// or with data-first API\nHashSet.intersection(HashSet.make(1, 2, 3), HashSet.make(2, 3, 4))\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const intersection: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1497"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "union",
    "description": "Computes the set union `( self  that )` between this `HashSet` and the\nspecified `Iterable<A>`.\n\nTime complexity: **`O(n)`** where n is the number of elements in the set\n\n**NOTE**: the hash and equal of the values in both the set and the iterable\nmust be the same.",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with data-last, a.k.a. pipeable API\npipe(HashSet.make(1, 2, 3), HashSet.union(HashSet.make(3, 4, 5)))\n\n// or piped with the pipe function\nHashSet.make(1, 2, 3).pipe(HashSet.union(HashSet.make(3, 4, 5)))\n\n// or with data-first API\nHashSet.union(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const union: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1592"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "toggle",
    "description": "Checks if a value is present in the `HashSet`. If it is present, the value\nwill be removed from the `HashSet`, otherwise the value will be added to the\n`HashSet`.\n\nTime complexity: **`O(1)`** average",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.toggle(0))\n\n// or piped with the pipe function\nHashSet.make(0, 1, 2).pipe(HashSet.toggle(0))\n\n// or with `data-first` API\nHashSet.toggle(HashSet.make(0, 1, 2), 0)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const toggle: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1699"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Maps over the values of the `HashSet` using the specified function.\n\nThe time complexity is of **`O(n)`**.",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(0, 1, 2), // HashSet.HashSet<number>\n  HashSet.map(String) // HashSet.HashSet<string>\n)\n\n// or piped with the pipe method\nHashSet.make(0, 1, 2).pipe(HashSet.map(String))\n\n// or with `data-first` API\nHashSet.map(HashSet.make(0, 1, 2), String)\n```"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <A, B>(f: (a: A) => B): (self: HashSet<A>) => HashSet<B>; <A, B>(self: HashSet<A>, f: (a: A) => B): HashSet<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1786"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Chains over the values of the `HashSet` using the specified function.\n\nThe time complexity is of **`O(n)`**.",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(0, 1, 2), // HashSet.HashSet<number>\n  HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>\n)\n\n// or piped with the pipe method\nHashSet.make(0, 1, 2) // HashSet.HashSet<number>\n  .pipe(\n    HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>\n  )\n\n// or with `data-first` API\nHashSet.flatMap(HashSet.make(0, 1, 2), (n) => Array.of(String(n)))\n```"
    ],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMap: { <A, B>(f: (a: A) => Iterable<B>): (self: HashSet<A>) => HashSet<B>; <A, B>(self: HashSet<A>, f: (a: A) => Iterable<B>): HashSet<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1854"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "Applies the specified function to the values of the `HashSet`.\n\nThe time complexity is of **`O(n)`**.",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.forEach(console.log)) // logs: 0 1 2\n\n// or piped with the pipe method\nHashSet.make(0, 1, 2).pipe(HashSet.forEach(console.log)) // logs: 0 1 2\n\n// or with `data-first` API\nHashSet.forEach(HashSet.make(0, 1, 2), console.log) // logs: 0 1 2\n```"
    ],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const forEach: { <A>(f: (value: A) => void): (self: HashSet<A>) => void; <A>(self: HashSet<A>, f: (value: A) => void): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1915"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "reduce",
    "description": "Reduces the specified state over the values of the `HashSet`.\n\nThe time complexity is of **`O(n)`**.",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet, pipe } from \"effect\"\n\nconst sum = (a: number, b: number): number => a + b\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.reduce(0, sum))\n\n// or with the pipe method\nHashSet.make(0, 1, 2).pipe(HashSet.reduce(0, sum))\n\n// or with `data-first` API\nHashSet.reduce(HashSet.make(0, 1, 2), 0, sum)\n```"
    ],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduce: { <A, Z>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: HashSet<A>) => Z; <A, Z>(self: HashSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L1982"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters values out of a `HashSet` using the specified predicate.\n\nThe time complexity is of **`O(n)`**.",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax with  Predicate\nimport { HashSet, type Predicate, pipe } from \"effect\"\n\nconst filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(-2, -1, 0, 1, 2),\n  HashSet.filter(filterPositiveNumbers)\n)\n\n// or with the pipe method\nHashSet.make(-2, -1, 0, 1, 2).pipe(HashSet.filter(filterPositiveNumbers))\n\n// or with `data-first` API\nHashSet.filter(HashSet.make(-2, -1, 0, 1, 2), filterPositiveNumbers)\n```",
      "```ts\n/// Syntax with Refinement\nimport { HashSet, pipe } from \"effect\"\n\nconst stringRefinement = (value: unknown): value is string =>\n  typeof value === \"string\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"), // // HashSet.HashSet<number | string>\n  HashSet.filter(stringRefinement)\n) // HashSet.HashSet<string>\n\n// or with the pipe method\nHashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\") // HashSet.HashSet<number | string>\n  .pipe(HashSet.filter(stringRefinement)) // HashSet.HashSet<string>\n\n// or with `data-first` API\nHashSet.filter(\n  HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"), // HashSet.HashSet<number | string>\n  stringRefinement\n) // HashSet.HashSet<string>\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => HashSet<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => HashSet<A>; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): HashSet<B>; <A>(self: HashSet<A>, predicate: Predicate<A>): HashSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L2076"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "partition",
    "description": "Partition the values of a `HashSet` using the specified predicate.\n\nIf a value matches the predicate, it will be placed into the `HashSet` on the\nright side of the resulting `Tuple`, otherwise the value will be placed into\nthe left side.\n\nTime complexity is of **`O(n)`**.",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax with Predicate\nimport { HashSet, pipe, Predicate } from \"effect\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(0, 1, 2, 3, 4, 5),\n  HashSet.partition((n) => n % 2 === 0)\n)\n\n// or with the pipe method\nHashSet.make(0, 1, 2, 3, 4, 5).pipe(\n  HashSet.partition((n) => n % 2 === 0)\n)\n\n// or with `data-first` API\nHashSet.partition(HashSet.make(0, 1, 2, 3, 4, 5), (n) => n % 2 === 0)\n```",
      "```ts\n// Syntax with Refinement\nimport { HashSet, pipe, Predicate } from \"effect\"\n\nconst stringRefinement: Predicate.Refinement<string | number, string> = (\n  value\n) => typeof value === \"string\"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"),\n  HashSet.partition(stringRefinement)\n)\n\n// or with the pipe method\nHashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\").pipe(\n  HashSet.partition(stringRefinement)\n)\n\n// or with `data-first` API\nHashSet.partition(\n  HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"),\n  stringRefinement\n)\n```"
    ],
    "since": "2.0.0",
    "category": "partitioning",
    "signature": "declare const partition: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]; <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => [excluded: HashSet<A>, satisfying: HashSet<A>]; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]; <A>(self: HashSet<A>, predicate: Predicate<A>): [excluded: HashSet<A>, satisfying: HashSet<A>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L2234"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "toValues",
    "description": "Returns an `Array` of the values within the `HashSet`.\n\nTime complexity: **`O(n)`** where n is the number of elements in the set",
    "deprecated": false,
    "examples": [
      "```ts\nimport { HashSet, pipe } from \"effect\"\nimport { deepStrictEqual } from \"node:assert/strict\"\n\ndeepStrictEqual(\n  pipe(\n    HashSet.make(0, 1, 1, 2), // HashSet<number>\n    HashSet.toValues // takes an HashSet<A> and returns an Array<A>\n  ),\n  Array.of(0, 1, 2)\n)\n```"
    ],
    "since": "3.13.0",
    "category": "getters",
    "signature": "declare const toValues: <A>(self: HashSet<A>) => Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L994"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "HashSet",
    "deprecated": false,
    "examples": [
      "```ts\n// Syntax\nimport { HashSet } from \"effect\"\n\nlet numberSet: HashSet.HashSet<number>\n```"
    ],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface HashSet<out A> extends Iterable<A>, Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L285"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "HashSet.ts",
      "path": "src/HashSet.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HashSet.ts#L268"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "HKT.ts",
      "path": "src/HKT.ts"
    },
    "project": "effect",
    "name": "TypeClass",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TypeClass<F extends TypeLambda> {\n  readonly [URI]?: F\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HKT.ts#L14"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "HKT.ts",
      "path": "src/HKT.ts"
    },
    "project": "effect",
    "name": "TypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TypeLambda {\n  readonly In: unknown\n  readonly Out2: unknown\n  readonly Out1: unknown\n  readonly Target: unknown\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HKT.ts#L21"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "HKT.ts",
      "path": "src/HKT.ts"
    },
    "project": "effect",
    "name": "Kind",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Kind<F, In, Out2, Out1, Target> = F extends {\n  readonly type: unknown\n} ? (F & {\n    readonly In: In\n    readonly Out2: Out2\n    readonly Out1: Out1\n    readonly Target: Target\n  })[\"type\"]\n  : {\n    readonly F: F\n    readonly In: Types.Contravariant<In>\n    readonly Out2: Types.Covariant<Out2>\n    readonly Out1: Types.Covariant<Out1>\n    readonly Target: Types.Invariant<Target>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/HKT.ts#L31"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Inspectable.ts",
      "path": "src/Inspectable.ts"
    },
    "project": "effect",
    "name": "Class",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare class Class",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Inspectable.ts#L72"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Inspectable.ts",
      "path": "src/Inspectable.ts"
    },
    "project": "effect",
    "name": "NodeInspectSymbol",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const NodeInspectSymbol: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Inspectable.ts#L12"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Inspectable.ts",
      "path": "src/Inspectable.ts"
    },
    "project": "effect",
    "name": "BaseProto",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const BaseProto: Inspectable",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Inspectable.ts#L57"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Inspectable.ts",
      "path": "src/Inspectable.ts"
    },
    "project": "effect",
    "name": "symbolRedactable",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "redactable",
    "signature": "declare const symbolRedactable: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Inspectable.ts#L138"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Inspectable.ts",
      "path": "src/Inspectable.ts"
    },
    "project": "effect",
    "name": "toJSON",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const toJSON: (x: unknown) => unknown",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Inspectable.ts#L33"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Inspectable.ts",
      "path": "src/Inspectable.ts"
    },
    "project": "effect",
    "name": "format",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const format: (x: unknown) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Inspectable.ts#L52"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Inspectable.ts",
      "path": "src/Inspectable.ts"
    },
    "project": "effect",
    "name": "toStringUnknown",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const toStringUnknown: (u: unknown, whitespace?: number | string | undefined) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Inspectable.ts#L94"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Inspectable.ts",
      "path": "src/Inspectable.ts"
    },
    "project": "effect",
    "name": "stringifyCircular",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const stringifyCircular: (obj: unknown, whitespace?: number | string | undefined) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Inspectable.ts#L108"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Inspectable.ts",
      "path": "src/Inspectable.ts"
    },
    "project": "effect",
    "name": "isRedactable",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "redactable",
    "signature": "declare const isRedactable: (u: unknown) => u is Redactable",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Inspectable.ts#L144"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Inspectable.ts",
      "path": "src/Inspectable.ts"
    },
    "project": "effect",
    "name": "withRedactableContext",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "redactable",
    "signature": "declare const withRedactableContext: <A>(context: FiberRefs.FiberRefs, f: () => A) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Inspectable.ts#L155"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Inspectable.ts",
      "path": "src/Inspectable.ts"
    },
    "project": "effect",
    "name": "redact",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "redactable",
    "signature": "declare const redact: (u: unknown) => unknown",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Inspectable.ts#L169"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Inspectable.ts",
      "path": "src/Inspectable.ts"
    },
    "project": "effect",
    "name": "Inspectable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Inspectable {\n  toString(): string\n  toJSON(): unknown\n  [NodeInspectSymbol](): unknown\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Inspectable.ts#L24"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Inspectable.ts",
      "path": "src/Inspectable.ts"
    },
    "project": "effect",
    "name": "Redactable",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "redactable",
    "signature": "export interface Redactable {\n  readonly [symbolRedactable]: (fiberRefs: FiberRefs.FiberRefs) => unknown\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Inspectable.ts#L130"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Inspectable.ts",
      "path": "src/Inspectable.ts"
    },
    "project": "effect",
    "name": "NodeInspectSymbol",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type NodeInspectSymbol = typeof NodeInspectSymbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Inspectable.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "replicate",
    "description": "Return a `Iterable` containing a value repeated the specified number of times.\n\n**Note**. `n` is normalized to an integer >= 1.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { replicate } from \"effect/Iterable\"\n\nassert.deepStrictEqual(Array.from(replicate(\"a\", 3)), [\"a\", \"a\", \"a\"])\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const replicate: { (n: number): <A>(a: A) => Iterable<A>; <A>(a: A, n: number): Iterable<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L97"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "prepend",
    "description": "Prepend an element to the front of an `Iterable`, creating a new `Iterable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const prepend: { <B>(head: B): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, head: B): Iterable<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L133"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "prependAll",
    "description": "Prepends the specified prefix iterable to the beginning of the specified iterable.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Iterable } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.from(Iterable.prependAll([1, 2], [\"a\", \"b\"])),\n  [\"a\", \"b\", 1, 2]\n)\n```"
    ],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const prependAll: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L155"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "append",
    "description": "Append an element to the end of an `Iterable`, creating a new `Iterable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const append: { <B>(last: B): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, last: B): Iterable<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L169"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "appendAll",
    "description": "Concatenates two iterables, combining their elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const appendAll: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L180"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "scan",
    "description": "Reduce an `Iterable` from the left, keeping all intermediate results instead of only the final result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const scan: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): Iterable<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L214"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "take",
    "description": "Keep only a max number of elements from the start of an `Iterable`, creating a new `Iterable`.\n\n**Note**. `n` is normalized to a non negative integer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const take: { (n: number): <A>(self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, n: number): Iterable<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L305"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "takeWhile",
    "description": "Calculate the longest initial Iterable for which all element satisfy the specified predicate, creating a new `Iterable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const takeWhile: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Iterable<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Iterable<A>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Iterable<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Iterable<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L330"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "drop",
    "description": "Drop a max number of elements from the start of an `Iterable`\n\n**Note**. `n` is normalized to a non negative integer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const drop: { (n: number): <A>(self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, n: number): Iterable<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L359"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirst: { <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L388"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "findLast",
    "description": "Find the last element for which a predicate holds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findLast: { <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L422"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Takes two `Iterable`s and returns an `Iterable` of corresponding pairs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zip: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L457"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results. If one\ninput `Iterable` is short, excess elements of the longer `Iterable` are discarded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWith: { <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>; <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L472"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "intersperse",
    "description": "Places an element in between members of an `Iterable`.\nIf the input is a non-empty array, the result is also a non-empty array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const intersperse: { <B>(middle: B): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, middle: B): Iterable<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L498"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "contains",
    "description": "Returns a function that checks if a `Iterable` contains a given value using the default `Equivalence`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const contains: { <A>(a: A): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, a: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L550"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "chunksOf",
    "description": "Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\nthe `Iterable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "declare const chunksOf: { (n: number): <A>(self: Iterable<A>) => Iterable<Array<A>>; <A>(self: Iterable<A>, n: number): Iterable<Array<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L562"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "groupWith",
    "description": "Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s using the provided `isEquivalent` function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "declare const groupWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<NonEmptyArray<A>>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<NonEmptyArray<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L599"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "group",
    "description": "Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "declare const group: <A>(self: Iterable<A>) => Iterable<NonEmptyArray<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L645"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "groupBy",
    "description": "Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\nfunction on each element, and grouping the results according to values returned",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "declare const groupBy: { <A, K extends string | symbol>(f: (a: A) => K): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; <A, K extends string | symbol>(self: Iterable<A>, f: (a: A) => K): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L656"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "map",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <A, B>(f: (a: NoInfer<A>, i: number) => B): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, f: (a: NoInfer<A>, i: number) => B): Iterable<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L709"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Applies a function to each element in an Iterable and returns a new Iterable containing the concatenated mapped elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMap: { <A, B>(f: (a: NoInfer<A>, i: number) => Iterable<B>): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, f: (a: NoInfer<A>, i: number) => Iterable<B>): Iterable<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L736"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "filterMap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterMap: { <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Iterable<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L779"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "filterMapWhile",
    "description": "Transforms all elements of the `Iterable` for as long as the specified function returns some value",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterMapWhile: { <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Iterable<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L811"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "getSomes",
    "description": "Retrieves the `Some` values from an `Iterable` of `Option`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Iterable, Option } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.from(Iterable.getSomes([Option.some(1), Option.none(), Option.some(2)])),\n  [1, 2]\n)\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const getSomes: <A>(self: Iterable<Option<A>>) => Iterable<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L851"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "filter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filter: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Iterable<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Iterable<A>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Iterable<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Iterable<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L895"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "flatMapNullable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMapNullable: { <A, B>(f: (a: A) => B | null | undefined): (self: Iterable<A>) => Iterable<NonNullable<B>>; <A, B>(self: Iterable<A>, f: (a: A) => B | null | undefined): Iterable<NonNullable<B>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L926"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "some",
    "description": "Check if a predicate holds true for some `Iterable` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const some: { <A>(predicate: (a: A, i: number) => boolean): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L944"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "Iterate over the `Iterable` applying `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const forEach: { <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void; <A>(self: Iterable<A>, f: (a: A, i: number) => void): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L986"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "reduce",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduce: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L1000"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "dedupeAdjacentWith",
    "description": "Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const dedupeAdjacentWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L1020"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "dedupeAdjacent",
    "description": "Deduplicates adjacent elements that are identical.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const dedupeAdjacent: <A>(self: Iterable<A>) => Iterable<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L1054"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "cartesianWith",
    "description": "Zips this Iterable crosswise with the specified Iterable using the specified combiner.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const cartesianWith: { <A, B, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>; <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L1062"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "cartesian",
    "description": "Zips this Iterable crosswise with the specified Iterable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const cartesian: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L1077"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "makeBy",
    "description": "Return a `Iterable` with element `i` initialized with `f(i)`.\n\nIf the `length` is not specified, the `Iterable` will be infinite.\n\n**Note**. `length` is normalized to an integer >= 1.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { makeBy } from \"effect/Iterable\"\n\nassert.deepStrictEqual(Array.from(makeBy(n => n * 2, { length: 5 })), [0, 2, 4, 6, 8])\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeBy: <A>(f: (i: number) => A, options?: { readonly length?: number; }) => Iterable<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L37"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "range",
    "description": "Return a `Iterable` containing a range of integers, including both endpoints.\n\nIf `end` is omitted, the range will not have an upper bound.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { range } from \"effect/Iterable\"\n\nassert.deepStrictEqual(Array.from(range(1, 3)), [1, 2, 3])\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const range: (start: number, end?: number) => Iterable<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L72"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "fromRecord",
    "description": "Takes a record and returns an Iterable of tuples containing its keys and values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { fromRecord } from \"effect/Iterable\"\n\nconst x = { a: 1, b: 2, c: 3 }\nassert.deepStrictEqual(Array.from(fromRecord(x)), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n```"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Iterable<[K, A]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L117"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Determine if an `Iterable` is empty",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isEmpty } from \"effect/Iterable\"\n\nassert.deepStrictEqual(isEmpty([]), true);\nassert.deepStrictEqual(isEmpty([1, 2, 3]), false);\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isEmpty: <A>(self: Iterable<A>) => self is Iterable<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L252"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Return the number of elements in a `Iterable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <A>(self: Iterable<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L263"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "head",
    "description": "Get the first element of a `Iterable`, or `None` if the `Iterable` is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const head: <A>(self: Iterable<A>) => Option<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L278"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "unsafeHead",
    "description": "Get the first element of a `Iterable`, or throw an error if the `Iterable` is empty.",
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "getters",
    "signature": "declare const unsafeHead: <A>(self: Iterable<A>) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L290"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "containsWith",
    "description": "Returns a function that checks if an `Iterable` contains a given value using a provided `isEquivalent` function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Iterable<A>) => boolean; (self: Iterable<A>, a: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L529"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <A = never>() => Iterable<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L695"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "of",
    "description": "Constructs a new `Iterable<A>` from the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const of: <A>(a: A) => Iterable<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L703"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens an Iterable of Iterables into a single Iterable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatten: <A>(self: Iterable<Iterable<A>>) => Iterable<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L752"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "getLefts",
    "description": "Retrieves the `Left` values from an `Iterable` of `Either`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Iterable, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.from(Iterable.getLefts([Either.right(1), Either.left(\"err\"), Either.right(2)])),\n  [\"err\"]\n)\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const getLefts: <R, L>(self: Iterable<Either<R, L>>) => Iterable<L>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L870"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "getRights",
    "description": "Retrieves the `Right` values from an `Iterable` of `Either`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Iterable, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.from(Iterable.getRights([Either.right(1), Either.left(\"err\"), Either.right(2)])),\n  [1, 2]\n)\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const getRights: <R, L>(self: Iterable<Either<R, L>>) => Iterable<R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L889"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable.ts",
      "path": "src/Iterable.ts"
    },
    "project": "effect",
    "name": "unfold",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unfold: <B, A>(b: B, f: (b: B) => Option<readonly [A, B]>) => Iterable<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Iterable.ts#L964"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const make: <A, I, R>(schema: Schema.Schema<A, I, R>) => JsonSchema7Root",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L248"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "fromAST",
    "description": "Returns a JSON Schema with additional options and definitions.\n\n**Warning**\n\nThis function is experimental and subject to change.\n\n**Options**\n\n- `definitions`: A record of definitions that are included in the schema.\n- `definitionPath`: The path to the definitions within the schema (defaults\n  to \"#/$defs/\").\n- `target`: Which spec to target. Possible values are:\n  - `'jsonSchema7'`: JSON Schema draft-07 (default behavior).\n  - `'jsonSchema2019-09'`: JSON Schema draft-2019-09.\n  - `'openApi3.1'`: OpenAPI 3.1.\n- `topLevelReferenceStrategy`: Controls the handling of the top-level\n  reference. Possible values are:\n  - `\"keep\"`: Keep the top-level reference (default behavior).\n  - `\"skip\"`: Skip the top-level reference.\n- `additionalPropertiesStrategy`: Controls the handling of additional properties. Possible values are:\n  - `\"strict\"`: Disallow additional properties (default behavior).\n  - `\"allow\"`: Allow additional properties.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.5",
    "category": "encoding",
    "signature": "declare const fromAST: (ast: AST.AST, options: { readonly definitions: Record<string, JsonSchema7>; readonly definitionPath?: string | undefined; readonly target?: Target | undefined; readonly topLevelReferenceStrategy?: TopLevelReferenceStrategy | undefined; readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy | undefined; }) => JsonSchema7",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L304"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchemaAnnotations",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchemaAnnotations {\n  title?: string\n  description?: string\n  default?: unknown\n  examples?: Array<unknown>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L16"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Never",
    "deprecated": false,
    "examples": [],
    "since": "3.11.5",
    "category": "model",
    "signature": "export interface JsonSchema7Never extends JsonSchemaAnnotations {\n  $id: \"/schemas/never\"\n  not: {}\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L27"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Any",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Any extends JsonSchemaAnnotations {\n  $id: \"/schemas/any\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L36"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Unknown",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Unknown extends JsonSchemaAnnotations {\n  $id: \"/schemas/unknown\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L44"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Void",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Void extends JsonSchemaAnnotations {\n  $id: \"/schemas/void\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L52"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7object",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7object extends JsonSchemaAnnotations {\n  $id: \"/schemas/object\"\n  anyOf: [\n    { type: \"object\" },\n    { type: \"array\" }\n  ]\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L60"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7empty",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7empty extends JsonSchemaAnnotations {\n  $id: \"/schemas/{}\"\n  anyOf: [\n    { type: \"object\" },\n    { type: \"array\" }\n  ]\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L72"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Ref",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Ref extends JsonSchemaAnnotations {\n  $ref: string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L84"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Null",
    "deprecated": false,
    "examples": [],
    "since": "3.11.7",
    "category": "model",
    "signature": "export interface JsonSchema7Null extends JsonSchemaAnnotations {\n  type: \"null\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L92"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7String",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7String extends JsonSchemaAnnotations {\n  type: \"string\"\n  minLength?: number\n  maxLength?: number\n  pattern?: string\n  format?: string\n  contentMediaType?: string\n  allOf?: Array<{\n    minLength?: number\n    maxLength?: number\n    pattern?: string\n  }>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L100"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Numeric",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Numeric extends JsonSchemaAnnotations {\n  minimum?: number\n  exclusiveMinimum?: number\n  maximum?: number\n  exclusiveMaximum?: number\n  multipleOf?: number\n  allOf?: Array<{\n    minimum?: number\n    exclusiveMinimum?: number\n    maximum?: number\n    exclusiveMaximum?: number\n    multipleOf?: number\n  }>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L118"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Number",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Number extends JsonSchema7Numeric {\n  type: \"number\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L137"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Integer",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Integer extends JsonSchema7Numeric {\n  type: \"integer\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L145"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Boolean",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Boolean extends JsonSchemaAnnotations {\n  type: \"boolean\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L153"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Array",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Array extends JsonSchemaAnnotations {\n  type: \"array\"\n  items?: JsonSchema7 | Array<JsonSchema7>\n  minItems?: number\n  maxItems?: number\n  additionalItems?: JsonSchema7 | boolean\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L161"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Enum",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Enum extends JsonSchemaAnnotations {\n  type?: \"string\" | \"number\" | \"boolean\"\n  enum: Array<string | number | boolean>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L173"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Enums",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Enums extends JsonSchemaAnnotations {\n  $comment: \"/schemas/enums\"\n  anyOf: Array<{\n    type: \"string\" | \"number\"\n    title: string\n    enum: [string | number]\n  }>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L182"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7AnyOf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7AnyOf extends JsonSchemaAnnotations {\n  anyOf: Array<JsonSchema7>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L195"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Object",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Object extends JsonSchemaAnnotations {\n  type: \"object\"\n  required: Array<string>\n  properties: Record<string, JsonSchema7>\n  additionalProperties?: boolean | JsonSchema7\n  patternProperties?: Record<string, JsonSchema7>\n  propertyNames?: JsonSchema7\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L203"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "type JsonSchema7 = | JsonSchema7Never\n  | JsonSchema7Any\n  | JsonSchema7Unknown\n  | JsonSchema7Void\n  | JsonSchema7object\n  | JsonSchema7empty\n  | JsonSchema7Ref\n  | JsonSchema7Null\n  | JsonSchema7String\n  | JsonSchema7Number\n  | JsonSchema7Integer\n  | JsonSchema7Boolean\n  | JsonSchema7Array\n  | JsonSchema7Enum\n  | JsonSchema7Enums\n  | JsonSchema7AnyOf\n  | JsonSchema7Object",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L216"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "JSONSchema.ts",
      "path": "src/JSONSchema.ts"
    },
    "project": "effect",
    "name": "JsonSchema7Root",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "type JsonSchema7Root = JsonSchema7 & {\n  $schema?: string\n  $defs?: Record<string, JsonSchema7>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/JSONSchema.ts#L239"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "KeyedPool.ts",
      "path": "src/KeyedPool.ts"
    },
    "project": "effect",
    "name": "KeyedPoolTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const KeyedPoolTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L15"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "KeyedPool.ts",
      "path": "src/KeyedPool.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Makes a new pool of the specified fixed size. The pool is returned in a\n`Scope`, which governs the lifetime of the pool. When the pool is shutdown\nbecause the `Scope` is closed, the individual items allocated by the pool\nwill be released in some unspecified order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly size: number; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L73"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "KeyedPool.ts",
      "path": "src/KeyedPool.ts"
    },
    "project": "effect",
    "name": "makeWith",
    "description": "Makes a new pool of the specified fixed size. The pool is returned in a\n`Scope`, which governs the lifetime of the pool. When the pool is shutdown\nbecause the `Scope` is closed, the individual items allocated by the pool\nwill be released in some unspecified order.\n\nThe size of the underlying pools can be configured per key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeWith: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly size: (key: K) => number; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L91"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "KeyedPool.ts",
      "path": "src/KeyedPool.ts"
    },
    "project": "effect",
    "name": "makeWithTTL",
    "description": "Makes a new pool with the specified minimum and maximum sizes and time to\nlive before a pool whose excess items are not being used will be shrunk\ndown to the minimum size. The pool is returned in a `Scope`, which governs\nthe lifetime of the pool. When the pool is shutdown because the `Scope` is\nused, the individual items allocated by the pool will be released in some\nunspecified order.\n\nThe size of the underlying pools can be configured per key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeWithTTL: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly min: (key: K) => number; readonly max: (key: K) => number; readonly timeToLive: Duration.DurationInput; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L111"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "KeyedPool.ts",
      "path": "src/KeyedPool.ts"
    },
    "project": "effect",
    "name": "makeWithTTLBy",
    "description": "Makes a new pool with the specified minimum and maximum sizes and time to\nlive before a pool whose excess items are not being used will be shrunk\ndown to the minimum size. The pool is returned in a `Scope`, which governs\nthe lifetime of the pool. When the pool is shutdown because the `Scope` is\nused, the individual items allocated by the pool will be released in some\nunspecified order.\n\nThe size of the underlying pools can be configured per key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeWithTTLBy: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly min: (key: K) => number; readonly max: (key: K) => number; readonly timeToLive: (key: K) => Duration.DurationInput; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L133"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "KeyedPool.ts",
      "path": "src/KeyedPool.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves an item from the pool belonging to the given key in a scoped\neffect. Note that if acquisition fails, then the returned effect will fail\nfor that same reason. Retrying a failed acquisition attempt will repeat the\nacquisition attempt.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const get: { <K>(key: K): <A, E>(self: KeyedPool<K, A, E>) => Effect.Effect<A, E, Scope.Scope>; <K, A, E>(self: KeyedPool<K, A, E>, key: K): Effect.Effect<A, E, Scope.Scope>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L151"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "KeyedPool.ts",
      "path": "src/KeyedPool.ts"
    },
    "project": "effect",
    "name": "invalidate",
    "description": "Invalidates the specified item. This will cause the pool to eventually\nreallocate the item, although this reallocation may occur lazily rather\nthan eagerly.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const invalidate: { <A>(item: A): <K, E>(self: KeyedPool<K, A, E>) => Effect.Effect<void>; <K, A, E>(self: KeyedPool<K, A, E>, item: A): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L164"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "KeyedPool.ts",
      "path": "src/KeyedPool.ts"
    },
    "project": "effect",
    "name": "KeyedPool",
    "description": "A `KeyedPool<K, A, E>` is a pool of `Pool`s of items of type `A`. Each pool\nin the `KeyedPool` is associated with a key of type `K`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface KeyedPool<in K, in out A, out E = never> extends KeyedPool.Variance<K, A, E>, Pipeable {\n  /**\n   * Retrieves an item from the pool belonging to the given key in a scoped\n   * effect. Note that if acquisition fails, then the returned effect will fail\n   * for that same reason. Retrying a failed acquisition attempt will repeat the\n   * acquisition attempt.\n   */\n  get(key: K): Effect.Effect<A, E, Scope.Scope>\n\n  /**\n   * Invalidates the specified item. This will cause the pool to eventually\n   * reallocate the item, although this reallocation may occur lazily rather\n   * than eagerly.\n   */\n  invalidate(item: A): Effect.Effect<void>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L30"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "KeyedPool.ts",
      "path": "src/KeyedPool.ts"
    },
    "project": "effect",
    "name": "KeyedPoolTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type KeyedPoolTypeId = typeof KeyedPoolTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L21"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "KeyedPool.ts",
      "path": "src/KeyedPool.ts"
    },
    "project": "effect",
    "name": "KeyedPool.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in K, in out A, out E> {\n    readonly [KeyedPoolTypeId]: {\n      readonly _K: Types.Contravariant<K>\n      readonly _A: Types.Invariant<A>\n      readonly _E: Types.Covariant<E>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/KeyedPool.ts#L55"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "LayerTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const LayerTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L50"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "MemoMapTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const MemoMapTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L114"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "CurrentMemoMap",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "models",
    "signature": "declare const CurrentMemoMap: Context.Reference<CurrentMemoMap, MemoMap>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L148"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "isLayer",
    "description": "Returns `true` if the specified value is a `Layer`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isLayer: (u: unknown) => u is Layer<unknown, unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L156"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "isFresh",
    "description": "Returns `true` if the specified `Layer` is a fresh version that will not be\nshared, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isFresh: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L165"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "annotateLogs",
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "tracing",
    "signature": "declare const annotateLogs: { (key: string, value: unknown): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; (values: Record<string, unknown>): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R>(self: Layer<A, E, R>, key: string, value: unknown): Layer<A, E, R>; <A, E, R>(self: Layer<A, E, R>, values: Record<string, unknown>): Layer<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L171"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "annotateSpans",
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "tracing",
    "signature": "declare const annotateSpans: { (key: string, value: unknown): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; (values: Record<string, unknown>): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R>(self: Layer<A, E, R>, key: string, value: unknown): Layer<A, E, R>; <A, E, R>(self: Layer<A, E, R>, values: Record<string, unknown>): Layer<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L182"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "build",
    "description": "Builds a layer into a scoped value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const build: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, Scope.Scope | RIn>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L195"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "buildWithScope",
    "description": "Builds a layer into an `Effect` value. Any resources associated with this\nlayer will be released when the specified scope is closed unless their scope\nhas been extended. This allows building layers where the lifetime of some of\nthe services output by the layer exceed the lifetime of the effect the\nlayer is provided to.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const buildWithScope: { (scope: Scope.Scope): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, scope: Scope.Scope): Effect.Effect<Context.Context<ROut>, E, RIn>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L209"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "catchAll",
    "description": "Recovers from all errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const catchAll: { <E, RIn2, E2, ROut2>(onError: (error: E) => Layer<ROut2, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut & ROut2, E2, RIn2 | RIn>; <RIn, E, ROut, RIn2, E2, ROut2>(self: Layer<ROut, E, RIn>, onError: (error: E) => Layer<ROut2, E2, RIn2>): Layer<ROut & ROut2, E2, RIn | RIn2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L220"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "catchAllCause",
    "description": "Recovers from all errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const catchAllCause: { <E, RIn2, E2, ROut2>(onError: (cause: Cause.Cause<E>) => Layer<ROut2, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut & ROut2, E2, RIn2 | RIn>; <RIn, E, ROut, RIn2, E2, ROut22>(self: Layer<ROut, E, RIn>, onError: (cause: Cause.Cause<E>) => Layer<ROut22, E2, RIn2>): Layer<ROut & ROut22, E2, RIn | RIn2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L236"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "context",
    "description": "Constructs a `Layer` that passes along the specified context as an\noutput.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const context: <R>() => Layer<R, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L253"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "die",
    "description": "Constructs a layer that dies with the specified defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const die: (defect: unknown) => Layer<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L261"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "dieSync",
    "description": "Constructs a layer that dies with the specified defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dieSync: (evaluate: LazyArg<unknown>) => Layer<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L269"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "discard",
    "description": "Replaces the layer's output with `void` and includes the layer only for its\nside-effects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const discard: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<never, E, RIn>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L278"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "effect",
    "description": "Constructs a layer from the specified effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const effect: { <I, S>(tag: Context.Tag<I, S>): <E, R>(effect: Effect.Effect<Types.NoInfer<S>, E, R>) => Layer<I, E, R>; <I, S, E, R>(tag: Context.Tag<I, S>, effect: Effect.Effect<Types.NoInfer<S>, E, R>): Layer<I, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L286"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "effectDiscard",
    "description": "Constructs a layer from the specified effect, discarding its output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const effectDiscard: <X, E, R>(effect: Effect.Effect<X, E, R>) => Layer<never, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L297"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "effectContext",
    "description": "Constructs a layer from the specified effect, which must return one or more\nservices.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const effectContext: <A, E, R>(effect: Effect.Effect<Context.Context<A>, E, R>) => Layer<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L306"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "A Layer that constructs an empty Context.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L315"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "extendScope",
    "description": "Extends the scope of this layer, returning a new layer that when provided\nto an effect will not immediately release its associated resources when\nthat effect completes execution but instead when the scope the resulting\neffect depends on is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const extendScope: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E, Scope.Scope | RIn>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L326"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "fail",
    "description": "Constructs a layer that fails with the specified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fail: <E>(error: E) => Layer<unknown, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L335"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "failSync",
    "description": "Constructs a layer that fails with the specified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failSync: <E>(evaluate: LazyArg<E>) => Layer<unknown, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L343"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "failCause",
    "description": "Constructs a layer that fails with the specified cause.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failCause: <E>(cause: Cause.Cause<E>) => Layer<unknown, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L351"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "failCauseSync",
    "description": "Constructs a layer that fails with the specified cause.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Layer<unknown, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L359"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Constructs a layer dynamically based on the output of this layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMap: { <A, A2, E2, R2>(f: (context: Context.Context<A>) => Layer<A2, E2, R2>): <E, R>(self: Layer<A, E, R>) => Layer<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Layer<A, E, R>, f: (context: Context.Context<A>) => Layer<A2, E2, R2>): Layer<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L367"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens layers nested in the context of an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatten: { <I, A, E2, R2>(tag: Context.Tag<I, Layer<A, E2, R2>>): <E, R>(self: Layer<I, E, R>) => Layer<A, E2 | E, R2 | R>; <I, E, R, A, E2, R2>(self: Layer<I, E, R>, tag: Context.Tag<I, Layer<A, E2, R2>>): Layer<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L383"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "fresh",
    "description": "Creates a fresh version of this layer that will not be shared.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const fresh: <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L394"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "launch",
    "description": "Builds this layer and uses it until it is interrupted. This is useful when\nyour entire application is a layer, such as an HTTP server.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const launch: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<never, E, RIn>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L419"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Returns a new layer whose output is mapped by the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <A, B>(f: (context: Context.Context<A>) => Context.Context<B>): <E, R>(self: Layer<A, E, R>) => Layer<B, E, R>; <A, E, R, B>(self: Layer<A, E, R>, f: (context: Context.Context<A>) => Context.Context<B>): Layer<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L427"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "mapError",
    "description": "Returns a layer with its error channel mapped using the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: Layer<A, E, R>) => Layer<A, E2, R>; <A, E, R, E2>(self: Layer<A, E, R>, f: (error: E) => E2): Layer<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L438"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Feeds the error or output services of this layer into the input of either\nthe specified `failure` or `success` layers, resulting in a new layer with\nthe inputs of this layer, and the error or outputs of the specified layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const match: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (error: E) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; }): <R>(self: Layer<A, E, R>) => Layer<A2 & A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Layer<A, E, R>, options: { readonly onFailure: (error: E) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; }): Layer<A2 & A3, E2 | E3, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L451"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "matchCause",
    "description": "Feeds the error or output services of this layer into the input of either\nthe specified `failure` or `success` layers, resulting in a new layer with\nthe inputs of this layer, and the error or outputs of the specified layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const matchCause: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; }): <R>(self: Layer<A, E, R>) => Layer<A2 & A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Layer<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; }): Layer<A2 & A3, E2 | E3, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L475"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "memoize",
    "description": "Returns a scoped effect that, if evaluated, will return the lazily computed\nresult of this layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const memoize: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Layer<ROut, E, RIn>, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L498"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "merge",
    "description": "Merges this layer with the specified layer concurrently, producing a new layer with combined input and output types.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const merge: { <RIn2, E2, ROut2>(that: Layer<ROut2, E2, RIn2>): <RIn, E1, ROut>(self: Layer<ROut, E1, RIn>) => Layer<ROut2 | ROut, E2 | E1, RIn2 | RIn>; <RIn, E1, ROut, RIn2, E2, ROut2>(self: Layer<ROut, E1, RIn>, that: Layer<ROut2, E2, RIn2>): Layer<ROut | ROut2, E1 | E2, RIn | RIn2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L508"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "mergeAll",
    "description": "Combines all the provided layers concurrently, creating a new layer with merged input, error, and output types.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const mergeAll: <Layers extends [Layer<never, any, any>, ...Array<Layer<never, any, any>>]>(...layers: Layers) => Layer<{ [k in keyof Layers]: Layer.Success<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L524"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "orDie",
    "description": "Translates effect failure into death of the fiber, making all failures\nunchecked and not a part of the type of the layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orDie: <A, E, R>(self: Layer<A, E, R>) => Layer<A, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L539"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "orElse",
    "description": "Executes this layer and returns its output, if it succeeds, but otherwise\nexecutes the specified layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElse: { <A2, E2, R2>(that: LazyArg<Layer<A2, E2, R2>>): <A, E, R>(self: Layer<A, E, R>) => Layer<A & A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Layer<A, E, R>, that: LazyArg<Layer<A2, E2, R2>>): Layer<A & A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L548"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "passthrough",
    "description": "Returns a new layer that produces the outputs of this layer but also\npasses through the inputs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const passthrough: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<RIn | ROut, E, RIn>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L560"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "project",
    "description": "Projects out part of one of the services output by this layer using the\nspecified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const project: { <I1, S1, I2, S2>(tagA: Context.Tag<I1, S1>, tagB: Context.Tag<I2, S2>, f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>): <RIn, E>(self: Layer<I1, E, RIn>) => Layer<I2, E, RIn>; <RIn, E, I1, S1, I2, S2>(self: Layer<I1, E, RIn>, tagA: Context.Tag<I1, S1>, tagB: Context.Tag<I2, S2>, f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>): Layer<I2, E, RIn>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L569"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "locallyEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const locallyEffect: { <RIn, E, ROut, RIn2, E2, ROut2>(f: (_: Effect.Effect<RIn, E, Context.Context<ROut>>) => Effect.Effect<RIn2, E2, Context.Context<ROut2>>): (self: Layer<ROut, E, RIn>) => Layer<ROut2, E2, RIn2>; <RIn, E, ROut, RIn2, E2, ROut2>(self: Layer<ROut, E, RIn>, f: (_: Effect.Effect<RIn, E, Context.Context<ROut>>) => Effect.Effect<RIn2, E2, Context.Context<ROut2>>): Layer<ROut2, E2, RIn2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L587"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "locally",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const locally: { <X>(ref: FiberRef<X>, value: X): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R, X>(self: Layer<A, E, R>, ref: FiberRef<X>, value: X): Layer<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L601"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "locallyWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const locallyWith: { <X>(ref: FiberRef<X>, value: (_: X) => X): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R, X>(self: Layer<A, E, R>, ref: FiberRef<X>, value: (_: X) => X): Layer<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L617"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "locallyScoped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const locallyScoped: <A>(self: FiberRef<A>, value: A) => Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L626"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "fiberRefLocallyScopedWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const fiberRefLocallyScopedWith: <A>(self: FiberRef<A>, value: (_: A) => A) => Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L632"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "retry",
    "description": "Retries constructing this layer according to the specified schedule.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "retrying",
    "signature": "declare const retry: { <X, E, RIn2>(schedule: Schedule.Schedule<X, NoInfer<E>, RIn2>): <ROut, RIn>(self: Layer<ROut, E, RIn>) => Layer<ROut, E, RIn2 | RIn>; <ROut, E, RIn, X, RIn2>(self: Layer<ROut, E, RIn>, schedule: Schedule.Schedule<X, E, RIn2>): Layer<ROut, E, RIn | RIn2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L641"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "scope",
    "description": "A layer that constructs a scope and closes it when the workflow the layer\nis provided to completes execution, whether by success, failure, or\ninterruption. This can be used to close a scope when providing a layer to a\nworkflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const scope: Layer<Scope.Scope, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L660"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "scoped",
    "description": "Constructs a layer from the specified scoped effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const scoped: { <I, S>(tag: Context.Tag<I, S>): <E, R>(effect: Effect.Effect<Types.NoInfer<S>, E, R>) => Layer<I, E, Exclude<R, Scope.Scope>>; <I, S, E, R>(tag: Context.Tag<I, S>, effect: Effect.Effect<Types.NoInfer<S>, E, R>): Layer<I, E, Exclude<R, Scope.Scope>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L668"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "scopedDiscard",
    "description": "Constructs a layer from the specified scoped effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const scopedDiscard: <X, E, R>(effect: Effect.Effect<X, E, R>) => Layer<never, E, Exclude<R, Scope.Scope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L684"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "scopedContext",
    "description": "Constructs a layer from the specified scoped effect, which must return one\nor more services.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const scopedContext: <A, E, R>(effect: Effect.Effect<Context.Context<A>, E, R>) => Layer<A, E, Exclude<R, Scope.Scope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L694"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "service",
    "description": "Constructs a layer that accesses and returns the specified service from the\ncontext.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const service: <I, S>(tag: Context.Tag<I, S>) => Layer<I, never, I>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L705"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "succeed",
    "description": "Constructs a layer from the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const succeed: { <I, S>(tag: Context.Tag<I, S>): (resource: Types.NoInfer<S>) => Layer<I>; <I, S>(tag: Context.Tag<I, S>, resource: Types.NoInfer<S>): Layer<I>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L713"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "succeedContext",
    "description": "Constructs a layer from the specified value, which must return one or more\nservices.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const succeedContext: <A>(context: Context.Context<A>) => Layer<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L725"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "suspend",
    "description": "Lazily constructs a layer. This is useful to avoid infinite recursion when\ncreating layers that refer to themselves.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const suspend: <RIn, E, ROut>(evaluate: LazyArg<Layer<ROut, E, RIn>>) => Layer<ROut, E, RIn>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L734"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "sync",
    "description": "Lazily constructs a layer from the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sync: { <I, S>(tag: Context.Tag<I, S>): (evaluate: LazyArg<Types.NoInfer<S>>) => Layer<I>; <I, S>(tag: Context.Tag<I, S>, evaluate: LazyArg<Types.NoInfer<S>>): Layer<I>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L742"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "syncContext",
    "description": "Lazily constructs a layer from the specified value, which must return one or more\nservices.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const syncContext: <A>(evaluate: LazyArg<Context.Context<A>>) => Layer<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L754"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "tap",
    "description": "Performs the specified effect if this layer succeeds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const tap: { <ROut, XR extends ROut, RIn2, E2, X>(f: (context: Context.Context<XR>) => Effect.Effect<X, E2, RIn2>): <RIn, E>(self: Layer<ROut, E, RIn>) => Layer<ROut, E2 | E, RIn2 | RIn>; <RIn, E, ROut, XR extends ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (context: Context.Context<XR>) => Effect.Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L762"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "tapError",
    "description": "Performs the specified effect if this layer fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const tapError: { <E, XE extends E, RIn2, E2, X>(f: (e: XE) => Effect.Effect<X, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E | E2, RIn2 | RIn>; <RIn, E, XE extends E, ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (e: XE) => Effect.Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L778"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "tapErrorCause",
    "description": "Performs the specified effect if this layer fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const tapErrorCause: { <E, XE extends E, RIn2, E2, X>(f: (cause: Cause.Cause<XE>) => Effect.Effect<X, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E | E2, RIn2 | RIn>; <RIn, E, XE extends E, ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (cause: Cause.Cause<XE>) => Effect.Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L794"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "toRuntime",
    "description": "Converts a layer that requires no services into a scoped runtime, which can\nbe used to execute effects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const toRuntime: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L811"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "toRuntimeWithMemoMap",
    "description": "Converts a layer that requires no services into a scoped runtime, which can\nbe used to execute effects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const toRuntimeWithMemoMap: { (memoMap: MemoMap): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, memoMap: MemoMap): Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L822"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "provide",
    "description": "Feeds the output services of this builder into the input of the specified\nbuilder, resulting in a new builder with the inputs of this builder as\nwell as any leftover inputs, and the outputs of the specified builder.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const provide: { <RIn, E, ROut>(that: Layer<ROut, E, RIn>): <RIn2, E2, ROut2>(self: Layer<ROut2, E2, RIn2>) => Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <const Layers extends [Layer.Any, ...Array<Layer.Any>]>(that: Layers): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; <RIn2, E2, ROut2, RIn, E, ROut>(self: Layer<ROut2, E2, RIn2>, that: Layer<ROut, E, RIn>): Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <A, E, R, const Layers extends [Layer.Any, ...Array<Layer.Any>]>(self: Layer<A, E, R>, that: Layers): Layer<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L840"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "provideMerge",
    "description": "Feeds the output services of this layer into the input of the specified\nlayer, resulting in a new layer with the inputs of this layer, and the\noutputs of both layers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const provideMerge: { <RIn, E, ROut>(self: Layer<ROut, E, RIn>): <RIn2, E2, ROut2>(that: Layer<ROut2, E2, RIn2>) => Layer<ROut | ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <RIn2, E2, ROut2, RIn, E, ROut>(that: Layer<ROut2, E2, RIn2>, self: Layer<ROut, E, RIn>): Layer<ROut2 | ROut, E2 | E, RIn | Exclude<RIn2, ROut>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L877"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Combines this layer with the specified layer concurrently, creating a new layer with merged input types and\ncombined output types using the provided function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWith: { <B, E2, R2, A, C>(that: Layer<B, E2, R2>, f: (a: Context.Context<A>, b: Context.Context<B>) => Context.Context<C>): <E, R>(self: Layer<A, E, R>) => Layer<C, E2 | E, R2 | R>; <A, E, R, B, E2, R2, C>(self: Layer<A, E, R>, that: Layer<B, E2, R2>, f: (a: Context.Context<A>, b: Context.Context<B>) => Context.Context<C>): Layer<C, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L894"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "unwrapEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const unwrapEffect: <A, E1, R1, E, R>(self: Effect.Effect<Layer<A, E1, R1>, E, R>) => Layer<A, E | E1, R | R1>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L910"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "unwrapScoped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const unwrapScoped: <A, E1, R1, E, R>(self: Effect.Effect<Layer<A, E1, R1>, E, R>) => Layer<A, E | E1, R1 | Exclude<R, Scope.Scope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L917"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "setConfigProvider",
    "description": "Sets the current `ConfigProvider`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "config",
    "signature": "declare const setConfigProvider: (configProvider: ConfigProvider) => Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L938"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "parentSpan",
    "description": "Adds the provided span to the span stack.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "declare const parentSpan: (span: Tracer.AnySpan) => Layer<Tracer.ParentSpan>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L946"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "setRequestCache",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "requests & batching",
    "signature": "declare const setRequestCache: { <E, R>(cache: Effect.Effect<Request.Cache, E, R>): Layer<never, E, Exclude<R, Scope.Scope>>; (cache: Request.Cache): Layer<never>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L974"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "span",
    "description": "Create and add a span to the current span stack.\n\nThe span is ended when the Layer is released.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "declare const span: (name: string, options?: Tracer.SpanOptions & { readonly onEnd?: ((span: Tracer.Span, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>) | undefined; }) => Layer<Tracer.ParentSpan>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1007"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "setTracer",
    "description": "Create a Layer that sets the current Tracer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "declare const setTracer: (tracer: Tracer.Tracer) => Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1022"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "withSpan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "declare const withSpan: { (name: string, options?: Tracer.SpanOptions & { readonly onEnd?: ((span: Tracer.Span, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>) | undefined; }): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Layer<A, E, R>, name: string, options?: Tracer.SpanOptions & { readonly onEnd?: ((span: Tracer.Span, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>) | undefined; }): Layer<A, E, Exclude<R, Tracer.ParentSpan>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1057"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "withParentSpan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "declare const withParentSpan: { (span: Tracer.AnySpan): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Layer<A, E, R>, span: Tracer.AnySpan): Layer<A, E, Exclude<R, Tracer.ParentSpan>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1081"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "makeMemoMap",
    "description": "Constructs a `MemoMap` that can be used to build additional layers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "memo map",
    "signature": "declare const makeMemoMap: Effect.Effect<MemoMap, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1096"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "buildWithMemoMap",
    "description": "Builds a layer into an `Effect` value, using the specified `MemoMap` to memoize\nthe layer construction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "memo map",
    "signature": "declare const buildWithMemoMap: { (memoMap: MemoMap, scope: Scope.Scope): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, memoMap: MemoMap, scope: Scope.Scope): Effect.Effect<Context.Context<ROut>, E, RIn>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1105"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "updateService",
    "description": "Updates a service in the context with a new implementation.\n\n**Details**\n\nThis function modifies the existing implementation of a service in the\ncontext. It retrieves the current service, applies the provided\ntransformation function `f`, and replaces the old service with the\ntransformed one.\n\n**When to Use**\n\nThis is useful for adapting or extending a service's behavior during the\ncreation of a layer.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "utils",
    "signature": "declare const updateService: (<I, A>(tag: Context.Tag<I, A>, f: (a: A) => A) => <A1, E1, R1>(layer: Layer<A1, E1, R1>) => Layer<A1, E1, I | R1>) & (<A1, E1, R1, I, A>(layer: Layer<A1, E1, R1>, tag: Context.Tag<I, A>, f: (a: A) => A) => Layer<A1, E1, I | R1>)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1135"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "setClock",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "clock",
    "signature": "declare const setClock: <A extends Clock.Clock>(clock: A) => Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L925"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "setRequestBatching",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "requests & batching",
    "signature": "declare const setRequestBatching: (requestBatching: boolean) => Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L952"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "setRequestCaching",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "requests & batching",
    "signature": "declare const setRequestCaching: (requestCaching: boolean) => Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L963"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "setScheduler",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "scheduler",
    "signature": "declare const setScheduler: (scheduler: Scheduler.Scheduler) => Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L992"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "setTracerEnabled",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "declare const setTracerEnabled: (enabled: boolean) => Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1028"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "setTracerTiming",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "declare const setTracerTiming: (enabled: boolean) => Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1037"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "setUnhandledErrorLogLevel",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "logging",
    "signature": "declare const setUnhandledErrorLogLevel: (level: Option.Option<LogLevel>) => Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L1046"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "Layer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Layer<in ROut, out E = never, out RIn = never> extends Layer.Variance<ROut, E, RIn>, Pipeable {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L62"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "MemoMap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MemoMap {\n  readonly [MemoMapTypeId]: MemoMapTypeId\n\n  /** @internal */\n  readonly getOrElseMemoize: <RIn, E, ROut>(\n    layer: Layer<ROut, E, RIn>,\n    scope: Scope.Scope\n  ) => Effect.Effect<Context.Context<ROut>, E, RIn>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L126"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "CurrentMemoMap",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "models",
    "signature": "export interface CurrentMemoMap {\n  readonly _: unique symbol\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L140"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "LayerTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type LayerTypeId = typeof LayerTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L56"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "MemoMapTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type MemoMapTypeId = typeof MemoMapTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L120"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "Layer.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in ROut, out E, out RIn> {\n    readonly [LayerTypeId]: {\n      readonly _ROut: Types.Contravariant<ROut>\n      readonly _E: Types.Covariant<E>\n      readonly _RIn: Types.Covariant<RIn>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L72"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "Layer.Any",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "type-level",
    "signature": "export interface Any {\n    readonly [LayerTypeId]: {\n      readonly _ROut: Types.Contravariant<never>\n      readonly _E: Types.Covariant<any>\n      readonly _RIn: Types.Covariant<any>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L83"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "Layer.Context",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type-level",
    "signature": "type Context<T> = [T] extends [Layer<infer _ROut, infer _E, infer _RIn>] ? _RIn\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L94"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "Layer.Error",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type-level",
    "signature": "type Error<T> = [T] extends [Layer<infer _ROut, infer _E, infer _RIn>] ? _E\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L100"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Layer.ts",
      "path": "src/Layer.ts"
    },
    "project": "effect",
    "name": "Layer.Success",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type-level",
    "signature": "type Success<T> = [T] extends [Layer<infer _ROut, infer _E, infer _RIn>] ? _ROut\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Layer.ts#L106"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LayerMap.ts",
      "path": "src/LayerMap.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.14.0",
    "category": "Symbols",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LayerMap.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LayerMap.ts",
      "path": "src/LayerMap.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "3.14.0",
    "category": "Constructors",
    "signature": "declare const make: <Accessor extends Context.Tag<any, any> | Effect.Effect<any, any, any>, K, L extends Layer.Layer<Exclude<Effect.Effect.Context<Accessor>, Scope.Scope>, any, any>>(tagOrAccessor: Accessor, lookup: (key: K) => L, options?: { readonly idleTimeToLive?: Duration.DurationInput | undefined; } | undefined) => Effect.Effect<LayerMap<K, Exclude<Effect.Effect.Context<Accessor>, Scope.Scope>, Effect.Effect.Success<Accessor>, Effect.Effect.Error<Accessor> | (L extends Layer.Layer<infer _A, infer _E, infer _R> ? _E : never)>, never, Scope.Scope | (L extends Layer.Layer<infer _A, infer _E, infer _R> ? _R : never)>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LayerMap.ts#L109"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "LayerMap.ts",
      "path": "src/LayerMap.ts"
    },
    "project": "effect",
    "name": "fromRecord",
    "deprecated": false,
    "examples": [],
    "since": "3.14.0",
    "category": "Constructors",
    "signature": "declare const fromRecord: <Accessor extends Context.Tag<any, any> | Effect.Effect<any, any, any>, const Layers extends Record<string, Layer.Layer<Exclude<Effect.Effect.Context<Accessor>, Scope.Scope>, any, any>>>(tagOrAccessor: Accessor, layers: Layers, options?: { readonly idleTimeToLive?: Duration.DurationInput | undefined; } | undefined) => Effect.Effect<LayerMap<keyof Layers, Exclude<Effect.Effect.Context<Accessor>, Scope.Scope>, Effect.Effect.Success<Accessor>, Effect.Effect.Error<Accessor> | (Layers[keyof Layers] extends Layer.Layer<infer _A, infer _E, infer _R> ? _E : never)>, never, Scope.Scope | (Layers[keyof Layers] extends Layer.Layer<infer _A, infer _E, infer _R> ? _R : never)>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LayerMap.ts#L175"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "LayerMap.ts",
      "path": "src/LayerMap.ts"
    },
    "project": "effect",
    "name": "Service",
    "deprecated": false,
    "examples": [],
    "since": "3.14.0",
    "category": "Service",
    "signature": "declare const Service: <Self>() => <const Id extends string, Accessor extends Context.Tag<any, any> | Effect.Effect<any, any, any>, Lookup extends { readonly lookup: (key: any) => Layer.Layer<Exclude<Effect.Effect.Context<Accessor>, Scope.Scope>, any, any>; } | { readonly layers: Record<string, Layer.Layer<Exclude<Effect.Effect.Context<Accessor>, Scope.Scope>, any, any>>; }, const Deps extends ReadonlyArray<Layer.Layer<any, any, any>> = []>(id: Id, options: Lookup & { readonly provides: Accessor; readonly dependencies?: Deps | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; }) => TagClass<Self, Id, Lookup extends { readonly lookup: (key: infer K) => any; } ? K : Lookup extends { readonly layers: infer Layers; } ? keyof Layers : never, Exclude<Effect.Effect.Context<Accessor>, Scope.Scope>, Effect.Effect.Success<Accessor>, Effect.Effect.Error<Accessor> | Service.Error<Lookup>, Service.Context<Lookup>, Deps[number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LayerMap.ts#L297"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LayerMap.ts",
      "path": "src/LayerMap.ts"
    },
    "project": "effect",
    "name": "LayerMap",
    "deprecated": false,
    "examples": [],
    "since": "3.14.0",
    "category": "Models",
    "signature": "export interface LayerMap<in K, in out I, out S, out E = never> {\n  readonly [TypeId]: TypeId\n\n  /**\n   * The internal RcMap that stores the resources.\n   */\n  readonly rcMap: RcMap.RcMap<K, readonly [Context.Context<I>, S], E>\n\n  /**\n   * Retrieves an instance of the resource associated with the key.\n   */\n  get(key: K): Effect.Effect<S, E, Scope.Scope>\n\n  /**\n   * Provides an instance of the resource associated with the key\n   * to the given effect.\n   */\n  provide(key: K): <A, EX, R>(effect: Effect.Effect<A, EX, R>) => Effect.Effect<A, EX | E, Exclude<R, I>>\n\n  /**\n   * Invalidates the resource associated with the key.\n   */\n  invalidate(key: K): Effect.Effect<void>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LayerMap.ts#L31"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LayerMap.ts",
      "path": "src/LayerMap.ts"
    },
    "project": "effect",
    "name": "TagClass",
    "deprecated": false,
    "examples": [],
    "since": "3.14.0",
    "category": "Service",
    "signature": "export interface TagClass<\n  in out Self,\n  in out Id extends string,\n  in out K,\n  in out I,\n  in out S,\n  in out E,\n  in out R,\n  in out Deps extends Layer.Layer<any, any, any>\n> extends Context.TagClass<Self, Id, LayerMap<K, I, S, E>> {\n  /**\n   * A default layer for the `LayerMap` service.\n   */\n  readonly Default: Layer.Layer<\n    Self,\n    (Deps extends Layer.Layer<infer _A, infer _E, infer _R> ? _E : never),\n    | Exclude<R, (Deps extends Layer.Layer<infer _A, infer _E, infer _R> ? _A : never)>\n    | (Deps extends Layer.Layer<infer _A, infer _E, infer _R> ? _R : never)\n  >\n\n  /**\n   * A default layer for the `LayerMap` service without the dependencies provided.\n   */\n  readonly DefaultWithoutDependencies: Layer.Layer<Self, never, R>\n\n  /**\n   * Retrieves an instance of the resource associated with the key.\n   */\n  readonly get: (key: K) => Effect.Effect<S, E, Scope.Scope | Self>\n\n  /**\n   * Provides an instance of the resource associated with the key to the given\n   * effect.\n   */\n  readonly provide: (\n    key: K\n  ) => <A, EX, R>(effect: Effect.Effect<A, EX, R>) => Effect.Effect<A, EX | E, Exclude<R, I> | Self>\n\n  /**\n   * Invalidates the resource associated with the key.\n   */\n  readonly invalidate: (key: K) => Effect.Effect<void, never, Self>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LayerMap.ts#L200"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "LayerMap.ts",
      "path": "src/LayerMap.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.14.0",
    "category": "Symbols",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LayerMap.ts#L24"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "LayerMap.ts",
      "path": "src/LayerMap.ts"
    },
    "project": "effect",
    "name": "Service.Key",
    "deprecated": false,
    "examples": [],
    "since": "3.14.0",
    "category": "Service",
    "signature": "type Key<Options> = Options extends { readonly lookup: (key: infer K) => any } ? K\n    : Options extends { readonly layers: infer Layers } ? keyof Layers\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LayerMap.ts#L370"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "LayerMap.ts",
      "path": "src/LayerMap.ts"
    },
    "project": "effect",
    "name": "Service.Layers",
    "deprecated": false,
    "examples": [],
    "since": "3.14.0",
    "category": "Service",
    "signature": "type Layers<Options> = Options extends { readonly lookup: (key: infer _K) => infer Layers } ? Layers\n    : Options extends { readonly layers: infer Layers } ? Layers[keyof Layers]\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LayerMap.ts#L379"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "LayerMap.ts",
      "path": "src/LayerMap.ts"
    },
    "project": "effect",
    "name": "Service.Error",
    "deprecated": false,
    "examples": [],
    "since": "3.14.0",
    "category": "Service",
    "signature": "type Error<Options> = Layers<Options> extends Layer.Layer<infer _A, infer _E, infer _R> ? _E : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LayerMap.ts#L388"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "LayerMap.ts",
      "path": "src/LayerMap.ts"
    },
    "project": "effect",
    "name": "Service.Context",
    "deprecated": false,
    "examples": [],
    "since": "3.14.0",
    "category": "Service",
    "signature": "type Context<Options> = Layers<Options> extends Layer.Layer<infer _A, infer _E, infer _R> ? _R : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LayerMap.ts#L395"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L55"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Constructs a new empty `List<A>`.\n\nAlias of {@link nil}.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <A = never>() => List<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L269"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "append",
    "description": "Appends the specified element to the end of the `List`, creating a new `Cons`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const append: { <B>(element: B): <A>(self: List<A>) => Cons<A | B>; <A, B>(self: List<A>, element: B): Cons<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L318"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "appendAll",
    "description": "Concatenates two lists, combining their elements.\nIf either list is non-empty, the result is also a non-empty list.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { List } from \"effect\"\n\nassert.deepStrictEqual(\n  List.make(1, 2).pipe(List.appendAll(List.make(\"a\", \"b\")), List.toArray),\n  [1, 2, \"a\", \"b\"]\n)\n```"
    ],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const appendAll: { <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>; <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>; <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>; <A, B>(self: List<A>, that: List<B>): List<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L341"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "prepend",
    "description": "Prepends the specified element to the beginning of the list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const prepend: { <B>(element: B): <A>(self: List<A>) => Cons<A | B>; <A, B>(self: List<A>, element: B): Cons<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L354"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "prependAll",
    "description": "Prepends the specified prefix list to the beginning of the specified list.\nIf either list is non-empty, the result is also a non-empty list.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { List } from \"effect\"\n\nassert.deepStrictEqual(\n  List.make(1, 2).pipe(List.prependAll(List.make(\"a\", \"b\")), List.toArray),\n  [\"a\", \"b\", 1, 2]\n)\n```"
    ],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const prependAll: { <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>; <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>; <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>; <A, B>(self: List<A>, that: List<B>): List<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L377"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "prependAllReversed",
    "description": "Prepends the specified prefix list (in reverse order) to the beginning of the\nspecified list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const prependAllReversed: { <B>(prefix: List<B>): <A>(self: List<A>) => List<A | B>; <A, B>(self: List<A>, prefix: List<B>): List<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L408"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "drop",
    "description": "Drops the first `n` elements from the specified list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const drop: { (n: number): <A>(self: List<A>) => List<A>; <A>(self: List<A>, n: number): List<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L427"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "every",
    "description": "Check if a predicate holds true for every `List` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const every: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => self is List<B>; <A>(predicate: Predicate<A>): (self: List<A>) => boolean; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): self is List<B>; <A>(self: List<A>, predicate: Predicate<A>): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L452"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "some",
    "description": "Check if a predicate holds true for some `List` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const some: { <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => self is Cons<A>; <A>(self: List<A>, predicate: Predicate<A>): self is Cons<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L472"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters a list using the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => List<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => List<A>; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): List<B>; <A>(self: List<A>, predicate: Predicate<A>): List<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L492"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Filters and maps a list using the specified partial function. The resulting\nlist may be smaller than the input list due to the possibility of the partial\nfunction not being defined for some elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const filterMap: { <A, B>(f: (a: A) => Option.Option<B>): (self: List<A>) => List<B>; <A, B>(self: List<A>, f: (a: A) => Option.Option<B>): List<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L597"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirst: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => Option.Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => Option.Option<A>; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): Option.Option<B>; <A>(self: List<A>, predicate: Predicate<A>): Option.Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L626"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMap: { <S extends List<any>, T extends List<any>>(f: (a: List.Infer<S>, i: number) => T): (self: S) => List.AndNonEmpty<S, T, List.Infer<T>>; <A, B>(self: Cons<A>, f: (a: A, i: number) => Cons<B>): Cons<B>; <A, B>(self: List<A>, f: (a: A, i: number) => List<B>): List<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L648"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "Applies the specified function to each element of the `List`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const forEach: { <A, B>(f: (a: A) => B): (self: List<A>) => void; <A, B>(self: List<A>, f: (a: A) => B): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L684"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Applies the specified mapping function to each element of the list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <S extends List<any>, B>(f: (a: List.Infer<S>, i: number) => B): (self: S) => List.With<S, B>; <S extends List<any>, B>(self: S, f: (a: List.Infer<S>, i: number) => B): List.With<S, B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L749"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "partition",
    "description": "Partition a list into two lists, where the first list contains all elements\nthat did not satisfy the specified predicate, and the second list contains\nall elements that did satisfy the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const partition: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => [excluded: List<Exclude<A, B>>, satisfying: List<B>]; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => [excluded: List<A>, satisfying: List<A>]; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): [excluded: List<Exclude<A, B>>, satisfying: List<B>]; <A>(self: List<A>, predicate: Predicate<A>): [excluded: List<A>, satisfying: List<A>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L778"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "partitionMap",
    "description": "Partition a list into two lists, where the first list contains all elements\nfor which the specified function returned a `Left`, and the second list\ncontains all elements for which the specified function returned a `Right`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const partitionMap: { <A, B, C>(f: (a: A) => Either.Either<C, B>): (self: List<A>) => [left: List<B>, right: List<C>]; <A, B, C>(self: List<A>, f: (a: A) => Either.Either<C, B>): [left: List<B>, right: List<C>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L806"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "reduce",
    "description": "Folds over the elements of the list using the specified function, using the\nspecified initial value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduce: { <Z, A>(zero: Z, f: (b: Z, a: A) => Z): (self: List<A>) => Z; <A, Z>(self: List<A>, zero: Z, f: (b: Z, a: A) => Z): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L830"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "reduceRight",
    "description": "Folds over the elements of the list using the specified function, beginning\nwith the last element of the list, using the specified initial value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduceRight: { <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: List<A>) => Z; <Z, A>(self: List<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L850"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "splitAt",
    "description": "Splits the specified list into two lists at the specified index.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const splitAt: { (n: number): <A>(self: List<A>) => [beforeIndex: List<A>, fromIndex: List<A>]; <A>(self: List<A>, n: number): [beforeIndex: List<A>, fromIndex: List<A>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L885"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "take",
    "description": "Takes the specified number of elements from the beginning of the specified\nlist.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const take: { (n: number): <A>(self: List<A>) => List<A>; <A>(self: List<A>, n: number): List<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L905"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "toArray",
    "description": "Converts the specified `List` to an `Array`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const toArray: <A>(self: List<A>) => Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L89"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "getEquivalence",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "equivalence",
    "signature": "declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<List<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L95"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "isList",
    "description": "Returns `true` if the specified value is a `List`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isList: { <A>(u: Iterable<A>): u is List<A>; (u: unknown): u is List<unknown>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L208"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "isNil",
    "description": "Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isNil: <A>(self: List<A>) => self is Nil<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L219"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "isCons",
    "description": "Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isCons: <A>(self: List<A>) => self is Cons<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L227"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the number of elements contained in the specified `List`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <A>(self: List<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L235"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "nil",
    "description": "Constructs a new empty `List<A>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const nil: <A = never>() => List<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L251"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "cons",
    "description": "Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const cons: <A>(head: A, tail: List<A>) => Cons<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L259"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "of",
    "description": "Constructs a new `List<A>` from the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const of: <A>(value: A) => Cons<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L277"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `List` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: <A>(prefix: Iterable<A>) => List<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L285"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new `List<A>` from the specified values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Elements extends readonly [any, ...Array<any>]>(...elements: Elements) => Cons<Elements[number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L308"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "compact",
    "description": "Removes all `None` values from the specified list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const compact: <A>(self: List<Option.Option<A>>) => List<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L617"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "head",
    "description": "Returns the first element of the specified list, or `None` if the list is\nempty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const head: <A>(self: List<A>) => Option.Option<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L702"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "last",
    "description": "Returns the last element of the specified list, or `None` if the list is\nempty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const last: <A>(self: List<A>) => Option.Option<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L711"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "reverse",
    "description": "Returns a new list with the elements of the specified list in reverse order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const reverse: <A>(self: List<A>) => List<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L869"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "tail",
    "description": "Returns the tail of the specified list, or `None` if the list is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const tail: <A>(self: List<A>) => Option.Option<List<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L896"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "toChunk",
    "description": "Converts the specified `List` to a `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const toChunk: <A>(self: List<A>) => Chunk.Chunk<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L930"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "unsafeHead",
    "description": "Unsafely returns the first element of the specified `List`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeHead: <A>(self: List<A>) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L940"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "unsafeLast",
    "description": "Unsafely returns the last element of the specified `List`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeLast: <A>(self: List<A>) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L953"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "unsafeTail",
    "description": "Unsafely returns the tail of the specified `List`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeTail: <A>(self: List<A>) => List<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L972"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "Nil",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Nil<out A> extends Iterable<A>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly _tag: \"Nil\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L67"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "Cons",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Cons<out A> extends NonEmptyIterable<A>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly _tag: \"Cons\"\n  readonly head: A\n  readonly tail: List<A>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L76"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "List",
    "description": "Represents an immutable linked list of elements of type `A`.\n\nA `List` is optimal for last-in-first-out (LIFO), stack-like access patterns.\nIf you need another access pattern, for example, random access or FIFO,\nconsider using a collection more suited for that other than `List`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type List<A> = Cons<A> | Nil<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L49"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L61"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "List.Infer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Infer<S> = S extends List<infer A> ? A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L720"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "List.With",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type With<S, A> = S extends Cons<any> ? Cons<A> : List<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L725"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "List.OrNonEmpty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type OrNonEmpty<S, T, A> = S extends Cons<any> ? Cons<A>\n    : T extends Cons<any> ? Cons<A>\n    : List<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L730"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "List.ts",
      "path": "src/List.ts"
    },
    "project": "effect",
    "name": "List.AndNonEmpty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type AndNonEmpty<S, T, A> = S extends Cons<any> ?\n    T extends Cons<any> ? Cons<A>\n    : List<A> :\n    List<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/List.ts#L737"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "LoggerTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const LoggerTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L28"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a custom logger that formats log messages according to the provided\nfunction.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Logger, LogLevel } from \"effect\"\n\nconst logger = Logger.make(({ logLevel, message }) => {\n  globalThis.console.log(`[${logLevel.label}] ${message}`)\n})\n\nconst task1 = Effect.logDebug(\"task1 done\")\nconst task2 = Effect.logDebug(\"task2 done\")\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"start\")\n  yield* task1\n  yield* task2\n  yield* Effect.log(\"done\")\n}).pipe(\n  Logger.withMinimumLogLevel(LogLevel.Debug),\n  Effect.provide(Logger.replace(Logger.defaultLogger, logger))\n)\n\nEffect.runFork(program)\n// [INFO] start\n// [DEBUG] task1 done\n// [DEBUG] task2 done\n// [INFO] done\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Message, Output>(log: (options: Logger.Options<Message>) => Output) => Logger<Message, Output>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L110"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "add",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const add: <B>(logger: Logger<unknown, B>) => Layer.Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L117"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "addEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const addEffect: <A, E, R>(effect: Effect<Logger<unknown, A>, E, R>) => Layer.Layer<never, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L123"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "addScoped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const addScoped: <A, E, R>(effect: Effect<Logger<unknown, A>, E, R>) => Layer.Layer<never, E, Exclude<R, Scope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L130"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "mapInput",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapInput: { <Message, Message2>(f: (message: Message2) => Message): <Output>(self: Logger<Message, Output>) => Logger<Message2, Output>; <Output, Message, Message2>(self: Logger<Message, Output>, f: (message: Message2) => Message): Logger<Message2, Output>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L138"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "mapInputOptions",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapInputOptions: { <Message, Message2>(f: (options: Logger.Options<Message2>) => Logger.Options<Message>): <Output>(self: Logger<Message, Output>) => Logger<Message2, Output>; <Output, Message, Message2>(self: Logger<Message, Output>, f: (options: Logger.Options<Message2>) => Logger.Options<Message>): Logger<Message2, Output>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L152"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "filterLogLevel",
    "description": "Returns a version of this logger that only logs messages when the log level\nsatisfies the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterLogLevel: { (f: (logLevel: LogLevel.LogLevel) => boolean): <Message, Output>(self: Logger<Message, Output>) => Logger<Message, Option.Option<Output>>; <Message, Output>(self: Logger<Message, Output>, f: (logLevel: LogLevel.LogLevel) => boolean): Logger<Message, Option.Option<Output>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L169"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "map",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <Output, Output2>(f: (output: Output) => Output2): <Message>(self: Logger<Message, Output>) => Logger<Message, Output2>; <Message, Output, Output2>(self: Logger<Message, Output>, f: (output: Output) => Output2): Logger<Message, Output2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L183"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "batched",
    "description": "Creates a batched logger that groups log messages together and processes them\nin intervals.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Console, Effect, Logger } from \"effect\"\n\nconst LoggerLive = Logger.replaceScoped(\n  Logger.defaultLogger,\n  Logger.logfmtLogger.pipe(\n    Logger.batched(\"500 millis\", (messages) => Console.log(\"BATCH\", `[\\n${messages.join(\"\\n\")}\\n]`))\n  )\n)\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"one\")\n  yield* Effect.log(\"two\")\n  yield* Effect.log(\"three\")\n}).pipe(Effect.provide(LoggerLive))\n\nEffect.runFork(program)\n// BATCH [\n// timestamp=... level=INFO fiber=#0 message=one\n// timestamp=... level=INFO fiber=#0 message=two\n// timestamp=... level=INFO fiber=#0 message=three\n// ]\n```"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const batched: { <Output, R>(window: DurationInput, f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>): <Message>(self: Logger<Message, Output>) => Effect<Logger<Message, void>, never, R | Scope>; <Message, Output, R>(self: Logger<Message, Output>, window: DurationInput, f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>): Effect<Logger<Message, void>, never, Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L225"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "withConsoleLog",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "console",
    "signature": "declare const withConsoleLog: <M, O>(self: Logger<M, O>) => Logger<M, void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L241"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "withLeveledConsole",
    "description": "Takes a `Logger<M, O>` and returns a logger that calls the respective `Console` method\nbased on the log level.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Logger, Effect } from \"effect\"\n\nconst loggerLayer = Logger.replace(\n  Logger.defaultLogger,\n  Logger.withLeveledConsole(Logger.stringLogger),\n)\n\nEffect.gen(function* () {\n  yield* Effect.logError(\"an error\")\n  yield* Effect.logInfo(\"an info\")\n}).pipe(Effect.provide(loggerLayer))\n```"
    ],
    "since": "3.8.0",
    "category": "console",
    "signature": "declare const withLeveledConsole: <M, O>(self: Logger<M, O>) => Logger<M, void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L265"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "withConsoleError",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "console",
    "signature": "declare const withConsoleError: <M, O>(self: Logger<M, O>) => Logger<M, void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L271"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "none",
    "description": "A logger that does nothing in response to logging events.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const none: Logger<unknown, void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L279"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "remove",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const remove: <A>(logger: Logger<unknown, A>) => Layer.Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L285"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "replace",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const replace: { <B>(that: Logger<unknown, B>): <A>(self: Logger<unknown, A>) => Layer.Layer<never>; <A, B>(self: Logger<unknown, A>, that: Logger<unknown, B>): Layer.Layer<never>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L291"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "replaceEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const replaceEffect: { <B, E, R>(that: Effect<Logger<unknown, B>, E, R>): <A>(self: Logger<unknown, A>) => Layer.Layer<never, E, R>; <A, B, E, R>(self: Logger<unknown, A>, that: Effect<Logger<unknown, B>, E, R>): Layer.Layer<never, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L300"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "replaceScoped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const replaceScoped: { <B, E, R>(that: Effect<Logger<unknown, B>, E, R>): <A>(self: Logger<unknown, A>) => Layer.Layer<never, E, Exclude<R, Scope>>; <A, B, E, R>(self: Logger<unknown, A>, that: Effect<Logger<unknown, B>, E, R>): Layer.Layer<never, E, Exclude<R, Scope>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L309"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "simple",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const simple: <A, B>(log: (a: A) => B) => Logger<A, B>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L323"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "succeed",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const succeed: <A>(value: A) => Logger<unknown, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L329"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "sync",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sync: <A>(evaluate: LazyArg<A>) => Logger<unknown, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L335"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "test",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const test: { <Message>(input: Message): <Output>(self: Logger<Message, Output>) => Output; <Message, Output>(self: Logger<Message, Output>, input: Message): Output; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L341"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "withMinimumLogLevel",
    "description": "Sets the minimum log level for subsequent logging operations, allowing\ncontrol over which log messages are displayed based on their severity.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.logDebug(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message1\n```"
    ],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const withMinimumLogLevel: { (level: LogLevel.LogLevel): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, level: LogLevel.LogLevel): Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L363"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "withSpanAnnotations",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "declare const withSpanAnnotations: <Message, Output>(self: Logger<Message, Output>) => Logger<Message, Output>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L372"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Combines this logger with the specified logger to produce a new logger that\nlogs to both this logger and that logger.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zip: { <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, [Output, Output2]>; <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, [Output, Output2]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L382"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "zipLeft",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipLeft: { <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, Output>; <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, Output>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L396"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "zipRight",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipRight: { <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, Output2>; <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, Output2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L410"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "defaultLogger",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const defaultLogger: Logger<unknown, void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L424"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "jsonLogger",
    "description": "The `jsonLogger` logger formats log entries as JSON objects, making them easy to\nintegrate with logging systems that consume JSON data.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.json)))\n// {\"message\":[\"message1\",\"message2\"],\"logLevel\":\"INFO\",\"timestamp\":\"...\",\"annotations\":{\"key2\":\"value2\",\"key1\":\"value1\"},\"spans\":{\"myspan\":0},\"fiberId\":\"#0\"}\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const jsonLogger: Logger<unknown, string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L446"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "logfmtLogger",
    "description": "This logger outputs logs in a human-readable format that is easy to read\nduring development or in a production console.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.logFmt)))\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const logfmtLogger: Logger<unknown, string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L468"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "stringLogger",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const stringLogger: Logger<unknown, string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L474"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "prettyLogger",
    "description": "The pretty logger utilizes the capabilities of the console API to generate\nvisually engaging and color-enhanced log outputs. This feature is\nparticularly useful for improving the readability of log messages during\ndevelopment and debugging processes.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.pretty)))\n//         green --v                      v-- bold and cyan\n// [07:51:54.434] INFO (#0) myspan=1ms: message1\n//   message2\n//    v-- bold\n//   key2: value2\n//   key1: value1\n```"
    ],
    "since": "3.5.0",
    "category": "constructors",
    "signature": "declare const prettyLogger: (options?: { readonly colors?: \"auto\" | boolean | undefined; readonly stderr?: boolean | undefined; readonly formatDate?: ((date: Date) => string) | undefined; readonly mode?: \"browser\" | \"tty\" | \"auto\" | undefined; }) => Logger<unknown, void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L503"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "prettyLoggerDefault",
    "description": "A default version of the pretty logger.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "constructors",
    "signature": "declare const prettyLoggerDefault: Logger<unknown, void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L518"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "structuredLogger",
    "description": "The structured logger provides detailed log outputs, structured in a way that\nretains comprehensive traceability of the events, suitable for deeper\nanalysis and troubleshooting.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.structured)))\n// {\n//   message: [ 'message1', 'message2' ],\n//   logLevel: 'INFO',\n//   timestamp: '2024-07-09T14:05:41.623Z',\n//   cause: undefined,\n//   annotations: { key2: 'value2', key1: 'value1' },\n//   spans: { myspan: 0 },\n//   fiberId: '#0'\n// }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const structuredLogger: Logger<unknown, { readonly logLevel: string; readonly fiberId: string; readonly timestamp: string; readonly message: unknown; readonly cause: string | undefined; readonly annotations: Record<string, unknown>; readonly spans: Record<string, number>; }>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L549"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "tracerLogger",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const tracerLogger: Logger<unknown, void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L566"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "json",
    "description": "The `json` logger formats log entries as JSON objects, making them easy to\nintegrate with logging systems that consume JSON data.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.json)))\n// {\"message\":[\"message1\",\"message2\"],\"logLevel\":\"INFO\",\"timestamp\":\"...\",\"annotations\":{\"key2\":\"value2\",\"key1\":\"value1\"},\"spans\":{\"myspan\":0},\"fiberId\":\"#0\"}\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const json: Layer.Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L588"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "logFmt",
    "description": "This logger outputs logs in a human-readable format that is easy to read\nduring development or in a production console.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.logFmt)))\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const logFmt: Layer.Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L610"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "pretty",
    "description": "The pretty logger utilizes the capabilities of the console API to generate\nvisually engaging and color-enhanced log outputs. This feature is\nparticularly useful for improving the readability of log messages during\ndevelopment and debugging processes.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.pretty)))\n//         green --v                      v-- bold and cyan\n// [07:51:54.434] INFO (#0) myspan=1ms: message1\n//   message2\n//    v-- bold\n//   key2: value2\n//   key1: value1\n```"
    ],
    "since": "3.5.0",
    "category": "constructors",
    "signature": "declare const pretty: Layer.Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L639"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "structured",
    "description": "The structured logger provides detailed log outputs, structured in a way that\nretains comprehensive traceability of the events, suitable for deeper\nanalysis and troubleshooting.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.structured)))\n// {\n//   message: [ 'message1', 'message2' ],\n//   logLevel: 'INFO',\n//   timestamp: '2024-07-09T14:05:41.623Z',\n//   cause: undefined,\n//   annotations: { key2: 'value2', key1: 'value1' },\n//   spans: { myspan: 0 },\n//   fiberId: '#0'\n// }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const structured: Layer.Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L670"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "minimumLogLevel",
    "description": "Sets the minimum log level for logging operations, allowing control over\nwhich log messages are displayed based on their severity.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"Executing task...\")\n  yield* Effect.sleep(\"100 millis\")\n  console.log(\"task done\")\n})\n\n// Logging disabled using a layer\nEffect.runFork(program.pipe(Effect.provide(Logger.minimumLogLevel(LogLevel.None))))\n// task done\n```"
    ],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const minimumLogLevel: (level: LogLevel.LogLevel) => Layer.Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L694"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "isLogger",
    "description": "Returns `true` if the specified value is a `Logger`, otherwise returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "guards",
    "signature": "declare const isLogger: (u: unknown) => u is Logger<unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L702"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "Logger",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Logger<in Message, out Output> extends Logger.Variance<Message, Output>, Pipeable {\n  log(options: Logger.Options<Message>): Output\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L40"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "LoggerTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type LoggerTypeId = typeof LoggerTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L34"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "Logger.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in Message, out Output> {\n    readonly [LoggerTypeId]: {\n      readonly _Message: Types.Contravariant<Message>\n      readonly _Output: Types.Covariant<Output>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L52"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Logger.ts",
      "path": "src/Logger.ts"
    },
    "project": "effect",
    "name": "Logger.Options",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Options<out Message> {\n    readonly fiberId: FiberId.FiberId\n    readonly logLevel: LogLevel.LogLevel\n    readonly message: Message\n    readonly cause: Cause.Cause<unknown>\n    readonly context: FiberRefs.FiberRefs\n    readonly spans: List.List<LogSpan.LogSpan>\n    readonly annotations: HashMap.HashMap<string, unknown>\n    readonly date: Date\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Logger.ts#L63"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "All",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const All: LogLevel",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L123"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "Fatal",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Fatal: LogLevel",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L129"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "Error",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Error: LogLevel",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L135"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "Warning",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Warning: LogLevel",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L141"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "Info",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Info: LogLevel",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L147"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "Debug",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Debug: LogLevel",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L153"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "Trace",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Trace: LogLevel",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L159"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "None",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const None: LogLevel",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L165"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "allLevels",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const allLevels: ReadonlyArray<LogLevel>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L171"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "locally",
    "description": "Temporarily sets a `LogLevel` for an `Effect` workflow.\n\n**Details**\n\nThis function allows you to apply a specific `LogLevel` locally to an\n`Effect` workflow. Once the workflow completes, the `LogLevel` reverts to its\nprevious state.\n\n**When to Use**\n\nThis is particularly useful when you want to adjust the verbosity of logging\nfor specific parts of your program without affecting the global log level.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, LogLevel } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"message1\")\n  yield* Effect.gen(function*() {\n    yield* Effect.log(\"message2\")\n    yield* Effect.log(\"message3\")\n  }).pipe(LogLevel.locally(LogLevel.Warning))\n})\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=message1\n// timestamp=... level=WARN fiber=#0 message=message2\n// timestamp=... level=WARN fiber=#0 message=message3\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const locally: { (self: LogLevel): <A, E, R>(use: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(use: Effect.Effect<A, E, R>, self: LogLevel): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L208"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "Order",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Order: order.Order<LogLevel>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L221"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "lessThan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "declare const lessThan: { (that: LogLevel): (self: LogLevel) => boolean; (self: LogLevel, that: LogLevel): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L230"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "lessThanEqual",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "declare const lessThanEqual: { (that: LogLevel): (self: LogLevel) => boolean; (self: LogLevel, that: LogLevel): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L239"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "greaterThan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "declare const greaterThan: { (that: LogLevel): (self: LogLevel) => boolean; (self: LogLevel, that: LogLevel): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L248"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "greaterThanEqual",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "declare const greaterThanEqual: { (that: LogLevel): (self: LogLevel) => boolean; (self: LogLevel, that: LogLevel): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L257"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "fromLiteral",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const fromLiteral: (literal: Literal) => LogLevel",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L266"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "All",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface All extends Pipeable {\n  readonly _tag: \"All\"\n  readonly label: \"ALL\"\n  readonly syslog: 0\n  readonly ordinal: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L35"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "Fatal",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface Fatal extends Pipeable {\n  readonly _tag: \"Fatal\"\n  readonly label: \"FATAL\"\n  readonly syslog: 2\n  readonly ordinal: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L46"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "Error",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface Error extends Pipeable {\n  readonly _tag: \"Error\"\n  readonly label: \"ERROR\"\n  readonly syslog: 3\n  readonly ordinal: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L57"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "Warning",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface Warning extends Pipeable {\n  readonly _tag: \"Warning\"\n  readonly label: \"WARN\"\n  readonly syslog: 4\n  readonly ordinal: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L68"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "Info",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface Info extends Pipeable {\n  readonly _tag: \"Info\"\n  readonly label: \"INFO\"\n  readonly syslog: 6\n  readonly ordinal: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L79"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "Debug",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface Debug extends Pipeable {\n  readonly _tag: \"Debug\"\n  readonly label: \"DEBUG\"\n  readonly syslog: 7\n  readonly ordinal: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L90"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "Trace",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface Trace extends Pipeable {\n  readonly _tag: \"Trace\"\n  readonly label: \"TRACE\"\n  readonly syslog: 7\n  readonly ordinal: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L101"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "None",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface None extends Pipeable {\n  readonly _tag: \"None\"\n  readonly label: \"OFF\"\n  readonly syslog: 7\n  readonly ordinal: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L112"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "LogLevel",
    "description": "A `LogLevel` represents the log level associated with an individual logging\noperation. Log levels are used both to describe the granularity (or\nimportance) of individual log statements, as well as to enable tuning\nverbosity of log output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "type LogLevel = All | Fatal | Error | Warning | Info | Debug | Trace | None",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L23"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "LogLevel.ts",
      "path": "src/LogLevel.ts"
    },
    "project": "effect",
    "name": "Literal",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "type Literal = LogLevel[\"_tag\"]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogLevel.ts#L29"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogSpan.ts",
      "path": "src/LogSpan.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (label: string, startTime: number) => LogSpan",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogSpan.ts#L19"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogSpan.ts",
      "path": "src/LogSpan.ts"
    },
    "project": "effect",
    "name": "render",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const render: (now: number) => (self: LogSpan) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogSpan.ts#L25"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogSpan.ts",
      "path": "src/LogSpan.ts"
    },
    "project": "effect",
    "name": "LogSpan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface LogSpan {\n  readonly label: string\n  readonly startTime: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/LogSpan.ts#L10"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Mailbox.ts",
      "path": "src/Mailbox.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "type ids",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L22"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Mailbox.ts",
      "path": "src/Mailbox.ts"
    },
    "project": "effect",
    "name": "ReadonlyTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "type ids",
    "signature": "declare const ReadonlyTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L36"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Mailbox.ts",
      "path": "src/Mailbox.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "A `Mailbox` is a queue that can be signaled to be done or failed.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Effect, Mailbox } from \"effect\"\n\nEffect.gen(function*() {\n  const mailbox = yield* Mailbox.make<number, string>()\n\n  // add messages to the mailbox\n  yield* mailbox.offer(1)\n  yield* mailbox.offer(2)\n  yield* mailbox.offerAll([3, 4, 5])\n\n  // take messages from the mailbox\n  const [messages, done] = yield* mailbox.takeAll\n  assert.deepStrictEqual(messages, [1, 2, 3, 4, 5])\n  assert.strictEqual(done, false)\n\n  // signal that the mailbox is done\n  yield* mailbox.end\n  const [messages2, done2] = yield* mailbox.takeAll\n  assert.deepStrictEqual(messages2, [])\n  assert.strictEqual(done2, true)\n\n  // signal that the mailbox has failed\n  yield* mailbox.fail(\"boom\")\n})\n```"
    ],
    "since": "3.8.0",
    "category": "constructors",
    "signature": "declare const make: <A, E = never>(capacity?: number | { readonly capacity?: number; readonly strategy?: \"suspend\" | \"dropping\" | \"sliding\"; } | undefined) => Effect<Mailbox<A, E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L209"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Mailbox.ts",
      "path": "src/Mailbox.ts"
    },
    "project": "effect",
    "name": "into",
    "description": "Run an `Effect` into a `Mailbox`, where success ends the mailbox and failure\nfails the mailbox.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "combinators",
    "signature": "declare const into: { <A, E>(self: Mailbox<A, E>): <AX, EX extends E, RX>(effect: Effect<AX, EX, RX>) => Effect<boolean, never, RX>; <AX, E, EX extends E, RX, A>(effect: Effect<AX, EX, RX>, self: Mailbox<A, E>): Effect<boolean, never, RX>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L224"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Mailbox.ts",
      "path": "src/Mailbox.ts"
    },
    "project": "effect",
    "name": "toChannel",
    "description": "Create a `Channel` from a `Mailbox`.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "conversions",
    "signature": "declare const toChannel: <A, E>(self: ReadonlyMailbox<A, E>) => Channel<Chunk<A>, unknown, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L236"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Mailbox.ts",
      "path": "src/Mailbox.ts"
    },
    "project": "effect",
    "name": "toStream",
    "description": "Create a `Stream` from a `Mailbox`.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "conversions",
    "signature": "declare const toStream: <A, E>(self: ReadonlyMailbox<A, E>) => Stream<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L245"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Mailbox.ts",
      "path": "src/Mailbox.ts"
    },
    "project": "effect",
    "name": "fromStream",
    "description": "Create a `ReadonlyMailbox` from a `Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "conversions",
    "signature": "declare const fromStream: { (options?: { readonly capacity?: number | undefined; readonly strategy?: \"suspend\" | \"dropping\" | \"sliding\" | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect<ReadonlyMailbox<A, E>, never, R | Scope>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly capacity?: number | undefined; readonly strategy?: \"suspend\" | \"dropping\" | \"sliding\" | undefined; }): Effect<ReadonlyMailbox<A, E>, never, R | Scope>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L254"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Mailbox.ts",
      "path": "src/Mailbox.ts"
    },
    "project": "effect",
    "name": "isMailbox",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "guards",
    "signature": "declare const isMailbox: <A = unknown, E = unknown>(u: unknown) => u is Mailbox<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L50"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Mailbox.ts",
      "path": "src/Mailbox.ts"
    },
    "project": "effect",
    "name": "isReadonlyMailbox",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "guards",
    "signature": "declare const isReadonlyMailbox: <A = unknown, E = unknown>(u: unknown) => u is ReadonlyMailbox<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L57"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Mailbox.ts",
      "path": "src/Mailbox.ts"
    },
    "project": "effect",
    "name": "Mailbox",
    "description": "A `Mailbox` is a queue that can be signaled to be done or failed.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface Mailbox<in out A, in out E = never> extends ReadonlyMailbox<A, E> {\n  readonly [TypeId]: TypeId\n  /**\n   * Add a message to the mailbox. Returns `false` if the mailbox is done.\n   */\n  readonly offer: (message: A) => Effect<boolean>\n  /**\n   * Add a message to the mailbox. Returns `false` if the mailbox is done.\n   */\n  readonly unsafeOffer: (message: A) => boolean\n  /**\n   * Add multiple messages to the mailbox. Returns the remaining messages that\n   * were not added.\n   */\n  readonly offerAll: (messages: Iterable<A>) => Effect<Chunk<A>>\n  /**\n   * Add multiple messages to the mailbox. Returns the remaining messages that\n   * were not added.\n   */\n  readonly unsafeOfferAll: (messages: Iterable<A>) => Chunk<A>\n  /**\n   * Fail the mailbox with an error. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly fail: (error: E) => Effect<boolean>\n  /**\n   * Fail the mailbox with a cause. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly failCause: (cause: Cause<E>) => Effect<boolean>\n  /**\n   * Signal that the mailbox is complete. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly end: Effect<boolean>\n  /**\n   * Signal that the mailbox is done. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly done: (exit: Exit<void, E>) => Effect<boolean>\n  /**\n   * Signal that the mailbox is done. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly unsafeDone: (exit: Exit<void, E>) => boolean\n  /**\n   * Shutdown the mailbox, canceling any pending operations.\n   * If the mailbox is already done, `false` is returned.\n   */\n  readonly shutdown: Effect<boolean>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L67"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Mailbox.ts",
      "path": "src/Mailbox.ts"
    },
    "project": "effect",
    "name": "ReadonlyMailbox",
    "description": "A `ReadonlyMailbox` represents a mailbox that can only be read from.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface ReadonlyMailbox<out A, out E = never>\n  extends Effect<readonly [messages: Chunk<A>, done: boolean], E>, Inspectable\n{\n  readonly [ReadonlyTypeId]: ReadonlyTypeId\n  /**\n   * Take all messages from the mailbox, returning an empty Chunk if the mailbox\n   * is empty or done.\n   */\n  readonly clear: Effect<Chunk<A>, E>\n  /**\n   * Take all messages from the mailbox, or wait for messages to be available.\n   *\n   * If the mailbox is done, the `done` flag will be `true`. If the mailbox\n   * fails, the Effect will fail with the error.\n   */\n  readonly takeAll: Effect<readonly [messages: Chunk<A>, done: boolean], E>\n  /**\n   * Take a specified number of messages from the mailbox. It will only take\n   * up to the capacity of the mailbox.\n   *\n   * If the mailbox is done, the `done` flag will be `true`. If the mailbox\n   * fails, the Effect will fail with the error.\n   */\n  readonly takeN: (n: number) => Effect<readonly [messages: Chunk<A>, done: boolean], E>\n  /**\n   * Take a single message from the mailbox, or wait for a message to be\n   * available.\n   *\n   * If the mailbox is done, it will fail with `NoSuchElementException`. If the\n   * mailbox fails, the Effect will fail with the error.\n   */\n  readonly take: Effect<A, E | NoSuchElementException>\n  /** Wait for the mailbox to be done. */\n  readonly await: Effect<void, E>\n  /**\n   * Check the size of the mailbox.\n   *\n   * If the mailbox is complete, it will return `None`.\n   */\n  readonly size: Effect<Option<number>>\n  /**\n   * Check the size of the mailbox.\n   *\n   * If the mailbox is complete, it will return `None`.\n   */\n  readonly unsafeSize: () => Option<number>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L126"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Mailbox.ts",
      "path": "src/Mailbox.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "type ids",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L29"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Mailbox.ts",
      "path": "src/Mailbox.ts"
    },
    "project": "effect",
    "name": "ReadonlyTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "type ids",
    "signature": "type ReadonlyTypeId = typeof ReadonlyTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Mailbox.ts#L43"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ManagedRuntime.ts",
      "path": "src/ManagedRuntime.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "symbol",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ManagedRuntime.ts#L17"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ManagedRuntime.ts",
      "path": "src/ManagedRuntime.ts"
    },
    "project": "effect",
    "name": "isManagedRuntime",
    "description": "Checks if the provided argument is a `ManagedRuntime`.",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "guards",
    "signature": "declare const isManagedRuntime: (input: unknown) => input is ManagedRuntime<unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ManagedRuntime.ts#L31"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ManagedRuntime.ts",
      "path": "src/ManagedRuntime.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Convert a Layer into an ManagedRuntime, that can be used to run Effect's using\nyour services.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Console, Effect, Layer, ManagedRuntime } from \"effect\"\n\nclass Notifications extends Effect.Tag(\"Notifications\")<\n  Notifications,\n  { readonly notify: (message: string) => Effect.Effect<void> }\n>() {\n  static Live = Layer.succeed(this, { notify: (message) => Console.log(message) })\n}\n\nasync function main() {\n  const runtime = ManagedRuntime.make(Notifications.Live)\n  await runtime.runPromise(Notifications.notify(\"Hello, world!\"))\n  await runtime.dispose()\n}\n\nmain()\n```"
    ],
    "since": "2.0.0",
    "category": "runtime class",
    "signature": "declare const make: <R, E>(layer: Layer.Layer<R, E, never>, memoMap?: Layer.MemoMap | undefined) => ManagedRuntime<R, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ManagedRuntime.ts#L177"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ManagedRuntime.ts",
      "path": "src/ManagedRuntime.ts"
    },
    "project": "effect",
    "name": "ManagedRuntime",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ManagedRuntime<in R, out ER> extends Effect.Effect<Runtime.Runtime<R>, ER> {\n  readonly [TypeId]: TypeId\n  readonly memoMap: Layer.MemoMap\n  readonly runtimeEffect: Effect.Effect<Runtime.Runtime<R>, ER>\n  readonly runtime: () => Promise<Runtime.Runtime<R>>\n\n  /**\n   * Executes the effect using the provided Scheduler or using the global\n   * Scheduler if not provided\n   */\n  readonly runFork: <A, E>(\n    self: Effect.Effect<A, E, R>,\n    options?: Runtime.RunForkOptions\n  ) => Fiber.RuntimeFiber<A, E | ER>\n\n  /**\n   * Executes the effect synchronously returning the exit.\n   *\n   * This method is effectful and should only be invoked at the edges of your\n   * program.\n   */\n  readonly runSyncExit: <A, E>(effect: Effect.Effect<A, E, R>) => Exit.Exit<A, ER | E>\n\n  /**\n   * Executes the effect synchronously throwing in case of errors or async boundaries.\n   *\n   * This method is effectful and should only be invoked at the edges of your\n   * program.\n   */\n  readonly runSync: <A, E>(effect: Effect.Effect<A, E, R>) => A\n\n  /**\n   * Executes the effect asynchronously, eventually passing the exit value to\n   * the specified callback.\n   *\n   * This method is effectful and should only be invoked at the edges of your\n   * program.\n   */\n  readonly runCallback: <A, E>(\n    effect: Effect.Effect<A, E, R>,\n    options?: Runtime.RunCallbackOptions<A, E | ER> | undefined\n  ) => Runtime.Cancel<A, E | ER>\n\n  /**\n   * Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\n   * with the value of the effect once the effect has been executed, or will be\n   * rejected with the first error or exception throw by the effect.\n   *\n   * This method is effectful and should only be used at the edges of your\n   * program.\n   */\n  readonly runPromise: <A, E>(effect: Effect.Effect<A, E, R>, options?: {\n    readonly signal?: AbortSignal | undefined\n  }) => Promise<A>\n\n  /**\n   * Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\n   * with the `Exit` state of the effect once the effect has been executed.\n   *\n   * This method is effectful and should only be used at the edges of your\n   * program.\n   */\n  readonly runPromiseExit: <A, E>(effect: Effect.Effect<A, E, R>, options?: {\n    readonly signal?: AbortSignal | undefined\n  }) => Promise<Exit.Exit<A, ER | E>>\n\n  /**\n   * Dispose of the resources associated with the runtime.\n   */\n  readonly dispose: () => Promise<void>\n\n  /**\n   * Dispose of the resources associated with the runtime.\n   */\n  readonly disposeEffect: Effect.Effect<void, never, never>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: ManagedRuntimeUnify<this>\n  readonly [Unify.ignoreSymbol]?: ManagedRuntimeUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ManagedRuntime.ts#L54"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ManagedRuntime.ts",
      "path": "src/ManagedRuntime.ts"
    },
    "project": "effect",
    "name": "ManagedRuntimeUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface ManagedRuntimeUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  ManagedRuntime?: () => Extract<A[Unify.typeSymbol], ManagedRuntime<any, any>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ManagedRuntime.ts#L139"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ManagedRuntime.ts",
      "path": "src/ManagedRuntime.ts"
    },
    "project": "effect",
    "name": "ManagedRuntimeUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface ManagedRuntimeUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ManagedRuntime.ts#L147"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ManagedRuntime.ts",
      "path": "src/ManagedRuntime.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ManagedRuntime.ts#L23"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ManagedRuntime.ts",
      "path": "src/ManagedRuntime.ts"
    },
    "project": "effect",
    "name": "ManagedRuntime.Context",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "type-level",
    "signature": "type Context<T> = [T] extends [ManagedRuntime<infer R, infer _E>] ? R\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ManagedRuntime.ts#L41"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ManagedRuntime.ts",
      "path": "src/ManagedRuntime.ts"
    },
    "project": "effect",
    "name": "ManagedRuntime.Error",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "type-level",
    "signature": "type Error<T> = [T] extends [ManagedRuntime<infer _R, infer E>] ? E : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ManagedRuntime.ts#L47"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "MatcherTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Symbols",
    "signature": "declare const MatcherTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L41"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "type",
    "description": "Creates a matcher for a specific type.\n\n**Details**\n\nThis function defines a `Matcher` that operates on a given type, allowing you\nto specify conditions for handling different cases. Once the matcher is\ncreated, you can use pattern-matching functions like {@link when} to define\nhow different values should be processed.\n\n**Example** (Matching Numbers and Strings)\n\n```ts\nimport { Match } from \"effect\"\n\n// Create a matcher for values that are either strings or numbers\n//\n//       (u: string | number) => string\n//      \nconst match = Match.type<string | number>().pipe(\n  // Match when the value is a number\n  Match.when(Match.number, (n) => `number: ${n}`),\n  // Match when the value is a string\n  Match.when(Match.string, (s) => `string: ${s}`),\n  // Ensure all possible cases are handled\n  Match.exhaustive\n)\n\nconsole.log(match(0))\n// Output: \"number: 0\"\n\nconsole.log(match(\"hello\"))\n// Output: \"string: hello\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Creating a matcher",
    "signature": "declare const type: <I>() => Matcher<I, Types.Without<never>, I, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L193"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "value",
    "description": "Creates a matcher from a specific value.\n\n**Details**\n\nThis function allows you to define a `Matcher` directly from a given value,\nrather than from a type. This is useful when working with known values,\nenabling structured pattern matching on objects, primitives, or any data\nstructure.\n\nOnce the matcher is created, you can use pattern-matching functions like\n{@link when} to define how different cases should be handled.\n\n**Example** (Matching an Object by Property)\n\n```ts\nimport { Match } from \"effect\"\n\nconst input = { name: \"John\", age: 30 }\n\n// Create a matcher for the specific object\nconst result = Match.value(input).pipe(\n  // Match when the 'name' property is \"John\"\n  Match.when(\n    { name: \"John\" },\n    (user) => `${user.name} is ${user.age} years old`\n  ),\n  // Provide a fallback if no match is found\n  Match.orElse(() => \"Oh, not John\")\n)\n\nconsole.log(result)\n// Output: \"John is 30 years old\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Creating a matcher",
    "signature": "declare const value: <const I>(i: I) => Matcher<I, Types.Without<never>, I, never, I>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L235"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "valueTags",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Creating a matcher",
    "signature": "declare const valueTags: { <const I, P extends { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag; }>) => any; } & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never; }>(fields: P): (input: I) => Unify<ReturnType<P[keyof P]>>; <const I, P extends { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag; }>) => any; } & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never; }>(input: I, fields: P): Unify<ReturnType<P[keyof P]>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L243"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "typeTags",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Creating a matcher",
    "signature": "declare const typeTags: <I>() => <P extends { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag; }>) => any; } & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never; }>(fields: P) => (input: I) => Unify<ReturnType<P[keyof P]>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L262"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "withReturnType",
    "description": "Ensures that all branches of a matcher return a specific type.\n\n**Details**\n\nThis function enforces a consistent return type across all pattern-matching\nbranches. By specifying a return type, TypeScript will check that every\nmatching condition produces a value of the expected type.\n\n**Important:** This function must be the first step in the matcher pipeline.\nIf used later, TypeScript will not enforce type consistency correctly.\n\n**Example** (Validating Return Type Consistency)\n\n```ts\nimport { Match } from \"effect\"\n\nconst match = Match.type<{ a: number } | { b: string }>().pipe(\n  // Ensure all branches return a string\n  Match.withReturnType<string>(),\n  //  Type error: 'number' is not assignable to type 'string'\n  // @ts-expect-error\n  Match.when({ a: Match.number }, (_) => _.a),\n  //  Correct: returns a string\n  Match.when({ b: Match.string }, (_) => _.b),\n  Match.exhaustive\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "declare const withReturnType: <Ret>() => <I, F, R, A, Pr, _>(self: Matcher<I, F, R, A, Pr, _>) => [Ret] extends [[A] extends [never] ? any : A] ? Matcher<I, F, R, A, Pr, Ret> : \"withReturnType constraint does not extend Result type\"",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L303"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "when",
    "description": "Defines a condition for matching values.\n\n**Details**\n\nThis function enables pattern matching by checking whether a given value\nsatisfies a condition. It supports both direct value comparisons and\npredicate functions. If the condition is met, the associated function is\nexecuted.\n\nThis function is useful when defining matchers that need to check for\nspecific values or apply logical conditions to determine a match. It works\nwell with structured objects and primitive types.\n\n**Example** (Matching with Values and Predicates)\n\n```ts\nimport { Match } from \"effect\"\n\n// Create a matcher for objects with an \"age\" property\nconst match = Match.type<{ age: number }>().pipe(\n  // Match when age is greater than 18\n  Match.when({ age: (age) => age > 18 }, (user) => `Age: ${user.age}`),\n  // Match when age is exactly 18\n  Match.when({ age: 18 }, () => \"You can vote\"),\n  // Fallback case for all other ages\n  Match.orElse((user) => `${user.age} is too young`)\n)\n\nconsole.log(match({ age: 20 }))\n// Output: \"Age: 20\"\n\nconsole.log(match({ age: 18 }))\n// Output: \"You can vote\"\n\nconsole.log(match({ age: 4 }))\n// Output: \"4 is too young\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "declare const when: <R, const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>, Ret, Fn extends (_: Types.WhenMatch<R, P>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Types.PForExclude<P>>, Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P>>>, A | ReturnType<Fn>, Pr, Ret>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L355"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "whenOr",
    "description": "Matches one of multiple patterns in a single condition.\n\n**Details**\n\nThis function allows defining a condition where a value matches any of the\nprovided patterns. If a match is found, the associated function is executed.\nIt simplifies cases where multiple patterns share the same handling logic.\n\nUnlike {@link when}, which requires separate conditions for each pattern,\nthis function enables combining them into a single statement, making the\nmatcher more concise.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Match } from \"effect\"\n\ntype ErrorType =\n  | { readonly _tag: \"NetworkError\"; readonly message: string }\n  | { readonly _tag: \"TimeoutError\"; readonly duration: number }\n  | { readonly _tag: \"ValidationError\"; readonly field: string }\n\nconst handleError = Match.type<ErrorType>().pipe(\n  Match.whenOr(\n    { _tag: \"NetworkError\" },\n    { _tag: \"TimeoutError\" },\n    () => \"Retry the request\"\n  ),\n  Match.when({ _tag: \"ValidationError\" }, (_) => `Invalid field: ${_.field}`),\n  Match.exhaustive\n)\n\nconsole.log(handleError({ _tag: \"NetworkError\", message: \"No connection\" }))\n// Output: \"Retry the request\"\n\nconsole.log(handleError({ _tag: \"ValidationError\", field: \"email\" }))\n// Output: \"Invalid field: email\"\n```"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "declare const whenOr: <R, const P extends ReadonlyArray<Types.PatternPrimitive<R> | Types.PatternBase<R>>, Ret, Fn extends (_: Types.WhenMatch<R, P[number]>) => Ret>(...args: [...patterns: P, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Types.PForExclude<P[number]>>, Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P[number]>>>, A | ReturnType<Fn>, Pr, Ret>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L416"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "whenAnd",
    "description": "Matches a value that satisfies all provided patterns.\n\n**Details**\n\nThis function allows defining a condition where a value must match all the\ngiven patterns simultaneously. If the value satisfies every pattern, the\nassociated function is executed.\n\nUnlike {@link when}, which matches a single pattern at a time, this function\nensures that multiple conditions are met before executing the callback. It is\nuseful when checking for values that need to fulfill multiple criteria at\nonce.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Match } from \"effect\"\n\ntype User = { readonly age: number; readonly role: \"admin\" | \"user\" }\n\nconst checkUser = Match.type<User>().pipe(\n  Match.whenAnd(\n    { age: (n) => n >= 18 },\n    { role: \"admin\" },\n    () => \"Admin access granted\"\n  ),\n  Match.orElse(() => \"Access denied\")\n)\n\nconsole.log(checkUser({ age: 20, role: \"admin\" }))\n// Output: \"Admin access granted\"\n\nconsole.log(checkUser({ age: 20, role: \"user\" }))\n// Output: \"Access denied\"\n```"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "declare const whenAnd: <R, const P extends ReadonlyArray<Types.PatternPrimitive<R> | Types.PatternBase<R>>, Ret, Fn extends (_: Types.WhenMatch<R, T.UnionToIntersection<P[number]>>) => Ret>(...args: [...patterns: P, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Types.PForExclude<T.UnionToIntersection<P[number]>>>, Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<T.UnionToIntersection<P[number]>>>>, A | ReturnType<Fn>, Pr>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L473"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "discriminator",
    "description": "Matches values based on a specified discriminant field.\n\n**Details**\n\nThis function is used to define pattern matching on objects that follow a\n**discriminated union** structure, where a specific field (e.g., `type`,\n`kind`, `_tag`) determines the variant of the object. It allows matching\nmultiple values of the discriminant and provides a function to handle the\nmatched cases.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n  Match.discriminator(\"type\")(\"A\", \"B\", (_) => `A or B: ${_.type}`),\n  Match.discriminator(\"type\")(\"C\", (_) => `C(${_.c})`),\n  Match.exhaustive\n)\n```"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "declare const discriminator: <D extends string>(field: D) => <R, P extends Types.Tags<D, R> & string, Ret, Fn extends (_: Extract<R, Record<D, P>>) => Ret>(...pattern: [first: P, ...values: Array<P>, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, P>>>>, A | ReturnType<Fn>, Pr, Ret>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L516"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "discriminatorStartsWith",
    "description": "Matches values where a specified field starts with a given prefix.\n\n**Details**\n\nThis function is useful for working with discriminated unions where the\ndiscriminant field follows a hierarchical or namespaced structure. It allows\nyou to match values based on whether the specified field starts with a given\nprefix, making it easier to handle grouped cases.\n\nInstead of checking for exact matches, this function lets you match values\nthat share a common prefix. For example, if your discriminant field contains\nhierarchical names like `\"A\"`, `\"A.A\"`, and `\"B\"`, you can match all values\nstarting with `\"A\"` using a single rule.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ type: \"A\" } | { type: \"B\" } | { type: \"A.A\" } | {}>(),\n  Match.discriminatorStartsWith(\"type\")(\"A\", (_) => 1 as const),\n  Match.discriminatorStartsWith(\"type\")(\"B\", (_) => 2 as const),\n  Match.orElse((_) => 3 as const)\n)\n\nconsole.log(match({ type: \"A\" })) // 1\nconsole.log(match({ type: \"B\" })) // 2\nconsole.log(match({ type: \"A.A\" })) // 1\n```"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "declare const discriminatorStartsWith: <D extends string>(field: D) => <R, P extends string, Ret, Fn extends (_: Extract<R, Record<D, `${P}${string}`>>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>>, A | ReturnType<Fn>, Pr, Ret>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L565"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "discriminators",
    "description": "Matches values based on a field that serves as a discriminator, mapping each\npossible value to a corresponding handler.\n\n**Details**\n\nThis function simplifies working with discriminated unions by letting you\ndefine a set of handlers for each possible value of a given field. Instead of\nchaining multiple calls to {@link discriminator}, this function allows\ndefining all possible cases at once using an object where the keys are the\npossible values of the field, and the values are the corresponding handler\nfunctions.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n  Match.discriminators(\"type\")({\n    A: (a) => a.a,\n    B: (b) => b.b,\n    C: (c) => c.c\n  }),\n  Match.exhaustive\n)\n```"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "declare const discriminators: <D extends string>(field: D) => <R, Ret, P extends { readonly [Tag in Types.Tags<D, R> & string]?: ((_: Extract<R, Record<D, Tag>>) => Ret) | undefined; } & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>>, A | ReturnType<P[keyof P] & {}>, Pr, Ret>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L612"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "discriminatorsExhaustive",
    "description": "Matches values based on a discriminator field and **ensures all cases are\nhandled**.\n\n**Details*+\n\nThis function is similar to {@link discriminators}, but **requires that all\npossible cases** are explicitly handled. It is useful when working with\ndiscriminated unions, where a specific field (e.g., `\"type\"`) determines the\nshape of an object. Each possible value of the field must have a\ncorresponding handler, ensuring **exhaustiveness checking** at compile time.\n\nThis function **does not require** `Match.exhaustive` at the end of the\npipeline because it enforces exhaustiveness by design.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n  Match.discriminatorsExhaustive(\"type\")({\n    A: (a) => a.a,\n    B: (b) => b.b,\n    C: (c) => c.c\n  })\n)\n```"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "declare const discriminatorsExhaustive: <D extends string>(field: D) => <R, Ret, P extends { readonly [Tag in Types.Tags<D, R> & string]: (_: Extract<R, Record<D, Tag>>) => Ret; } & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L665"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "tag",
    "description": "The `Match.tag` function allows pattern matching based on the `_tag` field in\na [Discriminated Union](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions).\nYou can specify multiple tags to match within a single pattern.\n\n**Note**\n\nThe `Match.tag` function relies on the convention within the Effect ecosystem\nof naming the tag field as `\"_tag\"`. Ensure that your discriminated unions\nfollow this naming convention for proper functionality.\n\n**Example** (Matching a Discriminated Union by Tag)\n\n```ts\nimport { Match } from \"effect\"\n\ntype Event =\n  | { readonly _tag: \"fetch\" }\n  | { readonly _tag: \"success\"; readonly data: string }\n  | { readonly _tag: \"error\"; readonly error: Error }\n  | { readonly _tag: \"cancel\" }\n\n// Create a Matcher for Either<number, string>\nconst match = Match.type<Event>().pipe(\n  // Match either \"fetch\" or \"success\"\n  Match.tag(\"fetch\", \"success\", () => `Ok!`),\n  // Match \"error\" and extract the error message\n  Match.tag(\"error\", (event) => `Error: ${event.error.message}`),\n  // Match \"cancel\"\n  Match.tag(\"cancel\", () => \"Cancelled\"),\n  Match.exhaustive\n)\n\nconsole.log(match({ _tag: \"success\", data: \"Hello\" }))\n// Output: \"Ok!\"\n\nconsole.log(match({ _tag: \"error\", error: new Error(\"Oops!\") }))\n// Output: \"Error: Oops!\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "declare const tag: <R, P extends Types.Tags<\"_tag\", R> & string, Ret, Fn extends (_: Extract<R, Record<\"_tag\", P>>) => Ret>(...pattern: [first: P, ...values: Array<P>, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", P>>>>, ReturnType<Fn> | A, Pr, Ret>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L723"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "tagStartsWith",
    "description": "Matches values where the `_tag` field starts with a given prefix.\n\n**Details**\n\nThis function allows you to match on values in a **discriminated union**\nbased on whether the `_tag` field starts with a specified prefix. It is\nuseful for handling hierarchical or namespaced tags, where multiple related\ncases share a common prefix.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ _tag: \"A\" } | { _tag: \"B\" } | { _tag: \"A.A\" } | {}>(),\n  Match.tagStartsWith(\"A\", (_) => 1 as const),\n  Match.tagStartsWith(\"B\", (_) => 2 as const),\n  Match.orElse((_) => 3 as const)\n)\n\nconsole.log(match({ _tag: \"A\" })) // 1\nconsole.log(match({ _tag: \"B\" })) // 2\nconsole.log(match({ _tag: \"A.A\" })) // 1\n```"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "declare const tagStartsWith: <R, P extends string, Ret, Fn extends (_: Extract<R, Record<\"_tag\", `${P}${string}`>>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", `${P}${string}`>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", `${P}${string}`>>>>, ReturnType<Fn> | A, Pr, Ret>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L770"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "tags",
    "description": "Matches values based on their `_tag` field, mapping each tag to a\ncorresponding handler.\n\n**Details**\n\nThis function provides a way to handle discriminated unions by mapping `_tag`\nvalues to specific functions. Each handler receives the matched value and\nreturns a transformed result. If all possible tags are handled, you can\nenforce exhaustiveness using `Match.exhaustive` to ensure no case is missed.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ _tag: \"A\"; a: string } | { _tag: \"B\"; b: number } | { _tag: \"C\"; c: boolean }>(),\n  Match.tags({\n    A: (a) => a.a,\n    B: (b) => b.b,\n    C: (c) => c.c\n  }),\n  Match.exhaustive\n)\n```"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "declare const tags: <R, Ret, P extends { readonly [Tag in Types.Tags<\"_tag\", R> & string]?: ((_: Extract<R, Record<\"_tag\", Tag>>) => Ret) | undefined; } & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", keyof P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", keyof P>>>>, A | ReturnType<P[keyof P] & {}>, Pr, Ret>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L818"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "tagsExhaustive",
    "description": "Matches values based on their `_tag` field and requires handling of all\npossible cases.\n\n**Details**\n\nThis function is designed for **discriminated unions** where every possible\n`_tag` value must have a corresponding handler. Unlike {@link tags}, this\nfunction ensures **exhaustiveness**, meaning all cases must be explicitly\nhandled. If a `_tag` value is missing from the mapping, TypeScript will\nreport an error.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ _tag: \"A\"; a: string } | { _tag: \"B\"; b: number } | { _tag: \"C\"; c: boolean }>(),\n  Match.tagsExhaustive({\n    A: (a) => a.a,\n    B: (b) => b.b,\n    C: (c) => c.c\n  })\n)\n```"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "declare const tagsExhaustive: <R, Ret, P extends { readonly [Tag in Types.Tags<\"_tag\", R> & string]: (_: Extract<R, Record<\"_tag\", Tag>>) => Ret; } & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L866"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "not",
    "description": "Excludes a specific value from matching while allowing all others.\n\n**Details**\n\nThis function is useful when you need to **handle all values except one or\nmore specific cases**. Instead of listing all possible matches manually, this\nfunction simplifies the logic by allowing you to specify values to exclude.\nAny excluded value will bypass the provided function and continue matching\nthrough other cases.\n\n**Example** (Ignoring a Specific Value)\n\n```ts\nimport { Match } from \"effect\"\n\n// Create a matcher for string or number values\nconst match = Match.type<string | number>().pipe(\n  // Match any value except \"hi\", returning \"ok\"\n  Match.not(\"hi\", () => \"ok\"),\n  // Fallback case for when the value is \"hi\"\n  Match.orElse(() => \"fallback\")\n)\n\nconsole.log(match(\"hello\"))\n// Output: \"ok\"\n\nconsole.log(match(\"hi\"))\n// Output: \"fallback\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "declare const not: <R, const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>, Ret, Fn extends (_: Exclude<R, Types.ExtractMatch<R, Types.PForExclude<P>>>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddOnly<F, Types.WhenMatch<R, P>>, Types.ApplyFilters<I, Types.AddOnly<F, Types.WhenMatch<R, P>>>, A | ReturnType<Fn>, Pr, Ret>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L913"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "nonEmptyString",
    "description": "Matches non-empty strings.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "declare const nonEmptyString: SafeRefinement<string, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L938"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "is",
    "description": "Matches a specific set of literal values (e.g., `Match.is(\"a\", 42, true)`).",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "declare const is: <Literals extends ReadonlyArray<string | number | bigint | boolean | null>>(...literals: Literals) => Predicate.Refinement<unknown, Literals[number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L946"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "string",
    "description": "Matches values of type `string`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "declare const string: Predicate.Refinement<unknown, string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L956"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "number",
    "description": "Matches values of type `number`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "declare const number: Predicate.Refinement<unknown, number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L964"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "any",
    "description": "Matches any value without restrictions.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "declare const any: SafeRefinement<unknown, any>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L972"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "defined",
    "description": "Matches any defined (non-null and non-undefined) value.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "declare const defined: <A>(u: A) => u is A & {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L980"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "boolean",
    "description": "Matches values of type `boolean`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "declare const boolean: Predicate.Refinement<unknown, boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L988"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "bigint",
    "description": "Matches values of type `bigint`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "declare const bigint: Predicate.Refinement<unknown, bigint>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1018"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "symbol",
    "description": "Matches values of type `symbol`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "declare const symbol: Predicate.Refinement<unknown, symbol>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1026"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "date",
    "description": "Matches values that are instances of `Date`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "declare const date: Predicate.Refinement<unknown, Date>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1034"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "record",
    "description": "Matches objects where keys are `string` or `symbol` and values are `unknown`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "declare const record: Predicate.Refinement<unknown, { [x: string]: unknown; [x: symbol]: unknown; }>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1042"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "instanceOf",
    "description": "Matches instances of a given class.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "declare const instanceOf: <A extends abstract new (...args: any) => any>(constructor: A) => SafeRefinement<InstanceType<A>, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1050"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "instanceOfUnsafe",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "declare const instanceOfUnsafe: <A extends abstract new (...args: any) => any>(constructor: A) => SafeRefinement<InstanceType<A>, InstanceType<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1058"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "orElse",
    "description": "Provides a fallback value when no patterns match.\n\n**Details**\n\nThis function ensures that a matcher always returns a valid result, even if\nno defined patterns match. It acts as a default case, similar to the\n`default` clause in a `switch` statement or the final `else` in an `if-else`\nchain.\n\n**Example** (Providing a Default Value When No Patterns Match)\n\n```ts\nimport { Match } from \"effect\"\n\n// Create a matcher for string or number values\nconst match = Match.type<string | number>().pipe(\n  // Match when the value is \"a\"\n  Match.when(\"a\", () => \"ok\"),\n  // Fallback when no patterns match\n  Match.orElse(() => \"fallback\")\n)\n\nconsole.log(match(\"a\"))\n// Output: \"ok\"\n\nconsole.log(match(\"b\"))\n// Output: \"fallback\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Completion",
    "signature": "declare const orElse: <RA, Ret, F extends (_: RA) => Ret>(f: F) => <I, R, A, Pr>(self: Matcher<I, R, RA, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Unify<ReturnType<F> | A> : Unify<ReturnType<F> | A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1095"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "orElseAbsurd",
    "description": "Throws an error if no pattern matches.\n\n**Details**\n\nThis function finalizes a matcher by ensuring that if no patterns match, an\nerror is thrown. It is useful when all cases should be covered, and any\nunexpected input should trigger an error instead of returning a default\nvalue.\n\nWhen used, this function removes the need for an explicit fallback case and\nensures that an unmatched value is never silently ignored.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Completion",
    "signature": "declare const orElseAbsurd: <I, R, RA, A, Pr, Ret>(self: Matcher<I, R, RA, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Unify<A> : Unify<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1118"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "either",
    "description": "Wraps the match result in an `Either`, distinguishing matched and unmatched\ncases.\n\n**Details**\n\nThis function ensures that the result of a matcher is always wrapped in an\n`Either`, allowing clear differentiation between successful matches\n(`Right(value)`) and cases where no pattern matched (`Left(unmatched\nvalue)`).\n\nThis approach is particularly useful when handling optional values or when an\nunmatched case should be explicitly handled rather than returning a default\nvalue or throwing an error.\n\n**Example** (Extracting a User Role with `Match.either`)\n\n```ts\nimport { Match } from \"effect\"\n\ntype User = { readonly role: \"admin\" | \"editor\" | \"viewer\" }\n\n// Create a matcher to extract user roles\nconst getRole = Match.type<User>().pipe(\n  Match.when({ role: \"admin\" }, () => \"Has full access\"),\n  Match.when({ role: \"editor\" }, () => \"Can edit content\"),\n  Match.either // Wrap the result in an Either\n)\n\nconsole.log(getRole({ role: \"admin\" }))\n// Output: { _id: 'Either', _tag: 'Right', right: 'Has full access' }\n\nconsole.log(getRole({ role: \"viewer\" }))\n// Output: { _id: 'Either', _tag: 'Left', left: { role: 'viewer' } }\n```",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Completion",
    "signature": "declare const either: <I, F, R, A, Pr, Ret>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Either.Either<Unify<A>, R> : Either.Either<Unify<A>, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1161"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "option",
    "description": "Wraps the match result in an `Option`, representing an optional match.\n\n**Details**\n\nThis function ensures that the result of a matcher is wrapped in an `Option`,\nmaking it easy to handle cases where no pattern matches. If a match is found,\nit returns `Some(value)`, otherwise, it returns `None`.\n\nThis is useful in cases where a missing match is expected and should be\nhandled explicitly rather than throwing an error or returning a default\nvalue.\n\n**Example** (Extracting a User Role with `Match.option`)\n\n```ts\nimport { Match } from \"effect\"\n\ntype User = { readonly role: \"admin\" | \"editor\" | \"viewer\" }\n\n// Create a matcher to extract user roles\nconst getRole = Match.type<User>().pipe(\n  Match.when({ role: \"admin\" }, () => \"Has full access\"),\n  Match.when({ role: \"editor\" }, () => \"Can edit content\"),\n  Match.option // Wrap the result in an Option\n)\n\nconsole.log(getRole({ role: \"admin\" }))\n// Output: { _id: 'Option', _tag: 'Some', value: 'Has full access' }\n\nconsole.log(getRole({ role: \"viewer\" }))\n// Output: { _id: 'Option', _tag: 'None' }\n```",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Completion",
    "signature": "declare const option: <I, F, R, A, Pr, Ret>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Option.Option<Unify<A>> : Option.Option<Unify<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1202"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "exhaustive",
    "description": "The `Match.exhaustive` method finalizes the pattern matching process by\nensuring that all possible cases are accounted for. If any case is missing,\nTypeScript will produce a type error. This is particularly useful when\nworking with unions, as it helps prevent unintended gaps in pattern matching.\n\n**Example** (Ensuring All Cases Are Covered)\n\n```ts\nimport { Match } from \"effect\"\n\n// Create a matcher for string or number values\nconst match = Match.type<string | number>().pipe(\n  // Match when the value is a number\n  Match.when(Match.number, (n) => `number: ${n}`),\n  // Mark the match as exhaustive, ensuring all cases are handled\n  // TypeScript will throw an error if any case is missing\n  // @ts-expect-error Type 'string' is not assignable to type 'never'\n  Match.exhaustive\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Completion",
    "signature": "declare const exhaustive: <I, F, A, Pr, Ret>(self: Matcher<I, F, never, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A> : Unify<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1231"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "SafeRefinementId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Symbols",
    "signature": "declare const SafeRefinementId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1239"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "TypeMatcher",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Model",
    "signature": "export interface TypeMatcher<in Input, out Filters, out Remaining, out Result, out Return = any> extends Pipeable {\n  readonly _tag: \"TypeMatcher\"\n  readonly [MatcherTypeId]: {\n    readonly _input: T.Contravariant<Input>\n    readonly _filters: T.Covariant<Filters>\n    readonly _remaining: T.Covariant<Remaining>\n    readonly _result: T.Covariant<Result>\n    readonly _return: T.Covariant<Return>\n  }\n  readonly cases: ReadonlyArray<Case>\n  add<I, R, RA, A>(_case: Case): TypeMatcher<I, R, RA, A>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L95"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "ValueMatcher",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Model",
    "signature": "export interface ValueMatcher<in Input, Filters, out Remaining, out Result, Provided, out Return = any>\n  extends Pipeable\n{\n  readonly _tag: \"ValueMatcher\"\n  readonly [MatcherTypeId]: {\n    readonly _input: T.Contravariant<Input>\n    readonly _filters: T.Covariant<Filters>\n    readonly _result: T.Covariant<Result>\n    readonly _return: T.Covariant<Return>\n  }\n  readonly provided: Provided\n  readonly value: Either.Either<Provided, Remaining>\n  add<I, R, RA, A, Pr>(_case: Case): ValueMatcher<I, R, RA, A, Pr>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L112"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "When",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Model",
    "signature": "export interface When {\n  readonly _tag: \"When\"\n  guard(u: unknown): boolean\n  evaluate(input: unknown): any\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L137"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Not",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Model",
    "signature": "export interface Not {\n  readonly _tag: \"Not\"\n  guard(u: unknown): boolean\n  evaluate(input: unknown): any\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L147"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "SafeRefinement",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Model",
    "signature": "export interface SafeRefinement<in A, out R = A> {\n  readonly [SafeRefinementId]: (a: A) => R\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1251"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "MatcherTypeId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Symbols",
    "signature": "type MatcherTypeId = typeof MatcherTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L47"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Matcher",
    "description": "Pattern matching follows a structured process:\n\n- **Creating a matcher**: Define a `Matcher` that operates on either a\n  specific `Match.type` or `Match.value`.\n\n- **Defining patterns**: Use combinators such as `Match.when`, `Match.not`,\n  and `Match.tag` to specify matching conditions.\n\n- **Completing the match**: Apply a finalizer such as `Match.exhaustive`,\n  `Match.orElse`, or `Match.option` to determine how unmatched cases should\n  be handled.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Match } from \"effect\"\n\n// Simulated dynamic input that can be a string or a number\nconst input: string | number = \"some input\"\n\n//       string\n//      \nconst result = Match.value(input).pipe(\n  // Match if the value is a number\n  Match.when(Match.number, (n) => `number: ${n}`),\n  // Match if the value is a string\n  Match.when(Match.string, (s) => `string: ${s}`),\n  // Ensure all possible cases are covered\n  Match.exhaustive\n)\n\nconsole.log(result)\n// Output: \"string: some input\"\n```"
    ],
    "since": "1.0.0",
    "category": "Model",
    "signature": "type Matcher<Input, Filters, RemainingApplied, Result, Provided, Return> = | TypeMatcher<Input, Filters, RemainingApplied, Result, Return>\n  | ValueMatcher<Input, Filters, RemainingApplied, Result, Provided, Return>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L87"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Case",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Model",
    "signature": "type Case = When | Not",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L131"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "SafeRefinementId",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Symbols",
    "signature": "type SafeRefinementId = typeof SafeRefinementId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1245"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Types.Without",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "export interface Without<out X> {\n    readonly _tag: \"Without\"\n    readonly _X: X\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1349"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Types.Only",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "export interface Only<out X> {\n    readonly _tag: \"Only\"\n    readonly _X: X\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1357"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Types.WhenMatch",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type WhenMatch<R, P> = [0] extends [1 & R] ? PForMatch<P>\n      : P extends SafeRefinement<infer SP, never> ? SP\n      : P extends Predicate.Refinement<infer _R, infer RP>\n      // try to narrow refinement\n        ? [Extract<R, RP>] extends [infer X] ? [X] extends [never]\n            // fallback to original refinement\n            ? RP\n          : X\n        : never\n      : P extends PredicateA<infer PP> ? PP\n      : ExtractMatch<R, PForMatch<P>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1265"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Types.NotMatch",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type NotMatch<R, P> = Exclude<R, ExtractMatch<R, PForExclude<P>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1282"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Types.PForMatch",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type PForMatch<P> = [SafeRefinementP<ResolvePred<P>>] extends [infer X] ? X\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1287"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Types.PForExclude",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type PForExclude<P> = [SafeRefinementR<ToSafeRefinement<P>>] extends [infer X] ? X\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1293"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Types.PatternBase",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type PatternBase<A> = A extends ReadonlyArray<infer _T> ? ReadonlyArray<any> | PatternPrimitive<A>\n    : A extends Record<string, any> ? Partial<\n        { [K in keyof A]: PatternPrimitive<A[K] & {}> | PatternBase<A[K] & {}> }\n      >\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1335"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Types.PatternPrimitive",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type PatternPrimitive<A> = PredicateA<A> | A | SafeRefinement<any>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1344"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Types.AddWithout",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type AddWithout<A, X> = [A] extends [Without<infer WX>] ? Without<X | WX>\n    : [A] extends [Only<infer OX>] ? Only<Exclude<OX, X>>\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1365"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Types.AddOnly",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type AddOnly<A, X> = [A] extends [Without<infer WX>] ? [X] extends [WX] ? never\n    : Only<X>\n    : [A] extends [Only<infer OX>] ? [X] extends [OX] ? Only<X>\n      : never\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1372"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Types.ApplyFilters",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type ApplyFilters<I, A> = A extends Only<infer X> ? X\n    : A extends Without<infer X> ? Exclude<I, X>\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1381"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Types.Tags",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type Tags<D, P> = P extends Record<D, infer X> ? X : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1388"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Types.ArrayToIntersection",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type ArrayToIntersection<A> = T.UnionToIntersection<\n    A[number]\n  >",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1393"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match.ts",
      "path": "src/Match.ts"
    },
    "project": "effect",
    "name": "Types.ExtractMatch",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": null,
    "signature": "type ExtractMatch<I, P> = [ExtractAndNarrow<I, P>] extends [infer EI] ? EI\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Match.ts#L1400"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeDecision.ts",
      "path": "src/MergeDecision.ts"
    },
    "project": "effect",
    "name": "MergeDecisionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const MergeDecisionTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeDecision.ts#L13"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeDecision.ts",
      "path": "src/MergeDecision.ts"
    },
    "project": "effect",
    "name": "Done",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Done: <Z, E, R>(effect: Effect.Effect<Z, E, R>) => MergeDecision<R, unknown, unknown, E, Z>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeDecision.ts#L50"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeDecision.ts",
      "path": "src/MergeDecision.ts"
    },
    "project": "effect",
    "name": "Await",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Await: <R, E0, Z0, E, Z>(f: (exit: Exit.Exit<Z0, E0>) => Effect.Effect<Z, E, R>) => MergeDecision<R, E0, Z0, E, Z>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeDecision.ts#L56"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeDecision.ts",
      "path": "src/MergeDecision.ts"
    },
    "project": "effect",
    "name": "AwaitConst",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const AwaitConst: <Z, E, R>(effect: Effect.Effect<Z, E, R>) => MergeDecision<R, unknown, unknown, E, Z>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeDecision.ts#L64"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeDecision.ts",
      "path": "src/MergeDecision.ts"
    },
    "project": "effect",
    "name": "isMergeDecision",
    "description": "Returns `true` if the specified value is a `MergeDecision`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isMergeDecision: (u: unknown) => u is MergeDecision<unknown, unknown, unknown, unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeDecision.ts#L74"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeDecision.ts",
      "path": "src/MergeDecision.ts"
    },
    "project": "effect",
    "name": "match",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const match: { <R, E0, Z0, E, Z, Z2>(options: { readonly onDone: (effect: Effect.Effect<Z, E, R>) => Z2; readonly onAwait: (f: (exit: Exit.Exit<Z0, E0>) => Effect.Effect<Z, E, R>) => Z2; }): (self: MergeDecision<R, E0, Z0, E, Z>) => Z2; <R, E0, Z0, E, Z, Z2>(self: MergeDecision<R, E0, Z0, E, Z>, options: { readonly onDone: (effect: Effect.Effect<Z, E, R>) => Z2; readonly onAwait: (f: (exit: Exit.Exit<Z0, E0>) => Effect.Effect<Z, E, R>) => Z2; }): Z2; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeDecision.ts#L81"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeDecision.ts",
      "path": "src/MergeDecision.ts"
    },
    "project": "effect",
    "name": "MergeDecision",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MergeDecision<out R, in E0, in Z0, out E, out Z> extends MergeDecision.Variance<R, E0, Z0, E, Z> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeDecision.ts#L25"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MergeDecision.ts",
      "path": "src/MergeDecision.ts"
    },
    "project": "effect",
    "name": "MergeDecisionTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type MergeDecisionTypeId = typeof MergeDecisionTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeDecision.ts#L19"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeDecision.ts",
      "path": "src/MergeDecision.ts"
    },
    "project": "effect",
    "name": "MergeDecision.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out R, in E0, in Z0, out E, out Z> {\n    readonly [MergeDecisionTypeId]: {\n      _R: Types.Covariant<R>\n      _E0: Types.Contravariant<E0>\n      _Z0: Types.Contravariant<Z0>\n      _E: Types.Covariant<E>\n      _Z: Types.Covariant<Z>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeDecision.ts#L35"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "MergeStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const MergeStateTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L14"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "BothRunning",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const BothRunning: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(left: Fiber.Fiber<Either.Either<Elem, Done>, Err>, right: Fiber.Fiber<Either.Either<Elem, Done1>, Err1>) => MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L82"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "LeftDone",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const LeftDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(f: (exit: Exit.Exit<Done1, Err1>) => Effect.Effect<Done2, Err2, Env>) => MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L91"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "RightDone",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const RightDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(f: (exit: Exit.Exit<Done, Err>) => Effect.Effect<Done2, Err2, Env>) => MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L99"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "isMergeState",
    "description": "Returns `true` if the specified value is a `MergeState`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isMergeState: (u: unknown) => u is MergeState<unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L109"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "isBothRunning",
    "description": "Returns `true` if the specified `MergeState` is a `BothRunning`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isBothRunning: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is BothRunning<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L120"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "isLeftDone",
    "description": "Returns `true` if the specified `MergeState` is a `LeftDone`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isLeftDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is LeftDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L131"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "isRightDone",
    "description": "Returns `true` if the specified `MergeState` is a `RightDone`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isRightDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is RightDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L142"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "match",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const match: { <Env, Err, Err1, Err2, Elem, Done, Done1, Done2, Z>(options: { readonly onBothRunning: (left: Fiber.Fiber<Either.Either<Elem, Done>, Err>, right: Fiber.Fiber<Either.Either<Elem, Done1>, Err1>) => Z; readonly onLeftDone: (f: (exit: Exit.Exit<Done1, Err1>) => Effect.Effect<Done2, Err2, Env>) => Z; readonly onRightDone: (f: (exit: Exit.Exit<Done, Err>) => Effect.Effect<Done2, Err2, Env>) => Z; }): (self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => Z; <Env, Err, Err1, Err2, Elem, Done, Done1, Done2, Z>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>, options: { readonly onBothRunning: (left: Fiber.Fiber<Either.Either<Elem, Done>, Err>, right: Fiber.Fiber<Either.Either<Elem, Done1>, Err1>) => Z; readonly onLeftDone: (f: (exit: Exit.Exit<Done1, Err1>) => Effect.Effect<Done2, Err2, Env>) => Z; readonly onRightDone: (f: (exit: Exit.Exit<Done, Err>) => Effect.Effect<Done2, Err2, Env>) => Z; }): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L150"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "BothRunning",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BothRunning<_Env, out Err, out Err1, _Err2, out Elem, out Done, out Done1, _Done2>\n  extends MergeState.Proto\n{\n  readonly _tag: \"BothRunning\"\n  readonly left: Fiber.Fiber<Either.Either<Elem, Done>, Err>\n  readonly right: Fiber.Fiber<Either.Either<Elem, Done1>, Err1>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L48"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "LeftDone",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface LeftDone<out Env, _Err, in Err1, out Err2, _Elem, _Done, in Done1, out Done2>\n  extends MergeState.Proto\n{\n  readonly _tag: \"LeftDone\"\n  f(exit: Exit.Exit<Done1, Err1>): Effect.Effect<Done2, Err2, Env>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L60"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "RightDone",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RightDone<out Env, in Err, _Err1, out Err2, _Elem, in Done, _Done1, out Done2>\n  extends MergeState.Proto\n{\n  readonly _tag: \"RightDone\"\n  f(exit: Exit.Exit<Done, Err>): Effect.Effect<Done2, Err2, Env>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L71"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "MergeStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type MergeStateTypeId = typeof MergeStateTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L20"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "MergeState",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2> = | BothRunning<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>\n  | LeftDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>\n  | RightDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L26"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeState.ts",
      "path": "src/MergeState.ts"
    },
    "project": "effect",
    "name": "MergeState.Proto",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Proto {\n    readonly [MergeStateTypeId]: MergeStateTypeId\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeState.ts#L39"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeStrategy.ts",
      "path": "src/MergeStrategy.ts"
    },
    "project": "effect",
    "name": "MergeStrategyTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const MergeStrategyTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L10"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeStrategy.ts",
      "path": "src/MergeStrategy.ts"
    },
    "project": "effect",
    "name": "BackPressure",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const BackPressure: (_: void) => MergeStrategy",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L57"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeStrategy.ts",
      "path": "src/MergeStrategy.ts"
    },
    "project": "effect",
    "name": "BufferSliding",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const BufferSliding: (_: void) => MergeStrategy",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L63"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeStrategy.ts",
      "path": "src/MergeStrategy.ts"
    },
    "project": "effect",
    "name": "isMergeStrategy",
    "description": "Returns `true` if the specified value is a `MergeStrategy`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isMergeStrategy: (u: unknown) => u is MergeStrategy",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L72"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeStrategy.ts",
      "path": "src/MergeStrategy.ts"
    },
    "project": "effect",
    "name": "isBackPressure",
    "description": "Returns `true` if the specified `MergeStrategy` is a `BackPressure`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isBackPressure: (self: MergeStrategy) => self is BackPressure",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L81"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeStrategy.ts",
      "path": "src/MergeStrategy.ts"
    },
    "project": "effect",
    "name": "isBufferSliding",
    "description": "Returns `true` if the specified `MergeStrategy` is a `BufferSliding`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isBufferSliding: (self: MergeStrategy) => self is BufferSliding",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L90"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeStrategy.ts",
      "path": "src/MergeStrategy.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Folds an `MergeStrategy` into a value of type `A`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const match: { <A>(options: { readonly onBackPressure: () => A; readonly onBufferSliding: () => A; }): (self: MergeStrategy) => A; <A>(self: MergeStrategy, options: { readonly onBackPressure: () => A; readonly onBufferSliding: () => A; }): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L98"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeStrategy.ts",
      "path": "src/MergeStrategy.ts"
    },
    "project": "effect",
    "name": "BackPressure",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BackPressure extends MergeStrategy.Proto {\n  readonly _tag: \"BackPressure\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L41"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeStrategy.ts",
      "path": "src/MergeStrategy.ts"
    },
    "project": "effect",
    "name": "BufferSliding",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BufferSliding extends MergeStrategy.Proto {\n  readonly _tag: \"BufferSliding\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L49"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MergeStrategy.ts",
      "path": "src/MergeStrategy.ts"
    },
    "project": "effect",
    "name": "MergeStrategyTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type MergeStrategyTypeId = typeof MergeStrategyTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L16"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MergeStrategy.ts",
      "path": "src/MergeStrategy.ts"
    },
    "project": "effect",
    "name": "MergeStrategy",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type MergeStrategy = BackPressure | BufferSliding",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L22"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeStrategy.ts",
      "path": "src/MergeStrategy.ts"
    },
    "project": "effect",
    "name": "MergeStrategy.Proto",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Proto {\n    readonly [MergeStrategyTypeId]: MergeStrategyTypeId\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MergeStrategy.ts#L32"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "MetricTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const MetricTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L23"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "globalMetricRegistry",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "globals",
    "signature": "declare const globalMetricRegistry: MetricRegistry.MetricRegistry",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L138"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: MetricApply",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L144"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "mapInput",
    "description": "Returns a new metric that is powered by this one, but which accepts updates\nof the specified new type, which must be transformable to the input type of\nthis metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapInput: { <In, In2>(f: (input: In2) => In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In2, Out>; <Type, In, Out, In2>(self: Metric<Type, In, Out>, f: (input: In2) => In): Metric<Type, In2, Out>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L154"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "counter",
    "description": "Represents a Counter metric that tracks cumulative numerical values over time.\nCounters can be incremented and decremented and provide a running total of changes.\n\n**Options**\n\n- description - A description of the counter.\n- bigint - Indicates if the counter uses 'bigint' data type.\n- incremental - Set to 'true' for a counter that only increases. With this configuration, Effect ensures that non-incremental updates have no impact on the counter, making it exclusively suitable for counting upwards.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Metric } from \"effect\"\n\nconst numberCounter = Metric.counter(\"count\", {\n  description: \"A number counter\"\n});\n\nconst bigintCounter = Metric.counter(\"count\", {\n  description: \"A bigint counter\",\n  bigint: true\n});\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const counter: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; readonly incremental?: boolean | undefined; }): Metric.Counter<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; readonly incremental?: boolean | undefined; }): Metric.Counter<bigint>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L186"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "frequency",
    "description": "Creates a Frequency metric to count occurrences of events.\nFrequency metrics are used to count the number of times specific events or incidents occur.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Metric } from \"effect\"\n\nconst errorFrequency = Metric.frequency(\"error_frequency\", {\n   description: \"Counts the occurrences of errors.\"\n});\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const frequency: (name: string, options?: { readonly description?: string | undefined; readonly preregisteredWords?: ReadonlyArray<string> | undefined; } | undefined) => Metric.Frequency<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L221"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "withConstantInput",
    "description": "Returns a new metric that is powered by this one, but which accepts updates\nof any type, and translates them to updates with the specified constant\nupdate value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const withConstantInput: { <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, unknown, Out>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Metric<Type, unknown, Out>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L236"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "fromMetricKey",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromMetricKey: <Type extends MetricKeyType.MetricKeyType<any, any>>(key: MetricKey.MetricKey<Type>) => Metric<Type, MetricKeyType.MetricKeyType.InType<Type>, MetricKeyType.MetricKeyType.OutType<Type>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L245"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "gauge",
    "description": "Represents a Gauge metric that tracks and reports a single numerical value at a specific moment.\nGauges are suitable for metrics that represent instantaneous values, such as memory usage or CPU load.\n\n**Options**\n\n- description - A description of the gauge metric.\n- bigint - Indicates if the counter uses 'bigint' data type.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Metric } from \"effect\"\n\nconst numberGauge = Metric.gauge(\"memory_usage\", {\n  description: \"A gauge for memory usage\"\n});\n\nconst bigintGauge = Metric.gauge(\"cpu_load\", {\n  description: \"A gauge for CPU load\",\n  bigint: true\n});\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const gauge: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; }): Metric.Gauge<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; }): Metric.Gauge<bigint>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L276"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "histogram",
    "description": "Represents a Histogram metric that records observations in specified value boundaries.\nHistogram metrics are useful for measuring the distribution of values within a range.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Metric, MetricBoundaries } from \"effect\"\n\nconst latencyHistogram = Metric.histogram(\"latency_histogram\",\n  MetricBoundaries.linear({ start: 0, width: 10, count: 11 }),\n  \"Measures the distribution of request latency.\"\n);\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const histogram: (name: string, boundaries: MetricBoundaries.MetricBoundaries, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, number, MetricState.MetricState.Histogram>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L304"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "increment",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const increment: (self: Metric.Counter<number> | Metric.Counter<bigint> | Metric.Gauge<number> | Metric.Gauge<bigint>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L314"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "incrementBy",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const incrementBy: { (amount: number): (self: Metric.Counter<number> | Metric.Counter<number>) => Effect.Effect<void>; (amount: bigint): (self: Metric.Counter<bigint> | Metric.Gauge<bigint>) => Effect.Effect<void>; (self: Metric.Counter<number> | Metric.Gauge<number>, amount: number): Effect.Effect<void>; (self: Metric.Counter<bigint> | Metric.Gauge<bigint>, amount: bigint): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L322"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Returns a new metric that is powered by this one, but which outputs a new\nstate type, determined by transforming the state type of this metric by the\nspecified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <Out, Out2>(f: (out: Out) => Out2): <Type, In>(self: Metric<Type, In, Out>) => Metric<Type, In, Out2>; <Type, In, Out, Out2>(self: Metric<Type, In, Out>, f: (out: Out) => Out2): Metric<Type, In, Out2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L337"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "mapType",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapType: { <Type, Type2>(f: (type: Type) => Type2): <In, Out>(self: Metric<Type, In, Out>) => Metric<Type2, In, Out>; <Type, In, Out, Type2>(self: Metric<Type, In, Out>, f: (type: Type) => Type2): Metric<Type2, In, Out>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L346"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "modify",
    "description": "Modifies the metric with the specified update message. For example, if the\nmetric were a gauge, the update would increment the method by the provided\namount.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.5",
    "category": "utils",
    "signature": "declare const modify: { <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L359"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "set",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "declare const set: { (value: number): (self: Metric.Gauge<number>) => Effect.Effect<void>; (value: bigint): (self: Metric.Gauge<bigint>) => Effect.Effect<void>; (self: Metric.Gauge<number>, value: number): Effect.Effect<void>; (self: Metric.Gauge<bigint>, value: bigint): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L368"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "snapshot",
    "description": "Captures a snapshot of all metrics recorded by the application.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const snapshot: Effect.Effect<Array<MetricPair.MetricPair.Untyped>, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L381"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "succeed",
    "description": "Creates a metric that ignores input and produces constant output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const succeed: <Out>(out: Out) => Metric<void, unknown, Out>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L389"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "sync",
    "description": "Creates a metric that ignores input and produces constant output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sync: <Out>(evaluate: LazyArg<Out>) => Metric<void, unknown, Out>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L397"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "summary",
    "description": "Creates a Summary metric that records observations and calculates quantiles.\nSummary metrics provide statistical information about a set of values, including quantiles.\n\n**Options**\n\n- name - The name of the Summary metric.\n- maxAge - The maximum age of observations to retain.\n- maxSize - The maximum number of observations to keep.\n- error - The error percentage when calculating quantiles.\n- quantiles - An `Chunk` of quantiles to calculate (e.g., [0.5, 0.9]).\n- description - An optional description of the Summary metric.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Metric, Chunk } from \"effect\"\n\nconst responseTimesSummary = Metric.summary({\n  name: \"response_times_summary\",\n  maxAge: \"60 seconds\", // Retain observations for 60 seconds.\n  maxSize: 1000, // Keep a maximum of 1000 observations.\n  error: 0.01, // Allow a 1% error when calculating quantiles.\n  quantiles: [0.5, 0.9, 0.99], // Calculate 50th, 90th, and 99th percentiles.\n  description: \"Measures the distribution of response times.\"\n});\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const summary: (options: { readonly name: string; readonly maxAge: Duration.DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: ReadonlyArray<number>; readonly description?: string | undefined; }) => Metric.Summary<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L429"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "summaryTimestamp",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const summaryTimestamp: (options: { readonly name: string; readonly maxAge: Duration.DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: ReadonlyArray<number>; readonly description?: string | undefined; }) => Metric.Summary<readonly [value: number, timestamp: number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L444"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "tagged",
    "description": "Returns a new metric, which is identical in every way to this one, except\nthe specified tags have been added to the tags of this metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const tagged: { <Type, In, Out>(key: string, value: string): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>; <Type, In, Out>(self: Metric<Type, In, Out>, key: string, value: string): Metric<Type, In, Out>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L463"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "taggedWithLabelsInput",
    "description": "Returns a new metric, which is identical in every way to this one, except\ndynamic tags are added based on the update values. Note that the metric\nreturned by this method does not return any useful information, due to the\ndynamic nature of the added tags.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const taggedWithLabelsInput: { <In>(f: (input: In) => Iterable<MetricLabel.MetricLabel>): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In, void>; <Type, In, Out>(self: Metric<Type, In, Out>, f: (input: In) => Iterable<MetricLabel.MetricLabel>): Metric<Type, In, void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L477"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "taggedWithLabels",
    "description": "Returns a new metric, which is identical in every way to this one, except\nthe specified tags have been added to the tags of this metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const taggedWithLabels: { <Type, In, Out>(extraTags: Iterable<MetricLabel.MetricLabel>): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>; <Type, In, Out>(self: Metric<Type, In, Out>, extraTags: Iterable<MetricLabel.MetricLabel>): Metric<Type, In, Out>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L494"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "timer",
    "description": "Creates a timer metric, based on a histogram, which keeps track of\ndurations in milliseconds. The unit of time will automatically be added to\nthe metric as a tag (i.e. `\"time_unit: milliseconds\"`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const timer: (name: string, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L507"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "timerWithBoundaries",
    "description": "Creates a timer metric, based on a histogram created from the provided\nboundaries, which keeps track of durations in milliseconds. The unit of time\nwill automatically be added to the metric as a tag (i.e.\n`\"time_unit: milliseconds\"`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const timerWithBoundaries: (name: string, boundaries: ReadonlyArray<number>, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L522"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "trackAll",
    "description": "Returns an aspect that will update this metric with the specified constant\nvalue every time the aspect is applied to an effect, regardless of whether\nthat effect fails or succeeds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "declare const trackAll: { <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L537"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "trackDefect",
    "description": "Returns an aspect that will update this metric with the defects of the\neffects that it is applied to.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "declare const trackDefect: { <Type, Out>(metric: Metric<Type, unknown, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, unknown, Out>): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L554"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "trackDefectWith",
    "description": "Returns an aspect that will update this metric with the result of applying\nthe specified function to the defect throwables of the effects that the\naspect is applied to.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "declare const trackDefectWith: { <Type, In, Out>(metric: Metric<Type, In, Out>, f: (defect: unknown) => In): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (defect: unknown) => In): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L567"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "trackDuration",
    "description": "Returns an aspect that will update this metric with the duration that the\neffect takes to execute. To call this method, the input type of the metric\nmust be `Duration`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "declare const trackDuration: { <Type, Out>(metric: Metric<Type, Duration.Duration, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, Duration.Duration, Out>): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L587"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "trackDurationWith",
    "description": "Returns an aspect that will update this metric with the duration that the\neffect takes to execute. To call this method, you must supply a function\nthat can convert the `Duration` to the input type of this metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "declare const trackDurationWith: { <Type, In, Out>(metric: Metric<Type, In, Out>, f: (duration: Duration.Duration) => In): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (duration: Duration.Duration) => In): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L605"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "trackError",
    "description": "Returns an aspect that will update this metric with the failure value of\nthe effects that it is applied to.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "declare const trackError: { <Type, In, Out>(metric: Metric<Type, In, Out>): <A, E extends In, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E extends In, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L624"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "trackErrorWith",
    "description": "Returns an aspect that will update this metric with the result of applying\nthe specified function to the error value of the effects that the aspect is\napplied to.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "declare const trackErrorWith: { <Type, In, Out, In2>(metric: Metric<Type, In, Out>, f: (error: In2) => In): <A, E extends In2, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E extends In2, R, Type, In, Out, In2>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (error: In2) => In): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L642"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "trackSuccess",
    "description": "Returns an aspect that will update this metric with the success value of\nthe effects that it is applied to.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "declare const trackSuccess: { <Type, In, Out>(metric: Metric<Type, In, Out>): <A extends In, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A extends In, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L661"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "trackSuccessWith",
    "description": "Returns an aspect that will update this metric with the result of applying\nthe specified function to the success value of the effects that the aspect is\napplied to.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "declare const trackSuccessWith: { <Type, In, Out, In2>(metric: Metric<Type, In, Out>, f: (value: In2) => In): <A extends In2, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A extends In2, E, R, Type, In, Out, In2>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (value: In2) => In): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L679"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "update",
    "description": "Updates the metric with the specified update message. For example, if the\nmetric were a counter, the update would increment the method by the\nprovided amount.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const update: { <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L699"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "value",
    "description": "Retrieves a snapshot of the value of the metric at this moment in time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const value: <Type, In, Out>(self: Metric<Type, In, Out>) => Effect.Effect<Out>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L710"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "withNow",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const withNow: <Type, In, Out>(self: Metric<Type, readonly [In, number], Out>) => Metric<Type, In, Out>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L716"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "zip",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zip: { <Type2, In2, Out2>(that: Metric<Type2, In2, Out2>): <Type, In, Out>(self: Metric<Type, In, Out>) => Metric<readonly [Type, Type2], readonly [In, In2], [Out, Out2]>; <Type, In, Out, Type2, In2, Out2>(self: Metric<Type, In, Out>, that: Metric<Type2, In2, Out2>): Metric<readonly [Type, Type2], readonly [In, In2], [Out, Out2]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L723"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "unsafeSnapshot",
    "description": "Unsafely captures a snapshot of all metrics recorded by the application.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeSnapshot: (_: void) => ReadonlyArray<MetricPair.MetricPair.Untyped>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L749"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "fiberStarted",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "metrics",
    "signature": "declare const fiberStarted: Metric.Counter<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L755"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "fiberSuccesses",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "metrics",
    "signature": "declare const fiberSuccesses: Metric.Counter<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L761"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "fiberFailures",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "metrics",
    "signature": "declare const fiberFailures: Metric.Counter<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L767"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "fiberLifetimes",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "metrics",
    "signature": "declare const fiberLifetimes: Metric<MetricKeyType.MetricKeyType.Histogram, number, MetricState.MetricState.Histogram>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L773"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "fiberActive",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "metrics",
    "signature": "declare const fiberActive: Metric.Counter<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L780"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "Metric",
    "description": "A `Metric<Type, In, Out>` represents a concurrent metric which accepts\nupdates of type `In` and are aggregated to a stateful value of type `Out`.\n\nFor example, a counter metric would have type `Metric<number, number>`,\nrepresenting the fact that the metric can be updated with numbers (the amount\nto increment or decrement the counter by), and the state of the counter is a\nnumber.\n\nThere are five primitive metric types supported by Effect:\n\n  - Counters\n  - Frequencies\n  - Gauges\n  - Histograms\n  - Summaries",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Metric<in out Type, in In, out Out> extends Metric.Variance<Type, In, Out>, Pipeable {\n  /**\n   * The type of the underlying primitive metric. For example, this could be\n   * `MetricKeyType.Counter` or `MetricKeyType.Gauge`.\n   */\n  readonly keyType: Type\n  unsafeUpdate(input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): void\n  unsafeValue(extraTags: ReadonlyArray<MetricLabel.MetricLabel>): Out\n  unsafeModify(input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): void\n  register(): this\n  <A extends In, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L51"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "MetricApply",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricApply {\n  <Type, In, Out>(\n    keyType: Type,\n    unsafeUpdate: (input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => void,\n    unsafeValue: (extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => Out,\n    unsafeModify: (input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => void\n  ): Metric<Type, In, Out>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L68"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "MetricTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type MetricTypeId = typeof MetricTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L29"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "Metric.Counter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Counter<In extends number | bigint>\n    extends Metric<MetricKeyType.MetricKeyType.Counter<In>, In, MetricState.MetricState.Counter<In>>\n  {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L85"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "Metric.Gauge",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Gauge<In extends number | bigint>\n    extends Metric<MetricKeyType.MetricKeyType.Gauge<In>, In, MetricState.MetricState.Gauge<In>>\n  {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L93"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "Metric.Frequency",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Frequency<In>\n    extends Metric<MetricKeyType.MetricKeyType.Frequency, In, MetricState.MetricState.Frequency>\n  {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L101"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "Metric.Histogram",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Histogram<In>\n    extends Metric<MetricKeyType.MetricKeyType.Histogram, In, MetricState.MetricState.Histogram>\n  {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L109"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "Metric.Summary",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Summary<In>\n    extends Metric<MetricKeyType.MetricKeyType.Summary, In, MetricState.MetricState.Summary>\n  {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L117"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Metric.ts",
      "path": "src/Metric.ts"
    },
    "project": "effect",
    "name": "Metric.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out Type, in In, out Out> {\n    readonly [MetricTypeId]: {\n      readonly _Type: Types.Invariant<Type>\n      readonly _In: Types.Contravariant<In>\n      readonly _Out: Types.Covariant<Out>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Metric.ts#L125"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricBoundaries.ts",
      "path": "src/MetricBoundaries.ts"
    },
    "project": "effect",
    "name": "MetricBoundariesTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const MetricBoundariesTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricBoundaries.ts#L12"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricBoundaries.ts",
      "path": "src/MetricBoundaries.ts"
    },
    "project": "effect",
    "name": "isMetricBoundaries",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isMetricBoundaries: (u: unknown) => u is MetricBoundaries",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricBoundaries.ts#L33"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricBoundaries.ts",
      "path": "src/MetricBoundaries.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: (iterable: Iterable<number>) => MetricBoundaries",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricBoundaries.ts#L39"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricBoundaries.ts",
      "path": "src/MetricBoundaries.ts"
    },
    "project": "effect",
    "name": "linear",
    "description": "A helper method to create histogram bucket boundaries for a histogram\nwith linear increasing values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const linear: (options: { readonly start: number; readonly width: number; readonly count: number; }) => MetricBoundaries",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricBoundaries.ts#L48"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricBoundaries.ts",
      "path": "src/MetricBoundaries.ts"
    },
    "project": "effect",
    "name": "exponential",
    "description": "A helper method to create histogram bucket boundaries for a histogram\nwith exponentially increasing values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const exponential: (options: { readonly start: number; readonly factor: number; readonly count: number; }) => MetricBoundaries",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricBoundaries.ts#L63"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricBoundaries.ts",
      "path": "src/MetricBoundaries.ts"
    },
    "project": "effect",
    "name": "MetricBoundaries",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricBoundaries extends Equal.Equal, Pipeable {\n  readonly [MetricBoundariesTypeId]: MetricBoundariesTypeId\n  readonly values: ReadonlyArray<number>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricBoundaries.ts#L24"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricBoundaries.ts",
      "path": "src/MetricBoundaries.ts"
    },
    "project": "effect",
    "name": "MetricBoundariesTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type MetricBoundariesTypeId = typeof MetricBoundariesTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricBoundaries.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "MetricHookTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const MetricHookTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L15"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <In, Out>(options: { readonly get: LazyArg<Out>; readonly update: (input: In) => void; readonly modify: (input: In) => void; }) => MetricHook<In, Out>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L95"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "counter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const counter: <A extends (number | bigint)>(key: MetricKey.MetricKey.Counter<A>) => MetricHook.Counter<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L105"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "frequency",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const frequency: (_key: MetricKey.MetricKey.Frequency) => MetricHook.Frequency",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L112"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "gauge",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const gauge: { (key: MetricKey.MetricKey.Gauge<number>, startAt: number): MetricHook.Gauge<number>; (key: MetricKey.MetricKey.Gauge<bigint>, startAt: bigint): MetricHook.Gauge<bigint>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L118"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "histogram",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const histogram: (key: MetricKey.MetricKey.Histogram) => MetricHook.Histogram",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L127"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "summary",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const summary: (key: MetricKey.MetricKey.Summary) => MetricHook.Summary",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L133"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "onUpdate",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const onUpdate: { <In, Out>(f: (input: In) => void): (self: MetricHook<In, Out>) => MetricHook<In, Out>; <In, Out>(self: MetricHook<In, Out>, f: (input: In) => void): MetricHook<In, Out>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L139"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "onModify",
    "deprecated": false,
    "examples": [],
    "since": "3.6.5",
    "category": "utils",
    "signature": "declare const onModify: { <In, Out>(f: (input: In) => void): (self: MetricHook<In, Out>) => MetricHook<In, Out>; <In, Out>(self: MetricHook<In, Out>, f: (input: In) => void): MetricHook<In, Out>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L148"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "MetricHook",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricHook<in In, out Out> extends MetricHook.Variance<In, Out>, Pipeable {\n  get(): Out\n  update(input: In): void\n  modify(input: In): void\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L27"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "MetricHookTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type MetricHookTypeId = typeof MetricHookTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L21"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "MetricHook.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in In, out Out> {\n    readonly [MetricHookTypeId]: {\n      readonly _In: Types.Contravariant<In>\n      readonly _Out: Types.Covariant<Out>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L83"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "MetricHook.Root",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Root = MetricHook<any, MetricState.MetricState.Untyped>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L41"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "MetricHook.Untyped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Untyped = MetricHook<any, any>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L47"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "MetricHook.Counter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Counter<A> = MetricHook<A, MetricState.MetricState.Counter<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L53"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "MetricHook.Gauge",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Gauge<A> = MetricHook<A, MetricState.MetricState.Gauge<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L59"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "MetricHook.Frequency",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Frequency = MetricHook<string, MetricState.MetricState.Frequency>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L65"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "MetricHook.Histogram",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Histogram = MetricHook<number, MetricState.MetricState.Histogram>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L71"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricHook.ts",
      "path": "src/MetricHook.ts"
    },
    "project": "effect",
    "name": "MetricHook.Summary",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Summary = MetricHook<readonly [number, number], MetricState.MetricState.Summary>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricHook.ts#L77"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "MetricKeyTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const MetricKeyTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "isMetricKey",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isMetricKey: (u: unknown) => u is MetricKey<MetricKeyType.MetricKeyType<unknown, unknown>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L100"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "counter",
    "description": "Creates a metric key for a counter, with the specified name.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const counter: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; readonly incremental?: boolean | undefined; }): MetricKey.Counter<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; readonly incremental?: boolean | undefined; }): MetricKey.Counter<bigint>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L109"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "frequency",
    "description": "Creates a metric key for a categorical frequency table, with the specified\nname.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const frequency: (name: string, options?: { readonly description?: string | undefined; readonly preregisteredWords?: ReadonlyArray<string> | undefined; } | undefined) => MetricKey.Frequency",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L135"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "gauge",
    "description": "Creates a metric key for a gauge, with the specified name.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const gauge: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; }): MetricKey.Gauge<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; }): MetricKey.Gauge<bigint>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L151"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "histogram",
    "description": "Creates a metric key for a histogram, with the specified name and boundaries.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const histogram: (name: string, boundaries: MetricBoundaries.MetricBoundaries, description?: string) => MetricKey.Histogram",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L168"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "summary",
    "description": "Creates a metric key for a summary, with the specified name, maxAge,\nmaxSize, error, and quantiles.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const summary: (options: { readonly name: string; readonly maxAge: Duration.DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: ReadonlyArray<number>; readonly description?: string | undefined; }) => MetricKey.Summary",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L181"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "tagged",
    "description": "Returns a new `MetricKey` with the specified tag appended.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const tagged: { (key: string, value: string): <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>) => MetricKey<Type>; <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>, key: string, value: string): MetricKey<Type>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L198"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "taggedWithLabels",
    "description": "Returns a new `MetricKey` with the specified tags appended.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const taggedWithLabels: { (extraTags: ReadonlyArray<MetricLabel.MetricLabel>): <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>) => MetricKey<Type>; <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): MetricKey<Type>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L216"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "MetricKey",
    "description": "A `MetricKey` is a unique key associated with each metric. The key is based\non a combination of the metric type, the name and tags associated with the\nmetric, an optional description of the key, and any other information to\ndescribe a metric, such as the boundaries of a histogram. In this way, it is\nimpossible to ever create different metrics with conflicting keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricKey<out Type extends MetricKeyType.MetricKeyType<any, any>>\n  extends MetricKey.Variance<Type>, Equal.Equal, Pipeable\n{\n  readonly name: string\n  readonly keyType: Type\n  readonly description: Option.Option<string>\n  readonly tags: ReadonlyArray<MetricLabel.MetricLabel>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L36"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "MetricKeyTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type MetricKeyTypeId = typeof MetricKeyTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L24"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "MetricKey.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out Type> {\n    readonly [MetricKeyTypeId]: {\n      _Type: Types.Covariant<Type>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L89"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "MetricKey.Untyped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Untyped = MetricKey<any>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L53"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "MetricKey.Counter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Counter<A> = MetricKey<MetricKeyType.MetricKeyType.Counter<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L59"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "MetricKey.Gauge",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Gauge<A> = MetricKey<MetricKeyType.MetricKeyType.Gauge<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L65"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "MetricKey.Frequency",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Frequency = MetricKey<MetricKeyType.MetricKeyType.Frequency>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L71"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "MetricKey.Histogram",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Histogram = MetricKey<MetricKeyType.MetricKeyType.Histogram>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L77"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKey.ts",
      "path": "src/MetricKey.ts"
    },
    "project": "effect",
    "name": "MetricKey.Summary",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Summary = MetricKey<MetricKeyType.MetricKeyType.Summary>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKey.ts#L83"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "MetricKeyTypeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const MetricKeyTypeTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L16"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "CounterKeyTypeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const CounterKeyTypeTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L28"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "FrequencyKeyTypeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const FrequencyKeyTypeTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L40"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "GaugeKeyTypeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const GaugeKeyTypeTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L52"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "HistogramKeyTypeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const HistogramKeyTypeTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L64"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "SummaryKeyTypeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const SummaryKeyTypeTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L76"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "counter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const counter: <A extends number | bigint>() => MetricKeyType.Counter<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L191"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "frequency",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const frequency: (options?: { readonly preregisteredWords?: ReadonlyArray<string> | undefined; } | undefined) => MetricKeyType.Frequency",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L197"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "gauge",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const gauge: <A extends number | bigint>() => MetricKeyType.Gauge<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L207"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "histogram",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const histogram: (boundaries: MetricBoundaries.MetricBoundaries) => MetricKeyType.Histogram",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L213"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "summary",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const summary: (options: { readonly maxAge: Duration.DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: ReadonlyArray<number>; }) => MetricKeyType.Summary",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L219"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "isMetricKeyType",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isMetricKeyType: (u: unknown) => u is MetricKeyType<unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L232"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "isCounterKey",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isCounterKey: (u: unknown) => u is MetricKeyType.Counter<number | bigint>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L238"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "isFrequencyKey",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isFrequencyKey: (u: unknown) => u is MetricKeyType.Frequency",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L244"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "isGaugeKey",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isGaugeKey: (u: unknown) => u is MetricKeyType.Gauge<number | bigint>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L250"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "isHistogramKey",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isHistogramKey: (u: unknown) => u is MetricKeyType.Histogram",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L256"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "isSummaryKey",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isSummaryKey: (u: unknown) => u is MetricKeyType.Summary",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L262"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "MetricKeyType",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "modelz",
    "signature": "export interface MetricKeyType<in In, out Out> extends MetricKeyType.Variance<In, Out>, Equal.Equal, Pipeable {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L88"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "MetricKeyTypeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type MetricKeyTypeTypeId = typeof MetricKeyTypeTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L22"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "CounterKeyTypeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type CounterKeyTypeTypeId = typeof CounterKeyTypeTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L34"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "FrequencyKeyTypeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type FrequencyKeyTypeTypeId = typeof FrequencyKeyTypeTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L46"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "GaugeKeyTypeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type GaugeKeyTypeTypeId = typeof GaugeKeyTypeTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L58"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "HistogramKeyTypeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type HistogramKeyTypeTypeId = typeof HistogramKeyTypeTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L70"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "SummaryKeyTypeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type SummaryKeyTypeTypeId = typeof SummaryKeyTypeTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L82"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "MetricKeyType.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in In, out Out> {\n    readonly [MetricKeyTypeTypeId]: {\n      readonly _In: Types.Contravariant<In>\n      readonly _Out: Types.Covariant<Out>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L153"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "MetricKeyType.Untyped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Untyped = MetricKeyType<any, any>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L98"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "MetricKeyType.Counter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Counter<A> = MetricKeyType<A, MetricState.MetricState.Counter<A>> & {\n    readonly [CounterKeyTypeTypeId]: CounterKeyTypeTypeId\n    readonly incremental: boolean\n    readonly bigint: boolean\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L104"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "MetricKeyType.Frequency",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Frequency = MetricKeyType<string, MetricState.MetricState.Frequency> & {\n    readonly [FrequencyKeyTypeTypeId]: FrequencyKeyTypeTypeId\n    readonly preregisteredWords: ReadonlyArray<string>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L114"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "MetricKeyType.Gauge",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Gauge<A> = MetricKeyType<A, MetricState.MetricState.Gauge<A>> & {\n    readonly [GaugeKeyTypeTypeId]: GaugeKeyTypeTypeId\n    readonly bigint: boolean\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L123"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "MetricKeyType.Histogram",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Histogram = MetricKeyType<number, MetricState.MetricState.Histogram> & {\n    readonly [HistogramKeyTypeTypeId]: HistogramKeyTypeTypeId\n    readonly boundaries: MetricBoundaries.MetricBoundaries\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L132"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "MetricKeyType.Summary",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Summary = MetricKeyType<readonly [number, number], MetricState.MetricState.Summary> & {\n    readonly [SummaryKeyTypeTypeId]: SummaryKeyTypeTypeId\n    readonly maxAge: Duration.Duration\n    readonly maxSize: number\n    readonly error: number\n    readonly quantiles: ReadonlyArray<number>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L141"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "MetricKeyType.InType",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type InType<Type> = [Type] extends [\n    {\n      readonly [MetricKeyTypeTypeId]: {\n        readonly _In: (_: infer In) => void\n      }\n    }\n  ] ? In\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L164"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType.ts",
      "path": "src/MetricKeyType.ts"
    },
    "project": "effect",
    "name": "MetricKeyType.OutType",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type OutType<Type> = [Type] extends [\n    {\n      readonly [MetricKeyTypeTypeId]: {\n        readonly _Out: (_: never) => infer Out\n      }\n    }\n  ] ? Out\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricKeyType.ts#L177"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricLabel.ts",
      "path": "src/MetricLabel.ts"
    },
    "project": "effect",
    "name": "MetricLabelTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const MetricLabelTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricLabel.ts#L12"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricLabel.ts",
      "path": "src/MetricLabel.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (key: string, value: string) => MetricLabel",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricLabel.ts#L41"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricLabel.ts",
      "path": "src/MetricLabel.ts"
    },
    "project": "effect",
    "name": "isMetricLabel",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isMetricLabel: (u: unknown) => u is MetricLabel",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricLabel.ts#L47"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricLabel.ts",
      "path": "src/MetricLabel.ts"
    },
    "project": "effect",
    "name": "MetricLabel",
    "description": "A `MetricLabel` represents a key value pair that allows analyzing metrics at\nan additional level of granularity.\n\nFor example if a metric tracks the response time of a service labels could\nbe used to create separate versions that track response times for different\nclients.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricLabel extends Equal.Equal, Pipeable {\n  readonly [MetricLabelTypeId]: MetricLabelTypeId\n  readonly key: string\n  readonly value: string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricLabel.ts#L31"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricLabel.ts",
      "path": "src/MetricLabel.ts"
    },
    "project": "effect",
    "name": "MetricLabelTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type MetricLabelTypeId = typeof MetricLabelTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricLabel.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPair.ts",
      "path": "src/MetricPair.ts"
    },
    "project": "effect",
    "name": "MetricPairTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const MetricPairTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPair.ts#L15"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPair.ts",
      "path": "src/MetricPair.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Type extends MetricKeyType.MetricKeyType<any, any>>(metricKey: MetricKey.MetricKey<Type>, metricState: MetricState.MetricState<MetricKeyType.MetricKeyType.OutType<Type>>) => MetricPair.Untyped",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPair.ts#L59"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPair.ts",
      "path": "src/MetricPair.ts"
    },
    "project": "effect",
    "name": "unsafeMake",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeMake: <Type extends MetricKeyType.MetricKeyType<any, any>>(metricKey: MetricKey.MetricKey<Type>, metricState: MetricState.MetricState.Untyped) => MetricPair.Untyped",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPair.ts#L68"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricPair.ts",
      "path": "src/MetricPair.ts"
    },
    "project": "effect",
    "name": "MetricPair",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface MetricPair<out Type extends MetricKeyType.MetricKeyType<any, any>>\n  extends MetricPair.Variance<Type>, Pipeable\n{\n  readonly metricKey: MetricKey.MetricKey<Type>\n  readonly metricState: MetricState.MetricState<MetricKeyType.MetricKeyType.OutType<Type>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPair.ts#L27"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricPair.ts",
      "path": "src/MetricPair.ts"
    },
    "project": "effect",
    "name": "MetricPairTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type MetricPairTypeId = typeof MetricPairTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPair.ts#L21"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricPair.ts",
      "path": "src/MetricPair.ts"
    },
    "project": "effect",
    "name": "MetricPair.Untyped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Untyped extends MetricPair<MetricKeyType.MetricKeyType<any, any>> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPair.ts#L42"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricPair.ts",
      "path": "src/MetricPair.ts"
    },
    "project": "effect",
    "name": "MetricPair.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out Type extends MetricKeyType.MetricKeyType<any, any>> {\n    readonly [MetricPairTypeId]: {\n      readonly _Type: Types.Covariant<Type>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPair.ts#L48"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling.ts",
      "path": "src/MetricPolling.ts"
    },
    "project": "effect",
    "name": "MetricPollingTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const MetricPollingTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L16"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling.ts",
      "path": "src/MetricPolling.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new polling metric from a metric and poll effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Type, In, Out, R, E>(metric: Metric.Metric<Type, In, Out>, poll: Effect.Effect<In, E, R>) => MetricPolling<Type, In, R, E, Out>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L49"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling.ts",
      "path": "src/MetricPolling.ts"
    },
    "project": "effect",
    "name": "collectAll",
    "description": "Collects all of the polling metrics into a single polling metric, which\npolls for, updates, and produces the outputs of all individual metrics.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const collectAll: <R, E, Out>(iterable: Iterable<MetricPolling<any, any, R, E, Out>>) => MetricPolling<Array<any>, Array<any>, R, E, Array<Out>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L61"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling.ts",
      "path": "src/MetricPolling.ts"
    },
    "project": "effect",
    "name": "launch",
    "description": "Returns an effect that will launch the polling metric in a background\nfiber, using the specified schedule.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const launch: { <A2, R2>(schedule: Schedule.Schedule<A2, unknown, R2>): <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<Fiber.Fiber<A2, E>, never, R2 | R | Scope.Scope>; <Type, In, R, E, Out, A2, R2>(self: MetricPolling<Type, In, R, E, Out>, schedule: Schedule.Schedule<A2, unknown, R2>): Effect.Effect<Fiber.Fiber<A2, E>, never, Scope.Scope | R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L72"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling.ts",
      "path": "src/MetricPolling.ts"
    },
    "project": "effect",
    "name": "poll",
    "description": "An effect that polls a value that may be fed to the metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const poll: <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<In, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L90"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling.ts",
      "path": "src/MetricPolling.ts"
    },
    "project": "effect",
    "name": "pollAndUpdate",
    "description": "An effect that polls for a value and uses the value to update the metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const pollAndUpdate: <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<void, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L99"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling.ts",
      "path": "src/MetricPolling.ts"
    },
    "project": "effect",
    "name": "retry",
    "description": "Returns a new polling metric whose poll function will be retried with the\nspecified retry policy.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const retry: { <X, E, R2>(policy: Schedule.Schedule<X, NoInfer<E>, R2>): <Type, In, R, Out>(self: MetricPolling<Type, In, R, E, Out>) => MetricPolling<Type, In, R2 | R, E, Out>; <Type, In, R, E, Out, X, R2>(self: MetricPolling<Type, In, R, E, Out>, policy: Schedule.Schedule<X, E, R2>): MetricPolling<Type, In, R | R2, E, Out>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L110"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling.ts",
      "path": "src/MetricPolling.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Zips this polling metric with the specified polling metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const zip: { <Type2, In2, R2, E2, Out2>(that: MetricPolling<Type2, In2, R2, E2, Out2>): <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => MetricPolling<readonly [Type, Type2], readonly [In, In2], R2 | R, E2 | E, [Out, Out2]>; <Type, In, R, E, Out, Type2, In2, R2, E2, Out2>(self: MetricPolling<Type, In, R, E, Out>, that: MetricPolling<Type2, In2, R2, E2, Out2>): MetricPolling<readonly [Type, Type2], readonly [In, In2], R | R2, E | E2, [Out, Out2]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L126"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricPolling.ts",
      "path": "src/MetricPolling.ts"
    },
    "project": "effect",
    "name": "MetricPolling",
    "description": "A `MetricPolling` is a combination of a metric and an effect that polls for\nupdates to the metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricPolling<in out Type, in out In, out R, out E, out Out> extends Pipeable {\n  readonly [MetricPollingTypeId]: MetricPollingTypeId\n  /**\n   * The metric that this `MetricPolling` polls to update.\n   */\n  readonly metric: Metric.Metric<Type, In, Out>\n  /**\n   * An effect that polls a value that may be fed to the metric.\n   */\n  readonly poll: Effect.Effect<In, E, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L31"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricPolling.ts",
      "path": "src/MetricPolling.ts"
    },
    "project": "effect",
    "name": "MetricPollingTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type MetricPollingTypeId = typeof MetricPollingTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricPolling.ts#L22"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricRegistry.ts",
      "path": "src/MetricRegistry.ts"
    },
    "project": "effect",
    "name": "MetricRegistryTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const MetricRegistryTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricRegistry.ts#L14"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricRegistry.ts",
      "path": "src/MetricRegistry.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (_: void) => MetricRegistry",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricRegistry.ts#L48"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricRegistry.ts",
      "path": "src/MetricRegistry.ts"
    },
    "project": "effect",
    "name": "MetricRegistry",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricRegistry {\n  readonly [MetricRegistryTypeId]: MetricRegistryTypeId\n  snapshot(): Array<MetricPair.MetricPair.Untyped>\n  get<Type extends MetricKeyType.MetricKeyType<any, any>>(\n    key: MetricKey.MetricKey<Type>\n  ): MetricHook.MetricHook<\n    MetricKeyType.MetricKeyType.InType<typeof key[\"keyType\"]>,\n    MetricKeyType.MetricKeyType.OutType<typeof key[\"keyType\"]>\n  >\n  getCounter<A extends (number | bigint)>(\n    key: MetricKey.MetricKey.Counter<A>\n  ): MetricHook.MetricHook.Counter<A>\n  getFrequency(key: MetricKey.MetricKey.Frequency): MetricHook.MetricHook.Frequency\n  getGauge<A extends (number | bigint)>(key: MetricKey.MetricKey.Gauge<A>): MetricHook.MetricHook.Gauge<A>\n  getHistogram(key: MetricKey.MetricKey.Histogram): MetricHook.MetricHook.Histogram\n  getSummary(key: MetricKey.MetricKey.Summary): MetricHook.MetricHook.Summary\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricRegistry.ts#L26"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricRegistry.ts",
      "path": "src/MetricRegistry.ts"
    },
    "project": "effect",
    "name": "MetricRegistryTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type MetricRegistryTypeId = typeof MetricRegistryTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricRegistry.ts#L20"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "MetricStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const MetricStateTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L15"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "CounterStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const CounterStateTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L27"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "FrequencyStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const FrequencyStateTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L39"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "GaugeStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const GaugeStateTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L51"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "HistogramStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const HistogramStateTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L63"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "SummaryStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const SummaryStateTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L75"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "counter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const counter: { (count: number): MetricState.Counter<number>; (count: bigint): MetricState.Counter<bigint>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L174"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "frequency",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const frequency: (occurrences: ReadonlyMap<string, number>) => MetricState.Frequency",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L183"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "gauge",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const gauge: { (count: number): MetricState.Gauge<number>; (count: bigint): MetricState.Gauge<bigint>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L189"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "histogram",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const histogram: (options: { readonly buckets: ReadonlyArray<readonly [number, number]>; readonly count: number; readonly min: number; readonly max: number; readonly sum: number; }) => MetricState.Histogram",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L198"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "summary",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const summary: (options: { readonly error: number; readonly quantiles: ReadonlyArray<readonly [number, Option.Option<number>]>; readonly count: number; readonly min: number; readonly max: number; readonly sum: number; }) => MetricState.Summary",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L212"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "isMetricState",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isMetricState: (u: unknown) => u is MetricState.Counter<number | bigint>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L227"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "isCounterState",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isCounterState: (u: unknown) => u is MetricState.Counter<number | bigint>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L233"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "isFrequencyState",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isFrequencyState: (u: unknown) => u is MetricState.Frequency",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L239"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "isGaugeState",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isGaugeState: (u: unknown) => u is MetricState.Gauge<number | bigint>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L245"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "isHistogramState",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isHistogramState: (u: unknown) => u is MetricState.Histogram",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L251"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "isSummaryState",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isSummaryState: (u: unknown) => u is MetricState.Summary",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L257"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "MetricState",
    "description": "A `MetricState` describes the state of a metric. The type parameter of a\nmetric state corresponds to the type of the metric key (`MetricStateType`).\nThis phantom type parameter is used to tie keys to their expected states.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricState<in A> extends MetricState.Variance<A>, Equal.Equal, Pipeable {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L91"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "MetricStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type MetricStateTypeId = typeof MetricStateTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L21"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "CounterStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type CounterStateTypeId = typeof CounterStateTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L33"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "FrequencyStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type FrequencyStateTypeId = typeof FrequencyStateTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L45"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "GaugeStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type GaugeStateTypeId = typeof GaugeStateTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L57"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "HistogramStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type HistogramStateTypeId = typeof HistogramStateTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L69"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "SummaryStateTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type SummaryStateTypeId = typeof SummaryStateTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L81"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "MetricState.Untyped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Untyped extends MetricState<any> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L101"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "MetricState.Counter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Counter<in out A extends (number | bigint)>\n    extends MetricState<MetricKeyType.MetricKeyType.Counter<A>>\n  {\n    readonly [CounterStateTypeId]: CounterStateTypeId\n    readonly count: A\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L107"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "MetricState.Frequency",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Frequency extends MetricState<MetricKeyType.MetricKeyType.Frequency> {\n    readonly [FrequencyStateTypeId]: FrequencyStateTypeId\n    readonly occurrences: ReadonlyMap<string, number>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L118"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "MetricState.Gauge",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Gauge<in out A extends (number | bigint)> extends MetricState<MetricKeyType.MetricKeyType.Gauge<A>> {\n    readonly [GaugeStateTypeId]: GaugeStateTypeId\n    readonly value: A\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L127"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "MetricState.Histogram",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Histogram extends MetricState<MetricKeyType.MetricKeyType.Histogram> {\n    readonly [HistogramStateTypeId]: HistogramStateTypeId\n    readonly buckets: ReadonlyArray<readonly [number, number]>\n    readonly count: number\n    readonly min: number\n    readonly max: number\n    readonly sum: number\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L136"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "MetricState.Summary",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Summary extends MetricState<MetricKeyType.MetricKeyType.Summary> {\n    readonly [SummaryStateTypeId]: SummaryStateTypeId\n    readonly error: number\n    readonly quantiles: ReadonlyArray<readonly [number, Option.Option<number>]>\n    readonly count: number\n    readonly min: number\n    readonly max: number\n    readonly sum: number\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L149"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricState.ts",
      "path": "src/MetricState.ts"
    },
    "project": "effect",
    "name": "MetricState.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in A> {\n    readonly [MetricStateTypeId]: {\n      readonly _A: Types.Contravariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MetricState.ts#L163"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroSchedulerDefault",
    "deprecated": false,
    "examples": [],
    "since": "3.5.9",
    "category": "scheduler",
    "signature": "declare class MicroSchedulerDefault",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1777"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MaxOpsBeforeYield",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "references",
    "signature": "declare class MaxOpsBeforeYield",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2029"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "CurrentConcurrency",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "environment refs",
    "signature": "declare class CurrentConcurrency",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2042"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "CurrentScheduler",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "environment refs",
    "signature": "declare class CurrentScheduler",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2055"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "NoSuchElementException",
    "description": "Represents a checked exception which occurs when an expected element was\nunable to be found.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.4",
    "category": "errors",
    "signature": "declare class NoSuchElementException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4395"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "TimeoutException",
    "description": "Represents a checked exception which occurs when a timeout occurs.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.4",
    "category": "errors",
    "signature": "declare class TimeoutException",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4404"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "type ids",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L40"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroExitTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "MicroExit",
    "signature": "declare const MicroExitTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L54"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroCauseTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "declare const MicroCauseTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L162"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "causeWithTrace",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "declare const causeWithTrace: { (trace: string): <E>(self: MicroCause<E>) => MicroCause<E>; <E>(self: MicroCause<E>, trace: string): MicroCause<E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L392"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroFiberTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroFiber",
    "signature": "declare const MicroFiberTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L416"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "succeed",
    "description": "Creates a `Micro` effect that will succeed with the specified constant value.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const succeed: <A>(value: A) => Micro<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L827"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "failCause",
    "description": "Creates a `Micro` effect that will fail with the specified `MicroCause`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "constructors",
    "signature": "declare const failCause: <E>(cause: MicroCause<E>) => Micro<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L843"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "sync",
    "description": "Creates a `Micro` effect that succeeds with a lazily evaluated value.\n\nIf the evaluation of the value throws an error, the effect will fail with a\n`Die` variant of the `MicroCause` type.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const sync: <A>(evaluate: LazyArg<A>) => Micro<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L877"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "suspend",
    "description": "Lazily creates a `Micro` effect from the given side-effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const suspend: <A, E, R>(evaluate: LazyArg<Micro<A, E, R>>) => Micro<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L893"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "yieldNowWith",
    "description": "Pause the execution of the current `Micro` effect, and resume it on the next\nscheduler tick.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const yieldNowWith: (priority?: number) => Micro<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L908"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "yieldNow",
    "description": "Pause the execution of the current `Micro` effect, and resume it on the next\nscheduler tick.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const yieldNow: Micro<void, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L930"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "succeedNone",
    "description": "Creates a `Micro` effect that succeeds with `None`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const succeedNone: Micro<Option.Option<never>, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L948"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "withMicroFiber",
    "description": "Create a `Micro` effect using the current `MicroFiber`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const withMicroFiber: <A, E = never, R = never>(evaluate: (fiber: MicroFiberImpl<A, E>) => Micro<A, E, R>) => Micro<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1111"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "yieldFlush",
    "description": "Flush any yielded effects that are waiting to be executed.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const yieldFlush: Micro<void, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1127"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "never",
    "description": "A `Micro` that will never succeed or fail. It wraps `setInterval` to prevent\nthe Javascript runtime from exiting.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const never: Micro<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1212"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "as",
    "description": "Create a `Micro` effect that will replace the success value of the given\neffect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "declare const as: { <A, B>(value: B): <E, R>(self: Micro<A, E, R>) => Micro<B, E, R>; <A, E, R, B>(self: Micro<A, E, R>, value: B): Micro<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1259"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "andThen",
    "description": "A more flexible version of `flatMap` that combines `map` and `flatMap` into a\nsingle API.\n\nIt also lets you directly pass a `Micro` effect, which will be executed after\nthe current effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "declare const andThen: { <A, X>(f: (a: A) => X): <E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: (a: A) => X): [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: NotFunction<X>): [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1297"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "tap",
    "description": "Execute a side effect from the success value of the `Micro` effect.\n\nIt is similar to the `andThen` api, but the success value is ignored.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "declare const tap: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: NotFunction<X>): [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1338"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "race",
    "description": "Returns an effect that races two effects, yielding the value of the first\neffect to succeed. Losers of the race will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "sequencing",
    "signature": "declare const race: { <A2, E2, R2>(that: Micro<A2, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1491"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "raceFirst",
    "description": "Returns an effect that races two effects, yielding the value of the first\neffect to succeed *or* fail. Losers of the race will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "sequencing",
    "signature": "declare const raceFirst: { <A2, E2, R2>(that: Micro<A2, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1508"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Map the success value of this `Micro` effect to another `Micro` effect, then\nflatten the result.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "declare const flatMap: { <A, B, E2, R2>(f: (a: A) => Micro<B, E2, R2>): <E, R>(self: Micro<A, E, R>) => Micro<B, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (a: A) => Micro<B, E2, R2>): Micro<B, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1525"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms the success value of the `Micro` effect with the specified\nfunction.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Micro<A, E, R>) => Micro<B, E, R>; <A, E, R, B>(self: Micro<A, E, R>, f: (a: A) => B): Micro<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1576"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "exitSucceed",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "declare const exitSucceed: <A>(a: A) => MicroExit<A, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1649"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "exitFailCause",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "declare const exitFailCause: <E>(cause: MicroCause<E>) => MicroExit<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1656"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "exitInterrupt",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "declare const exitInterrupt: MicroExit<never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1663"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "exitVoid",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "declare const exitVoid: MicroExit<void, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1735"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "service",
    "description": "Access the given `Context.Tag` from the environment.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "environment",
    "signature": "declare const service: { <I, S>(tag: Context.Reference<I, S>): Micro<S>; <I, S>(tag: Context.Tag<I, S>): Micro<S, never, I>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1835"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "updateContext",
    "description": "Update the Context with the given mapping function.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "environment",
    "signature": "declare const updateContext: { <R2, R>(f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>): <A, E>(self: Micro<A, E, R>) => Micro<A, E, R2>; <A, E, R, R2>(self: Micro<A, E, R>, f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>): Micro<A, E, R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1864"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "updateService",
    "description": "Update the service for the given `Context.Tag` in the environment.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "environment",
    "signature": "declare const updateService: { <I, A>(tag: Context.Reference<I, A>, f: (value: A) => A): <XA, E, R>(self: Micro<XA, E, R>) => Micro<XA, E, R>; <I, A>(tag: Context.Tag<I, A>, f: (value: A) => A): <XA, E, R>(self: Micro<XA, E, R>) => Micro<XA, E, R | I>; <XA, E, R, I, A>(self: Micro<XA, E, R>, tag: Context.Reference<I, A>, f: (value: A) => A): Micro<XA, E, R>; <XA, E, R, I, A>(self: Micro<XA, E, R>, tag: Context.Tag<I, A>, f: (value: A) => A): Micro<XA, E, R | I>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1895"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "provideContext",
    "description": "Merge the given `Context` with the current context.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "environment",
    "signature": "declare const provideContext: { <XR>(context: Context.Context<XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, XR>>; <A, E, R, XR>(self: Micro<A, E, R>, context: Context.Context<XR>): Micro<A, E, Exclude<R, XR>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1951"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "provideService",
    "description": "Add the provided service to the current context.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "environment",
    "signature": "declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: S): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Micro<A, E, R>, tag: Context.Tag<I, S>, service: S): Micro<A, E, Exclude<R, I>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1974"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "provideServiceEffect",
    "description": "Create a service using the provided `Micro` effect, and add it to the\ncurrent context.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "environment",
    "signature": "declare const provideServiceEffect: { <I, S, E2, R2>(tag: Context.Tag<I, S>, acquire: Micro<S, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | E2, Exclude<R, I> | R2>; <A, E, R, I, S, E2, R2>(self: Micro<A, E, R>, tag: Context.Tag<I, S>, acquire: Micro<S, E2, R2>): Micro<A, E | E2, Exclude<R, I> | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2001"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "withConcurrency",
    "description": "If you have a `Micro` that uses `concurrency: \"inherit\"`, you can use this\napi to control the concurrency of that `Micro` when it is run.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as Micro from \"effect/Micro\"\n\nMicro.forEach([1, 2, 3], (n) => Micro.succeed(n), {\n  concurrency: \"inherit\"\n}).pipe(\n  Micro.withConcurrency(2) // use a concurrency of 2\n)\n```"
    ],
    "since": "3.4.0",
    "category": "environment refs",
    "signature": "declare const withConcurrency: { (concurrency: \"unbounded\" | number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, concurrency: \"unbounded\" | number): Micro<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2082"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Combine two `Micro` effects into a single effect that produces a tuple of\ntheir results.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "zipping",
    "signature": "declare const zip: { <A2, E2, R2>(that: Micro<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, E, R>(self: Micro<A, E, R>) => Micro<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; }): Micro<[A, A2], E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2110"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "description": "The `Micro.zipWith` function combines two `Micro` effects and allows you to\napply a function to the results of the combined effects, transforming them\ninto a single value.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.3",
    "category": "zipping",
    "signature": "declare const zipWith: { <A2, E2, R2, A, B>(that: Micro<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; }): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, B>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; }): Micro<B, E2 | E, R2 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2137"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "filterOrFailCause",
    "description": "Filter the specified effect with the provided function, failing with specified\n`MicroCause` if the predicate fails.\n\nIn addition to the filtering capabilities discussed earlier, you have the option to further\nrefine and narrow down the type of the success channel by providing a",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "filtering & conditionals",
    "signature": "declare const filterOrFailCause: { <A, B extends A, E2>(refinement: Refinement<A, B>, orFailWith: (a: NoInfer<A>) => MicroCause<E2>): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => MicroCause<E2>): <E, R>(self: Micro<A, E, R>) => Micro<A, E2 | E, R>; <A, E, R, B extends A, E2>(self: Micro<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => MicroCause<E2>): Micro<B, E | E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => MicroCause<E2>): Micro<A, E | E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2175"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "filterOrFail",
    "description": "Filter the specified effect with the provided function, failing with specified\nerror if the predicate fails.\n\nIn addition to the filtering capabilities discussed earlier, you have the option to further\nrefine and narrow down the type of the success channel by providing a",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "filtering & conditionals",
    "signature": "declare const filterOrFail: { <A, B extends A, E2>(refinement: Refinement<A, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Micro<A, E, R>) => Micro<A, E2 | E, R>; <A, E, R, B extends A, E2>(self: Micro<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): Micro<B, E | E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Micro<A, E | E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2211"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "when",
    "description": "The moral equivalent of `if (p) exp`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "filtering & conditionals",
    "signature": "declare const when: { <E2 = never, R2 = never>(condition: LazyArg<boolean> | Micro<boolean, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E | E2, R | R2>; <A, E, R, E2 = never, R2 = never>(self: Micro<A, E, R>, condition: LazyArg<boolean> | Micro<boolean, E2, R2>): Micro<Option.Option<A>, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2239"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "repeatExit",
    "description": "Repeat the given `Micro` using the provided options.\n\nThe `while` predicate will be checked after each iteration, and can use the\nfall `MicroExit` of the effect to determine if the repetition should continue.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "repetition",
    "signature": "declare const repeatExit: { <A, E>(options: { while: Predicate<MicroExit<A, E>>; times?: number | undefined; schedule?: MicroSchedule | undefined; }): <R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, options: { while: Predicate<MicroExit<A, E>>; times?: number | undefined; schedule?: MicroSchedule | undefined; }): Micro<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2270"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "repeat",
    "description": "Repeat the given `Micro` effect using the provided options. Only successful\nresults will be repeated.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "repetition",
    "signature": "declare const repeat: { <A, E>(options?: { while?: Predicate<A> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined; } | undefined): <R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, options?: { while?: Predicate<A> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined; } | undefined): Micro<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2320"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "replicate",
    "description": "Replicates the given effect `n` times.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "repetition",
    "signature": "declare const replicate: { (n: number): <A, E, R>(self: Micro<A, E, R>) => Array<Micro<A, E, R>>; <A, E, R>(self: Micro<A, E, R>, n: number): Array<Micro<A, E, R>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2356"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "replicateEffect",
    "description": "Performs this effect the specified number of times and collects the\nresults.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "repetition",
    "signature": "declare const replicateEffect: { (n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined; }): <A, E, R>(self: Micro<A, E, R>) => Micro<Array<A>, E, R>; (n: number, options: { readonly concurrency?: Concurrency | undefined; readonly discard: true; }): <A, E, R>(self: Micro<A, E, R>) => Micro<void, E, R>; <A, E, R>(self: Micro<A, E, R>, n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined; }): Micro<Array<A>, E, R>; <A, E, R>(self: Micro<A, E, R>, n: number, options: { readonly concurrency?: Concurrency | undefined; readonly discard: true; }): Micro<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2371"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "scheduleAddDelay",
    "description": "Returns a new `MicroSchedule` with an added calculated delay to each delay\nreturned by this schedule.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "declare const scheduleAddDelay: { (f: () => number): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, f: () => number): MicroSchedule; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2478"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "scheduleWithMaxDelay",
    "description": "Transform a `MicroSchedule` to one that will have a delay that will never exceed\nthe specified maximum.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "declare const scheduleWithMaxDelay: { (max: number): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, max: number): MicroSchedule; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2495"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "scheduleWithMaxElapsed",
    "description": "Transform a `MicroSchedule` to one that will stop repeating after the specified\namount of time.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "declare const scheduleWithMaxElapsed: { (max: number): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, max: number): MicroSchedule; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2512"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "scheduleUnion",
    "description": "Combines two `MicroSchedule`s, by recurring if either schedule wants to\nrecur, using the minimum of the two durations between recurrences.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "declare const scheduleUnion: { (that: MicroSchedule): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, that: MicroSchedule): MicroSchedule; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2529"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "scheduleIntersect",
    "description": "Combines two `MicroSchedule`s, by recurring only if both schedules want to\nrecur, using the maximum of the two durations between recurrences.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "declare const scheduleIntersect: { (that: MicroSchedule): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, that: MicroSchedule): MicroSchedule; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2546"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "catchAllCause",
    "description": "Catch the full `MicroCause` object of the given `Micro` effect, allowing you to\nrecover from any kind of cause.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "declare const catchAllCause: { <E, B, E2, R2>(f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A | B, E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2567"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "catchCauseIf",
    "description": "Selectively catch a `MicroCause` object of the given `Micro` effect,\nusing the provided predicate to determine if the failure should be caught.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "declare const catchCauseIf: { <E, B, E2, R2, EB extends MicroCause<E>>(refinement: Refinement<MicroCause<E>, EB>, f: (cause: EB) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, Exclude<E, MicroCause.Error<EB>> | E2, R | R2>; <E, B, E2, R2>(predicate: Predicate<MicroCause<NoInfer<E>>>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E | E2, R | R2>; <A, E, R, B, E2, R2, EB extends MicroCause<E>>(self: Micro<A, E, R>, refinement: Refinement<MicroCause<E>, EB>, f: (cause: EB) => Micro<B, E2, R2>): Micro<A | B, Exclude<E, MicroCause.Error<EB>> | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, predicate: Predicate<MicroCause<NoInfer<E>>>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A | B, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2603"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "catchAll",
    "description": "Catch the error of the given `Micro` effect, allowing you to recover from it.\n\nIt only catches expected errors.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "declare const catchAll: { <E, B, E2, R2>(f: (e: NoInfer<E>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (e: NoInfer<E>) => Micro<B, E2, R2>): Micro<A | B, E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2643"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "catchAllDefect",
    "description": "Catch any unexpected errors of the given `Micro` effect, allowing you to recover from them.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "declare const catchAllDefect: { <E, B, E2, R2>(f: (defect: unknown) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A | B, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2663"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "tapErrorCause",
    "description": "Perform a side effect using the full `MicroCause` object of the given `Micro`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "declare const tapErrorCause: { <E, B, E2, R2>(f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2681"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "tapErrorCauseIf",
    "description": "Perform a side effect using if a `MicroCause` object matches the specified\npredicate.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "declare const tapErrorCauseIf: { <E, B, E2, R2, EB extends MicroCause<E>>(refinement: Refinement<MicroCause<E>, EB>, f: (a: EB) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <E, B, E2, R2>(predicate: (cause: NoInfer<MicroCause<E>>) => boolean, f: (a: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2, EB extends MicroCause<E>>(self: Micro<A, E, R>, refinement: Refinement<MicroCause<E>, EB>, f: (a: EB) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, predicate: (cause: NoInfer<MicroCause<E>>) => boolean, f: (a: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2705"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "tapError",
    "description": "Perform a side effect from expected errors of the given `Micro`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "declare const tapError: { <E, B, E2, R2>(f: (e: NoInfer<E>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (e: NoInfer<E>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2740"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "tapDefect",
    "description": "Perform a side effect from unexpected errors of the given `Micro`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "declare const tapDefect: { <E, B, E2, R2>(f: (defect: unknown) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2758"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "catchIf",
    "description": "Catch any expected errors that match the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "declare const catchIf: { <E, EB extends E, A2, E2, R2>(refinement: Refinement<NoInfer<E>, EB>, f: (e: EB) => Micro<A2, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A2 | A, E2 | Exclude<E, EB>, R2 | R>; <E, A2, E2, R2>(predicate: Predicate<NoInfer<E>>, f: (e: NoInfer<E>) => Micro<A2, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A2 | A, E | E2, R2 | R>; <A, E, R, EB extends E, A2, E2, R2>(self: Micro<A, E, R>, refinement: Refinement<E, EB>, f: (e: EB) => Micro<A2, E2, R2>): Micro<A | A2, E2 | Exclude<E, EB>, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, predicate: Predicate<E>, f: (e: E) => Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2776"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "catchTag",
    "description": "Recovers from the specified tagged error.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "declare const catchTag: { <K extends E extends { _tag: string; } ? E[\"_tag\"] : never, E, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => Micro<A1, E1, R1>): <A, R>(self: Micro<A, E, R>) => Micro<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E[\"_tag\"] : never, R1, E1, A1>(self: Micro<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Micro<A1, E1, R1>): Micro<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2816"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "mapErrorCause",
    "description": "Transform the full `MicroCause` object of the given `Micro` effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "declare const mapErrorCause: { <E, E2>(f: (e: MicroCause<E>) => MicroCause<E2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, f: (e: MicroCause<E>) => MicroCause<E2>): Micro<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2840"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "mapError",
    "description": "Transform any expected errors of the given `Micro` effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "declare const mapError: { <E, E2>(f: (e: E) => E2): <A, R>(self: Micro<A, E, R>) => Micro<A, E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, f: (e: E) => E2): Micro<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2856"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "orElseSucceed",
    "description": "Recover from all errors by succeeding with the given value.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "declare const orElseSucceed: { <B>(f: LazyArg<B>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | B, never, R>; <A, E, R, B>(self: Micro<A, E, R>, f: LazyArg<B>): Micro<A | B, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2881"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "retry",
    "description": "Retry the given `Micro` effect using the provided options.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "declare const retry: { <A, E>(options?: { while?: Predicate<E> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined; } | undefined): <R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, options?: { while?: Predicate<E> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined; } | undefined): Micro<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2944"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "withTrace",
    "description": "Add a stack trace to any failures that occur in the effect. The trace will be\nadded to the `traces` field of the `MicroCause` object.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "declare const withTrace: { (name: string): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, name: string): Micro<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2983"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "matchCauseEffect",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "pattern matching",
    "signature": "declare const matchCauseEffect: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: MicroCause<E>) => Micro<A2, E2, R2>; readonly onSuccess: (a: A) => Micro<A3, E3, R3>; }): <R>(self: Micro<A, E, R>) => Micro<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Micro<A, E, R>, options: { readonly onFailure: (cause: MicroCause<E>) => Micro<A2, E2, R2>; readonly onSuccess: (a: A) => Micro<A3, E3, R3>; }): Micro<A2 | A3, E2 | E3, R2 | R3 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3019"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "matchCause",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "pattern matching",
    "signature": "declare const matchCause: { <E, A2, A, A3>(options: { readonly onFailure: (cause: MicroCause<E>) => A2; readonly onSuccess: (a: A) => A3; }): <R>(self: Micro<A, E, R>) => Micro<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Micro<A, E, R>, options: { readonly onFailure: (cause: MicroCause<E>) => A2; readonly onSuccess: (a: A) => A3; }): Micro<A2 | A3, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3060"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "matchEffect",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "pattern matching",
    "signature": "declare const matchEffect: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (e: E) => Micro<A2, E2, R2>; readonly onSuccess: (a: A) => Micro<A3, E3, R3>; }): <R>(self: Micro<A, E, R>) => Micro<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Micro<A, E, R>, options: { readonly onFailure: (e: E) => Micro<A2, E2, R2>; readonly onSuccess: (a: A) => Micro<A3, E3, R3>; }): Micro<A2 | A3, E2 | E3, R2 | R3 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3094"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "match",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "pattern matching",
    "signature": "declare const match: { <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: Micro<A, E, R>) => Micro<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Micro<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): Micro<A2 | A3, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3128"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "delay",
    "description": "Returns an effect that will delay the execution of this effect by the\nspecified duration.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "delays & timeouts",
    "signature": "declare const delay: { (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3186"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "timeoutOrElse",
    "description": "Returns an effect that will timeout this effect, that will execute the\nfallback effect if the timeout elapses before the effect has produced a value.\n\nIf the timeout elapses, the running effect will be safely interrupted.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "delays & timeouts",
    "signature": "declare const timeoutOrElse: { <A2, E2, R2>(options: { readonly duration: number; readonly onTimeout: LazyArg<Micro<A2, E2, R2>>; }): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, options: { readonly duration: number; readonly onTimeout: LazyArg<Micro<A2, E2, R2>>; }): Micro<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3204"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "timeout",
    "description": "Returns an effect that will timeout this effect, that will fail with a\n`TimeoutException` if the timeout elapses before the effect has produced a\nvalue.\n\nIf the timeout elapses, the running effect will be safely interrupted.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "delays & timeouts",
    "signature": "declare const timeout: { (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | TimeoutException, R>; <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E | TimeoutException, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3233"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "timeoutOption",
    "description": "Returns an effect that will timeout this effect, succeeding with a `None`\nif the timeout elapses before the effect has produced a value; and `Some` of\nthe produced value otherwise.\n\nIf the timeout elapses, the running effect will be safely interrupted.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "delays & timeouts",
    "signature": "declare const timeoutOption: { (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E, R>; <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<Option.Option<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3253"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroScopeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "declare const MicroScopeTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3274"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroScope",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "declare const MicroScope: Context.Tag<MicroScope, MicroScope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3315"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "scopeMake",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "declare const scopeMake: Micro<MicroScope.Closeable, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3385"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "scope",
    "description": "Access the current `MicroScope`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "declare const scope: Micro<MicroScope, never, MicroScope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3401"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "provideScope",
    "description": "Provide a `MicroScope` to an effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "declare const provideScope: { (scope: MicroScope): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, MicroScope>>; <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<A, E, Exclude<R, MicroScope>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3410"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "onExit",
    "description": "When the `Micro` effect is completed, run the given finalizer effect with the\n`MicroExit` of the executed effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "resources & finalization",
    "signature": "declare const onExit: { <A, E, XE, XR>(f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3469"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "ensuring",
    "description": "Regardless of the result of the this `Micro` effect, run the finalizer effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "declare const ensuring: { <XE, XR>(finalizer: Micro<void, XE, XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3498"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "onExitIf",
    "description": "When the `Micro` effect is completed, run the given finalizer effect if it\nmatches the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "resources & finalization",
    "signature": "declare const onExitIf: { <A, E, XE, XR, B extends MicroExit<A, E>>(refinement: Refinement<MicroExit<A, E>, B>, f: (exit: B) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, XE, XR>(predicate: Predicate<MicroExit<NoInfer<A>, NoInfer<E>>>, f: (exit: MicroExit<NoInfer<A>, NoInfer<E>>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR, B extends MicroExit<A, E>>(self: Micro<A, E, R>, refinement: Refinement<MicroExit<A, E>, B>, f: (exit: B) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, predicate: Predicate<MicroExit<NoInfer<A>, NoInfer<E>>>, f: (exit: MicroExit<NoInfer<A>, NoInfer<E>>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3522"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "onError",
    "description": "When the `Micro` effect fails, run the given finalizer effect with the\n`MicroCause` of the executed effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "resources & finalization",
    "signature": "declare const onError: { <A, E, XE, XR>(f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3558"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "onInterrupt",
    "description": "If this `Micro` effect is aborted, run the finalizer effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "resources & finalization",
    "signature": "declare const onInterrupt: { <XE, XR>(finalizer: Micro<void, XE, XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3581"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "interrupt",
    "description": "Abort the current `Micro` effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "interruption",
    "signature": "declare const interrupt: Micro<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3627"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "whileLoop",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "collecting & elements",
    "signature": "declare const whileLoop: <A, E, R>(options: { readonly while: LazyArg<boolean>; readonly body: LazyArg<Micro<A, E, R>>; readonly step: (a: A) => void; }) => Micro<void, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3832"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "Do",
    "description": "Start a do notation block.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "do notation",
    "signature": "declare const Do: Micro<{}, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4036"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "bindTo",
    "description": "Bind the success value of this `Micro` effect to the provided name.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "do notation",
    "signature": "declare const bindTo: { <N extends string>(name: N): <A, E, R>(self: Micro<A, E, R>) => Micro<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Micro<A, E, R>, name: N): Micro<{ [K in N]: A; }, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4045"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "bind",
    "description": "Bind the success value of this `Micro` effect to the provided name.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "do notation",
    "signature": "declare const bind: { <N extends string, A extends Record<string, any>, B, E2, R2>(name: N, f: (a: NoInfer<A>) => Micro<B, E2, R2>): <E, R>(self: Micro<A, E, R>) => Micro<Simplify<Omit<A, N> & { [K in N]: B; }>, E | E2, R | R2>; <A extends Record<string, any>, E, R, B, E2, R2, N extends string>(self: Micro<A, E, R>, name: N, f: (a: NoInfer<A>) => Micro<B, E2, R2>): Micro<Simplify<Omit<A, N> & { [K in N]: B; }>, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4057"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "forkIn",
    "description": "Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\naborted.\n\nThe lifetime of the handle will be attached to the provided `MicroScope`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "fiber & forking",
    "signature": "declare const forkIn: { (scope: MicroScope): <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>; <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<MicroFiber<A, E>, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4157"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "Error",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "errors",
    "signature": "declare const Error: new <A extends Record<string, any> = {}>(args: Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P]; }) => YieldableError & Readonly<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4357"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "isMicro",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "guards",
    "signature": "declare const isMicro: (u: unknown) => u is Micro<any, any, any>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L142"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "isMicroCause",
    "deprecated": false,
    "examples": [],
    "since": "3.6.6",
    "category": "guards",
    "signature": "declare const isMicroCause: (self: unknown) => self is MicroCause<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L196"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "causeFail",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "declare const causeFail: <E>(error: E, traces?: ReadonlyArray<string>) => MicroCause<E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L315"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "causeDie",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "declare const causeDie: (defect: unknown, traces?: ReadonlyArray<string>) => MicroCause<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L334"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "causeInterrupt",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "declare const causeInterrupt: (traces?: ReadonlyArray<string>) => MicroCause<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L350"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "causeIsFail",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "declare const causeIsFail: <E>(self: MicroCause<E>) => self is MicroCause.Fail<E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L359"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "causeIsDie",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "declare const causeIsDie: <E>(self: MicroCause<E>) => self is MicroCause.Die",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L368"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "causeIsInterrupt",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "declare const causeIsInterrupt: <E>(self: MicroCause<E>) => self is MicroCause.Interrupt",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L375"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "causeSquash",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "declare const causeSquash: <E>(self: MicroCause<E>) => unknown",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L384"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "fiberAwait",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroFiber",
    "signature": "declare const fiberAwait: <A, E>(self: MicroFiber<A, E>) => Micro<MicroExit<A, E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L610"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "fiberJoin",
    "deprecated": false,
    "examples": [],
    "since": "3.11.2",
    "category": "MicroFiber",
    "signature": "declare const fiberJoin: <A, E>(self: MicroFiber<A, E>) => Micro<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L618"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "fiberInterrupt",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroFiber",
    "signature": "declare const fiberInterrupt: <A, E>(self: MicroFiber<A, E>) => Micro<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L625"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "fiberInterruptAll",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroFiber",
    "signature": "declare const fiberInterruptAll: <A extends Iterable<MicroFiber<any, any>>>(fibers: A) => Micro<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L636"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "fail",
    "description": "Creates a `Micro` effect that fails with the given error.\n\nThis results in a `Fail` variant of the `MicroCause` type, where the error is\ntracked at the type level.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const fail: <E>(error: E) => Micro<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L865"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "succeedSome",
    "description": "Creates a `Micro` effect that will succeed with the value wrapped in `Some`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const succeedSome: <A>(a: A) => Micro<Option.Option<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L939"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "failCauseSync",
    "description": "Creates a `Micro` effect that will fail with the lazily evaluated `MicroCause`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const failCauseSync: <E>(evaluate: LazyArg<MicroCause<E>>) => Micro<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L957"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "die",
    "description": "Creates a `Micro` effect that will die with the specified error.\n\nThis results in a `Die` variant of the `MicroCause` type, where the error is\nnot tracked at the type level.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const die: (defect: unknown) => Micro<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L970"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "failSync",
    "description": "Creates a `Micro` effect that will fail with the lazily evaluated error.\n\nThis results in a `Fail` variant of the `MicroCause` type, where the error is\ntracked at the type level.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "constructors",
    "signature": "declare const failSync: <E>(error: LazyArg<E>) => Micro<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L982"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "fromOption",
    "description": "Converts an `Option` into a `Micro` effect, that will fail with\n`NoSuchElementException` if the option is `None`. Otherwise, it will succeed with the\nvalue of the option.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const fromOption: <A>(option: Option.Option<A>) => Micro<A, NoSuchElementException>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L993"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "fromEither",
    "description": "Converts an `Either` into a `Micro` effect, that will fail with the left side\nof the either if it is a `Left`. Otherwise, it will succeed with the right\nside of the either.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const fromEither: <R, L>(either: Either.Either<R, L>) => Micro<R, L>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1005"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "promise",
    "description": "Wrap a `Promise` into a `Micro` effect.\n\nAny errors will result in a `Die` variant of the `MicroCause` type, where the\nerror is not tracked at the type level.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const promise: <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>) => Micro<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1063"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "tryPromise",
    "description": "Wrap a `Promise` into a `Micro` effect. Any errors will be caught and\nconverted into a specific error type.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Micro } from \"effect\"\n\nMicro.tryPromise({\n  try: () => Promise.resolve(\"success\"),\n  catch: (cause) => new Error(\"caught\", { cause })\n})\n```"
    ],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const tryPromise: <A, E>(options: { readonly try: (signal: AbortSignal) => PromiseLike<A>; readonly catch: (error: unknown) => E; }) => Micro<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1089"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "async",
    "description": "Create a `Micro` effect from an asynchronous computation.\n\nYou can return a cleanup effect that will be run when the effect is aborted.\nIt is also passed an `AbortSignal` that is triggered when the effect is\naborted.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const async: <A, E = never, R = never>(register: (resume: (effect: Micro<A, E, R>) => void, signal: AbortSignal) => void | Micro<void, never, R>) => Micro<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1197"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "gen",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "declare const gen: <Self, Eff extends YieldWrap<Micro<any, any, any>>, AEff>(...args: [self: Self, body: (this: Self) => Generator<Eff, AEff, never>] | [body: () => Generator<Eff, AEff, never>]) => Micro<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Micro<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Micro<infer _A, infer _E, infer R>>] ? R : never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1222"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "asSome",
    "description": "Wrap the success value of this `Micro` effect in a `Some`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "declare const asSome: <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1271"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "flip",
    "description": "Swap the error and success types of the `Micro` effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "declare const flip: <A, E, R>(self: Micro<A, E, R>) => Micro<E, A, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1280"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "asVoid",
    "description": "Replace the success value of the `Micro` effect with `void`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "declare const asVoid: <A, E, R>(self: Micro<A, E, R>) => Micro<void, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1377"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "exit",
    "description": "Access the `MicroExit` of the given `Micro` effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "mapping & sequencing",
    "signature": "declare const exit: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroExit<A, E>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1386"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "sandbox",
    "description": "Replace the error type of the given `Micro` with the full `MicroCause` object.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "declare const sandbox: <A, E, R>(self: Micro<A, E, R>) => Micro<A, MicroCause<E>, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1399"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "raceAll",
    "description": "Returns an effect that races all the specified effects,\nyielding the value of the first effect to succeed with a value. Losers of\nthe race will be interrupted immediately",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "sequencing",
    "signature": "declare const raceAll: <Eff extends Micro<any, any, any>>(all: Iterable<Eff>) => Micro<Micro.Success<Eff>, Micro.Error<Eff>, Micro.Context<Eff>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1410"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "raceAllFirst",
    "description": "Returns an effect that races all the specified effects,\nyielding the value of the first effect to succeed or fail. Losers of\nthe race will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "sequencing",
    "signature": "declare const raceAllFirst: <Eff extends Micro<any, any, any>>(all: Iterable<Eff>) => Micro<Micro.Success<Eff>, Micro.Error<Eff>, Micro.Context<Eff>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1457"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens any nested `Micro` effects, merging the error and requirement types.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "declare const flatten: <A, E, R, E2, R2>(self: Micro<Micro<A, E, R>, E2, R2>) => Micro<A, E | E2, R | R2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1564"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "isMicroExit",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "declare const isMicroExit: (u: unknown) => u is MicroExit<unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1642"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "exitFail",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "declare const exitFail: <E>(e: E) => MicroExit<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1670"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "exitDie",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "declare const exitDie: (defect: unknown) => MicroExit<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1677"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "exitIsSuccess",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "declare const exitIsSuccess: <A, E>(self: MicroExit<A, E>) => self is MicroExit.Success<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1684"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "exitIsFailure",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "declare const exitIsFailure: <A, E>(self: MicroExit<A, E>) => self is MicroExit.Failure<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1693"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "exitIsInterrupt",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "declare const exitIsInterrupt: <A, E>(self: MicroExit<A, E>) => self is MicroExit.Failure<A, E> & { readonly cause: MicroCause.Interrupt; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1702"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "exitIsFail",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "declare const exitIsFail: <A, E>(self: MicroExit<A, E>) => self is MicroExit.Failure<A, E> & { readonly cause: MicroCause.Fail<E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1713"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "exitIsDie",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "declare const exitIsDie: <A, E>(self: MicroExit<A, E>) => self is MicroExit.Failure<A, E> & { readonly cause: MicroCause.Die; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1724"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "exitVoidAll",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroExit",
    "signature": "declare const exitVoidAll: <I extends Iterable<MicroExit<any, any>>>(exits: I) => MicroExit<void, I extends Iterable<MicroExit<infer _A, infer _E>> ? _E : never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1742"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "serviceOption",
    "description": "Access the given `Context.Tag` from the environment, without tracking the\ndependency at the type level.\n\nIt will return an `Option` of the service, depending on whether it is\navailable in the environment or not.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "environment",
    "signature": "declare const serviceOption: <I, S>(tag: Context.Tag<I, S>) => Micro<Option.Option<S>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1853"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "context",
    "description": "Access the current `Context` from the environment.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "environment",
    "signature": "declare const context: <R>() => Micro<Context.Context<R>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1941"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "forever",
    "description": "Repeat the given `Micro` effect forever, only stopping if the effect fails.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "repetition",
    "signature": "declare const forever: <A, E, R>(self: Micro<A, E, R>) => Micro<never, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2421"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "scheduleRecurs",
    "description": "Create a `MicroSchedule` that will stop repeating after the specified number\nof attempts.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "declare const scheduleRecurs: (n: number) => MicroSchedule",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2449"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "scheduleSpaced",
    "description": "Create a `MicroSchedule` that will generate a constant delay.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "declare const scheduleSpaced: (millis: number) => MicroSchedule",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2458"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "scheduleExponential",
    "description": "Create a `MicroSchedule` that will generate a delay with an exponential backoff.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "declare const scheduleExponential: (baseMillis: number, factor?: number) => MicroSchedule",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2467"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "orDie",
    "description": "Elevate any expected errors of the given `Micro` effect to unexpected errors,\nresulting in an error type of `never`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "declare const orDie: <A, E, R>(self: Micro<A, E, R>) => Micro<A, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2872"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "ignore",
    "description": "Ignore any expected errors of the given `Micro` effect, returning `void`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "declare const ignore: <A, E, R>(self: Micro<A, E, R>) => Micro<void, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2896"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "ignoreLogged",
    "description": "Ignore any expected errors of the given `Micro` effect, returning `void`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "declare const ignoreLogged: <A, E, R>(self: Micro<A, E, R>) => Micro<void, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2906"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "option",
    "description": "Replace the success value of the given `Micro` effect with an `Option`,\nwrapping the success value in `Some` and returning `None` if the effect fails\nwith an expected error.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "declare const option: <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2922"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "either",
    "description": "Replace the success value of the given `Micro` effect with an `Either`,\nwrapping the success value in `Right` and wrapping any expected errors with\na `Left`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "declare const either: <A, E, R>(self: Micro<A, E, R>) => Micro<Either.Either<A, E>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2934"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "sleep",
    "description": "Create a `Micro` effect that will sleep for the specified duration.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "delays & timeouts",
    "signature": "declare const sleep: (millis: number) => Micro<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3168"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "scopeUnsafeMake",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "declare const scopeUnsafeMake: () => MicroScope.Closeable",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3392"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "scoped",
    "description": "Provide a `MicroScope` to the given effect, closing it after the effect has\nfinished executing.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "declare const scoped: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, MicroScope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3427"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "acquireRelease",
    "description": "Create a resource with a cleanup `Micro` effect, ensuring the cleanup is\nexecuted when the `MicroScope` is closed.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "declare const acquireRelease: <A, E, R>(acquire: Micro<A, E, R>, release: (a: A, exit: MicroExit<unknown, unknown>) => Micro<void>) => Micro<A, E, R | MicroScope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3441"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "addFinalizer",
    "description": "Add a finalizer to the current `MicroScope`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "declare const addFinalizer: (finalizer: (exit: MicroExit<unknown, unknown>) => Micro<void>) => Micro<void, never, MicroScope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3457"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "acquireUseRelease",
    "description": "Acquire a resource, use it, and then release the resource when the `use`\neffect has completed.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "declare const acquireUseRelease: <Resource, E, R, A, E2, R2, E3, R3>(acquire: Micro<Resource, E, R>, use: (a: Resource) => Micro<A, E2, R2>, release: (a: Resource, exit: MicroExit<A, E2>) => Micro<void, E3, R3>) => Micro<A, E | E2 | E3, R | R2 | R3>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3600"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "uninterruptible",
    "description": "Flag the effect as uninterruptible, which means that when the effect is\ninterrupted, it will be allowed to continue running until completion.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "flags",
    "signature": "declare const uninterruptible: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3637"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "interruptible",
    "description": "Flag the effect as interruptible, which means that when the effect is\ninterrupted, it will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "flags",
    "signature": "declare const interruptible: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3665"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "uninterruptibleMask",
    "description": "Wrap the given `Micro` effect in an uninterruptible region, preventing the\neffect from being aborted.\n\nYou can use the `restore` function to restore a `Micro` effect to the\ninterruptibility state before the `uninterruptibleMask` was applied.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as Micro from \"effect/Micro\"\n\nMicro.uninterruptibleMask((restore) =>\n  Micro.sleep(1000).pipe( // uninterruptible\n    Micro.andThen(restore(Micro.sleep(1000))) // interruptible\n  )\n)\n```"
    ],
    "since": "3.4.0",
    "category": "interruption",
    "signature": "declare const uninterruptibleMask: <A, E, R>(f: (restore: <A, E, R>(effect: Micro<A, E, R>) => Micro<A, E, R>) => Micro<A, E, R>) => Micro<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3698"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "all",
    "description": "Runs all the provided effects in sequence respecting the structure provided in input.\n\nSupports multiple arguments, a single argument tuple / array or record / struct.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "collecting & elements",
    "signature": "declare const all: <const Arg extends Iterable<Micro<any, any, any>> | Record<string, Micro<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly discard?: boolean | undefined; }, O>>(arg: Arg, options?: O) => All.Return<Arg, O>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3800"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "For each element of the provided iterable, run the effect and collect the\nresults.\n\nIf the `discard` option is set to `true`, the results will be discarded and\nthe effect will return `void`.\n\nThe `concurrency` option can be set to control how many effects are run\nconcurrently. By default, the effects are run sequentially.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "collecting & elements",
    "signature": "declare const forEach: { <A, B, E, R>(iterable: Iterable<A>, f: (a: A, index: number) => Micro<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined; }): Micro<Array<B>, E, R>; <A, B, E, R>(iterable: Iterable<A>, f: (a: A, index: number) => Micro<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly discard: true; }): Micro<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3869"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "filter",
    "description": "Effectfully filter the elements of the provided iterable.\n\nUse the `concurrency` option to control how many elements are processed\nconcurrently.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "collecting & elements",
    "signature": "declare const filter: <A, E, R>(iterable: Iterable<A>, f: (a: NoInfer<A>) => Micro<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly negate?: boolean | undefined; }) => Micro<Array<A>, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3982"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Effectfully filter the elements of the provided iterable.\n\nUse the `concurrency` option to control how many elements are processed\nconcurrently.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "collecting & elements",
    "signature": "declare const filterMap: <A, B, E, R>(iterable: Iterable<A>, f: (a: NoInfer<A>) => Micro<Option.Option<B>, E, R>, options?: { readonly concurrency?: Concurrency | undefined; }) => Micro<Array<B>, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4002"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "fork",
    "description": "Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\naborted.\n\nWhen the parent `Micro` finishes, this `Micro` will be aborted.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "fiber & forking",
    "signature": "declare const fork: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4106"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "forkDaemon",
    "description": "Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\naborted.\n\nIt will not be aborted when the parent `Micro` finishes.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "fiber & forking",
    "signature": "declare const forkDaemon: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4143"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "forkScoped",
    "description": "Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\naborted.\n\nThe lifetime of the handle will be attached to the current `MicroScope`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "fiber & forking",
    "signature": "declare const forkScoped: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R | MicroScope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4182"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "runFork",
    "description": "Execute the `Micro` effect and return a `MicroFiber` that can be awaited, joined,\nor aborted.\n\nYou can listen for the result by adding an observer using the handle's\n`addObserver` method.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as Micro from \"effect/Micro\"\n\nconst handle = Micro.succeed(42).pipe(\n  Micro.delay(1000),\n  Micro.runFork\n)\n\nhandle.addObserver((exit) => {\n  console.log(exit)\n})\n```"
    ],
    "since": "3.4.0",
    "category": "execution",
    "signature": "declare const runFork: <A, E>(effect: Micro<A, E>, options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined; } | undefined) => MicroFiberImpl<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4214"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "runPromiseExit",
    "description": "Execute the `Micro` effect and return a `Promise` that resolves with the\n`MicroExit` of the computation.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "execution",
    "signature": "declare const runPromiseExit: <A, E>(effect: Micro<A, E>, options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined; } | undefined) => Promise<MicroExit<A, E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4245"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "runPromise",
    "description": "Execute the `Micro` effect and return a `Promise` that resolves with the\nsuccessful value of the computation.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "execution",
    "signature": "declare const runPromise: <A, E>(effect: Micro<A, E>, options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined; } | undefined) => Promise<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4265"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "runSyncExit",
    "description": "Attempt to execute the `Micro` effect synchronously and return the `MicroExit`.\n\nIf any asynchronous effects are encountered, the function will return a\n`CauseDie` containing the `MicroFiber`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "execution",
    "signature": "declare const runSyncExit: <A, E>(effect: Micro<A, E>) => MicroExit<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4289"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "runSync",
    "description": "Attempt to execute the `Micro` effect synchronously and return the success\nvalue.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "execution",
    "signature": "declare const runSync: <A, E>(effect: Micro<A, E>) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4304"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "TaggedError",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "errors",
    "signature": "declare const TaggedError: <Tag extends string>(tag: Tag) => new <A extends Record<string, any> = {}>(args: Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends \"_tag\" ? never : P]: A[P]; }) => YieldableError & { readonly _tag: Tag; } & Readonly<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4376"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "Micro",
    "description": "A lightweight alternative to the `Effect` data type, with a subset of the functionality.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "models",
    "signature": "export interface Micro<out A, out E = never, out R = never> extends Effect<A, E, R> {\n  readonly [TypeId]: Micro.Variance<A, E, R>\n  [Symbol.iterator](): MicroIterator<Micro<A, E, R>>\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: MicroUnify<this>\n  [Unify.ignoreSymbol]?: MicroUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L72"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.4.3",
    "category": "models",
    "signature": "export interface MicroUnify<A extends { [Unify.typeSymbol]?: any }> extends EffectUnify<A> {\n  Micro?: () => A[Unify.typeSymbol] extends Micro<infer A0, infer E0, infer R0> | infer _ ? Micro<A0, E0, R0> : never\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L84"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.4.3",
    "category": "models",
    "signature": "export interface MicroUnifyIgnore extends EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L92"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroTypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "3.4.1",
    "category": "type lambdas",
    "signature": "export interface MicroTypeLambda extends TypeLambda {\n  readonly type: Micro<this[\"Target\"], this[\"Out1\"], this[\"Out2\"]>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L99"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroIterator",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "models",
    "signature": "export interface MicroIterator<T extends Micro<any, any, any>> {\n  next(...args: ReadonlyArray<any>): IteratorResult<YieldWrap<T>, Micro.Success<T>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L149"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroFiber",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroFiber",
    "signature": "export interface MicroFiber<out A, out E = never> {\n  readonly [MicroFiberTypeId]: MicroFiber.Variance<A, E>\n\n  readonly currentOpCount: number\n  readonly getRef: <I, A>(ref: Context.Reference<I, A>) => A\n  readonly context: Context.Context<never>\n  readonly addObserver: (cb: (exit: MicroExit<A, E>) => void) => () => void\n  readonly unsafeInterrupt: () => void\n  readonly unsafePoll: () => MicroExit<A, E> | undefined\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L430"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroScheduler",
    "deprecated": false,
    "examples": [],
    "since": "3.5.9",
    "category": "scheduler",
    "signature": "export interface MicroScheduler {\n  readonly scheduleTask: (task: () => void, priority: number) => void\n  readonly shouldYield: (fiber: MicroFiber<unknown, unknown>) => boolean\n  readonly flush: () => void\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1762"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroScope",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "export interface MicroScope {\n  readonly [MicroScopeTypeId]: MicroScopeTypeId\n  readonly addFinalizer: (finalizer: (exit: MicroExit<unknown, unknown>) => Micro<void>) => Micro<void>\n  readonly fork: Micro<MicroScope.Closeable>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3288"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "YieldableError",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "errors",
    "signature": "export interface YieldableError extends Pipeable, Inspectable, Readonly<Error> {\n  readonly [Effectable.EffectTypeId]: Effect.VarianceStruct<never, this, never>\n  readonly [Effectable.StreamTypeId]: Stream.VarianceStruct<never, this, never>\n  readonly [Effectable.SinkTypeId]: Sink.VarianceStruct<never, unknown, never, this, never>\n  readonly [Effectable.ChannelTypeId]: Channel.VarianceStruct<never, unknown, this, unknown, never, unknown, never>\n  readonly [TypeId]: Micro.Variance<never, this, never>\n  [Symbol.iterator](): MicroIterator<Micro<never, this, never>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L4319"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "type ids",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L47"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroExitTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "MicroExit",
    "signature": "type MicroExitTypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L63"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroCauseTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "type MicroCauseTypeId = typeof MicroCauseTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L169"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroCause",
    "description": "A `MicroCause` is a data type that represents the different ways a `Micro` can fail.\n\n**Details**\n\n`MicroCause` comes in three forms:\n\n- `Die`: Indicates an unforeseen defect that wasn't planned for in the system's logic.\n- `Fail`: Covers anticipated errors that are recognized and typically handled within the application.\n- `Interrupt`: Signifies an operation that has been purposefully stopped.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "type MicroCause<E> = | MicroCause.Die\n  | MicroCause.Fail<E>\n  | MicroCause.Interrupt",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L186"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroFiberTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroFiber",
    "signature": "type MicroFiberTypeId = typeof MicroFiberTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L423"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroExit",
    "description": "The `MicroExit` type is used to represent the result of a `Micro` computation. It\ncan either be successful, containing a value of type `A`, or it can fail,\ncontaining an error of type `E` wrapped in a `MicroCause`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "type MicroExit<A, E> = | MicroExit.Success<A, E>\n  | MicroExit.Failure<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1597"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroSchedule",
    "description": "The `MicroSchedule` type represents a function that can be used to calculate\nthe delay between repeats.\n\nThe function takes the current attempt number and the elapsed time since the\nfirst attempt, and returns the delay for the next attempt. If the function\nreturns `None`, the repetition will stop.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "type MicroSchedule = (attempt: number, elapsed: number) => Option.Option<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L2439"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroScopeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "type MicroScopeTypeId = typeof MicroScopeTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3281"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "Micro.Variance",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": null,
    "signature": "export interface Variance<A, E, R> {\n    _A: Covariant<A>\n    _E: Covariant<E>\n    _R: Covariant<R>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L112"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "Micro.Success",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": null,
    "signature": "type Success<T> = T extends Micro<infer _A, infer _E, infer _R> ? _A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L122"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "Micro.Error",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": null,
    "signature": "type Error<T> = T extends Micro<infer _A, infer _E, infer _R> ? _E : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L128"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "Micro.Context",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": null,
    "signature": "type Context<T> = T extends Micro<infer _A, infer _E, infer _R> ? _R : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L134"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroCause.Proto",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": null,
    "signature": "export interface Proto<Tag extends string, E> extends Pipeable, globalThis.Error {\n    readonly [MicroCauseTypeId]: {\n      _E: Covariant<E>\n    }\n    readonly _tag: Tag\n    readonly traces: ReadonlyArray<string>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L214"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroCause.Die",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "export interface Die extends Proto<\"Die\", never> {\n    readonly defect: unknown\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L227"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroCause.Fail",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "export interface Fail<E> extends Proto<\"Fail\", E> {\n    readonly error: E\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L236"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroCause.Interrupt",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "export interface Interrupt extends Proto<\"Interrupt\", never> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L245"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroCause.Error",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": null,
    "signature": "type Error<T> = T extends MicroCause.Fail<infer E> ? E : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L208"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroFiber.Variance",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroFiber",
    "signature": "export interface Variance<out A, out E = never> {\n    readonly _A: Covariant<A>\n    readonly _E: Covariant<E>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L452"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroExit.Proto",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "export interface Proto<out A, out E = never> extends Micro<A, E> {\n    readonly [MicroExitTypeId]: MicroExitTypeId\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1612"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroExit.Success",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "export interface Success<out A, out E> extends Proto<A, E> {\n    readonly _tag: \"Success\"\n    readonly value: A\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1621"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroExit.Failure",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "export interface Failure<out A, out E> extends Proto<A, E> {\n    readonly _tag: \"Failure\"\n    readonly cause: MicroCause<E>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L1631"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "MicroScope.Closeable",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "export interface Closeable extends MicroScope {\n    readonly close: (exit: MicroExit<any, any>) => Micro<void>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3305"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "All.MicroAny",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": null,
    "signature": "type MicroAny = Micro<any, any, any>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3723"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "All.ReturnIterable",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": null,
    "signature": "type ReturnIterable<T, Discard> = [T] extends\n    [Iterable<Micro<infer A, infer E, infer R>>] ? Micro<\n      Discard extends true ? void : Array<A>,\n      E,\n      R\n    >\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3729"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "All.ReturnTuple",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": null,
    "signature": "type Micro<Discard extends true ? void : T[number] extends never ? [] : { -readonly [K in keyof T]: T[K] extends Micro<infer _A, infer _E, infer _R> ? _A : never; }, T[number] extends never ? never : T[number] extends Micro<infer _A, infer _E, infer _R> ? _E : never, T[number] extends never ? never : T[number] extends Micro<infer _A, infer _E, infer _R> ? _R : never> = Micro<\n    Discard extends true ? void\n      : T[number] extends never ? []\n      : { -readonly [K in keyof T]: T[K] extends Micro<infer _A, infer _E, infer _R> ? _A : never },\n    T[number] extends never ? never\n      : T[number] extends Micro<infer _A, infer _E, infer _R> ? _E\n      : never,\n    T[number] extends never ? never\n      : T[number] extends Micro<infer _A, infer _E, infer _R> ? _R\n      : never\n  > extends infer X ? X : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3741"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "All.ReturnObject",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": null,
    "signature": "type ReturnObject<T, Discard> = [T] extends [{ [K: string]: MicroAny }] ? Micro<\n      Discard extends true ? void :\n        { -readonly [K in keyof T]: [T[K]] extends [Micro<infer _A, infer _E, infer _R>] ? _A : never },\n      keyof T extends never ? never\n        : T[keyof T] extends Micro<infer _A, infer _E, infer _R> ? _E\n        : never,\n      keyof T extends never ? never\n        : T[keyof T] extends Micro<infer _A, infer _E, infer _R> ? _R\n        : never\n    >\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3757"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "All.IsDiscard",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": null,
    "signature": "type IsDiscard<A> = [Extract<A, { readonly discard: true }>] extends [never] ? false : true",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3773"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro.ts",
      "path": "src/Micro.ts"
    },
    "project": "effect",
    "name": "All.Return",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": null,
    "signature": "type Return<Arg, O> = [Arg] extends [ReadonlyArray<MicroAny>] ? ReturnTuple<Arg, IsDiscard<O>>\n    : [Arg] extends [Iterable<MicroAny>] ? ReturnIterable<Arg, IsDiscard<O>>\n    : [Arg] extends [Record<string, MicroAny>] ? ReturnObject<Arg, IsDiscard<O>>\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Micro.ts#L3779"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ModuleVersion.ts",
      "path": "src/ModuleVersion.ts"
    },
    "project": "effect",
    "name": "getCurrentVersion",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "version",
    "signature": "declare const getCurrentVersion: () => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ModuleVersion.ts#L12"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ModuleVersion.ts",
      "path": "src/ModuleVersion.ts"
    },
    "project": "effect",
    "name": "setCurrentVersion",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "version",
    "signature": "declare const setCurrentVersion: (version: string) => void",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ModuleVersion.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "get",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const get: { <K>(key: K): <V>(self: MutableHashMap<K, V>) => Option.Option<V>; <K, V>(self: MutableHashMap<K, V>, key: K): Option.Option<V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L142"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "has",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const has: { <K>(key: K): <V>(self: MutableHashMap<K, V>) => boolean; <K, V>(self: MutableHashMap<K, V>, key: K): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L214"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "set",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const set: { <K, V>(key: K, value: V): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>; <K, V>(self: MutableHashMap<K, V>, key: K, value: V): MutableHashMap<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L225"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "modify",
    "description": "Updates the value of the specified key within the `MutableHashMap` if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const modify: { <K, V>(key: K, f: (v: V) => V): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>; <K, V>(self: MutableHashMap<K, V>, key: K, f: (v: V) => V): MutableHashMap<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L270"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "modifyAt",
    "description": "Set or remove the specified key in the `MutableHashMap` using the specified\nupdate function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const modifyAt: { <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>; <K, V>(self: MutableHashMap<K, V>, key: K, f: (value: Option.Option<V>) => Option.Option<V>): MutableHashMap<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L305"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "remove",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const remove: { <K>(key: K): <V>(self: MutableHashMap<K, V>) => MutableHashMap<K, V>; <K, V>(self: MutableHashMap<K, V>, key: K): MutableHashMap<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L351"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "forEach",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const forEach: { <K, V>(f: (value: V, key: K) => void): (self: MutableHashMap<K, V>) => void; <K, V>(self: MutableHashMap<K, V>, f: (value: V, key: K) => void): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L401"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <K, V>() => MutableHashMap<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L105"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Entries extends Array<readonly [any, any]>>(...entries: Entries) => MutableHashMap<Entries[number] extends readonly [infer K, any] ? K : never, Entries[number] extends readonly [any, infer V] ? V : never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L117"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `MutableHashMap` from an iterable collection of key/value pairs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: <K, V>(entries: Iterable<readonly [K, V]>) => MutableHashMap<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L130"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "keys",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "elements",
    "signature": "declare const keys: <K, V>(self: MutableHashMap<K, V>) => Array<K>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L166"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "values",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "elements",
    "signature": "declare const values: <K, V>(self: MutableHashMap<K, V>) => Array<V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L180"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "clear",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const clear: <K, V>(self: MutableHashMap<K, V>) => MutableHashMap<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L378"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "size",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const size: <K, V>(self: MutableHashMap<K, V>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L389"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const isEmpty: <K, V>(self: MutableHashMap<K, V>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L396"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "MutableHashMap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MutableHashMap<out K, out V> extends Iterable<[K, V]>, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  /** @internal */\n  readonly referential: Map<K, V>\n  /** @internal */\n  readonly buckets: Map<number, NonEmptyArray<readonly [K & Equal.Equal, V]>>\n  /** @internal */\n  bucketsSize: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L25"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MutableHashMap.ts",
      "path": "src/MutableHashMap.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashMap.ts#L19"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashSet.ts",
      "path": "src/MutableHashSet.ts"
    },
    "project": "effect",
    "name": "add",
    "description": "**Checks** whether the `MutableHashSet` contains the given element, and\n**adds** it if not.\n\nTime complexity: **`O(1)`** average\n\n**Syntax**\n\n```ts\nimport { MutableHashSet, pipe } from \"effect\"\n\n// with data-last, a.k.a. pipeable API\npipe(\n  MutableHashSet.empty(),\n  MutableHashSet.add(0),\n  MutableHashSet.add(0)\n)\n\n// or piped with the pipe function\nMutableHashSet.empty().pipe(MutableHashSet.add(0))\n\n// or with data-first API\nMutableHashSet.add(MutableHashSet.empty(), 0)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const add: { <V>(key: V): (self: MutableHashSet<V>) => MutableHashSet<V>; <V>(self: MutableHashSet<V>, key: V): MutableHashSet<V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L402"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashSet.ts",
      "path": "src/MutableHashSet.ts"
    },
    "project": "effect",
    "name": "has",
    "description": "Checks if the specified value exists in the `MutableHashSet`.\n\nTime complexity: `O(1)` average\n\n**Syntax**\n\n```ts\nimport { MutableHashSet, pipe } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nassert.equal(\n  // with `data-last`, a.k.a. `pipeable` API\n  pipe(MutableHashSet.make(0, 1, 2), MutableHashSet.has(3)),\n  false\n)\n\nassert.equal(\n  // or piped with the pipe function\n  MutableHashSet.make(0, 1, 2).pipe(MutableHashSet.has(3)),\n  false\n)\n\nassert.equal(\n  // or with `data-first` API\n  MutableHashSet.has(MutableHashSet.make(0, 1, 2), 3),\n  false\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const has: { <V>(key: V): (self: MutableHashSet<V>) => boolean; <V>(self: MutableHashSet<V>, key: V): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L501"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashSet.ts",
      "path": "src/MutableHashSet.ts"
    },
    "project": "effect",
    "name": "remove",
    "description": "Removes a value from the `MutableHashSet`.\n\nTime complexity: **`O(1)`** average\n\n**Syntax**\n\n```ts\nimport { MutableHashSet, pipe } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nassert.equal(\n  // with `data-last`, a.k.a. `pipeable` API\n  pipe(\n    MutableHashSet.make(0, 1, 2),\n    MutableHashSet.remove(0),\n    MutableHashSet.has(0)\n  ),\n  false\n)\n\nassert.equal(\n  // or piped with the pipe function\n  MutableHashSet.make(0, 1, 2).pipe(\n    MutableHashSet.remove(0),\n    MutableHashSet.has(0)\n  ),\n  false\n)\n\nassert.equal(\n  // or with `data-first` API\n  MutableHashSet.remove(MutableHashSet.make(0, 1, 2), 0).pipe(\n    MutableHashSet.has(0)\n  ),\n  false\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const remove: { <V>(key: V): (self: MutableHashSet<V>) => MutableHashSet<V>; <V>(self: MutableHashSet<V>, key: V): MutableHashSet<V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L584"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashSet.ts",
      "path": "src/MutableHashSet.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates an empty mutable hash set.\n\nThis function initializes and returns an empty `MutableHashSet` instance,\nwhich allows for efficient storage and manipulation of unique elements.\n\nTime complexity: **`O(1)`**",
    "deprecated": false,
    "examples": [
      "```ts\nimport { MutableHashSet } from \"effect\"\n\ntype T = unknown // replace with your type\n\n// in places where the type can't be inferred, replace with your type\nconst set: MutableHashSet.MutableHashSet<T> = MutableHashSet.empty<T>()\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <K = never>() => MutableHashSet<K>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L179"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashSet.ts",
      "path": "src/MutableHashSet.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `MutableHashSet` from an iterable collection of values.\nDuplicate values are omitted.\n\nTime complexity: **`O(n)`** where n is the number of elements in the iterable\n\nCreating a `MutableHashSet` from an {@link Array}\n\n```ts\nimport { MutableHashSet } from \"effect\"\n\nconst array: Iterable<number> = [1, 2, 3, 4, 5, 1, 2, 3] // Array<T> is also Iterable<T>\nconst mutableHashSet: MutableHashSet.MutableHashSet<number> =\n  MutableHashSet.fromIterable(array)\n\nconsole.log(\n  // MutableHashSet.MutableHashSet<T> is also an Iterable<T>\n  Array.from(mutableHashSet)\n) // Output: [1, 2, 3, 4, 5]\n```\n\nCreating a `MutableHashSet` from a {@link Set}\n\n```ts\nimport { MutableHashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    // Set<string> is an Iterable<string>\n    new Set([\"apple\", \"banana\", \"orange\", \"apple\"]),\n    // constructs MutableHashSet from an Iterable Set\n    MutableHashSet.fromIterable,\n    // since MutableHashSet it is itself an Iterable, we can pass it to other functions expecting an Iterable\n    Array.from\n  )\n) // Output: [\"apple\", \"banana\", \"orange\"]\n```\n\nCreating a `MutableHashSet` from a {@link Generator}\n\n```ts\nimport { MutableHashSet } from \"effect\"\n\n// Generator functions return iterables\nfunction* fibonacci(n: number): Generator<number, void, never> {\n  let [a, b] = [0, 1]\n  for (let i = 0; i < n; i++) {\n    yield a\n    ;[a, b] = [b, a + b]\n  }\n}\n\n// Create a MutableHashSet from the first 10 Fibonacci numbers\nconst fibonacciSet = MutableHashSet.fromIterable(fibonacci(10))\n\nconsole.log(Array.from(fibonacciSet))\n// Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order\n```\n\nCreating a `MutableHashSet` from another {@link module:MutableHashSet}\n\n```ts\nimport { MutableHashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    MutableHashSet.make(1, 2, 3, 4),\n    MutableHashSet.fromIterable,\n    Array.from\n  )\n) // Output: [1, 2, 3, 4]\n```\n\nCreating a `MutableHashSet` from an {@link module:HashSet}\n\n```ts\nimport { HashSet, MutableHashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    HashSet.make(1, 2, 3, 4), // it works also with its immutable HashSet sibling\n    MutableHashSet.fromIterable,\n    Array.from\n  )\n) // Output: [1, 2, 3, 4]\n```\n\nCreating a `MutableHashSet` from other Effect's data structures like\n{@link Chunk}\n\n```ts\nimport { Chunk, MutableHashSet, pipe } from \"effect\"\n\nconsole.log(\n  pipe(\n    Chunk.make(1, 2, 3, 4), //  Chunk is also an Iterable<T>\n    MutableHashSet.fromIterable,\n    Array.from\n  )\n) // Outputs: [1, 2, 3, 4]\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: <K = never>(keys: Iterable<K>) => MutableHashSet<K>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L294"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashSet.ts",
      "path": "src/MutableHashSet.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Construct a new `MutableHashSet` from a variable number of values.\n\nTime complexity: **`O(n)`** where n is the number of elements",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Equal, Hash, MutableHashSet } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nclass Character implements Equal.Equal {\n  readonly name: string\n  readonly trait: string\n\n  constructor(name: string, trait: string) {\n    this.name = name\n    this.trait = trait\n  }\n\n  // Define equality based on name, and trait\n  [Equal.symbol](that: Equal.Equal): boolean {\n    if (that instanceof Character) {\n      return (\n        Equal.equals(this.name, that.name) &&\n        Equal.equals(this.trait, that.trait)\n      )\n    }\n    return false\n  }\n\n  // Generate a hash code based on the sum of the character's name and trait\n  [Hash.symbol](): number {\n    return Hash.hash(this.name + this.trait)\n  }\n\n  static readonly of = (name: string, trait: string): Character => {\n    return new Character(name, trait)\n  }\n}\n\nconst mutableCharacterHashSet = MutableHashSet.make(\n  Character.of(\"Alice\", \"Curious\"),\n  Character.of(\"Alice\", \"Curious\"),\n  Character.of(\"White Rabbit\", \"Always late\"),\n  Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n)\n\nassert.equal(\n  MutableHashSet.has(\n    mutableCharacterHashSet,\n    Character.of(\"Alice\", \"Curious\")\n  ),\n  true\n)\nassert.equal(\n  MutableHashSet.has(\n    mutableCharacterHashSet,\n    Character.of(\"Fluffy\", \"Kind\")\n  ),\n  false\n)\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Keys extends ReadonlyArray<unknown>>(...keys: Keys) => MutableHashSet<Keys[number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L368"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashSet.ts",
      "path": "src/MutableHashSet.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Calculates the number of values in the `HashSet`.\n\nTime complexity: **`O(1)`**",
    "deprecated": false,
    "examples": [
      "```ts\nimport { MutableHashSet } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nassert.equal(MutableHashSet.size(MutableHashSet.empty()), 0)\n\nassert.equal(\n  MutableHashSet.size(MutableHashSet.make(1, 2, 2, 3, 4, 3)),\n  4\n)\n```"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const size: <V>(self: MutableHashSet<V>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L672"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashSet.ts",
      "path": "src/MutableHashSet.ts"
    },
    "project": "effect",
    "name": "clear",
    "description": "Removes all values from the `MutableHashSet`.\n\nThis function operates by delegating the clearing action to the underlying\nkey map associated with the given `MutableHashSet`. It ensures that the hash\nset becomes empty while maintaining its existence and structure.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { MutableHashSet, pipe } from \"effect\"\nimport assert from \"node:assert/strict\"\n\nassert.deepStrictEqual(\n  pipe(\n    MutableHashSet.make(1, 2, 3, 4),\n    MutableHashSet.clear,\n    MutableHashSet.size\n  ),\n  0\n)\n```"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const clear: <V>(self: MutableHashSet<V>) => MutableHashSet<V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L704"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MutableHashSet.ts",
      "path": "src/MutableHashSet.ts"
    },
    "project": "effect",
    "name": "MutableHashSet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MutableHashSet<out V> extends Iterable<V>, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n\n  /** @internal */\n  readonly keyMap: MutableHashMap.MutableHashMap<V, boolean>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L113"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MutableHashSet.ts",
      "path": "src/MutableHashSet.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableHashSet.ts#L107"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "Executes the specified function `f` for each element in the list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const forEach: { <A>(f: (element: A) => void): (self: MutableList<A>) => void; <A>(self: MutableList<A>, f: (element: A) => void): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L168"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "append",
    "description": "Appends the specified element to the end of the `MutableList`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const append: { <A>(value: A): (self: MutableList<A>) => MutableList<A>; <A>(self: MutableList<A>, value: A): MutableList<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L200"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "prepend",
    "description": "Prepends the specified value to the beginning of the list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const prepend: { <A>(value: A): (self: MutableList<A>) => MutableList<A>; <A>(self: MutableList<A>, value: A): MutableList<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L256"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates an empty `MutableList`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <A>() => MutableList<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L100"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `MutableList` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: <A>(iterable: Iterable<A>) => MutableList<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L114"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new `MutableList` from the specified elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A>(...elements: ReadonlyArray<A>) => MutableList<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L128"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the list contains zero elements, `false`, otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isEmpty: <A>(self: MutableList<A>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L136"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "length",
    "description": "Returns the length of the list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const length: <A>(self: MutableList<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L144"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "tail",
    "description": "Returns the last element of the list, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const tail: <A>(self: MutableList<A>) => A | undefined",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L152"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "head",
    "description": "Returns the first element of the list, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const head: <A>(self: MutableList<A>) => A | undefined",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L160"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "reset",
    "description": "Removes all elements from the doubly-linked list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const reset: <A>(self: MutableList<A>) => MutableList<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L187"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "shift",
    "description": "Removes the first value from the list and returns it, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "0.0.1",
    "category": null,
    "signature": "declare const shift: <A>(self: MutableList<A>) => A | undefined",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L227"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "pop",
    "description": "Removes the last value from the list and returns it, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "0.0.1",
    "category": null,
    "signature": "declare const pop: <A>(self: MutableList<A>) => A | undefined",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L241"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "MutableList",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface MutableList<out A> extends Iterable<A>, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n\n  /** @internal */\n  head: LinkedListNode<A> | undefined\n  /** @internal */\n  tail: LinkedListNode<A> | undefined\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L22"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MutableList.ts",
      "path": "src/MutableList.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableList.ts#L16"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableQueue.ts",
      "path": "src/MutableQueue.ts"
    },
    "project": "effect",
    "name": "EmptyMutableQueue",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "declare const EmptyMutableQueue: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L23"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableQueue.ts",
      "path": "src/MutableQueue.ts"
    },
    "project": "effect",
    "name": "offer",
    "description": "Offers an element to the queue.\n\nReturns whether the enqueue was successful or not.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const offer: { <A>(self: MutableQueue<A>, value: A): boolean; <A>(value: A): (self: MutableQueue<A>) => boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L136"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableQueue.ts",
      "path": "src/MutableQueue.ts"
    },
    "project": "effect",
    "name": "offerAll",
    "description": "Enqueues a collection of values into the queue.\n\nReturns a `Chunk` of the values that were **not** able to be enqueued.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const offerAll: { <A>(values: Iterable<A>): (self: MutableQueue<A>) => Chunk.Chunk<A>; <A>(self: MutableQueue<A>, values: Iterable<A>): Chunk.Chunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L158"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableQueue.ts",
      "path": "src/MutableQueue.ts"
    },
    "project": "effect",
    "name": "poll",
    "description": "Dequeues an element from the queue.\n\nReturns either an element from the queue, or the `def` param.\n\n**Note**: if there is no meaningful default for your type, you can always\nuse `poll(MutableQueue.EmptyMutableQueue)`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const poll: { <D>(def: D): <A>(self: MutableQueue<A>) => D | A; <A, D>(self: MutableQueue<A>, def: D): A | D; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L189"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableQueue.ts",
      "path": "src/MutableQueue.ts"
    },
    "project": "effect",
    "name": "pollUpTo",
    "description": "Dequeues up to `n` elements from the queue.\n\nReturns a `List` of up to `n` elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const pollUpTo: { (n: number): <A>(self: MutableQueue<A>) => Chunk.Chunk<A>; <A>(self: MutableQueue<A>, n: number): Chunk.Chunk<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L209"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableQueue.ts",
      "path": "src/MutableQueue.ts"
    },
    "project": "effect",
    "name": "bounded",
    "description": "Creates a new bounded `MutableQueue`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const bounded: <A>(capacity: number) => MutableQueue<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L83"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableQueue.ts",
      "path": "src/MutableQueue.ts"
    },
    "project": "effect",
    "name": "unbounded",
    "description": "Creates a new unbounded `MutableQueue`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unbounded: <A>() => MutableQueue<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L91"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableQueue.ts",
      "path": "src/MutableQueue.ts"
    },
    "project": "effect",
    "name": "length",
    "description": "Returns the current number of elements in the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const length: <A>(self: MutableQueue<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L99"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableQueue.ts",
      "path": "src/MutableQueue.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the queue is empty, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isEmpty: <A>(self: MutableQueue<A>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L107"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableQueue.ts",
      "path": "src/MutableQueue.ts"
    },
    "project": "effect",
    "name": "isFull",
    "description": "Returns `true` if the queue is full, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isFull: <A>(self: MutableQueue<A>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L115"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableQueue.ts",
      "path": "src/MutableQueue.ts"
    },
    "project": "effect",
    "name": "capacity",
    "description": "The **maximum** number of elements that a queue can hold.\n\n**Note**: unbounded queues can still implement this interface with\n`capacity = Infinity`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const capacity: <A>(self: MutableQueue<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L127"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MutableQueue.ts",
      "path": "src/MutableQueue.ts"
    },
    "project": "effect",
    "name": "MutableQueue",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface MutableQueue<out A> extends Iterable<A>, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n\n  /** @internal */\n  queue: MutableList.MutableList<A>\n  /** @internal */\n  capacity: number | undefined\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L29"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MutableQueue.ts",
      "path": "src/MutableQueue.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L17"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MutableQueue.ts",
      "path": "src/MutableQueue.ts"
    },
    "project": "effect",
    "name": "MutableQueue.Empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Empty = typeof EmptyMutableQueue",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableQueue.ts#L45"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "compareAndSet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "declare const compareAndSet: { <T>(oldValue: T, newValue: T): (self: MutableRef<T>) => boolean; <T>(self: MutableRef<T>, oldValue: T, newValue: T): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L60"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "getAndSet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "declare const getAndSet: { <T>(value: T): (self: MutableRef<T>) => T; <T>(self: MutableRef<T>, value: T): T; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L108"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdate",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "declare const getAndUpdate: { <T>(f: (value: T) => T): (self: MutableRef<T>) => T; <T>(self: MutableRef<T>, f: (value: T) => T): T; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L124"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "set",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "declare const set: { <T>(value: T): (self: MutableRef<T>) => MutableRef<T>; <T>(self: MutableRef<T>, value: T): MutableRef<T>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L148"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "setAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "declare const setAndGet: { <T>(value: T): (self: MutableRef<T>) => T; <T>(self: MutableRef<T>, value: T): T; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L163"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "update",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "declare const update: { <T>(f: (value: T) => T): (self: MutableRef<T>) => MutableRef<T>; <T>(self: MutableRef<T>, f: (value: T) => T): MutableRef<T>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L178"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "updateAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "declare const updateAndGet: { <T>(f: (value: T) => T): (self: MutableRef<T>) => T; <T>(self: MutableRef<T>, f: (value: T) => T): T; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L190"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <T>(value: T) => MutableRef<T>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L50"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "decrement",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "numeric",
    "signature": "declare const decrement: (self: MutableRef<number>) => MutableRef<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L78"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "decrementAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "numeric",
    "signature": "declare const decrementAndGet: (self: MutableRef<number>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L84"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "get",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "declare const get: <T>(self: MutableRef<T>) => T",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L90"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "getAndDecrement",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "numeric",
    "signature": "declare const getAndDecrement: (self: MutableRef<number>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L96"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "getAndIncrement",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "numeric",
    "signature": "declare const getAndIncrement: (self: MutableRef<number>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L102"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "increment",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "numeric",
    "signature": "declare const increment: (self: MutableRef<number>) => MutableRef<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L136"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "incrementAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "numeric",
    "signature": "declare const incrementAndGet: (self: MutableRef<number>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L142"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "toggle",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "boolean",
    "signature": "declare const toggle: (self: MutableRef<boolean>) => MutableRef<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L202"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "MutableRef",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MutableRef<out T> extends Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  current: T\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L22"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MutableRef.ts",
      "path": "src/MutableRef.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/MutableRef.ts#L16"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "NonEmptyIterable.ts",
      "path": "src/NonEmptyIterable.ts"
    },
    "project": "effect",
    "name": "unprepend",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const unprepend: <A>(self: NonEmptyIterable<A>) => [firstElement: A, remainingElements: Iterator<A>]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/NonEmptyIterable.ts#L23"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "NonEmptyIterable.ts",
      "path": "src/NonEmptyIterable.ts"
    },
    "project": "effect",
    "name": "NonEmptyIterable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface NonEmptyIterable<out A> extends Iterable<A> {\n  readonly [nonEmpty]: A\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/NonEmptyIterable.ts#L15"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "isNumber",
    "description": "Tests if a value is a `number`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isNumber } from \"effect/Number\"\n\nassert.deepStrictEqual(isNumber(2), true)\nassert.deepStrictEqual(isNumber(\"2\"), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isNumber: (input: unknown) => input is number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L31"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "sum",
    "description": "Provides an addition operation on `number`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { sum } from \"effect/Number\"\n\nassert.deepStrictEqual(sum(2, 3), 5)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const sum: { (that: number): (self: number) => number; (self: number, that: number): number; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L47"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "multiply",
    "description": "Provides a multiplication operation on `number`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { multiply } from \"effect/Number\"\n\nassert.deepStrictEqual(multiply(2, 3), 6)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const multiply: { (that: number): (self: number) => number; (self: number, that: number): number; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L66"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "subtract",
    "description": "Provides a subtraction operation on `number`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { subtract } from \"effect/Number\"\n\nassert.deepStrictEqual(subtract(2, 3), -1)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const subtract: { (that: number): (self: number) => number; (self: number, that: number): number; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L85"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "divide",
    "description": "Provides a division operation on `number`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Number, Option } from \"effect\"\n\nassert.deepStrictEqual(Number.divide(6, 3), Option.some(2))\nassert.deepStrictEqual(Number.divide(6, 0), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const divide: { (that: number): (self: number) => Option<number>; (self: number, that: number): Option<number>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L105"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "unsafeDivide",
    "description": "Provides a division operation on `number`s.\n\nThrows a `RangeError` if the divisor is `0`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { unsafeDivide } from \"effect/Number\"\n\nassert.deepStrictEqual(unsafeDivide(6, 3), 2)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const unsafeDivide: { (that: number): (self: number) => number; (self: number, that: number): number; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L129"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "Equivalence",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Equivalence: equivalence.Equivalence<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L170"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "Order",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Order: order.Order<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L176"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "lessThan",
    "description": "Returns `true` if the first argument is less than the second, otherwise `false`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { lessThan } from \"effect/Number\"\n\nassert.deepStrictEqual(lessThan(2, 3), true)\nassert.deepStrictEqual(lessThan(3, 3), false)\nassert.deepStrictEqual(lessThan(4, 3), false)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const lessThan: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L194"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "lessThanOrEqualTo",
    "description": "Returns a function that checks if a given `number` is less than or equal to the provided one.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { lessThanOrEqualTo } from \"effect/Number\"\n\nassert.deepStrictEqual(lessThanOrEqualTo(2, 3), true)\nassert.deepStrictEqual(lessThanOrEqualTo(3, 3), true)\nassert.deepStrictEqual(lessThanOrEqualTo(4, 3), false)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const lessThanOrEqualTo: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L215"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "greaterThan",
    "description": "Returns `true` if the first argument is greater than the second, otherwise `false`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { greaterThan } from \"effect/Number\"\n\nassert.deepStrictEqual(greaterThan(2, 3), false)\nassert.deepStrictEqual(greaterThan(3, 3), false)\nassert.deepStrictEqual(greaterThan(4, 3), true)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const greaterThan: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L236"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "greaterThanOrEqualTo",
    "description": "Returns a function that checks if a given `number` is greater than or equal to the provided one.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { greaterThanOrEqualTo } from \"effect/Number\"\n\nassert.deepStrictEqual(greaterThanOrEqualTo(2, 3), false)\nassert.deepStrictEqual(greaterThanOrEqualTo(3, 3), true)\nassert.deepStrictEqual(greaterThanOrEqualTo(4, 3), true)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const greaterThanOrEqualTo: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L257"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "between",
    "description": "Checks if a `number` is between a `minimum` and `maximum` value (inclusive).",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Number } from \"effect\"\n\nconst between = Number.between({ minimum: 0, maximum: 5 })\n\nassert.deepStrictEqual(between(3), true)\nassert.deepStrictEqual(between(-1), false)\nassert.deepStrictEqual(between(6), false)\n```"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const between: { (options: { minimum: number; maximum: number; }): (self: number) => boolean; (self: number, options: { minimum: number; maximum: number; }): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L280"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "clamp",
    "description": "Restricts the given `number` to be within the range specified by the `minimum` and `maximum` values.\n\n- If the `number` is less than the `minimum` value, the function returns the `minimum` value.\n- If the `number` is greater than the `maximum` value, the function returns the `maximum` value.\n- Otherwise, it returns the original `number`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Number } from \"effect\"\n\nconst clamp = Number.clamp({ minimum: 1, maximum: 5 })\n\nassert.equal(clamp(3), 3)\nassert.equal(clamp(0), 1)\nassert.equal(clamp(6), 5)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const clamp: { (options: { minimum: number; maximum: number; }): (self: number) => number; (self: number, options: { minimum: number; maximum: number; }): number; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L312"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "min",
    "description": "Returns the minimum between two `number`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { min } from \"effect/Number\"\n\nassert.deepStrictEqual(min(2, 3), 2)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const min: { (that: number): (self: number) => number; (self: number, that: number): number; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L336"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "max",
    "description": "Returns the maximum between two `number`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { max } from \"effect/Number\"\n\nassert.deepStrictEqual(max(2, 3), 3)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const max: { (that: number): (self: number) => number; (self: number, that: number): number; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L354"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "remainder",
    "description": "Returns the remainder left over when one operand is divided by a second operand.\n\nIt always takes the sign of the dividend.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { remainder } from \"effect/Number\"\n\nassert.deepStrictEqual(remainder(2, 2), 0)\nassert.deepStrictEqual(remainder(3, 2), 1)\nassert.deepStrictEqual(remainder(-4, 2), -0)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const remainder: { (divisor: number): (self: number) => number; (self: number, divisor: number): number; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L442"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "round",
    "description": "Returns the number rounded with the given precision.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { round } from \"effect/Number\"\n\nassert.deepStrictEqual(round(1.1234, 2), 1.12)\nassert.deepStrictEqual(round(1.567, 2), 1.57)\n```"
    ],
    "since": "3.8.0",
    "category": "math",
    "signature": "declare const round: { (precision: number): (self: number) => number; (self: number, precision: number): number; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L516"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "increment",
    "description": "Returns the result of adding `1` to a given number.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { increment } from \"effect/Number\"\n\nassert.deepStrictEqual(increment(2), 3)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const increment: (n: number) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L148"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "decrement",
    "description": "Decrements a number by `1`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { decrement } from \"effect/Number\"\n\nassert.deepStrictEqual(decrement(3), 2)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const decrement: (n: number) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L164"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "sign",
    "description": "Determines the sign of a given `number`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { sign } from \"effect/Number\"\n\nassert.deepStrictEqual(sign(-5), -1)\nassert.deepStrictEqual(sign(0), 0)\nassert.deepStrictEqual(sign(5), 1)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const sign: (n: number) => Ordering",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L375"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "sumAll",
    "description": "Takes an `Iterable` of `number`s and returns their sum as a single `number`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { sumAll } from \"effect/Number\"\n\nassert.deepStrictEqual(sumAll([2, 3, 4]), 9)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const sumAll: (collection: Iterable<number>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L391"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "multiplyAll",
    "description": "Takes an `Iterable` of `number`s and returns their multiplication as a single `number`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { multiplyAll } from \"effect/Number\"\n\nassert.deepStrictEqual(multiplyAll([2, 3, 4]), 24)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const multiplyAll: (collection: Iterable<number>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L413"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "nextPow2",
    "description": "Returns the next power of 2 from the given number.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { nextPow2 } from \"effect/Number\"\n\nassert.deepStrictEqual(nextPow2(5), 8)\nassert.deepStrictEqual(nextPow2(17), 32)\n```"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "declare const nextPow2: (n: number) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L470"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Number.ts",
      "path": "src/Number.ts"
    },
    "project": "effect",
    "name": "parse",
    "description": "Tries to parse a `number` from a `string` using the `Number()` function.\nThe following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const parse: (s: string) => Option<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Number.ts#L482"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L46"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "some",
    "description": "Wraps the given value into an `Option` to represent its presence.\n\n**Example** (Creating an Option with a Value)\n\n```ts\nimport { Option } from \"effect\"\n\n// An Option holding the number 1\n//\n//       Option<number>\n//      \nconst value = Option.some(1)\n\nconsole.log(value)\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const some: <A>(value: A) => Option<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L187"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "isOption",
    "description": "Determines whether the given value is an `Option`.\n\n**Details**\n\nThis function checks if a value is an instance of `Option`. It returns `true`\nif the value is either `Option.some` or `Option.none`, and `false` otherwise.\nThis is particularly useful when working with unknown values or when you need\nto ensure type safety in your code.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconsole.log(Option.isOption(Option.some(1)))\n// Output: true\n\nconsole.log(Option.isOption(Option.none()))\n// Output: true\n\nconsole.log(Option.isOption({}))\n// Output: false\n```"
    ],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isOption: (input: unknown) => input is Option<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L216"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "isNone",
    "description": "Checks whether an `Option` represents the absence of a value (`None`).",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconsole.log(Option.isNone(Option.some(1)))\n// Output: false\n\nconsole.log(Option.isNone(Option.none()))\n// Output: true\n```"
    ],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isNone: <A>(self: Option<A>) => self is None<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L237"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "isSome",
    "description": "Checks whether an `Option` contains a value (`Some`).",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconsole.log(Option.isSome(Option.some(1)))\n// Output: true\n\nconsole.log(Option.isSome(Option.none()))\n// Output: false\n```"
    ],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isSome: <A>(self: Option<A>) => self is Some<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L258"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Performs pattern matching on an `Option` to handle both `Some` and `None`\ncases.\n\n**Details**\n\nThis function allows you to match against an `Option` and handle both\nscenarios: when the `Option` is `None` (i.e., contains no value), and when\nthe `Option` is `Some` (i.e., contains a value). It executes one of the\nprovided functions based on the case:\n\n- If the `Option` is `None`, the `onNone` function is executed and its result\n  is returned.\n- If the `Option` is `Some`, the `onSome` function is executed with the\n  contained value, and its result is returned.\n\nThis function provides a concise and functional way to handle optional values\nwithout resorting to `if` or manual checks, making your code more declarative\nand readable.\n\n**Example** (Pattern Matching with Option)\n\n```ts\nimport { Option } from \"effect\"\n\nconst foo = Option.some(1)\n\nconst message = Option.match(foo, {\n  onNone: () => \"Option is empty\",\n  onSome: (value) => `Option has a value: ${value}`\n})\n\nconsole.log(message)\n// Output: \"Option has a value: 1\"\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Pattern matching",
    "signature": "declare const match: { <B, A, C = B>(options: { readonly onNone: LazyArg<B>; readonly onSome: (a: A) => C; }): (self: Option<A>) => B | C; <A, B, C = B>(self: Option<A>, options: { readonly onNone: LazyArg<B>; readonly onSome: (a: A) => C; }): B | C; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L299"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "getRight",
    "description": "Converts an `Either` into an `Option` by discarding the error and extracting\nthe right value.\n\n**Details**\n\nThis function takes an `Either` and returns an `Option` based on its value:\n\n- If the `Either` is a `Right`, its value is wrapped in a `Some` and\n  returned.\n- If the `Either` is a `Left`, the error is discarded, and `None` is\n  returned.\n\nThis is particularly useful when you only care about the success case\n(`Right`) of an `Either` and want to handle the result using `Option`. By\nusing this function, you can convert `Either` into a simpler structure for\ncases where error handling is not required.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Either, Option } from \"effect\"\n\nconsole.log(Option.getRight(Either.right(\"ok\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'ok' }\n\nconsole.log(Option.getRight(Either.left(\"err\")))\n// Output: { _id: 'Option', _tag: 'None' }\n```"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": "declare const getRight: <R, L>(self: Either<R, L>) => Option<R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L431"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "getLeft",
    "description": "Converts an `Either` into an `Option` by discarding the right value and\nextracting the left value.\n\n**Details**\n\nThis function transforms an `Either` into an `Option` as follows:\n\n- If the `Either` is a `Left`, its value is wrapped in a `Some` and returned.\n- If the `Either` is a `Right`, the value is discarded, and `None` is\n  returned.\n\nThis utility is useful when you only care about the error case (`Left`) of an\n`Either` and want to handle it as an `Option`. By discarding the right value,\nit simplifies error-focused workflows.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Either, Option } from \"effect\"\n\nconsole.log(Option.getLeft(Either.right(\"ok\")))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.getLeft(Either.left(\"err\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'err' }\n```"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": "declare const getLeft: <R, L>(self: Either<R, L>) => Option<L>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L465"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "getOrElse",
    "description": "Returns the value contained in the `Option` if it is `Some`, otherwise\nevaluates and returns the result of `onNone`.\n\n**Details**\n\nThis function allows you to provide a fallback value or computation for when\nan `Option` is `None`. If the `Option` contains a value (`Some`), that value\nis returned. If it is empty (`None`), the `onNone` function is executed, and\nits result is returned instead.\n\nThis utility is helpful for safely handling `Option` values by ensuring you\nalways receive a meaningful result, whether or not the `Option` contains a\nvalue. It is particularly useful for providing default values or alternative\nlogic when working with optional values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconsole.log(Option.some(1).pipe(Option.getOrElse(() => 0)))\n// Output: 1\n\nconsole.log(Option.none().pipe(Option.getOrElse(() => 0)))\n// Output: 0\n```"
    ],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const getOrElse: { <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => B | A; <A, B>(self: Option<A>, onNone: LazyArg<B>): A | B; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L500"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "orElse",
    "description": "Returns the provided `Option` `that` if the current `Option` (`self`) is\n`None`; otherwise, it returns `self`.\n\n**Details**\n\nThis function provides a fallback mechanism for `Option` values. If the\ncurrent `Option` is `None` (i.e., it contains no value), the `that` function\nis evaluated, and its resulting `Option` is returned. If the current `Option`\nis `Some` (i.e., it contains a value), the original `Option` is returned\nunchanged.\n\nThis is particularly useful for chaining fallback values or computations,\nallowing you to provide alternative `Option` values when the first one is\nempty.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconsole.log(Option.none().pipe(Option.orElse(() => Option.none())))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.some(\"a\").pipe(Option.orElse(() => Option.none())))\n// Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n\nconsole.log(Option.none().pipe(Option.orElse(() => Option.some(\"b\"))))\n// Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n\nconsole.log(Option.some(\"a\").pipe(Option.orElse(() => Option.some(\"b\"))))\n// Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n```"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const orElse: { <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<B | A>; <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L544"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "orElseSome",
    "description": "Returns the provided default value wrapped in `Some` if the current `Option`\n(`self`) is `None`; otherwise, returns `self`.\n\n**Details**\n\nThis function provides a way to supply a default value for cases where an\n`Option` is `None`. If the current `Option` is empty (`None`), the `onNone`\nfunction is executed to compute the default value, which is then wrapped in a\n`Some`. If the current `Option` contains a value (`Some`), it is returned as\nis.\n\nThis is particularly useful for handling optional values where a fallback\ndefault needs to be provided explicitly in case of absence.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconsole.log(Option.none().pipe(Option.orElseSome(() => \"b\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n\nconsole.log(Option.some(\"a\").pipe(Option.orElseSome(() => \"b\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n```"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const orElseSome: { <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => Option<B | A>; <A, B>(self: Option<A>, onNone: LazyArg<B>): Option<A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L581"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "orElseEither",
    "description": "Similar to {@link orElse}, but returns an `Either` wrapped in an `Option` to\nindicate the source of the value.\n\n**Details**\n\nThis function allows you to provide a fallback `Option` in case the current\n`Option` (`self`) is `None`. However, unlike `orElse`, it returns the value\nwrapped in an `Either` object, providing additional information about where\nthe value came from:\n\n- If the value is from the fallback `Option` (`that`), it is wrapped in an\n  `Either.right`.\n- If the value is from the original `Option` (`self`), it is wrapped in an\n  `Either.left`.\n\nThis is especially useful when you need to differentiate between values\noriginating from the primary `Option` and those coming from the fallback,\nwhile still maintaining the `Option`-style handling.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const orElseEither: { <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<Either<B, A>>; <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<Either<B, A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L612"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "getOrNull",
    "description": "Returns the value contained in the `Option` if it is `Some`; otherwise,\nreturns `null`.\n\n**Details**\n\nThis function provides a way to extract the value of an `Option` while\nfalling back to `null` if the `Option` is `None`.\n\nIt is particularly useful in scenarios where `null` is an acceptable\nplaceholder for the absence of a value, such as when interacting with APIs or\nsystems that use `null` as a default for missing values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconsole.log(Option.getOrNull(Option.some(1)))\n// Output: 1\n\nconsole.log(Option.getOrNull(Option.none()))\n// Output: null\n```"
    ],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const getOrNull: <A>(self: Option<A>) => A | null",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L753"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "getOrUndefined",
    "description": "Returns the value contained in the `Option` if it is `Some`; otherwise,\nreturns `undefined`.\n\n**Details**\n\nThis function provides a way to extract the value of an `Option` while\nfalling back to `undefined` if the `Option` is `None`.\n\nIt is particularly useful in scenarios where `undefined` is an acceptable\nplaceholder for the absence of a value, such as when interacting with APIs or\nsystems that use `undefined` as a default for missing values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconsole.log(Option.getOrUndefined(Option.some(1)))\n// Output: 1\n\nconsole.log(Option.getOrUndefined(Option.none()))\n// Output: undefined\n```"
    ],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "declare const getOrUndefined: <A>(self: Option<A>) => A | undefined",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L782"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "getOrThrowWith",
    "description": "Extracts the value of an `Option` or throws an error if the `Option` is\n`None`, using a custom error factory.\n\n**Details**\n\nThis function allows you to extract the value of an `Option` when it is\n`Some`. If the `Option` is `None`, it throws an error generated by the\nprovided `onNone` function. This utility is particularly useful when you need\na fail-fast behavior for empty `Option` values and want to provide a custom\nerror message or object.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Option } from \"effect\"\n\nassert.deepStrictEqual(\n  Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),\n  1\n)\nassert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))\n```"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": "declare const getOrThrowWith: { (onNone: () => unknown): <A>(self: Option<A>) => A; <A>(self: Option<A>, onNone: () => unknown): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L852"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "getOrThrow",
    "description": "Extracts the value of an `Option` or throws a default error if the `Option`\nis `None`.\n\n**Details**\n\nThis function extracts the value from an `Option` if it is `Some`. If the\n`Option` is `None`, it throws a default error. It is useful for fail-fast\nscenarios where the absence of a value is treated as an exceptional case and\na default error is sufficient.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Option } from \"effect\"\n\nassert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)\nassert.throws(() => Option.getOrThrow(Option.none()))\n```"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": "declare const getOrThrow: <A>(self: Option<A>) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L887"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms the value inside a `Some` to a new value using the provided\nfunction, while leaving `None` unchanged.\n\n**Details**\n\nThis function applies a mapping function `f` to the value inside an `Option`\nif it is a `Some`. If the `Option` is `None`, it remains unchanged. The\nresult is a new `Option` with the transformed value (if it was a `Some`) or\nstill `None`.\n\nThis utility is particularly useful for chaining transformations in a\nfunctional way without needing to manually handle `None` cases.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\n// Mapping over a `Some`\nconst someValue = Option.some(2)\n\nconsole.log(Option.map(someValue, (n) => n * 2))\n// Output: { _id: 'Option', _tag: 'Some', value: 4 }\n\n// Mapping over a `None`\nconst noneValue = Option.none<number>()\n\nconsole.log(Option.map(noneValue, (n) => n * 2))\n// Output: { _id: 'Option', _tag: 'None' }\n```"
    ],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const map: { <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => B): Option<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L923"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "as",
    "description": "Replaces the value inside a `Some` with the specified constant value, leaving\n`None` unchanged.\n\n**Details**\n\nThis function transforms an `Option` by replacing the value inside a `Some`\nwith the given constant value `b`. If the `Option` is `None`, it remains\nunchanged.\n\nThis is useful when you want to preserve the presence of a value (`Some`) but\nreplace its content with a fixed value.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\n// Replacing the value of a `Some`\nconst someValue = Option.some(42)\n\nconsole.log(Option.as(someValue, \"new value\"))\n// Output: { _id: 'Option', _tag: 'Some', value: 'new value' }\n\n// Replacing a `None` (no effect)\nconst noneValue = Option.none<number>()\n\nconsole.log(Option.as(noneValue, \"new value\"))\n// Output: { _id: 'Option', _tag: 'None' }\n```"
    ],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const as: { <B>(b: B): <X>(self: Option<X>) => Option<B>; <X, B>(self: Option<X>, b: B): Option<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L964"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "asVoid",
    "description": "Replaces the value inside a `Some` with the constant value `void`, leaving\n`None` unchanged.\n\n**Details**\n\nThis function transforms an `Option` by replacing the value inside a `Some`\nwith `void`. If the `Option` is `None`, it remains unchanged.\n\nThis is particularly useful in scenarios where the presence or absence of a\nvalue is significant, but the actual content of the value is irrelevant.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const asVoid: <_>(self: Option<_>) => Option<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L984"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Applies a function to the value of a `Some` and flattens the resulting\n`Option`. If the input is `None`, it remains `None`.\n\n**Details**\n\nThis function allows you to chain computations that return `Option` values.\nIf the input `Option` is `Some`, the provided function `f` is applied to the\ncontained value, and the resulting `Option` is returned. If the input is\n`None`, the function is not applied, and the result remains `None`.\n\nThis utility is particularly useful for sequencing operations that may fail\nor produce optional results, enabling clean and concise workflows for\nhandling such cases.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\ninterface Address {\n  readonly city: string\n  readonly street: Option.Option<string>\n}\n\ninterface User {\n  readonly id: number\n  readonly username: string\n  readonly email: Option.Option<string>\n  readonly address: Option.Option<Address>\n}\n\nconst user: User = {\n  id: 1,\n  username: \"john_doe\",\n  email: Option.some(\"john.doe@example.com\"),\n  address: Option.some({\n    city: \"New York\",\n    street: Option.some(\"123 Main St\")\n  })\n}\n\n// Use flatMap to extract the street value\nconst street = user.address.pipe(\n  Option.flatMap((address) => address.street)\n)\n\nconsole.log(street)\n// Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }\n```"
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const flatMap: { <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1047"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "andThen",
    "description": "Chains two `Option`s together. The second `Option` can either be a static\nvalue or depend on the result of the first `Option`.\n\n**Details**\n\nThis function enables sequencing of two `Option` computations. If the first\n`Option` is `Some`, the second `Option` is evaluated. The second `Option` can\neither:\n\n- Be a static `Option` value.\n- Be a function that produces an `Option`, optionally based on the value of\n  the first `Option`.\n\nIf the first `Option` is `None`, the function skips the evaluation of the\nsecond `Option` and directly returns `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const andThen: { <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <B>(f: Option<B>): <A>(self: Option<A>) => Option<B>; <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>; <B>(f: NotFunction<B>): <A>(self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; <A, B>(self: Option<A>, f: Option<B>): Option<B>; <A, B>(self: Option<A>, f: (a: A) => B): Option<B>; <A, B>(self: Option<A>, f: NotFunction<B>): Option<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1075"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "flatMapNullable",
    "description": "Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`\nusing a function that may return `null` or `undefined`.\n\n**Details**\n\nThis function applies a transformation function `f` to the value inside a\n`Some`. The function `f` may return a value, `null`, or `undefined`. If `f`\nreturns a value, it is wrapped in a `Some`. If `f` returns `null` or\n`undefined`, the result is `None`. If the input `Option` is `None`, the\nfunction is not applied, and `None` is returned.\n\nThis utility is particularly useful when working with deeply nested optional\nvalues or chaining computations that may result in `null` or `undefined` at\nsome point.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\ninterface Employee {\n  company?: {\n    address?: {\n      street?: {\n        name?: string\n      }\n    }\n  }\n}\n\nconst employee1: Employee = { company: { address: { street: { name: \"high street\" } } } }\n\n// Extracting a deeply nested property\nconsole.log(\n  Option.some(employee1)\n    .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n)\n// Output: { _id: 'Option', _tag: 'Some', value: 'high street' }\n\nconst employee2: Employee = { company: { address: { street: {} } } }\n\n// Property does not exist\nconsole.log(\n  Option.some(employee2)\n    .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n)\n// Output: { _id: 'Option', _tag: 'None' }\n```"
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const flatMapNullable: { <A, B>(f: (a: A) => B | null | undefined): (self: Option<A>) => Option<NonNullable<B>>; <A, B>(self: Option<A>, f: (a: A) => B | null | undefined): Option<NonNullable<B>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1145"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens an `Option` of `Option` into a single `Option`.\n\n**Details**\n\nThis function takes an `Option` that wraps another `Option` and flattens it\ninto a single `Option`. If the outer `Option` is `Some`, the function\nextracts the inner `Option`. If the outer `Option` is `None`, the result\nremains `None`.\n\nThis is useful for simplifying nested `Option` structures that may arise\nduring functional operations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const flatten: <A>(self: Option<Option<A>>) => Option<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1170"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Combines two `Option`s, keeping the value from the second `Option` if both\nare `Some`.\n\n**Details**\n\nThis function takes two `Option`s and returns the second one if the first is\n`Some`. If the first `Option` is `None`, the result will also be `None`,\nregardless of the second `Option`. It effectively \"zips\" the two `Option`s\nwhile discarding the value from the first `Option`.\n\nThis is particularly useful when sequencing computations where the result of\nthe first computation is not needed, and you only care about the result of\nthe second computation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "declare const zipRight: { <B>(that: Option<B>): <_>(self: Option<_>) => Option<B>; <X, B>(self: Option<X>, that: Option<B>): Option<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1190"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Combines two `Option`s, keeping the value from the first `Option` if both are\n`Some`.\n\n**Details**\n\nThis function takes two `Option`s and returns the first one if it is `Some`.\nIf either the first `Option` or the second `Option` is `None`, the result\nwill be `None`. This operation \"zips\" the two `Option`s while discarding the\nvalue from the second `Option`.\n\nThis is useful when sequencing computations where the second `Option`\nrepresents a dependency or condition that must hold, but its value is\nirrelevant.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "declare const zipLeft: { <_>(that: Option<_>): <A>(self: Option<A>) => Option<A>; <A, X>(self: Option<A>, that: Option<X>): Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1213"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "composeK",
    "description": "Composes two functions that return `Option` values, creating a new function\nthat chains them together.\n\n**Details**\n\nThis function allows you to compose two computations, each represented by a\nfunction that returns an `Option`. The result of the first function is passed\nto the second function if it is `Some`. If the first function returns `None`,\nthe composed function short-circuits and returns `None` without invoking the\nsecond function.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconst parse = (s: string): Option.Option<number> => isNaN(Number(s)) ? Option.none() : Option.some(Number(s))\n\nconst double = (n: number): Option.Option<number> => n > 0 ? Option.some(n * 2) : Option.none()\n\nconst parseAndDouble = Option.composeK(parse, double)\n\nconsole.log(parseAndDouble(\"42\"))\n// Output: { _id: 'Option', _tag: 'Some', value: 84 }\n\nconsole.log(parseAndDouble(\"not a number\"))\n// Output: { _id: 'Option', _tag: 'None' }\n```"
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const composeK: { <B, C>(bfc: (b: B) => Option<C>): <A>(afb: (a: A) => Option<B>) => (a: A) => Option<C>; <A, B, C>(afb: (a: A) => Option<B>, bfc: (b: B) => Option<C>): (a: A) => Option<C>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1250"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "tap",
    "description": "Applies the provided function `f` to the value of the `Option` if it is\n`Some` and returns the original `Option`, unless `f` returns `None`, in which\ncase it returns `None`.\n\n**Details**\n\nThis function allows you to perform additional computations on the value of\nan `Option` without modifying its original value. If the `Option` is `Some`,\nthe provided function `f` is executed with the value, and its result\ndetermines whether the original `Option` is returned (`Some`) or the result\nis `None` if `f` returns `None`. If the input `Option` is `None`, the\nfunction is not executed, and `None` is returned.\n\nThis is particularly useful for applying side conditions or performing\nvalidation checks while retaining the original `Option`'s value.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconst getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()\n\nconsole.log(Option.tap(Option.none(), getInteger))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.tap(Option.some(1), getInteger))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(Option.tap(Option.some(1.14), getInteger))\n// Output: { _id: 'Option', _tag: 'None' }\n```"
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "declare const tap: { <A, X>(f: (a: A) => Option<X>): (self: Option<A>) => Option<A>; <A, X>(self: Option<A>, f: (a: A) => Option<X>): Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1291"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Combines two `Option` values into a new `Option` by applying a provided\nfunction to their values.\n\n**Details**\n\nThis function takes two `Option` values (`self` and `that`) and a combining\nfunction `f`. If both `Option` values are `Some`, the function `f` is applied\nto their values, and the result is wrapped in a new `Some`. If either\n`Option` is `None`, the result is `None`.\n\nThis utility is useful for combining two optional computations into a single\nresult while maintaining type safety and avoiding explicit checks for `None`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconst maybeName: Option.Option<string> = Option.some(\"John\")\nconst maybeAge: Option.Option<number> = Option.some(25)\n\n// Combine the name and age into a person object\nconst person = Option.zipWith(maybeName, maybeAge, (name, age) => ({\n  name: name.toUpperCase(),\n  age\n}))\n\nconsole.log(person)\n// Output:\n// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n```"
    ],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "declare const zipWith: { <B, A, C>(that: Option<B>, f: (a: A, b: B) => C): (self: Option<A>) => Option<C>; <A, B, C>(self: Option<A>, that: Option<B>, f: (a: A, b: B) => C): Option<C>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1455"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "ap",
    "description": "Applies a function inside a `Some` to a value inside another `Some`,\ncombining them into a new `Option`.\n\n**Details**\n\nThis function allows you to apply a function wrapped in an `Option` (`self`)\nto a value wrapped in another `Option` (`that`). If both `Option`s are\n`Some`, the function is applied to the value, and the result is wrapped in a\nnew `Some`. If either `Option` is `None`, the result is `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Combining",
    "signature": "declare const ap: { <A>(that: Option<A>): <B>(self: Option<(a: A) => B>) => Option<B>; <A, B>(self: Option<(a: A) => B>, that: Option<A>): Option<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1478"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "reduceCompact",
    "description": "Reduces an `Iterable` of `Option<A>` to a single value of type `B`, ignoring\nelements that are `None`.\n\n**Details**\n\nThis function takes an initial value of type `B` and a reducing function `f`\nthat combines the accumulator with values of type `A`. It processes an\niterable of `Option<A>`, applying `f` only to the `Some` values while\nignoring the `None` values. The result is a single value of type `B`.\n\nThis utility is particularly useful for aggregating values from an iterable\nof `Option`s while skipping the absent (`None`) values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option, pipe } from \"effect\"\n\nconst iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]\n\nconsole.log(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)))\n// Output: 3\n```"
    ],
    "since": "2.0.0",
    "category": "Reducing",
    "signature": "declare const reduceCompact: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<Option<A>>) => B; <A, B>(self: Iterable<Option<A>>, b: B, f: (b: B, a: A) => B): B; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1510"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "partitionMap",
    "description": "Splits an `Option` into two `Option`s based on the result of a mapping\nfunction that produces an `Either`.\n\n**Details**\n\nThis function takes an `Option` and a mapping function `f` that converts its\nvalue into an `Either`. It returns a tuple of two `Option`s:\n\n- The first `Option` (`left`) contains the value from the `Left` side of the\n  `Either` if it exists, otherwise `None`.\n- The second `Option` (`right`) contains the value from the `Right` side of\n  the `Either` if it exists, otherwise `None`.\n\nIf the input `Option` is `None`, both returned `Option`s are `None`.\n\nThis utility is useful for filtering and categorizing the contents of an\n`Option` based on a bifurcating computation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "declare const partitionMap: { <A, B, C>(f: (a: A) => Either<C, B>): (self: Option<A>) => [left: Option<B>, right: Option<C>]; <A, B, C>(self: Option<A>, f: (a: A) => Either<C, B>): [left: Option<B>, right: Option<C>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1569"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Alias of {@link flatMap}.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\n// Transform and filter numbers\nconst transformEven = (n: Option.Option<number>): Option.Option<string> =>\n  Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))\n\nconsole.log(transformEven(Option.none()))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(transformEven(Option.some(1)))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(transformEven(Option.some(2)))\n// Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }\n```"
    ],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "declare const filterMap: { <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1608"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n\nIf you need to change the type of the `Option` in addition to filtering, see `filterMap`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconst removeEmptyString = (input: Option.Option<string>) =>\n  Option.filter(input, (value) => value !== \"\")\n\nconsole.log(removeEmptyString(Option.none()))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(removeEmptyString(Option.some(\"\")))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(removeEmptyString(Option.some(\"a\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n```"
    ],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => Option<A>; <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Option<A>, predicate: Predicate<A>): Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1638"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "liftPredicate",
    "description": "Lifts a `Predicate` or `Refinement` into the `Option` context, returning a\n`Some` of the input value if the predicate is satisfied, or `None` otherwise.\n\n**Details**\n\nThis function transforms a `Predicate` (or a more specific `Refinement`) into\na function that produces an `Option`. If the predicate evaluates to `true`,\nthe input value is wrapped in a `Some`. If the predicate evaluates to\n`false`, the result is `None`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\n// Check if a number is positive\nconst isPositive = (n: number) => n > 0\n\n//       (b: number) => Option<number>\n//      \nconst parsePositive = Option.liftPredicate(isPositive)\n\nconsole.log(parsePositive(1))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(parsePositive(-1))\n// OUtput: { _id: 'Option', _tag: 'None' }\n```"
    ],
    "since": "2.0.0",
    "category": "Lifting",
    "signature": "declare const liftPredicate: { <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Option<B>; <B extends A, A = B>(predicate: Predicate<A>): (b: B) => Option<B>; <A, B extends A>(self: A, refinement: Refinement<A, B>): Option<B>; <B extends A, A = B>(self: B, predicate: Predicate<A>): Option<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1805"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "contains",
    "description": "Returns a function that checks if an `Option` contains a specified value\nusing the default `Equivalence`.\n\n**Details**\n\nThis function allows you to check whether an `Option` contains a specific\nvalue. It uses the default `Equivalence` for equality comparison. If the\n`Option` is `Some` and its value is equivalent to the provided value, the\nresult is `true`. If the `Option` is `None` or the values are not equivalent,\nthe result is `false`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconsole.log(Option.some(2).pipe(Option.contains(2)))\n// Output: true\n\nconsole.log(Option.some(1).pipe(Option.contains(2)))\n// Output: false\n\nconsole.log(Option.none().pipe(Option.contains(2)))\n// Output: false\n```"
    ],
    "since": "2.0.0",
    "category": "Elements",
    "signature": "declare const contains: { <A>(a: A): (self: Option<A>) => boolean; <A>(self: Option<A>, a: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1892"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "exists",
    "description": "Checks if a value in an `Option` satisfies a given predicate or refinement.\n\n**Details**\n\nThis function allows you to check if a value inside a `Some` meets a\nspecified condition. If the `Option` is `None`, the result is `false`. If the\n`Option` is `Some`, the provided predicate or refinement is applied to the\nvalue:\n\n- If the condition is met, the result is `true`.\n- If the condition is not met, the result is `false`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconst isEven = (n: number) => n % 2 === 0\n\nconsole.log(Option.some(2).pipe(Option.exists(isEven)))\n// Output: true\n\nconsole.log(Option.some(1).pipe(Option.exists(isEven)))\n// Output: false\n\nconsole.log(Option.none().pipe(Option.exists(isEven)))\n// Output: false\n```"
    ],
    "since": "2.0.0",
    "category": "Elements",
    "signature": "declare const exists: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => self is Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => boolean; <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): self is Option<B>; <A>(self: Option<A>, predicate: Predicate<A>): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1929"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "bindTo",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Option, pipe } from \"effect\"\n\nconst result = pipe(\n  Option.Do,\n  Option.bind(\"x\", () => Option.some(2)),\n  Option.bind(\"y\", () => Option.some(3)),\n  Option.let(\"sum\", ({ x, y }) => x + y),\n  Option.filter(({ x, y }) => x * y > 5)\n)\nassert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n```"
    ],
    "since": "2.0.0",
    "category": "Do notation",
    "signature": "declare const bindTo: { <N extends string>(name: N): <A>(self: Option<A>) => Option<{ [K in N]: A; }>; <A, N extends string>(self: Option<A>, name: N): Option<{ [K in N]: A; }>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1977"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "bind",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Option, pipe } from \"effect\"\n\nconst result = pipe(\n  Option.Do,\n  Option.bind(\"x\", () => Option.some(2)),\n  Option.bind(\"y\", () => Option.some(3)),\n  Option.let(\"sum\", ({ x, y }) => x + y),\n  Option.filter(({ x, y }) => x * y > 5)\n)\nassert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n```"
    ],
    "since": "2.0.0",
    "category": "Do notation",
    "signature": "declare const bind: { <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Option<B>): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <A extends object, N extends string, B>(self: Option<A>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Option<B>): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L2064"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "Do",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Option, pipe } from \"effect\"\n\nconst result = pipe(\n  Option.Do,\n  Option.bind(\"x\", () => Option.some(2)),\n  Option.bind(\"y\", () => Option.some(3)),\n  Option.let(\"sum\", ({ x, y }) => x + y),\n  Option.filter(({ x, y }) => x * y > 5)\n)\nassert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n```"
    ],
    "since": "2.0.0",
    "category": "Do notation",
    "signature": "declare const Do: Option<{}>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L2109"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "none",
    "description": "Represents the absence of a value by creating an empty `Option`.\n\n`Option.none` returns an `Option<never>`, which is a subtype of `Option<A>`.\nThis means you can use it in place of any `Option<A>` regardless of the type\n`A`.\n\n**Example** (Creating an Option with No Value)\n\n```ts\nimport { Option } from \"effect\"\n\n// An Option holding no value\n//\n//       Option<never>\n//      \nconst noValue = Option.none()\n\nconsole.log(noValue)\n// Output: { _id: 'Option', _tag: 'None' }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const none: <A = never>() => Option<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L162"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "toRefinement",
    "description": "Converts an `Option`-returning function into a type guard.\n\n**Details**\n\nThis function transforms a function that returns an `Option` into a type\nguard, ensuring type safety when validating or narrowing types. The returned\ntype guard function checks whether the input satisfies the condition defined\nin the original `Option`-returning function.\n\nIf the original function returns `Option.some`, the type guard evaluates to\n`true`, confirming the input is of the desired type. If the function returns\n`Option.none`, the type guard evaluates to `false`.\n\nThis utility is especially useful for validating types in union types,\nfiltering arrays, or ensuring safe handling of specific subtypes.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\ntype MyData = string | number\n\nconst parseString = (data: MyData): Option.Option<string> =>\n  typeof data === \"string\" ? Option.some(data) : Option.none()\n\n//       (a: MyData) => a is string\n//      \nconst isString = Option.toRefinement(parseString)\n\nconsole.log(isString(\"a\"))\n// Output: true\n\nconsole.log(isString(1))\n// Output: false\n```"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": "declare const toRefinement: <A, B extends A>(f: (a: A) => Option<B>) => (a: A) => a is B",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L356"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Converts an `Iterable` into an `Option`, wrapping the first element if it\nexists.\n\n**Details**\n\nThis function takes an `Iterable` (e.g., an array, a generator, or any object\nimplementing the `Iterable` interface) and returns an `Option` based on its\ncontent:\n\n- If the `Iterable` contains at least one element, the first element is\n  wrapped in a `Some` and returned.\n- If the `Iterable` is empty, `None` is returned, representing the absence of\n  a value.\n\nThis utility is useful for safely handling collections that might be empty,\nensuring you explicitly handle both cases where a value exists or doesn't.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconsole.log(Option.fromIterable([1, 2, 3]))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(Option.fromIterable([]))\n// Output: { _id: 'Option', _tag: 'None' }\n```"
    ],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const fromIterable: <A>(collection: Iterable<A>) => Option<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L390"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "firstSomeOf",
    "description": "Returns the first `Some` value found in an `Iterable` collection of\n`Option`s, or `None` if no `Some` is found.\n\n**Details**\n\nThis function iterates over a collection of `Option` values and returns the\nfirst `Some` it encounters. If the collection contains only `None` values,\nthe result will also be `None`. This utility is useful for efficiently\nfinding the first valid value in a sequence of potentially empty or invalid\noptions.\n\nThe iteration stops as soon as a `Some` is found, making this function\nefficient for large collections.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconsole.log(Option.firstSomeOf([\n  Option.none(),\n  Option.some(1),\n  Option.some(2)\n]))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n```"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "declare const firstSomeOf: <T, C extends Iterable<Option<T>> = Iterable<Option<T>>>(collection: C) => [C] extends [Iterable<Option<infer A>>] ? Option<A> : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L651"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "fromNullable",
    "description": "Converts a nullable value into an `Option`. Returns `None` if the value is\n`null` or `undefined`, otherwise wraps the value in a `Some`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconsole.log(Option.fromNullable(undefined))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.fromNullable(null))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.fromNullable(1))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n```"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": "declare const fromNullable: <A>(nullableValue: A) => Option<NonNullable<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L684"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "liftNullable",
    "description": "Lifts a function that returns `null` or `undefined` into the `Option`\ncontext.\n\n**Details**\n\nThis function takes a function `f` that might return `null` or `undefined`\nand transforms it into a function that returns an `Option`. The resulting\nfunction will return:\n- `Some` if the original function produces a non-null, non-undefined value.\n- `None` if the original function produces `null` or `undefined`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconst parse = (s: string): number | undefined => {\n  const n = parseFloat(s)\n  return isNaN(n) ? undefined : n\n}\n\nconst parseOption = Option.liftNullable(parse)\n\nconsole.log(parseOption(\"1\"))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(parseOption(\"not a number\"))\n// Output: { _id: 'Option', _tag: 'None' }\n```"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": "declare const liftNullable: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => Option<NonNullable<B>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L721"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "liftThrowable",
    "description": "Lifts a function that throws exceptions into a function that returns an\n`Option`.\n\n**Details**\n\nThis utility function takes a function `f` that might throw an exception and\ntransforms it into a safer function that returns an `Option`. If the original\nfunction executes successfully, the result is wrapped in a `Some`. If an\nexception is thrown, the result is `None`, allowing the developer to handle\nerrors in a functional, type-safe way.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconst parse = Option.liftThrowable(JSON.parse)\n\nconsole.log(parse(\"1\"))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(parse(\"\"))\n// Output: { _id: 'Option', _tag: 'None' }\n```"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": "declare const liftThrowable: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B) => (...a: A) => Option<B>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L812"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "product",
    "description": "Combines two `Option` values into a single `Option` containing a tuple of\ntheir values if both are `Some`.\n\n**Details**\n\nThis function takes two `Option`s and combines their values into a tuple `[A,\nB]` if both are `Some`. If either of the `Option`s is `None`, the result is\n`None`. This is particularly useful for combining multiple `Option` values\ninto a single one, ensuring both contain valid values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Combining",
    "signature": "declare const product: <A, B>(self: Option<A>, that: Option<B>) => Option<[A, B]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1310"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "productMany",
    "description": "Combines an `Option` with a collection of `Option`s into a single `Option`\ncontaining a tuple of their values if all are `Some`.\n\n**Details**\n\nThis function takes a primary `Option` and a collection of `Option`s and\ncombines their values into a tuple `[A, ...Array<A>]` if all are `Some`. If\nthe primary `Option` or any `Option` in the collection is `None`, the result\nis `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Combining",
    "signature": "declare const productMany: <A>(self: Option<A>, collection: Iterable<Option<A>>) => Option<[A, ...Array<A>]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1327"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "all",
    "description": "Combines a structure of `Option`s into a single `Option` containing the\nvalues with the same structure.\n\n**Details**\n\nThis function takes a structure of `Option`s (a tuple, struct, or iterable)\nand produces a single `Option` that contains the values from the input\nstructure if all `Option`s are `Some`. If any `Option` in the input is\n`None`, the result is `None`. The structure of the input is preserved in the\noutput.\n\n- If the input is a tuple (e.g., an array), the result will be an `Option`\n  containing a tuple with the same length.\n- If the input is a struct (e.g., an object), the result will be an `Option`\n  containing a struct with the same keys.\n- If the input is an iterable, the result will be an `Option` containing an\n  array.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconst maybeName: Option.Option<string> = Option.some(\"John\")\nconst maybeAge: Option.Option<number> = Option.some(25)\n\n//       Option<[string, number]>\n//      \nconst tuple = Option.all([maybeName, maybeAge])\nconsole.log(tuple)\n// Output:\n// { _id: 'Option', _tag: 'Some', value: [ 'John', 25 ] }\n\n//       Option<{ name: string; age: number; }>\n//      \nconst struct = Option.all({ name: maybeName, age: maybeAge })\nconsole.log(struct)\n// Output:\n// { _id: 'Option', _tag: 'Some', value: { name: 'John', age: 25 } }\n```"
    ],
    "since": "2.0.0",
    "category": "Combining",
    "signature": "declare const all: <const I extends Iterable<Option<any>> | Record<string, Option<any>>>(input: I) => [I] extends [ReadonlyArray<Option<any>>] ? Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never; }> : [I] extends [Iterable<Option<infer A>>] ? Option<Array<A>> : Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never; }>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1389"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "toArray",
    "description": "Converts an `Option` into an `Array`.\nIf the input is `None`, an empty array is returned.\nIf the input is `Some`, its value is wrapped in a single-element array.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\nconsole.log(Option.toArray(Option.some(1)))\n// Output: [1]\n\nconsole.log(Option.toArray(Option.none()))\n// Output: []\n```"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": "declare const toArray: <A>(self: Option<A>) => Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1545"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": "Creates an `Equivalence` instance for comparing `Option` values, using a\nprovided `Equivalence` for the inner type.\n\n**Details**\n\nThis function takes an `Equivalence` instance for a specific type `A` and\nproduces an `Equivalence` instance for `Option<A>`. The resulting\n`Equivalence` determines whether two `Option` values are equivalent:\n\n- Two `None`s are considered equivalent.\n- A `Some` and a `None` are not equivalent.\n- Two `Some` values are equivalent if their inner values are equivalent\n  according to the provided `Equivalence`.\n\n**Example** (Comparing Optional Numbers for Equivalence)\n\n```ts\nimport { Number, Option } from \"effect\"\n\nconst isEquivalent = Option.getEquivalence(Number.Equivalence)\n\nconsole.log(isEquivalent(Option.none(), Option.none()))\n// Output: true\n\nconsole.log(isEquivalent(Option.none(), Option.some(1)))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.none()))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.some(2)))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.some(1)))\n// Output: true\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Equivalence",
    "signature": "declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Option<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1690"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "getOrder",
    "description": "Creates an `Order` instance for comparing `Option` values, using a provided\n`Order` for the inner type.\n\n**Details**\n\nThis function produces an `Order` instance for `Option<A>`, allowing `Option`\nvalues to be compared:\n\n- `None` is always considered less than any `Some` value.\n- If both are `Some`, their inner values are compared using the provided\n  `Order` instance.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Number, Option } from \"effect\"\n\nconst order = Option.getOrder(Number.Order)\n\nconsole.log(order(Option.none(), Option.none()))\n// Output: 0\n\nconsole.log(order(Option.none(), Option.some(1)))\n// Output: -1\n\nconsole.log(order(Option.some(1), Option.none()))\n// Output: 1\n\nconsole.log(order(Option.some(1), Option.some(2)))\n// Output: -1\n\nconsole.log(order(Option.some(1), Option.some(1)))\n// Output: 0\n```"
    ],
    "since": "2.0.0",
    "category": "Sorting",
    "signature": "declare const getOrder: <A>(O: Order<A>) => Order<Option<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1731"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "lift2",
    "description": "Lifts a binary function to work with `Option` values, allowing the function\nto operate on two `Option`s.\n\n**Details**\n\nThis function takes a binary function `f` and returns a new function that\napplies `f` to the values of two `Option`s (`self` and `that`). If both\n`Option`s are `Some`, the binary function `f` is applied to their values, and\nthe result is wrapped in a new `Some`. If either `Option` is `None`, the\nresult is `None`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Option } from \"effect\"\n\n// A binary function to add two numbers\nconst add = (a: number, b: number): number => a + b\n\n// Lift the `add` function to work with `Option` values\nconst addOptions = Option.lift2(add)\n\n// Both `Option`s are `Some`\nconsole.log(addOptions(Option.some(2), Option.some(3)))\n// Output: { _id: 'Option', _tag: 'Some', value: 5 }\n\n// One `Option` is `None`\nconsole.log(addOptions(Option.some(2), Option.none()))\n// Output: { _id: 'Option', _tag: 'None' }\n```"
    ],
    "since": "2.0.0",
    "category": "Lifting",
    "signature": "declare const lift2: <A, B, C>(f: (a: A, b: B) => C) => { (that: Option<B>): (self: Option<A>) => Option<C>; (self: Option<A>, that: Option<B>): Option<C>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1768"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "containsWith",
    "description": "Returns a function that checks if an `Option` contains a specified value,\nusing a provided equivalence function.\n\n**Details**\n\nThis function allows you to check whether an `Option` contains a specific\nvalue. It uses an equivalence function `isEquivalent` to compare the value\ninside the `Option` to the provided value. If the `Option` is `Some` and the\nequivalence function returns `true`, the result is `true`. If the `Option` is\n`None` or the values are not equivalent, the result is `false`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Number, Option } from \"effect\"\n\nconst contains = Option.containsWith(Number.Equivalence)\n\nconsole.log(Option.some(2).pipe(contains(2)))\n// Output: true\n\nconsole.log(Option.some(1).pipe(contains(2)))\n// Output: false\n\nconsole.log(Option.none().pipe(contains(2)))\n// Output: false\n```"
    ],
    "since": "2.0.0",
    "category": "Elements",
    "signature": "declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Option<A>) => boolean; (self: Option<A>, a: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L1854"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "gen",
    "description": "Similar to `Effect.gen`, `Option.gen` provides a more readable,\ngenerator-based syntax for working with `Option` values, making code that\ninvolves `Option` easier to write and understand. This approach is similar to\nusing `async/await` but tailored for `Option`.\n\n**Example** (Using `Option.gen` to Create a Combined Value)\n\n```ts\nimport { Option } from \"effect\"\n\nconst maybeName: Option.Option<string> = Option.some(\"John\")\nconst maybeAge: Option.Option<number> = Option.some(25)\n\nconst person = Option.gen(function* () {\n  const name = (yield* maybeName).toUpperCase()\n  const age = yield* maybeAge\n  return { name, age }\n})\n\nconsole.log(person)\n// Output:\n// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Generators",
    "signature": "declare const gen: Gen.Gen<OptionTypeLambda, Gen.Adapter<OptionTypeLambda>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L2141"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "None",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface None<out A> extends Pipeable, Inspectable {\n  readonly _tag: \"None\"\n  readonly _op: \"None\"\n  readonly [TypeId]: {\n    readonly _A: Covariant<A>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: OptionUnify<this>\n  [Unify.ignoreSymbol]?: OptionUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L58"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "Some",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Some<out A> extends Pipeable, Inspectable {\n  readonly _tag: \"Some\"\n  readonly _op: \"Some\"\n  readonly value: A\n  readonly [TypeId]: {\n    readonly _A: Covariant<A>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: OptionUnify<this>\n  [Unify.ignoreSymbol]?: OptionUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L73"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "OptionUnify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface OptionUnify<A extends { [Unify.typeSymbol]?: any }> {\n  Option?: () => A[Unify.typeSymbol] extends Option<infer A0> | infer _ ? Option<A0> : never\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L89"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "OptionUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface OptionUnifyIgnore {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L125"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "OptionTypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Type Lambdas",
    "signature": "export interface OptionTypeLambda extends TypeLambda {\n  readonly type: Option<this[\"Target\"]>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L131"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "Option",
    "description": "The `Option` data type represents optional values. An `Option<A>` can either\nbe `Some<A>`, containing a value of type `A`, or `None`, representing the\nabsence of a value.\n\n**When to Use**\n\nYou can use `Option` in scenarios like:\n\n- Using it for initial values\n- Returning values from functions that are not defined for all possible\n  inputs (referred to as partial functions)\n- Managing optional fields in data structures\n- Handling optional function arguments",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "type Option<A> = None<A> | Some<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L40"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L52"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Option.ts",
      "path": "src/Option.ts"
    },
    "project": "effect",
    "name": "Option.Value",
    "description": "Extracts the type of the value contained in an `Option`.\n\n**Example** (Getting the Value Type of an Option)\n\n```ts\nimport { Option } from \"effect\"\n\n// Declare an Option holding a string\ndeclare const myOption: Option.Option<string>\n\n// Extract the type of the value within the Option\n//\n//       string\n//      \ntype MyType = Option.Option.Value<typeof myOption>\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Type-level Utils",
    "signature": "type Value<T> = [T] extends [Option<infer _A>] ? _A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Option.ts#L118"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "string",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const string: Order<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L51"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "number",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const number: Order<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L57"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "boolean",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const boolean: Order<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L63"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "bigint",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const bigint: Order<bigint>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L69"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "combine",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const combine: { <A>(that: Order<A>): (self: Order<A>) => Order<A>; <A>(self: Order<A>, that: Order<A>): Order<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L80"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "combineMany",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const combineMany: { <A>(collection: Iterable<Order<A>>): (self: Order<A>) => Order<A>; <A>(self: Order<A>, collection: Iterable<Order<A>>): Order<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L96"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "mapInput",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapInput: { <B, A>(f: (b: B) => A): (self: Order<A>) => Order<B>; <A, B>(self: Order<A>, f: (b: B) => A): Order<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L129"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "Date",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Date: Order<Date>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L141"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "product",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const product: { <B>(that: Order<B>): <A>(self: Order<A>) => Order<readonly [A, B]>; <A, B>(self: Order<A>, that: Order<B>): Order<readonly [A, B]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L147"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "productMany",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const productMany: { <A>(collection: Iterable<Order<A>>): (self: Order<A>) => Order<readonly [A, ...Array<A>]>; <A>(self: Order<A>, collection: Iterable<Order<A>>): Order<readonly [A, ...Array<A>]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L182"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A>(compare: (self: A, that: A) => -1 | 0 | 1) => Order<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L42"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "reverse",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const reverse: <A>(O: Order<A>) => Order<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L74"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const empty: <A>() => Order<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L117"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "combineAll",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const combineAll: <A>(collection: Iterable<Order<A>>) => Order<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L123"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "all",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const all: <A>(collection: Iterable<Order<A>>) => Order<ReadonlyArray<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L160"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "tuple",
    "description": "Similar to `Promise.all` but operates on `Order`s.\n\n```\n[Order<A>, Order<B>, ...] -> Order<[A, B, ...]>\n```\n\nThis function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\nThe returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\nIt is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\nof the tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const tuple: <T extends ReadonlyArray<Order<any>>>(...elements: T) => Order<Readonly<{ [I in keyof T]: [T[I]] extends [Order<infer A>] ? A : never; }>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L208"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "array",
    "description": "This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\nThe returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\nIf all elements are equal, the arrays are then compared based on their length.\nIt is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const array: <A>(O: Order<A>) => Order<ReadonlyArray<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L221"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "struct",
    "description": "This function creates and returns a new `Order` for a struct of values based on the given `Order`s\nfor each property in the struct.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const struct: <R extends { readonly [x: string]: Order<any>; }>(fields: R) => Order<{ [K in keyof R]: [R[K]] extends [Order<infer A>] ? A : never; }>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L242"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "lessThan",
    "description": "Test whether one value is _strictly less than_ another.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const lessThan: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L262"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "greaterThan",
    "description": "Test whether one value is _strictly greater than_ another.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const greaterThan: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L272"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "lessThanOrEqualTo",
    "description": "Test whether one value is _non-strictly less than_ another.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const lessThanOrEqualTo: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L282"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "greaterThanOrEqualTo",
    "description": "Test whether one value is _non-strictly greater than_ another.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const greaterThanOrEqualTo: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L292"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "min",
    "description": "Take the minimum of two values. If they are considered equal, the first argument is chosen.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const min: <A>(O: Order<A>) => { (that: A): (self: A) => A; (self: A, that: A): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L302"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "max",
    "description": "Take the maximum of two values. If they are considered equal, the first argument is chosen.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const max: <A>(O: Order<A>) => { (that: A): (self: A) => A; (self: A, that: A): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L312"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "clamp",
    "description": "Clamp a value between a minimum and a maximum.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Order, Number } from \"effect\"\n\nconst clamp = Order.clamp(Number.Order)({ minimum: 1, maximum: 5 })\n\nassert.equal(clamp(3), 3)\nassert.equal(clamp(0), 1)\nassert.equal(clamp(6), 5)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const clamp: <A>(O: Order<A>) => { (options: { minimum: A; maximum: A; }): (self: A) => A; (self: A, options: { minimum: A; maximum: A; }): A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L334"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "between",
    "description": "Test whether a value is between a minimum and a maximum (inclusive).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const between: <A>(O: Order<A>) => { (options: { minimum: A; maximum: A; }): (self: A) => boolean; (self: A, options: { minimum: A; maximum: A; }): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L357"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "Order",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type class",
    "signature": "export interface Order<in A> {\n  (self: A, that: A): -1 | 0 | 1\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L26"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Order.ts",
      "path": "src/Order.ts"
    },
    "project": "effect",
    "name": "OrderTypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface OrderTypeLambda extends TypeLambda {\n  readonly type: Order<this[\"Target\"]>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Order.ts#L34"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ordering.ts",
      "path": "src/Ordering.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Depending on the `Ordering` parameter given to it, returns a value produced by one of the 3 functions provided as parameters.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Ordering } from \"effect\"\nimport { constant } from \"effect/Function\"\n\nconst toMessage = Ordering.match({\n  onLessThan: constant('less than'),\n  onEqual: constant('equal'),\n  onGreaterThan: constant('greater than')\n})\n\nassert.deepStrictEqual(toMessage(-1), \"less than\")\nassert.deepStrictEqual(toMessage(0), \"equal\")\nassert.deepStrictEqual(toMessage(1), \"greater than\")\n```"
    ],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "declare const match: { <A, B, C = B>(options: { readonly onLessThan: LazyArg<A>; readonly onEqual: LazyArg<B>; readonly onGreaterThan: LazyArg<C>; }): (self: Ordering) => A | B | C; <A, B, C = B>(o: Ordering, options: { readonly onLessThan: LazyArg<A>; readonly onEqual: LazyArg<B>; readonly onGreaterThan: LazyArg<C>; }): A | B | C; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ordering.ts#L53"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ordering.ts",
      "path": "src/Ordering.ts"
    },
    "project": "effect",
    "name": "combine",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const combine: { (that: Ordering): (self: Ordering) => Ordering; (self: Ordering, that: Ordering): Ordering; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ordering.ts#L82"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ordering.ts",
      "path": "src/Ordering.ts"
    },
    "project": "effect",
    "name": "combineMany",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const combineMany: { (collection: Iterable<Ordering>): (self: Ordering) => Ordering; (self: Ordering, collection: Iterable<Ordering>): Ordering; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ordering.ts#L91"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Ordering.ts",
      "path": "src/Ordering.ts"
    },
    "project": "effect",
    "name": "reverse",
    "description": "Inverts the ordering of the input `Ordering`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { reverse } from \"effect/Ordering\"\n\nassert.deepStrictEqual(reverse(1), -1)\nassert.deepStrictEqual(reverse(-1), 1)\nassert.deepStrictEqual(reverse(0), 0)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const reverse: (o: Ordering) => Ordering",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ordering.ts#L28"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Ordering.ts",
      "path": "src/Ordering.ts"
    },
    "project": "effect",
    "name": "combineAll",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const combineAll: (collection: Iterable<Ordering>) => Ordering",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ordering.ts#L111"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Ordering.ts",
      "path": "src/Ordering.ts"
    },
    "project": "effect",
    "name": "Ordering",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "type Ordering = -1 | 0 | 1",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ordering.ts#L11"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "Pointer",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Pointer { constructor(\n    readonly path: Path,\n    readonly actual: unknown,\n    readonly issue: ParseIssue\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L57"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "Unexpected",
    "description": "Error that occurs when an unexpected key or index is present.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Unexpected { constructor(\n    readonly actual: unknown,\n    /**\n     * @since 3.10.0\n     */\n    readonly message?: string\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L75"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "Missing",
    "description": "Error that occurs when a required key or index is missing.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Missing { constructor(\n    /**\n     * @since 3.10.0\n     */\n    readonly ast: AST.Type,\n    /**\n     * @since 3.10.0\n     */\n    readonly message?: string\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L95"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "Composite",
    "description": "Error that contains multiple issues.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Composite { constructor(\n    readonly ast: AST.AST,\n    readonly actual: unknown,\n    readonly issues: SingleOrNonEmpty<ParseIssue>,\n    readonly output?: unknown\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L122"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "Refinement",
    "description": "Error that occurs when a refinement has an error.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Refinement { constructor(\n    readonly ast: AST.Refinement,\n    readonly actual: unknown,\n    readonly kind: \"From\" | \"Predicate\",\n    readonly issue: ParseIssue\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L141"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "Transformation",
    "description": "Error that occurs when a transformation has an error.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Transformation { constructor(\n    readonly ast: AST.Transformation,\n    readonly actual: unknown,\n    readonly kind: \"Encoded\" | \"Transformation\" | \"Type\",\n    readonly issue: ParseIssue\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L160"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "Type",
    "description": "The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.\nThe `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Type { constructor(\n    readonly ast: AST.AST,\n    readonly actual: unknown,\n    readonly message?: string\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L180"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "Forbidden",
    "description": "The `Forbidden` variant of the `ParseIssue` type represents a forbidden operation, such as when encountering an Effect that is not allowed to execute (e.g., using `runSync`).",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Forbidden { constructor(\n    readonly ast: AST.AST,\n    readonly actual: unknown,\n    readonly message?: string\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L198"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "ParseError",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare class ParseError",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L230"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "ParseErrorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "type id",
    "signature": "declare const ParseErrorTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L214"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "succeed",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const succeed: <A>(a: A) => Either.Either<A, ParseIssue>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L272"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "fail",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const fail: (issue: ParseIssue) => Either.Either<never, ParseIssue>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L278"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "fromOption",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const fromOption: { (onNone: () => ParseIssue): <A>(self: Option.Option<A>) => Either.Either<A, ParseIssue>; <A>(self: Option.Option<A>, onNone: () => ParseIssue): Either.Either<A, ParseIssue>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L297"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "optimisation",
    "signature": "declare const flatMap: { <A, B, E1, R1>(f: (a: A) => Effect.Effect<B, E1, R1>): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect.Effect<A, E, R>, f: (a: A) => Effect.Effect<B, E1, R1>): Effect.Effect<B, E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L308"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "map",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "optimisation",
    "signature": "declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>; <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L329"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "mapError",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "optimisation",
    "signature": "declare const mapError: { <E, E2>(f: (e: E) => E2): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>; <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L342"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "mapBoth",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "optimisation",
    "signature": "declare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R>; <A, E, R, E2, A2>(self: Effect.Effect<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Effect.Effect<A2, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L368"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "orElse",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "optimisation",
    "signature": "declare const orElse: { <E, A2, E2, R2>(f: (e: E) => Effect.Effect<A2, E2, R2>): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect.Effect<A, E, R>, f: (e: E) => Effect.Effect<A2, E2, R2>): Effect.Effect<A2 | A, E2, R2 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L389"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "decodeSync",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decodeSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L564"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "decodeOption",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decodeOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Option.Option<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L573"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "decodeEither",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decodeEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L582"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "decodePromise",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decodePromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Promise<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L591"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "decode",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decode: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L600"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "encodeSync",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encodeSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => I",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L693"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "encodeOption",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encodeOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (input: A, overrideOptions?: AST.ParseOptions) => Option.Option<I>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L702"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "encodeEither",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encodeEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => Either.Either<I, ParseIssue>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L711"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "encodePromise",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encodePromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => Promise<I>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L720"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "encode",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encode: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => Effect.Effect<I, ParseIssue, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L729"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "TreeFormatter",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "formatting",
    "signature": "declare const TreeFormatter: ParseResultFormatter<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L1746"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "isComposite",
    "description": "Returns `true` if the value is a `Composite`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isComposite: (issue: ParseIssue) => issue is Composite",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L1833"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "ArrayFormatter",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "formatting",
    "signature": "declare const ArrayFormatter: ParseResultFormatter<Array<ArrayFormatterIssue>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L1979"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "isParseError",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const isParseError: (u: unknown) => u is ParseError",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L225"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "parseError",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const parseError: (issue: ParseIssue) => ParseError",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L266"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "eitherOrUndefined",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "optimisation",
    "signature": "declare const eitherOrUndefined: <A, E, R>(self: Effect.Effect<A, E, R>) => Either.Either<A, E> | undefined",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L356"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "decodeUnknownSync",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decodeUnknownSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L463"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "decodeUnknownOption",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decodeUnknownOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L472"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "decodeUnknownEither",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decodeUnknownEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L481"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "decodeUnknownPromise",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decodeUnknownPromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Promise<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L491"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "decodeUnknown",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decodeUnknown: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L503"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "encodeUnknownSync",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encodeUnknownSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => I",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L514"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "encodeUnknownOption",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encodeUnknownOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<I>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L523"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "encodeUnknownEither",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encodeUnknownEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<I, ParseIssue>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L532"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "encodeUnknownPromise",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encodeUnknownPromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Promise<I>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L542"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "encodeUnknown",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encodeUnknown: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<I, ParseIssue, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L554"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "validateSync",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": "declare const validateSync: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L610"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "validateOption",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": "declare const validateOption: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L619"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "validateEither",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": "declare const validateEither: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L629"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "validatePromise",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": "declare const validatePromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Promise<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L639"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "validate",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": "declare const validate: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (a: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L651"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "is",
    "description": "By default the option `exact` is set to `true`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": "declare const is: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions | number) => u is A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L663"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "asserts",
    "description": "By default the option `exact` is set to `true`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": "declare const asserts: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => asserts u is A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L676"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "ParseResultFormatter",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "formatting",
    "signature": "export interface ParseResultFormatter<A> {\n  readonly formatIssue: (issue: ParseIssue) => Effect.Effect<A>\n  readonly formatIssueSync: (issue: ParseIssue) => A\n  readonly formatError: (error: ParseError) => Effect.Effect<A>\n  readonly formatErrorSync: (error: ParseError) => A\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L1735"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "ArrayFormatterIssue",
    "description": "Represents an issue returned by the {@link ArrayFormatter} formatter.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface ArrayFormatterIssue {\n  /**\n   * The tag identifying the type of parse issue.\n   */\n  readonly _tag: ParseIssue[\"_tag\"]\n\n  /**\n   * The path to the property where the issue occurred.\n   */\n  readonly path: ReadonlyArray<PropertyKey>\n\n  /**\n   * A descriptive message explaining the issue.\n   */\n  readonly message: string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L1952"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "ParseIssue",
    "description": "`ParseIssue` is a type that represents the different types of errors that can occur when decoding/encoding a value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "type ParseIssue = | Type\n  | Missing\n  | Unexpected\n  | Forbidden\n  // composite\n  | Pointer\n  | Refinement\n  | Transformation\n  | Composite",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L29"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "SingleOrNonEmpty",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "type SingleOrNonEmpty<A> = A | Arr.NonEmptyReadonlyArray<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L45"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "Path",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "type Path = SingleOrNonEmpty<PropertyKey>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L51"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "ParseErrorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "type id",
    "signature": "type ParseErrorTypeId = typeof ParseErrorTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L220"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "DecodeUnknown",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type DecodeUnknown<Out, R> = (u: unknown, options?: AST.ParseOptions) => Effect.Effect<Out, ParseIssue, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L409"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ParseResult.ts",
      "path": "src/ParseResult.ts"
    },
    "project": "effect",
    "name": "DeclarationDecodeUnknown",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type DeclarationDecodeUnknown<Out, R> = (\n  u: unknown,\n  options: AST.ParseOptions,\n  ast: AST.Declaration\n) => Effect.Effect<Out, ParseIssue, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ParseResult.ts#L414"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Pipeable.ts",
      "path": "src/Pipeable.ts"
    },
    "project": "effect",
    "name": "pipeArguments",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const pipeArguments: <A>(self: A, args: IArguments) => unknown",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pipeable.ts#L494"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Pipeable.ts",
      "path": "src/Pipeable.ts"
    },
    "project": "effect",
    "name": "Pipeable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Pipeable {\n  pipe<A>(this: A): A\n  pipe<A, B = never>(this: A, ab: (_: A) => B): B\n  pipe<A, B = never, C = never>(this: A, ab: (_: A) => B, bc: (_: B) => C): C\n  pipe<A, B = never, C = never, D = never>(this: A, ab: (_: A) => B, bc: (_: B) => C, cd: (_: C) => D): D\n  pipe<A, B = never, C = never, D = never, E = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E\n  ): E\n  pipe<A, B = never, C = never, D = never, E = never, F = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F\n  ): F\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G\n  ): G\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H\n  ): H\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I\n  ): I\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J\n  ): J\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K\n  ): K\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L\n  ): L\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M\n  ): M\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N\n  ): N\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O\n  ): O\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P\n  ): P\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q\n  ): Q\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R\n  ): R\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S\n  ): S\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never,\n    T = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S,\n    st: (_: S) => T\n  ): T\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never,\n    T = never,\n    U = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S,\n    st: (_: S) => T,\n    tu: (_: T) => U\n  ): U\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never,\n    T = never,\n    U = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S,\n    st: (_: S) => T,\n    tu: (_: T) => U\n  ): U\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pipeable.ts#L9"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pool.ts",
      "path": "src/Pool.ts"
    },
    "project": "effect",
    "name": "PoolTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const PoolTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L16"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pool.ts",
      "path": "src/Pool.ts"
    },
    "project": "effect",
    "name": "isPool",
    "description": "Returns `true` if the specified value is a `Pool`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isPool: (u: unknown) => u is Pool<unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L94"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pool.ts",
      "path": "src/Pool.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Makes a new pool of the specified fixed size. The pool is returned in a\n`Scope`, which governs the lifetime of the pool. When the pool is shutdown\nbecause the `Scope` is closed, the individual items allocated by the pool\nwill be released in some unspecified order.\n\nBy setting the `concurrency` parameter, you can control the level of concurrent\naccess per pool item. By default, the number of permits is set to `1`.\n\n`targetUtilization` determines when to create new pool items. It is a value\nbetween 0 and 1, where 1 means only create new pool items when all the existing\nitems are fully utilized.\n\nA `targetUtilization` of 0.5 will create new pool items when the existing items are\n50% utilized.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A, E, R>(options: { readonly acquire: Effect.Effect<A, E, R>; readonly size: number; readonly concurrency?: number | undefined; readonly targetUtilization?: number | undefined; }) => Effect.Effect<Pool<A, E>, never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L115"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pool.ts",
      "path": "src/Pool.ts"
    },
    "project": "effect",
    "name": "makeWithTTL",
    "description": "Makes a new pool with the specified minimum and maximum sizes and time to\nlive before a pool whose excess items are not being used will be shrunk\ndown to the minimum size. The pool is returned in a `Scope`, which governs\nthe lifetime of the pool. When the pool is shutdown because the `Scope` is\nused, the individual items allocated by the pool will be released in some\nunspecified order.\n\nBy setting the `concurrency` parameter, you can control the level of concurrent\naccess per pool item. By default, the number of permits is set to `1`.\n\n`targetUtilization` determines when to create new pool items. It is a value\nbetween 0 and 1, where 1 means only create new pool items when all the existing\nitems are fully utilized.\n\nA `targetUtilization` of 0.5 will create new pool items when the existing items are\n50% utilized.\n\nThe `timeToLiveStrategy` determines how items are invalidated. If set to\n\"creation\", then items are invalidated based on their creation time. If set\nto \"usage\", then items are invalidated based on pool usage.\n\nBy default, the `timeToLiveStrategy` is set to \"usage\".\n\n```ts skip-type-checking\nimport { createConnection } from \"mysql2\";\nimport { Duration, Effect, Pool } from \"effect\"\n\nconst acquireDBConnection = Effect.acquireRelease(\n  Effect.sync(() => createConnection('mysql://...')),\n  (connection) => Effect.sync(() => connection.end(() => {})),\n)\n\nconst connectionPool = Effect.flatMap(\n Pool.makeWithTTL({\n    acquire: acquireDBConnection,\n    min: 10,\n    max: 20,\n    timeToLive: Duration.seconds(60)\n  }),\n  (pool) => pool.get\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeWithTTL: <A, E, R>(options: { readonly acquire: Effect.Effect<A, E, R>; readonly min: number; readonly max: number; readonly concurrency?: number | undefined; readonly targetUtilization?: number | undefined; readonly timeToLive: Duration.DurationInput; readonly timeToLiveStrategy?: \"creation\" | \"usage\" | undefined; }) => Effect.Effect<Pool<A, E>, never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L171"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pool.ts",
      "path": "src/Pool.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves an item from the pool in a scoped effect. Note that if\nacquisition fails, then the returned effect will fail for that same reason.\nRetrying a failed acquisition attempt will repeat the acquisition attempt.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const get: <A, E>(self: Pool<A, E>) => Effect.Effect<A, E, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L191"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pool.ts",
      "path": "src/Pool.ts"
    },
    "project": "effect",
    "name": "invalidate",
    "description": "Invalidates the specified item. This will cause the pool to eventually\nreallocate the item, although this reallocation may occur lazily rather\nthan eagerly.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const invalidate: { <A>(value: A): <E>(self: Pool<A, E>) => Effect.Effect<void, never, Scope.Scope>; <A, E>(self: Pool<A, E>, value: A): Effect.Effect<void, never, Scope.Scope>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L201"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Pool.ts",
      "path": "src/Pool.ts"
    },
    "project": "effect",
    "name": "Pool",
    "description": "A `Pool<A, E>` is a pool of items of type `A`, each of which may be\nassociated with the acquisition and release of resources. An attempt to get\nan item `A` from a pool may fail with an error of type `E`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Pool<in out A, out E = never> extends Pool.Variance<A, E>, Effect.Effect<A, E, Scope.Scope>, Pipeable {\n  /**\n   * Retrieves an item from the pool in a scoped effect. Note that if\n   * acquisition fails, then the returned effect will fail for that same reason.\n   * Retrying a failed acquisition attempt will repeat the acquisition attempt.\n   */\n  readonly get: Effect.Effect<A, E, Scope.Scope>\n\n  /**\n   * Invalidates the specified item. This will cause the pool to eventually\n   * reallocate the item, although this reallocation may occur lazily rather\n   * than eagerly.\n   */\n  invalidate(item: A): Effect.Effect<void>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: PoolUnify<this>\n  readonly [Unify.ignoreSymbol]?: PoolUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L32"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Pool.ts",
      "path": "src/Pool.ts"
    },
    "project": "effect",
    "name": "PoolUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface PoolUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Pool?: () => Extract<A[Unify.typeSymbol], Pool<any, any>> extends Pool<infer A0, infer _E0> | infer _ ?\n    A0 extends any ? Extract<A[Unify.typeSymbol], Pool<A0, any>> extends Pool<A0, infer E1> ? Pool<A0, E1>\n      : never\n    : never :\n    never\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L56"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Pool.ts",
      "path": "src/Pool.ts"
    },
    "project": "effect",
    "name": "PoolUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface PoolUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L68"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Pool.ts",
      "path": "src/Pool.ts"
    },
    "project": "effect",
    "name": "PoolTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type PoolTypeId = typeof PoolTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L22"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Pool.ts",
      "path": "src/Pool.ts"
    },
    "project": "effect",
    "name": "Pool.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out A, out E> {\n    readonly [PoolTypeId]: {\n      readonly _A: Types.Invariant<A>\n      readonly _E: Types.Covariant<E>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pool.ts#L80"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "mapInput",
    "description": "Given a `Predicate<A>` returns a `Predicate<B>`",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Predicate, Number } from \"effect\"\n\nconst minLength3 = Predicate.mapInput(Number.greaterThan(2), (s: string) => s.length)\n\nassert.deepStrictEqual(minLength3(\"a\"), false)\nassert.deepStrictEqual(minLength3(\"aa\"), false)\nassert.deepStrictEqual(minLength3(\"aaa\"), true)\nassert.deepStrictEqual(minLength3(\"aaaa\"), true)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const mapInput: { <B, A>(f: (b: B) => A): (self: Predicate<A>) => Predicate<B>; <A, B>(self: Predicate<A>, f: (b: B) => A): Predicate<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L90"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isTupleOf",
    "description": "Determine if an `Array` is a tuple with exactly `N` elements, narrowing down the type to `TupleOf`.\n\nAn `Array` is considered to be a `TupleOf` if its length is exactly `N`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isTupleOf } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isTupleOf([1, 2, 3], 3), true);\nassert.deepStrictEqual(isTupleOf([1, 2, 3], 2), false);\nassert.deepStrictEqual(isTupleOf([1, 2, 3], 4), false);\n\nconst arr: number[] = [1, 2, 3];\nif (isTupleOf(arr, 3)) {\n  console.log(arr);\n  // ^? [number, number, number]\n}\n```"
    ],
    "since": "3.3.0",
    "category": "guards",
    "signature": "declare const isTupleOf: { <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOf<N, T>; <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOf<N, T>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L119"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isTupleOfAtLeast",
    "description": "Determine if an `Array` is a tuple with at least `N` elements, narrowing down the type to `TupleOfAtLeast`.\n\nAn `Array` is considered to be a `TupleOfAtLeast` if its length is at least `N`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isTupleOfAtLeast } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 3), true);\nassert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 2), true);\nassert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 4), false);\n\nconst arr: number[] = [1, 2, 3, 4];\nif (isTupleOfAtLeast(arr, 3)) {\n  console.log(arr);\n  // ^? [number, number, number, ...number[]]\n}\n```"
    ],
    "since": "3.3.0",
    "category": "guards",
    "signature": "declare const isTupleOfAtLeast: { <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOfAtLeast<N, T>; <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOfAtLeast<N, T>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L148"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isFunction",
    "description": "Tests if a value is a `function`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isFunction } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isFunction(isFunction), true)\n\nassert.deepStrictEqual(isFunction(\"function\"), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isFunction: (input: unknown) => input is Function",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L320"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "hasProperty",
    "description": "Checks whether a value is an `object` containing a specified property key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const hasProperty: { <P extends PropertyKey>(property: P): (self: unknown) => self is { [K in P]: unknown; }; <P extends PropertyKey>(self: unknown, property: P): self is { [K in P]: unknown; }; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L467"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isTagged",
    "description": "Tests if a value is an `object` with a property `_tag` that matches the given tag.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isTagged } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isTagged(1, \"a\"), false)\nassert.deepStrictEqual(isTagged(null, \"a\"), false)\nassert.deepStrictEqual(isTagged({}, \"a\"), false)\nassert.deepStrictEqual(isTagged({ a: \"a\" }, \"a\"), false)\nassert.deepStrictEqual(isTagged({ _tag: \"a\" }, \"a\"), true)\nassert.deepStrictEqual(isTagged(\"a\")({ _tag: \"a\" }), true)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isTagged: { <K extends string>(tag: K): (self: unknown) => self is { _tag: K; }; <K extends string>(self: unknown, tag: K): self is { _tag: K; }; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L495"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isReadonlyRecord",
    "description": "A guard that succeeds when the input is a readonly record.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isReadonlyRecord } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isReadonlyRecord({}), true)\nassert.deepStrictEqual(isReadonlyRecord({ a: 1 }), true)\n\nassert.deepStrictEqual(isReadonlyRecord([]), false)\nassert.deepStrictEqual(isReadonlyRecord([1, 2, 3]), false)\nassert.deepStrictEqual(isReadonlyRecord(null), false)\nassert.deepStrictEqual(isReadonlyRecord(undefined), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isReadonlyRecord: (input: unknown) => input is { readonly [x: string | symbol]: unknown; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L664"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "compose",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const compose: { <A, B extends A, C extends B>(bc: Refinement<B, C>): (ab: Refinement<A, B>) => Refinement<A, C>; <A, B extends A>(bc: Predicate<NoInfer<B>>): (ab: Refinement<A, B>) => Refinement<A, B>; <A, B extends A, C extends B>(ab: Refinement<A, B>, bc: Refinement<B, C>): Refinement<A, C>; <A, B extends A>(ab: Refinement<A, B>, bc: Predicate<NoInfer<B>>): Refinement<A, B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L716"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "struct",
    "description": "```ts skip-type-checking\n{ ab: Refinement<A, B>; cd: Refinement<C, D>, ... } -> Refinement<{ ab: A; cd: C; ... }, { ab: B; cd: D; ... }>\n{ a: Predicate<A, B>; b: Predicate<B>, ... } -> Predicate<{ a: A; b: B; ... }>\n{ ab: Refinement<A, B>; c: Predicate<C>, ... } -> Refinement<{ ab: A; c: C; ... }, { ab: B; c: ; ... }>\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const struct: <R extends Record<string, Predicate.Any>>(fields: R) => [Extract<R[keyof R], Refinement.Any>] extends [never] ? Predicate<{ readonly [K in keyof R]: Predicate.In<R[K]>; }> : Refinement<{ readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.In<R[K]> : Predicate.In<R[K]>; }, { readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.Out<R[K]> : Predicate.In<R[K]>; }>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L799"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "or",
    "description": "Combines two predicates into a new predicate that returns `true` if at least one of the predicates returns `true`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Predicate, Number } from \"effect\"\n\nconst nonZero = Predicate.or(Number.lessThan(0), Number.greaterThan(0))\n\nassert.deepStrictEqual(nonZero(-1), true)\nassert.deepStrictEqual(nonZero(0), false)\nassert.deepStrictEqual(nonZero(1), true)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const or: { <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B | C>; <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B | C>; <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L858"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "and",
    "description": "Combines two predicates into a new predicate that returns `true` if both of the predicates returns `true`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Predicate } from \"effect\"\n\nconst minLength = (n: number) => (s: string) => s.length >= n\nconst maxLength = (n: number) => (s: string) => s.length <= n\n\nconst length = (n: number) => Predicate.and(minLength(n), maxLength(n))\n\nassert.deepStrictEqual(length(2)(\"aa\"), true)\nassert.deepStrictEqual(length(2)(\"a\"), false)\nassert.deepStrictEqual(length(2)(\"aaa\"), false)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const and: { <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B & C>; <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B & C>; <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L886"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "xor",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const xor: { <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L897"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "eqv",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const eqv: { <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L906"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "implies",
    "description": "Represents the logical implication combinator for predicates. In formal\nlogic, the implication operator `->` denotes that if the first proposition\n(antecedent) is true, then the second proposition (consequent) must also be\ntrue. In simpler terms, `p implies q` can be interpreted as \"if p then q\". If\nthe first predicate holds, then the second predicate must hold\nfor the given context.\n\nIn practical terms within TypeScript, `p implies q` is equivalent to `!p || (p && q)`.\n\nNote that if the antecedent is `false`, the result is `true` by default\nbecause the outcome of the consequent cannot be determined.\n\nThis function is useful in situations where you need to enforce rules or\nconstraints that are contingent on certain conditions.\nIt proves especially helpful in defining property tests.\n\nThe example below illustrates the transitive property of order using the\n`implies` function. In simple terms, if `a <= b` and `b <= c`, then `a <= c`\nmust be true.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Predicate } from \"effect\"\n\ntype Triple = {\n  readonly a: number\n  readonly b: number\n  readonly c: number\n}\n\nconst transitivity = Predicate.implies(\n  // antecedent\n  (input: Triple) => input.a <= input.b && input.b <= input.c,\n  // consequent\n  (input: Triple) => input.a <= input.c\n)\n\nassert.equal(transitivity({ a: 1, b: 2, c: 3 }), true)\n// antecedent is `false`, so the result is `true`\nassert.equal(transitivity({ a: 1, b: 0, c: 0 }), true)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const implies: { <A>(consequent: Predicate<A>): (antecedent: Predicate<A>) => Predicate<A>; <A>(antecedent: Predicate<A>, consequent: Predicate<A>): Predicate<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L958"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "nor",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const nor: { <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L970"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "nand",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const nand: { <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L982"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isTruthy",
    "description": "Tests if a value is `truthy`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isTruthy } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isTruthy(1), true)\nassert.deepStrictEqual(isTruthy(0), false)\nassert.deepStrictEqual(isTruthy(\"\"), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isTruthy: (input: unknown) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L169"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isSet",
    "description": "Tests if a value is a `Set`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isSet } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isSet(new Set([1, 2])), true)\nassert.deepStrictEqual(isSet(new Set()), true)\nassert.deepStrictEqual(isSet({}), false)\nassert.deepStrictEqual(isSet(null), false)\nassert.deepStrictEqual(isSet(undefined), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isSet: (input: unknown) => input is Set<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L189"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isMap",
    "description": "Tests if a value is a `Map`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isMap } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isMap(new Map()), true)\nassert.deepStrictEqual(isMap({}), false)\nassert.deepStrictEqual(isMap(null), false)\nassert.deepStrictEqual(isMap(undefined), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isMap: (input: unknown) => input is Map<unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L208"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isString",
    "description": "Tests if a value is a `string`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isString } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isString(\"a\"), true)\n\nassert.deepStrictEqual(isString(1), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isString: (input: unknown) => input is string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L226"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isNumber",
    "description": "Tests if a value is a `number`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isNumber } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNumber(2), true)\n\nassert.deepStrictEqual(isNumber(\"2\"), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isNumber: (input: unknown) => input is number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L244"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isBoolean",
    "description": "Tests if a value is a `boolean`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isBoolean } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isBoolean(true), true)\n\nassert.deepStrictEqual(isBoolean(\"true\"), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isBoolean: (input: unknown) => input is boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L262"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isBigInt",
    "description": "Tests if a value is a `bigint`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isBigInt } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isBigInt(1n), true)\n\nassert.deepStrictEqual(isBigInt(1), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isBigInt: (input: unknown) => input is bigint",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L280"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isSymbol",
    "description": "Tests if a value is a `symbol`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isSymbol } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isSymbol(Symbol.for(\"a\")), true)\n\nassert.deepStrictEqual(isSymbol(\"a\"), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isSymbol: (input: unknown) => input is symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L298"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isUndefined",
    "description": "Tests if a value is `undefined`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isUndefined } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isUndefined(undefined), true)\n\nassert.deepStrictEqual(isUndefined(null), false)\nassert.deepStrictEqual(isUndefined(\"undefined\"), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isUndefined: (input: unknown) => input is undefined",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L339"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isNotUndefined",
    "description": "Tests if a value is not `undefined`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isNotUndefined } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNotUndefined(null), true)\nassert.deepStrictEqual(isNotUndefined(\"undefined\"), true)\n\nassert.deepStrictEqual(isNotUndefined(undefined), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isNotUndefined: <A>(input: A) => input is Exclude<A, undefined>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L358"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isNull",
    "description": "Tests if a value is `null`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isNull } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNull(null), true)\n\nassert.deepStrictEqual(isNull(undefined), false)\nassert.deepStrictEqual(isNull(\"null\"), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isNull: (input: unknown) => input is null",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L377"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isNotNull",
    "description": "Tests if a value is not `null`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isNotNull } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNotNull(undefined), true)\nassert.deepStrictEqual(isNotNull(\"null\"), true)\n\nassert.deepStrictEqual(isNotNull(null), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isNotNull: <A>(input: A) => input is Exclude<A, null>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L396"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isNever",
    "description": "A guard that always fails.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isNever } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNever(null), false)\nassert.deepStrictEqual(isNever(undefined), false)\nassert.deepStrictEqual(isNever({}), false)\nassert.deepStrictEqual(isNever([]), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isNever: (input: unknown) => input is never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L415"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isUnknown",
    "description": "A guard that always succeeds.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isUnknown } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isUnknown(null), true)\nassert.deepStrictEqual(isUnknown(undefined), true)\n\nassert.deepStrictEqual(isUnknown({}), true)\nassert.deepStrictEqual(isUnknown([]), true)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isUnknown: (input: unknown) => input is unknown",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L435"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isObject",
    "description": "Tests if a value is an `object`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isObject } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isObject({}), true)\nassert.deepStrictEqual(isObject([]), true)\n\nassert.deepStrictEqual(isObject(null), false)\nassert.deepStrictEqual(isObject(undefined), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isObject: (input: unknown) => input is object",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L459"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isNullable",
    "description": "A guard that succeeds when the input is `null` or `undefined`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isNullable } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNullable(null), true)\nassert.deepStrictEqual(isNullable(undefined), true)\n\nassert.deepStrictEqual(isNullable({}), false)\nassert.deepStrictEqual(isNullable([]), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isNullable: <A>(input: A) => input is Extract<A, null | undefined>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L521"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isNotNullable",
    "description": "A guard that succeeds when the input is not `null` or `undefined`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isNotNullable } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNotNullable({}), true)\nassert.deepStrictEqual(isNotNullable([]), true)\n\nassert.deepStrictEqual(isNotNullable(null), false)\nassert.deepStrictEqual(isNotNullable(undefined), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isNotNullable: <A>(input: A) => input is NonNullable<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L541"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isError",
    "description": "A guard that succeeds when the input is an `Error`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isError } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isError(new Error()), true)\n\nassert.deepStrictEqual(isError(null), false)\nassert.deepStrictEqual(isError({}), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isError: (input: unknown) => input is Error",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L560"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isUint8Array",
    "description": "A guard that succeeds when the input is a `Uint8Array`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isUint8Array } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isUint8Array(new Uint8Array()), true)\n\nassert.deepStrictEqual(isUint8Array(null), false)\nassert.deepStrictEqual(isUint8Array({}), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isUint8Array: (input: unknown) => input is Uint8Array",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L579"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isDate",
    "description": "A guard that succeeds when the input is a `Date`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isDate } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isDate(new Date()), true)\n\nassert.deepStrictEqual(isDate(null), false)\nassert.deepStrictEqual(isDate({}), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isDate: (input: unknown) => input is Date",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L598"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isIterable",
    "description": "A guard that succeeds when the input is an `Iterable`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isIterable } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isIterable([]), true)\nassert.deepStrictEqual(isIterable(new Set()), true)\n\nassert.deepStrictEqual(isIterable(null), false)\nassert.deepStrictEqual(isIterable({}), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isIterable: (input: unknown) => input is Iterable<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L618"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isRecord",
    "description": "A guard that succeeds when the input is a record.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isRecord } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isRecord({}), true)\nassert.deepStrictEqual(isRecord({ a: 1 }), true)\n\nassert.deepStrictEqual(isRecord([]), false)\nassert.deepStrictEqual(isRecord([1, 2, 3]), false)\nassert.deepStrictEqual(isRecord(null), false)\nassert.deepStrictEqual(isRecord(undefined), false)\nassert.deepStrictEqual(isRecord(() => null), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isRecord: (input: unknown) => input is { [x: string | symbol]: unknown; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L641"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isPromise",
    "description": "A guard that succeeds when the input is a Promise.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isPromise } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isPromise({}), false)\nassert.deepStrictEqual(isPromise(Promise.resolve(\"hello\")), true)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isPromise: (input: unknown) => input is Promise<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L683"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isPromiseLike",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isPromiseLike: (input: unknown) => input is PromiseLike<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L692"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "isRegExp",
    "description": "Tests if a value is a `RegExp`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Predicate } from \"effect\"\n\nassert.deepStrictEqual(Predicate.isRegExp(/a/), true)\nassert.deepStrictEqual(Predicate.isRegExp(\"a\"), false)\n```"
    ],
    "since": "3.9.0",
    "category": "guards",
    "signature": "declare const isRegExp: (input: unknown) => input is RegExp",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L711"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "product",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const product: <A, B>(self: Predicate<A>, that: Predicate<B>) => Predicate<readonly [A, B]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L731"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "all",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const all: <A>(collection: Iterable<Predicate<A>>) => Predicate<ReadonlyArray<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L739"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "productMany",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "declare const productMany: <A>(self: Predicate<A>, collection: Iterable<Predicate<A>>) => Predicate<readonly [A, ...Array<A>]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L761"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "tuple",
    "description": "Similar to `Promise.all` but operates on `Predicate`s.\n\n```ts skip-type-checking\n[Refinement<A, B>, Refinement<C, D>, ...] -> Refinement<[A, C, ...], [B, D, ...]>\n[Predicate<A>, Predicate<B>, ...] -> Predicate<[A, B, ...]>\n[Refinement<A, B>, Predicate<C>, ...] -> Refinement<[A, C, ...], [B, C, ...]>\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const tuple: <T extends ReadonlyArray<Predicate.Any>>(...elements: T) => [Extract<T[number], Refinement.Any>] extends [never] ? Predicate<{ readonly [I in keyof T]: Predicate.In<T[I]>; }> : Refinement<{ readonly [I in keyof T]: T[I] extends Refinement.Any ? Refinement.In<T[I]> : Predicate.In<T[I]>; }, { readonly [I in keyof T]: T[I] extends Refinement.Any ? Refinement.Out<T[I]> : Predicate.In<T[I]>; }>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L780"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "not",
    "description": "Negates the result of a given predicate.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Predicate, Number } from \"effect\"\n\nconst isPositive = Predicate.not(Number.lessThan(0))\n\nassert.deepStrictEqual(isPositive(-1), false)\nassert.deepStrictEqual(isPositive(0), true)\nassert.deepStrictEqual(isPositive(1), true)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const not: <A>(self: Predicate<A>) => Predicate<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L838"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "every",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const every: <A>(collection: Iterable<Predicate<A>>) => Predicate<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L994"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "some",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const some: <A>(collection: Iterable<Predicate<A>>) => Predicate<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L1007"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "Predicate",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Predicate<in A> {\n  (a: A): boolean\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L12"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "PredicateTypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface PredicateTypeLambda extends TypeLambda {\n  readonly type: Predicate<this[\"Target\"]>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L20"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "Refinement",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Refinement<in A, out B extends A> {\n  (a: A): a is B\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L28"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "Predicate.In",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "type-level",
    "signature": "type In<T> = [T] extends [Predicate<infer _A>] ? _A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L41"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "Predicate.Any",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "type-level",
    "signature": "type Any = Predicate<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L46"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "Refinement.In",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "type-level",
    "signature": "type In<T> = [T] extends [Refinement<infer _A, infer _>] ? _A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L58"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "Refinement.Out",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "type-level",
    "signature": "type Out<T> = [T] extends [Refinement<infer _, infer _B>] ? _B : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L63"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Predicate.ts",
      "path": "src/Predicate.ts"
    },
    "project": "effect",
    "name": "Refinement.Any",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "type-level",
    "signature": "type Any = Refinement<any, any>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Predicate.ts#L68"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pretty.ts",
      "path": "src/Pretty.ts"
    },
    "project": "effect",
    "name": "match",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const match: AST.Match<Pretty<any>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pretty.ts#L51"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Pretty.ts",
      "path": "src/Pretty.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "prettify",
    "signature": "declare const make: <A, I, R>(schema: Schema.Schema<A, I, R>) => (a: A) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pretty.ts#L32"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Pretty.ts",
      "path": "src/Pretty.ts"
    },
    "project": "effect",
    "name": "Pretty",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface Pretty<To> {\n  (a: To): string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pretty.ts#L16"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Pretty.ts",
      "path": "src/Pretty.ts"
    },
    "project": "effect",
    "name": "PrettyAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type PrettyAnnotation<A, TypeParameters> = (\n  ...pretties: { readonly [K in keyof TypeParameters]: Pretty<TypeParameters[K]> }\n) => Pretty<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Pretty.ts#L24"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PrimaryKey.ts",
      "path": "src/PrimaryKey.ts"
    },
    "project": "effect",
    "name": "symbol",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const symbol: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PrimaryKey.ts#L9"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "PrimaryKey.ts",
      "path": "src/PrimaryKey.ts"
    },
    "project": "effect",
    "name": "value",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessors",
    "signature": "declare const value: (self: PrimaryKey) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PrimaryKey.ts#L23"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "PrimaryKey.ts",
      "path": "src/PrimaryKey.ts"
    },
    "project": "effect",
    "name": "PrimaryKey",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface PrimaryKey {\n  [symbol](): string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PrimaryKey.ts#L15"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "bounded",
    "description": "Creates a bounded `PubSub` with the back pressure strategy. The `PubSub` will retain\nmessages until they have been taken by all subscribers, applying back\npressure to publishers if the `PubSub` is at capacity.\n\nFor best performance use capacities that are powers of two.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const bounded: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L49"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "dropping",
    "description": "Creates a bounded `PubSub` with the dropping strategy. The `PubSub` will drop new\nmessages if the `PubSub` is at capacity.\n\nFor best performance use capacities that are powers of two.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dropping: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L62"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "sliding",
    "description": "Creates a bounded `PubSub` with the sliding strategy. The `PubSub` will add new\nmessages and drop old messages if the `PubSub` is at capacity.\n\nFor best performance use capacities that are powers of two.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sliding: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L75"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "unbounded",
    "description": "Creates an unbounded `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unbounded: <A>(options?: { readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L85"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "capacity",
    "description": "Returns the number of elements the queue can hold.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const capacity: <A>(self: PubSub<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L94"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Retrieves the size of the queue, which is equal to the number of elements\nin the queue. This may be negative if fibers are suspended waiting for\nelements to be added to the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <A>(self: PubSub<A>) => Effect.Effect<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L104"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "isFull",
    "description": "Returns `true` if the `Queue` contains at least one element, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isFull: <A>(self: PubSub<A>) => Effect.Effect<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L113"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the `Queue` contains zero elements, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isEmpty: <A>(self: PubSub<A>) => Effect.Effect<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L121"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "shutdown",
    "description": "Interrupts any fibers that are suspended on `offer` or `take`. Future calls\nto `offer*` and `take*` will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const shutdown: <A>(self: PubSub<A>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L130"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "isShutdown",
    "description": "Returns `true` if `shutdown` has been called, otherwise returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isShutdown: <A>(self: PubSub<A>) => Effect.Effect<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L138"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "awaitShutdown",
    "description": "Waits until the queue is shutdown. The `Effect` returned by this method will\nnot resume until the queue has been shutdown. If the queue is already\nshutdown, the `Effect` will resume right away.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const awaitShutdown: <A>(self: PubSub<A>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L148"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "publish",
    "description": "Publishes a message to the `PubSub`, returning whether the message was published\nto the `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const publish: { <A>(value: A): (self: PubSub<A>) => Effect.Effect<boolean>; <A>(self: PubSub<A>, value: A): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L157"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "publishAll",
    "description": "Publishes all of the specified messages to the `PubSub`, returning whether they\nwere published to the `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const publishAll: { <A>(elements: Iterable<A>): (self: PubSub<A>) => Effect.Effect<boolean>; <A>(self: PubSub<A>, elements: Iterable<A>): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L169"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "subscribe",
    "description": "Subscribes to receive messages from the `PubSub`. The resulting subscription can\nbe evaluated multiple times within the scope to take a message from the `PubSub`\neach time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const subscribe: <A>(self: PubSub<A>) => Effect.Effect<Queue.Dequeue<A>, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L182"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "PubSub.ts",
      "path": "src/PubSub.ts"
    },
    "project": "effect",
    "name": "PubSub",
    "description": "A `PubSub<A>` is an asynchronous message hub into which publishers can publish\nmessages of type `A` and subscribers can subscribe to take messages of type\n`A`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface PubSub<in out A> extends Queue.Enqueue<A>, Pipeable {\n  /**\n   * Publishes a message to the `PubSub`, returning whether the message was published\n   * to the `PubSub`.\n   */\n  publish(value: A): Effect.Effect<boolean>\n\n  /**\n   * Publishes all of the specified messages to the `PubSub`, returning whether they\n   * were published to the `PubSub`.\n   */\n  publishAll(elements: Iterable<A>): Effect.Effect<boolean>\n\n  /**\n   * Subscribes to receive messages from the `PubSub`. The resulting subscription can\n   * be evaluated multiple times within the scope to take a message from the `PubSub`\n   * each time.\n   */\n  readonly subscribe: Effect.Effect<Queue.Dequeue<A>, never, Scope.Scope>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/PubSub.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "EnqueueTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const EnqueueTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L19"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "DequeueTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const DequeueTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L31"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "QueueStrategyTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const QueueStrategyTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L43"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "BackingQueueTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const BackingQueueTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L55"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "isQueue",
    "description": "Returns `true` if the specified value is a `Queue`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isQueue: (u: unknown) => u is Queue<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L381"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "isDequeue",
    "description": "Returns `true` if the specified value is a `Dequeue`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isDequeue: (u: unknown) => u is Dequeue<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L389"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "isEnqueue",
    "description": "Returns `true` if the specified value is a `Enqueue`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isEnqueue: (u: unknown) => u is Enqueue<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L397"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "backPressureStrategy",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "strategies",
    "signature": "declare const backPressureStrategy: <A>() => Strategy<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L403"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "droppingStrategy",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "strategies",
    "signature": "declare const droppingStrategy: <A>() => Strategy<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L409"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "slidingStrategy",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "strategies",
    "signature": "declare const slidingStrategy: <A>() => Strategy<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L415"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A>(queue: BackingQueue<A>, strategy: Strategy<A>) => Effect.Effect<Queue<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L421"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "bounded",
    "description": "Makes a new bounded `Queue`. When the capacity of the queue is reached, any\nadditional calls to `offer` will be suspended until there is more room in\nthe queue.\n\n**Note**: When possible use only power of 2 capacities; this will provide\nbetter performance by utilising an optimised version of the underlying\n`RingBuffer`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const bounded: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L435"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "dropping",
    "description": "Makes a new bounded `Queue` with the dropping strategy.\n\nWhen the capacity of the queue is reached, new elements will be dropped and the\nold elements will remain.\n\n**Note**: When possible use only power of 2 capacities; this will provide\nbetter performance by utilising an optimised version of the underlying\n`RingBuffer`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dropping: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L450"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "sliding",
    "description": "Makes a new bounded `Queue` with the sliding strategy.\n\nWhen the capacity of the queue is reached, new elements will be added and the\nold elements will be dropped.\n\n**Note**: When possible use only power of 2 capacities; this will provide\nbetter performance by utilising an optimised version of the underlying\n`RingBuffer`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sliding: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L465"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "unbounded",
    "description": "Creates a new unbounded `Queue`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unbounded: <A>() => Effect.Effect<Queue<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L473"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "capacity",
    "description": "Returns the number of elements the queue can hold.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const capacity: <A>(self: Dequeue<A> | Enqueue<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L481"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Retrieves the size of the queue, which is equal to the number of elements\nin the queue. This may be negative if fibers are suspended waiting for\nelements to be added to the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L491"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the `Queue` contains zero elements, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isEmpty: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L499"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "isFull",
    "description": "Returns `true` if the `Queue` contains at least one element, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isFull: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L508"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "isShutdown",
    "description": "Returns `true` if `shutdown` has been called, otherwise returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isShutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L516"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "awaitShutdown",
    "description": "Waits until the queue is shutdown. The `Effect` returned by this method will\nnot resume until the queue has been shutdown. If the queue is already\nshutdown, the `Effect` will resume right away.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const awaitShutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L526"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "shutdown",
    "description": "Interrupts any fibers that are suspended on `offer` or `take`. Future calls\nto `offer*` and `take*` will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const shutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L535"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "offer",
    "description": "Places one value in the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const offer: { <A>(value: A): (self: Enqueue<A>) => Effect.Effect<boolean>; <A>(self: Enqueue<A>, value: A): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L543"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "unsafeOffer",
    "description": "Places one value in the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const unsafeOffer: { <A>(value: A): (self: Enqueue<A>) => boolean; <A>(self: Enqueue<A>, value: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L554"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "offerAll",
    "description": "For Bounded Queue: uses the `BackPressure` Strategy, places the values in\nthe queue and always returns true. If the queue has reached capacity, then\nthe fiber performing the `offerAll` will be suspended until there is room\nin the queue.\n\nFor Unbounded Queue: Places all values in the queue and returns true.\n\nFor Sliding Queue: uses `Sliding` Strategy If there is room in the queue,\nit places the values otherwise it removes the old elements and enqueues the\nnew ones. Always returns true.\n\nFor Dropping Queue: uses `Dropping` Strategy, It places the values in the\nqueue but if there is no room it will not enqueue them and return false.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const offerAll: { <A>(iterable: Iterable<A>): (self: Enqueue<A>) => Effect.Effect<boolean>; <A>(self: Enqueue<A>, iterable: Iterable<A>): Effect.Effect<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L577"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "poll",
    "description": "Returns the first value in the `Queue` as a `Some<A>`, or `None` if the queue\nis empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const poll: <A>(self: Dequeue<A>) => Effect.Effect<Option.Option<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L589"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "take",
    "description": "Takes the oldest value in the queue. If the queue is empty, this will return\na computation that resumes when an item has been added to the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const take: <A>(self: Dequeue<A>) => Effect.Effect<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L598"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "takeAll",
    "description": "Takes all the values in the queue and returns the values. If the queue is\nempty returns an empty collection.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const takeAll: <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L607"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "takeUpTo",
    "description": "Takes up to max number of values from the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const takeUpTo: { (max: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>; <A>(self: Dequeue<A>, max: number): Effect.Effect<Chunk.Chunk<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L615"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "takeBetween",
    "description": "Takes a number of elements from the queue between the specified minimum and\nmaximum. If there are fewer than the minimum number of elements available,\nsuspends until at least the minimum number of elements have been collected.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const takeBetween: { (min: number, max: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>; <A>(self: Dequeue<A>, min: number, max: number): Effect.Effect<Chunk.Chunk<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L628"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "takeN",
    "description": "Takes the specified number of elements from the queue. If there are fewer\nthan the specified number of elements available, it suspends until they\nbecome available.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const takeN: { (n: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>; <A>(self: Dequeue<A>, n: number): Effect.Effect<Chunk.Chunk<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L641"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "Queue",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Queue<in out A> extends Enqueue<A>, Dequeue<A> {\n  /** @internal */\n  readonly queue: BackingQueue<A>\n  /** @internal */\n  readonly takers: MutableQueue.MutableQueue<Deferred.Deferred<A>>\n  /** @internal */\n  readonly shutdownHook: Deferred.Deferred<void>\n  /** @internal */\n  readonly shutdownFlag: MutableRef.MutableRef<boolean>\n  /** @internal */\n  readonly strategy: Strategy<A>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: QueueUnify<this>\n  readonly [Unify.ignoreSymbol]?: QueueUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L67"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "QueueUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface QueueUnify<A extends { [Unify.typeSymbol]?: any }> extends DequeueUnify<A> {\n  Queue?: () => Extract<A[Unify.typeSymbol], Queue<any>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L88"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "QueueUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface QueueUnifyIgnore extends DequeueUnifyIgnore {\n  Dequeue?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L96"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "Enqueue",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Enqueue<in A> extends Queue.EnqueueVariance<A>, BaseQueue, Pipeable {\n  /**\n   * Places one value in the queue.\n   */\n  offer(value: A): Effect.Effect<boolean>\n\n  /**\n   * Places one value in the queue when possible without needing the fiber runtime.\n   */\n  unsafeOffer(value: A): boolean\n\n  /**\n   * For Bounded Queue: uses the `BackPressure` Strategy, places the values in\n   * the queue and always returns true. If the queue has reached capacity, then\n   * the fiber performing the `offerAll` will be suspended until there is room\n   * in the queue.\n   *\n   * For Unbounded Queue: Places all values in the queue and returns true.\n   *\n   * For Sliding Queue: uses `Sliding` Strategy If there is room in the queue,\n   * it places the values otherwise it removes the old elements and enqueues the\n   * new ones. Always returns true.\n   *\n   * For Dropping Queue: uses `Dropping` Strategy, It places the values in the\n   * queue but if there is no room it will not enqueue them and return false.\n   */\n  offerAll(iterable: Iterable<A>): Effect.Effect<boolean>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L104"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "Dequeue",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Dequeue<out A> extends Effect.Effect<A>, Queue.DequeueVariance<A>, BaseQueue {\n  /**\n   * Takes the oldest value in the queue. If the queue is empty, this will return\n   * a computation that resumes when an item has been added to the queue.\n   */\n  readonly take: Effect.Effect<A>\n\n  /**\n   * Takes all the values in the queue and returns the values. If the queue is\n   * empty returns an empty collection.\n   */\n  readonly takeAll: Effect.Effect<Chunk.Chunk<A>>\n\n  /**\n   * Takes up to max number of values from the queue.\n   */\n  takeUpTo(max: number): Effect.Effect<Chunk.Chunk<A>>\n\n  /**\n   * Takes a number of elements from the queue between the specified minimum and\n   * maximum. If there are fewer than the minimum number of elements available,\n   * suspends until at least the minimum number of elements have been collected.\n   */\n  takeBetween(min: number, max: number): Effect.Effect<Chunk.Chunk<A>>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: DequeueUnify<this>\n  readonly [Unify.ignoreSymbol]?: DequeueUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L137"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "DequeueUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface DequeueUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Dequeue?: () => A[Unify.typeSymbol] extends Dequeue<infer A0> | infer _ ? Dequeue<A0> : never\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L171"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "DequeueUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface DequeueUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L179"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "BaseQueue",
    "description": "The base interface that all `Queue`s must implement.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BaseQueue {\n  /**\n   * Returns the number of elements the queue can hold.\n   */\n  capacity(): number\n\n  /**\n   * Returns false if shutdown has been called.\n   */\n  isActive(): boolean\n\n  /**\n   * Retrieves the size of the queue, which is equal to the number of elements\n   * in the queue. This may be negative if fibers are suspended waiting for\n   * elements to be added to the queue.\n   */\n  readonly size: Effect.Effect<number>\n\n  /**\n   * Retrieves the size of the queue, which is equal to the number of elements\n   * in the queue. This may be negative if fibers are suspended waiting for\n   * elements to be added to the queue. Returns None if shutdown has been called\n   */\n  unsafeSize(): Option.Option<number>\n\n  /**\n   * Returns `true` if the `Queue` contains at least one element, `false`\n   * otherwise.\n   */\n  readonly isFull: Effect.Effect<boolean>\n\n  /**\n   * Returns `true` if the `Queue` contains zero elements, `false` otherwise.\n   */\n  readonly isEmpty: Effect.Effect<boolean>\n\n  /**\n   * Interrupts any fibers that are suspended on `offer` or `take`. Future calls\n   * to `offer*` and `take*` will be interrupted immediately.\n   */\n  readonly shutdown: Effect.Effect<void>\n\n  /**\n   * Returns `true` if `shutdown` has been called, otherwise returns `false`.\n   */\n  readonly isShutdown: Effect.Effect<boolean>\n\n  /**\n   * Waits until the queue is shutdown. The `Effect` returned by this method will\n   * not resume until the queue has been shutdown. If the queue is already\n   * shutdown, the `Effect` will resume right away.\n   */\n  readonly awaitShutdown: Effect.Effect<void>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L189"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "Strategy",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Strategy<in out A> extends Queue.StrategyVariance<A> {\n  /**\n   * Returns the number of surplus values that were unable to be added to the\n   * `Queue`\n   */\n  surplusSize(): number\n\n  /**\n   * Determines how the `Queue.Strategy` should shut down when the `Queue` is\n   * shut down.\n   */\n  readonly shutdown: Effect.Effect<void>\n\n  /**\n   * Determines the behavior of the `Queue.Strategy` when there are surplus\n   * values that could not be added to the `Queue` following an `offer`\n   * operation.\n   */\n  handleSurplus(\n    iterable: Iterable<A>,\n    queue: BackingQueue<A>,\n    takers: MutableQueue.MutableQueue<Deferred.Deferred<A>>,\n    isShutdown: MutableRef.MutableRef<boolean>\n  ): Effect.Effect<boolean>\n\n  /**\n   * It is called when the backing queue is empty but there are some\n   * takers that can be completed\n   */\n  onCompleteTakersWithEmptyQueue(\n    takers: MutableQueue.MutableQueue<Deferred.Deferred<A>>\n  ): void\n\n  /**\n   * Determines the behavior of the `Queue.Strategy` when the `Queue` has empty\n   * slots following a `take` operation.\n   */\n  unsafeOnQueueEmptySpace(\n    queue: BackingQueue<A>,\n    takers: MutableQueue.MutableQueue<Deferred.Deferred<A>>\n  ): void\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L248"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "BackingQueue",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BackingQueue<in out A> extends Queue.BackingQueueVariance<A> {\n  /**\n   * Dequeues an element from the queue.\n   * Returns either an element from the queue, or the `def` param.\n   */\n  poll<Def>(def: Def): A | Def\n  /**\n   * Dequeues up to `limit` elements from the queue.\n   */\n  pollUpTo(limit: number): Chunk.Chunk<A>\n  /**\n   * Enqueues a collection of values into the queue.\n   *\n   * Returns a `Chunk` of the values that were **not** able to be enqueued.\n   */\n  offerAll(elements: Iterable<A>): Chunk.Chunk<A>\n  /**\n   * Offers an element to the queue.\n   *\n   * Returns whether the enqueue was successful or not.\n   */\n  offer(element: A): boolean\n  /**\n   * The **maximum** number of elements that a queue can hold.\n   *\n   * **Note**: unbounded queues can still implement this interface with\n   * `capacity = Infinity`.\n   */\n  capacity(): number\n  /**\n   * Returns the number of elements currently in the queue\n   */\n  length(): number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L295"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "EnqueueTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type EnqueueTypeId = typeof EnqueueTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L25"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "DequeueTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type DequeueTypeId = typeof DequeueTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L37"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "QueueStrategyTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type QueueStrategyTypeId = typeof QueueStrategyTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L49"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "BackingQueueTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type BackingQueueTypeId = typeof BackingQueueTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L61"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "Queue.EnqueueVariance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface EnqueueVariance<in A> {\n    readonly [EnqueueTypeId]: {\n      readonly _In: Types.Contravariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L338"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "Queue.DequeueVariance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface DequeueVariance<out A> {\n    readonly [DequeueTypeId]: {\n      readonly _Out: Types.Covariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L348"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "Queue.StrategyVariance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface StrategyVariance<in out A> {\n    readonly [QueueStrategyTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L358"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue.ts",
      "path": "src/Queue.ts"
    },
    "project": "effect",
    "name": "Queue.BackingQueueVariance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BackingQueueVariance<in out A> {\n    readonly [BackingQueueTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Queue.ts#L368"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random.ts",
      "path": "src/Random.ts"
    },
    "project": "effect",
    "name": "RandomTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const RandomTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L17"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random.ts",
      "path": "src/Random.ts"
    },
    "project": "effect",
    "name": "next",
    "description": "Returns the next numeric value from the pseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const next: Effect.Effect<number, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L65"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random.ts",
      "path": "src/Random.ts"
    },
    "project": "effect",
    "name": "nextInt",
    "description": "Returns the next integer value from the pseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const nextInt: Effect.Effect<number, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L73"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random.ts",
      "path": "src/Random.ts"
    },
    "project": "effect",
    "name": "nextBoolean",
    "description": "Returns the next boolean value from the pseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const nextBoolean: Effect.Effect<boolean, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L81"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random.ts",
      "path": "src/Random.ts"
    },
    "project": "effect",
    "name": "nextRange",
    "description": "Returns the next numeric value in the specified range from the\npseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const nextRange: (min: number, max: number) => Effect.Effect<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L90"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random.ts",
      "path": "src/Random.ts"
    },
    "project": "effect",
    "name": "nextIntBetween",
    "description": "Returns the next integer value in the specified range from the\npseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const nextIntBetween: (min: number, max: number) => Effect.Effect<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L99"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random.ts",
      "path": "src/Random.ts"
    },
    "project": "effect",
    "name": "shuffle",
    "description": "Uses the pseudo-random number generator to shuffle the specified iterable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const shuffle: <A>(elements: Iterable<A>) => Effect.Effect<Chunk.Chunk<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L107"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random.ts",
      "path": "src/Random.ts"
    },
    "project": "effect",
    "name": "choice",
    "description": "Get a random element from an iterable.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Random } from \"effect\"\n\nEffect.gen(function* () {\n  const randomItem = yield* Random.choice([1, 2, 3])\n  console.log(randomItem)\n})\n```"
    ],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "declare const choice: <Self extends Iterable<unknown>>(elements: Self) => Self extends NonEmptyIterable.NonEmptyIterable<infer A> ? Effect.Effect<A> : Self extends Array.NonEmptyReadonlyArray<infer A> ? Effect.Effect<A> : Self extends Iterable<infer A> ? Effect.Effect<A, Cause.NoSuchElementException> : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L125"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random.ts",
      "path": "src/Random.ts"
    },
    "project": "effect",
    "name": "randomWith",
    "description": "Retreives the `Random` service from the context and uses it to run the\nspecified workflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const randomWith: <A, E, R>(f: (random: Random) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L139"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random.ts",
      "path": "src/Random.ts"
    },
    "project": "effect",
    "name": "Random",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const Random: Context.Tag<Random, Random>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L146"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random.ts",
      "path": "src/Random.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs the `Random` service, seeding the pseudo-random number generator\nwith an hash of the specified seed.\nThis constructor is useful for generating predictable sequences of random values for specific use cases.\n\nExample uses:\n- Generating random UI data for visual tests.\n- Creating data that needs to change daily but remain the same throughout a single day, such as using a date as the seed.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Effect, Random } from \"effect\"\n\nconst random1 = Random.make(\"myseed\")\nconst random2 = Random.make(\"myseed\")\n\nassert.equal(Effect.runSync(random1.next), Effect.runSync(random2.next))\n```"
    ],
    "since": "3.5.0",
    "category": "constructors",
    "signature": "declare const make: <A>(seed: A) => Random",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L171"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Random.ts",
      "path": "src/Random.ts"
    },
    "project": "effect",
    "name": "Random",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Random {\n  readonly [RandomTypeId]: RandomTypeId\n  /**\n   * Returns the next numeric value from the pseudo-random number generator.\n   */\n  readonly next: Effect.Effect<number>\n  /**\n   * Returns the next boolean value from the pseudo-random number generator.\n   */\n  readonly nextBoolean: Effect.Effect<boolean>\n  /**\n   * Returns the next integer value from the pseudo-random number generator.\n   */\n  readonly nextInt: Effect.Effect<number>\n  /**\n   * Returns the next numeric value in the specified range from the\n   * pseudo-random number generator.\n   */\n  nextRange(min: number, max: number): Effect.Effect<number>\n  /**\n   * Returns the next integer value in the specified range from the\n   * pseudo-random number generator.\n   */\n  nextIntBetween(min: number, max: number): Effect.Effect<number>\n  /**\n   * Uses the pseudo-random number generator to shuffle the specified iterable.\n   */\n  shuffle<A>(elements: Iterable<A>): Effect.Effect<Chunk.Chunk<A>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L29"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Random.ts",
      "path": "src/Random.ts"
    },
    "project": "effect",
    "name": "RandomTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type RandomTypeId = typeof RandomTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Random.ts#L23"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RateLimiter.ts",
      "path": "src/RateLimiter.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new `RateLimiter` which will utilize the specified algorithm\nto limit requests (defaults to `token-bucket`).\n\nNotes\n- Only the moment of starting the effect is rate limited. The number of concurrent executions is not bounded.\n- Instances of `RateLimiter` can be composed.\n- The \"cost\" per effect can be changed. See {@link withCost}",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, RateLimiter } from \"effect\";\nimport { compose } from \"effect/Function\"\n\nconst program = Effect.scoped(\n  Effect.gen(function* ($) {\n    const perMinuteRL = yield* $(RateLimiter.make({ limit: 30, interval: \"1 minutes\" }))\n    const perSecondRL = yield* $(RateLimiter.make({ limit: 2, interval: \"1 seconds\" }))\n\n    // This rate limiter respects both the 30 calls per minute\n    // and the 2 calls per second constraints.\n     const rateLimit = compose(perMinuteRL, perSecondRL)\n\n    // simulate repeated calls\n    for (let n = 0; n < 100; n++) {\n      // wrap the effect we want to limit with rateLimit\n      yield* $(rateLimit(Effect.log(\"Calling RateLimited Effect\")));\n    }\n  })\n);\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (options: RateLimiter.Options) => Effect<RateLimiter, never, Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RateLimiter.ts#L98"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RateLimiter.ts",
      "path": "src/RateLimiter.ts"
    },
    "project": "effect",
    "name": "withCost",
    "description": "Alters the per-effect cost of the rate-limiter.\n\nThis can be used for \"credit\" based rate-limiting where different API endpoints\ncost a different number of credits within a time window.\nEg: 1000 credits / hour, where a query costs 1 credit and a mutation costs 5 credits.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, RateLimiter } from \"effect\";\nimport { compose } from \"effect/Function\";\n\nconst program = Effect.scoped(\n  Effect.gen(function* ($) {\n    // Create a rate limiter that has an hourly limit of 1000 credits\n    const rateLimiter = yield* $(RateLimiter.make({ limit: 1000, interval: \"1 hours\" }));\n    // Query API costs 1 credit per call ( 1 is the default cost )\n    const queryAPIRL = compose(rateLimiter, RateLimiter.withCost(1));\n    // Mutation API costs 5 credits per call\n    const mutationAPIRL = compose(rateLimiter, RateLimiter.withCost(5));\n\n    // Use the pre-defined rate limiters\n    yield* $(queryAPIRL(Effect.log(\"Sample Query\")));\n    yield* $(mutationAPIRL(Effect.log(\"Sample Mutation\")));\n\n    // Or set a cost on-the-fly\n    yield* $(\n      rateLimiter(Effect.log(\"Another query with a different cost\")).pipe(\n        RateLimiter.withCost(3)\n      )\n    );\n  })\n);\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const withCost: (cost: number) => <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RateLimiter.ts#L138"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RateLimiter.ts",
      "path": "src/RateLimiter.ts"
    },
    "project": "effect",
    "name": "RateLimiter",
    "description": "Limits the number of calls to a resource to a maximum amount in some interval.\n\nNote that only the moment of starting the effect is rate limited: the number\nof concurrent executions is not bounded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RateLimiter {\n  <A, E, R>(task: Effect<A, E, R>): Effect<A, E, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RateLimiter.ts#L20"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RateLimiter.ts",
      "path": "src/RateLimiter.ts"
    },
    "project": "effect",
    "name": "RateLimiter.Options",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Options {\n    /**\n     * The maximum number of requests that should be allowed.\n     */\n    readonly limit: number\n    /**\n     * The interval to utilize for rate-limiting requests. The semantics of the\n     * specified `interval` vary depending on the chosen `algorithm`:\n     *\n     * `token-bucket`: The maximum number of requests will be spread out over\n     * the provided interval if no tokens are available.\n     *\n     * For example, for a `RateLimiter` using the `token-bucket` algorithm with\n     * a `limit` of `10` and an `interval` of `1 seconds`, `1` request can be\n     * made every `100 millis`.\n     *\n     * `fixed-window`: The maximum number of requests will be reset during each\n     * interval. For example, for a `RateLimiter` using the `fixed-window`\n     * algorithm with a `limit` of `10` and an `interval` of `1 seconds`, a\n     * maximum of `10` requests can be made each second.\n     */\n    readonly interval: DurationInput\n    /**\n     * The algorithm to utilize for rate-limiting requests.\n     *\n     * Defaults to `token-bucket`.\n     */\n    readonly algorithm?: \"fixed-window\" | \"token-bucket\"\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RateLimiter.ts#L32"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcMap.ts",
      "path": "src/RcMap.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "type ids",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcMap.ts#L16"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcMap.ts",
      "path": "src/RcMap.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "An `RcMap` can contain multiple reference counted resources that can be indexed\nby a key. The resources are lazily acquired on the first call to `get` and\nreleased when the last reference is released.\n\nComplex keys can extend `Equal` and `Hash` to allow lookups by value.\n\n**Options**\n\n- `capacity`: The maximum number of resources that can be held in the map.\n- `idleTimeToLive`: When the reference count reaches zero, the resource will be released after this duration.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, RcMap } from \"effect\"\n\nEffect.gen(function*() {\n  const map = yield* RcMap.make({\n    lookup: (key: string) =>\n      Effect.acquireRelease(\n        Effect.succeed(`acquired ${key}`),\n        () => Effect.log(`releasing ${key}`)\n      )\n  })\n\n  // Get \"foo\" from the map twice, which will only acquire it once.\n  // It will then be released once the scope closes.\n  yield* RcMap.get(map, \"foo\").pipe(\n    Effect.andThen(RcMap.get(map, \"foo\")),\n    Effect.scoped\n  )\n})\n```"
    ],
    "since": "3.5.0",
    "category": "models",
    "signature": "declare const make: { <K, A, E, R>(options: { readonly lookup: (key: K) => Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; readonly capacity?: undefined; }): Effect.Effect<RcMap<K, A, E>, never, Scope.Scope | R>; <K, A, E, R>(options: { readonly lookup: (key: K) => Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; readonly capacity: number; }): Effect.Effect<RcMap<K, A, E | Cause.ExceededCapacityException>, never, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcMap.ts#L84"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcMap.ts",
      "path": "src/RcMap.ts"
    },
    "project": "effect",
    "name": "get",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "combinators",
    "signature": "declare const get: { <K>(key: K): <A, E>(self: RcMap<K, A, E>) => Effect.Effect<A, E, Scope.Scope>; <K, A, E>(self: RcMap<K, A, E>, key: K): Effect.Effect<A, E, Scope.Scope>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcMap.ts#L105"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcMap.ts",
      "path": "src/RcMap.ts"
    },
    "project": "effect",
    "name": "keys",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "combinators",
    "signature": "declare const keys: <K, A, E>(self: RcMap<K, A, E>) => Effect.Effect<Array<K>, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcMap.ts#L114"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcMap.ts",
      "path": "src/RcMap.ts"
    },
    "project": "effect",
    "name": "invalidate",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "combinators",
    "signature": "declare const invalidate: { <K>(key: K): <A, E>(self: RcMap<K, A, E>) => Effect.Effect<void>; <K, A, E>(self: RcMap<K, A, E>, key: K): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcMap.ts#L120"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcMap.ts",
      "path": "src/RcMap.ts"
    },
    "project": "effect",
    "name": "touch",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "combinators",
    "signature": "declare const touch: { <K>(key: K): <A, E>(self: RcMap<K, A, E>) => Effect.Effect<void>; <K, A, E>(self: RcMap<K, A, E>, key: K): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcMap.ts#L129"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RcMap.ts",
      "path": "src/RcMap.ts"
    },
    "project": "effect",
    "name": "RcMap",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "models",
    "signature": "export interface RcMap<in K, out A, out E = never> extends Pipeable {\n  readonly [TypeId]: RcMap.Variance<K, A, E>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcMap.ts#L28"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RcMap.ts",
      "path": "src/RcMap.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "type ids",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcMap.ts#L22"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RcMap.ts",
      "path": "src/RcMap.ts"
    },
    "project": "effect",
    "name": "RcMap.Variance",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "models",
    "signature": "export interface Variance<K, A, E> {\n    readonly _K: Types.Contravariant<K>\n    readonly _A: Types.Covariant<A>\n    readonly _E: Types.Covariant<E>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcMap.ts#L41"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcRef.ts",
      "path": "src/RcRef.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "type ids",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcRef.ts#L16"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcRef.ts",
      "path": "src/RcRef.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Create an `RcRef` from an acquire `Effect`.\n\nAn RcRef wraps a reference counted resource that can be acquired and released\nmultiple times.\n\nThe resource is lazily acquired on the first call to `get` and released when\nthe last reference is released.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, RcRef } from \"effect\"\n\nEffect.gen(function*() {\n  const ref = yield* RcRef.make({\n    acquire: Effect.acquireRelease(\n      Effect.succeed(\"foo\"),\n      () => Effect.log(\"release foo\")\n    )\n  })\n\n  // will only acquire the resource once, and release it\n  // when the scope is closed\n  yield* RcRef.get(ref).pipe(\n    Effect.andThen(RcRef.get(ref)),\n    Effect.scoped\n  )\n})\n```"
    ],
    "since": "3.5.0",
    "category": "constructors",
    "signature": "declare const make: <A, E, R>(options: { readonly acquire: Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; }) => Effect.Effect<RcRef<A, E>, never, R | Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcRef.ts#L100"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcRef.ts",
      "path": "src/RcRef.ts"
    },
    "project": "effect",
    "name": "get",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "combinators",
    "signature": "declare const get: <A, E>(self: RcRef<A, E>) => Effect.Effect<A, E, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcRef.ts#L115"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RcRef.ts",
      "path": "src/RcRef.ts"
    },
    "project": "effect",
    "name": "RcRef",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "models",
    "signature": "export interface RcRef<out A, out E = never>\n  extends Effect.Effect<A, E, Scope.Scope>, Readable.Readable<A, E, Scope.Scope>\n{\n  readonly [TypeId]: RcRef.Variance<A, E>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: RcRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: RcRefUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcRef.ts#L28"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RcRef.ts",
      "path": "src/RcRef.ts"
    },
    "project": "effect",
    "name": "RcRefUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface RcRefUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  RcRef?: () => A[Unify.typeSymbol] extends RcRef<infer A0, infer E0> | infer _ ? RcRef<A0, E0>\n    : never\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcRef.ts#L41"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RcRef.ts",
      "path": "src/RcRef.ts"
    },
    "project": "effect",
    "name": "RcRefUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface RcRefUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcRef.ts#L50"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RcRef.ts",
      "path": "src/RcRef.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "type ids",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcRef.ts#L22"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RcRef.ts",
      "path": "src/RcRef.ts"
    },
    "project": "effect",
    "name": "RcRef.Variance",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "models",
    "signature": "export interface Variance<A, E> {\n    readonly _A: Types.Covariant<A>\n    readonly _E: Types.Covariant<E>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RcRef.ts#L62"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Readable.ts",
      "path": "src/Readable.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Readable.ts#L15"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Readable.ts",
      "path": "src/Readable.ts"
    },
    "project": "effect",
    "name": "map",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const map: { <A, B>(f: (a: NoInfer<A>) => B): <E, R>(fa: Readable<A, E, R>) => Readable<B, E, R>; <A, E, R, B>(self: Readable<A, E, R>, f: (a: NoInfer<A>) => B): Readable<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Readable.ts#L59"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Readable.ts",
      "path": "src/Readable.ts"
    },
    "project": "effect",
    "name": "mapEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const mapEffect: { <A, B, E2, R2>(f: (a: NoInfer<A>) => Effect<B, E2, R2>): <E, R>(fa: Readable<A, E, R>) => Readable<B, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Readable<A, E, R>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): Readable<B, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Readable.ts#L71"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Readable.ts",
      "path": "src/Readable.ts"
    },
    "project": "effect",
    "name": "isReadable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isReadable: (u: unknown) => u is Readable<unknown, unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Readable.ts#L36"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Readable.ts",
      "path": "src/Readable.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A, E, R>(get: Effect<A, E, R>) => Readable<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Readable.ts#L49"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Readable.ts",
      "path": "src/Readable.ts"
    },
    "project": "effect",
    "name": "unwrap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unwrap: <A, E, R, E1, R1>(effect: Effect<Readable<A, E, R>, E1, R1>) => Readable<A, E | E1, R | R1>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Readable.ts#L88"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Readable.ts",
      "path": "src/Readable.ts"
    },
    "project": "effect",
    "name": "Readable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Readable<A, E = never, R = never> extends Pipeable {\n  readonly [TypeId]: TypeId\n  readonly get: Effect<A, E, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Readable.ts#L27"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Readable.ts",
      "path": "src/Readable.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Readable.ts#L21"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "isEmptyReadonlyRecord",
    "description": "Determine if a record is empty.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isEmptyReadonlyRecord } from \"effect/Record\"\n\nassert.deepStrictEqual(isEmptyReadonlyRecord({}), true);\nassert.deepStrictEqual(isEmptyReadonlyRecord({ a: 3 }), false);\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isEmptyReadonlyRecord: <K extends string, A>(self: ReadonlyRecord<K, A>) => self is ReadonlyRecord<K, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L99"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "fromIterableWith",
    "description": "Takes an iterable and a projection function and returns a record.\nThe projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { fromIterableWith } from \"effect/Record\"\n\nconst input = [1, 2, 3, 4]\n\nassert.deepStrictEqual(\n  fromIterableWith(input, a => [String(a), a * 2]),\n  { '1': 2, '2': 4, '3': 6, '4': 8 }\n)\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterableWith: { <A, K extends string | symbol, B>(f: (a: A) => readonly [K, B]): (self: Iterable<A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <A, K extends string | symbol, B>(self: Iterable<A>, f: (a: A) => readonly [K, B]): Record<ReadonlyRecord.NonLiteralKey<K>, B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L123"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "fromEntries",
    "description": "Builds a record from an iterable of key-value pairs.\n\nIf there are conflicting keys when using `fromEntries`, the last occurrence of the key/value pair will overwrite the\nprevious ones. So the resulting record will only have the value of the last occurrence of each key.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { fromEntries } from \"effect/Record\"\n\nconst input: Array<[string, number]> = [[\"a\", 1], [\"b\", 2]]\n\nassert.deepStrictEqual(fromEntries(input), { a: 1, b: 2 })\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromEntries: <Entry extends readonly [string | symbol, any]>(entries: Iterable<Entry>) => Record<ReadonlyRecord.NonLiteralKey<Entry[0]>, Entry[1]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L195"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "collect",
    "description": "Transforms the values of a record into an `Array` with a custom mapping function.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { collect } from \"effect/Record\"\n\nconst x = { a: 1, b: 2, c: 3 }\nassert.deepStrictEqual(collect(x, (key, n) => [key, n]), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n```"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const collect: { <K extends string, A, B>(f: (key: K, a: A) => B): (self: ReadonlyRecord<K, A>) => Array<B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => B): Array<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L214"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "toEntries",
    "description": "Takes a record and returns an array of tuples containing its keys and values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { toEntries } from \"effect/Record\"\n\nconst x = { a: 1, b: 2, c: 3 }\nassert.deepStrictEqual(toEntries(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n```"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const toEntries: <K extends string, A>(self: ReadonlyRecord<K, A>) => Array<[K, A]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L243"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "has",
    "description": "Check if a given `key` exists in a record.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { empty, has } from \"effect/Record\"\n\nassert.deepStrictEqual(has({ a: 1, b: 2 }, \"a\"), true);\nassert.deepStrictEqual(has(empty<string>(), \"c\"), false);\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const has: { <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => boolean; <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L277"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieve a value at a particular key from a record, returning it wrapped in an `Option`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Record as R, Option } from \"effect\"\n\nconst person: Record<string, unknown> = { name: \"John Doe\", age: 35 }\n\nassert.deepStrictEqual(R.get(person, \"name\"), Option.some(\"John Doe\"))\nassert.deepStrictEqual(R.get(person, \"email\"), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const get: { <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => Option.Option<A>; <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): Option.Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L309"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "modify",
    "description": "Apply a function to the element at the specified key, creating a new record.\nIf the key does not exist, the record is returned unchanged.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Record as R } from \"effect\"\n\nconst f = (x: number) => x * 2\n\nassert.deepStrictEqual(\n R.modify({ a: 3 }, 'a', f),\n { a: 6 }\n)\nassert.deepStrictEqual(\n R.modify({ a: 3 } as Record<string, number>, 'b', f),\n { a: 3 }\n)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const modify: { <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Record<K, A | B>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Record<K, A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L341"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "modifyOption",
    "description": "Apply a function to the element at the specified key, creating a new record,\nor return `None` if the key doesn't exist.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Record as R, Option } from \"effect\"\n\nconst f = (x: number) => x * 2\n\nassert.deepStrictEqual(\n R.modifyOption({ a: 3 }, 'a', f),\n Option.some({ a: 6 })\n)\nassert.deepStrictEqual(\n R.modifyOption({ a: 3 } as Record<string, number>, 'b', f),\n Option.none()\n)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const modifyOption: { <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Option.Option<Record<K, A | B>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L380"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "replaceOption",
    "description": "Replaces a value in the record with the new value passed as parameter.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Record, Option } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),\n  Option.some({ a: 10, b: 2, c: 3 })\n)\nassert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), 'a', 10), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const replaceOption: { <K extends string | symbol, B>(key: NoInfer<K>, b: B): <A>(self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, b: B): Option.Option<Record<K, A | B>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L421"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "remove",
    "description": "If the given key exists in the record, returns a new record with the key removed,\notherwise returns a copy of the original record.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { remove } from \"effect/Record\"\n\nassert.deepStrictEqual(remove({ a: 1, b: 2 }, \"a\"), { b: 2 })\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const remove: { <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Record<Exclude<K, X>, A>; <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Record<Exclude<K, X>, A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L454"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "pop",
    "description": "Retrieves the value of the property with the given `key` from a record and returns an `Option`\nof a tuple with the value and the record with the removed property.\nIf the key is not present, returns `O.none`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Record as R, Option } from \"effect\"\n\nassert.deepStrictEqual(R.pop({ a: 1, b: 2 }, \"a\"), Option.some([1, { b: 2 }]))\nassert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, \"c\"), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": "record",
    "signature": "declare const pop: { <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Option.Option<[A, Record<Exclude<K, X>, A>]>; <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Option.Option<[A, Record<Exclude<K, X>, A>]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L486"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Maps a record into another record by applying a transformation function to each of its values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { map } from \"effect/Record\"\n\nconst f = (n: number) => `-${n}`\n\nassert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: \"-3\", b: \"-5\" })\n\nconst g = (n: number, key: string) => `${key.toUpperCase()}-${n}`\n\nassert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: \"A-3\", b: \"B-5\" })\n```"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <K extends string, A, B>(f: (a: A, key: NoInfer<K>) => B): (self: ReadonlyRecord<K, A>) => Record<K, B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: NoInfer<K>) => B): Record<K, B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L520"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "mapKeys",
    "description": "Maps the keys of a `ReadonlyRecord` while preserving the corresponding values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { mapKeys } from \"effect/Record\"\n\nassert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })\n```"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapKeys: { <K extends string, A, K2 extends string>(f: (key: K, a: A) => K2): (self: ReadonlyRecord<K, A>) => Record<K2, A>; <K extends string, A, K2 extends string>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => K2): Record<K2, A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L548"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "mapEntries",
    "description": "Maps entries of a `ReadonlyRecord` using the provided function, allowing modification of both keys and corresponding values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { mapEntries } from \"effect/Record\"\n\nassert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })\n```"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapEntries: { <K extends string, A, K2 extends string, B>(f: (a: A, key: K) => readonly [K2, B]): (self: ReadonlyRecord<K, A>) => Record<K2, B>; <K extends string, A, K2 extends string, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => [K2, B]): Record<K2, B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L585"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Transforms a record into a record by applying the function `f` to each key and value in the original record.\nIf the function returns `Some`, the key-value pair is included in the output record.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Record, Option } from \"effect\"\n\nconst x = { a: 1, b: 2, c: 3 }\nconst f = (a: number, key: string) => a > 2 ? Option.some(a * 2) : Option.none()\nassert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const filterMap: { <K extends string, A, B>(f: (a: A, key: K) => Option.Option<B>): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => Option.Option<B>): Record<ReadonlyRecord.NonLiteralKey<K>, B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L624"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "filter",
    "description": "Selects properties from a record whose values match the given predicate.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { filter } from \"effect/Record\"\n\nconst x = { a: 1, b: 2, c: 3, d: 4 }\nassert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filter: { <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A>(predicate: (A: NoInfer<A>, key: K) => boolean): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, A>; <K extends string, A, B extends A>(self: ReadonlyRecord<K, A>, refinement: (a: A, key: K) => a is B): Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (a: A, key: K) => boolean): Record<ReadonlyRecord.NonLiteralKey<K>, A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L664"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "getSomes",
    "description": "Given a record with `Option` values, returns a new record containing only the `Some` values, preserving the original keys.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Record, Option } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.getSomes({ a: Option.some(1), b: Option.none(), c: Option.some(2) }),\n  { a: 1, c: 2 }\n)\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const getSomes: <K extends string, A>(self: ReadonlyRecord<K, Option.Option<A>>) => Record<ReadonlyRecord.NonLiteralKey<K>, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L712"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "partitionMap",
    "description": "Partitions the elements of a record into two groups: those that match a predicate, and those that don't.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Record, Either } from \"effect\"\n\nconst x = { a: 1, b: 2, c: 3 }\nconst f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))\nassert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const partitionMap: { <K extends string, A, B, C>(f: (a: A, key: K) => Either<C, B>): (self: ReadonlyRecord<K, A>) => [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]; <K extends string, A, B, C>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => Either<C, B>): [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L796"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "separate",
    "description": "Partitions a record of `Either` values into two separate records,\none with the `Left` values and one with the `Right` values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Record, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.separate({ a: Either.left(\"e\"), b: Either.right(1) }),\n  [{ a: \"e\" }, { b: 1 }]\n)\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const separate: <K extends string, A, B>(self: ReadonlyRecord<K, Either<B, A>>) => [Record<ReadonlyRecord.NonLiteralKey<K>, A>, Record<ReadonlyRecord.NonLiteralKey<K>, B>]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L844"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "partition",
    "description": "Partitions a record into two separate records based on the result of a predicate function.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { partition } from \"effect/Record\"\n\nassert.deepStrictEqual(\n  partition({ a: 1, b: 3 }, (n) => n > 2),\n  [{ a: 1 }, { b: 3 }]\n)\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const partition: { <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (self: ReadonlyRecord<K, A>) => [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>]; <K extends string, A>(predicate: (a: NoInfer<A>, key: K) => boolean): (self: ReadonlyRecord<K, A>) => [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]; <K extends string, A, B extends A>(self: ReadonlyRecord<K, A>, refinement: (a: A, key: K) => a is B): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>]; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (a: A, key: K) => boolean): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L865"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "set",
    "description": "Add a new key-value pair or update an existing key's value in a record.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { set } from \"effect/Record\"\n\nassert.deepStrictEqual(set(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\nassert.deepStrictEqual(set(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const set: { <K extends string | symbol, K1 extends K | ((string | symbol) & {}), B>(key: K1, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K | K1, A | B>; <K extends string | symbol, A, K1 extends K | ((string | symbol) & {}), B>(self: ReadonlyRecord<K, A>, key: K1, value: B): Record<K | K1, A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L936"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "replace",
    "description": "Replace a key's value in a record and return the updated record.\nIf the key does not exist in the record, a copy of the original record is returned.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Record } from \"effect\"\n\nassert.deepStrictEqual(Record.replace(\"a\", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });\nassert.deepStrictEqual(Record.replace(\"c\", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const replace: { <K extends string | symbol, B>(key: NoInfer<K>, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K, A | B>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, value: B): Record<K, A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L972"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "isSubrecord",
    "description": "Check if one record is a subrecord of another, meaning it contains all the keys and values found in the second record.\nThis comparison uses default equality checks (`Equal.equivalence()`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const isSubrecord: { <K extends string, A>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean; <K extends string, A>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1009"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "reduce",
    "description": "Reduce a record to a single value by combining its entries with a specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduce: { <Z, V, K extends string>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: ReadonlyRecord<K, V>) => Z; <K extends string, V, Z>(self: ReadonlyRecord<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1020"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "every",
    "description": "Check if all entries in a record meet a specific condition.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const every: { <A, K extends string, B extends A>(refinement: (value: A, key: K) => value is B): (self: ReadonlyRecord<K, A>) => self is ReadonlyRecord<K, B>; <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean; <A, K extends string, B extends A>(self: ReadonlyRecord<K, A>, refinement: (value: A, key: K) => value is B): self is ReadonlyRecord<K, B>; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1046"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "some",
    "description": "Check if any entry in a record meets a specific condition.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const some: { <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1076"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "union",
    "description": "Merge two records, preserving entries that exist in either of the records.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const union: { <K1 extends string, A, B, C>(that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B | C>; <K0 extends string, A, K1 extends string, B, C>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): Record<K0 | K1, A | B | C>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1096"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "intersection",
    "description": "Merge two records, retaining only the entries that exist in both records.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const intersection: { <K1 extends string, A, B, C>(that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>; <K0 extends string, A, K1 extends string, B, C>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1141"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "difference",
    "description": "Merge two records, preserving only the entries that are unique to each record.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const difference: { <K1 extends string, B>(that: ReadonlyRecord<K1, B>): <K0 extends string, A>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B>; <K0 extends string, A, K1 extends string, B>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>): Record<K0 | K1, A | B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1176"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates a new, empty record.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <K extends string | symbol = never, V = never>() => Record<ReadonlyRecord.NonLiteralKey<K>, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L61"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "isEmptyRecord",
    "description": "Determine if a record is empty.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { isEmptyRecord } from \"effect/Record\"\n\nassert.deepStrictEqual(isEmptyRecord({}), true);\nassert.deepStrictEqual(isEmptyRecord({ a: 3 }), false);\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isEmptyRecord: <K extends string, A>(self: Record<K, A>) => self is Record<K, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L81"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "fromIterableBy",
    "description": "Creates a new record from an iterable, utilizing the provided function to determine the key for each element.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { fromIterableBy } from \"effect/Record\"\n\nconst users = [\n  { id: \"2\", name: \"name2\" },\n  { id: \"1\", name: \"name1\" }\n]\n\nassert.deepStrictEqual(\n  fromIterableBy(users, user => user.id),\n  {\n    \"2\": { id: \"2\", name: \"name2\" },\n    \"1\": { id: \"1\", name: \"name1\" }\n  }\n)\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterableBy: <A, K extends string | symbol>(items: Iterable<A>, f: (a: A) => K) => Record<ReadonlyRecord.NonLiteralKey<K>, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L171"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the number of key/value pairs in a record.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { size } from \"effect/Record\";\n\nassert.deepStrictEqual(size({ a: \"a\", b: 1, c: true }), 3);\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const size: <K extends string, A>(self: ReadonlyRecord<K, A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L261"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "getLefts",
    "description": "Given a record with `Either` values, returns a new record containing only the `Left` values, preserving the original keys.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Record, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.getLefts({ a: Either.right(1), b: Either.left(\"err\"), c: Either.right(2) }),\n  { b: \"err\" }\n)\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const getLefts: <K extends string, R, L>(self: ReadonlyRecord<K, Either<R, L>>) => Record<ReadonlyRecord.NonLiteralKey<K>, L>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L735"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "getRights",
    "description": "Given a record with `Either` values, returns a new record containing only the `Right` values, preserving the original keys.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Record, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.getRights({ a: Either.right(1), b: Either.left(\"err\"), c: Either.right(2) }),\n  { a: 1, c: 2 }\n)\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const getRights: <K extends string, R, L>(self: ReadonlyRecord<K, Either<R, L>>) => Record<string, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L766"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "keys",
    "description": "Retrieve the keys of a given record as an array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const keys: <K extends string | symbol, A>(self: ReadonlyRecord<K, A>) => Array<K & string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L912"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "values",
    "description": "Retrieve the values of a given record as an array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const values: <K extends string, A>(self: ReadonlyRecord<K, A>) => Array<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L920"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "isSubrecordBy",
    "description": "Check if all the keys and values in one record are also found in another record.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const isSubrecordBy: <A>(equivalence: Equivalence<A>) => { <K extends string>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean; <K extends string>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L990"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": "Create an `Equivalence` for records using the provided `Equivalence` for values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const getEquivalence: <K extends string, A>(equivalence: Equivalence<A>) => Equivalence<ReadonlyRecord<K, A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1214"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "singleton",
    "description": "Create a non-empty record from a single element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const singleton: <K extends string | symbol, A>(key: K, value: A) => Record<K, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L1227"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "ReadonlyRecordTypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface ReadonlyRecordTypeLambda<K extends string = string> extends TypeLambda {\n  readonly type: ReadonlyRecord<K, this[\"Target\"]>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L51"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "ReadonlyRecord",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type ReadonlyRecord<K, A> = {\n  readonly [P in K]: A\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L20"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "ReadonlyRecord.NonLiteralKey",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type NonLiteralKey<K> = K extends string ? IsFiniteString<K> extends true ? string : K\n    : symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L36"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Record.ts",
      "path": "src/Record.ts"
    },
    "project": "effect",
    "name": "ReadonlyRecord.IntersectKeys",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type IntersectKeys<K1, K2> = [string] extends [K1 | K2] ?\n    NonLiteralKey<K1> & NonLiteralKey<K2>\n    : K1 & K2",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Record.ts#L42"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Redacted.ts",
      "path": "src/Redacted.ts"
    },
    "project": "effect",
    "name": "RedactedTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "symbols",
    "signature": "declare const RedactedTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Redacted.ts#L19"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Redacted.ts",
      "path": "src/Redacted.ts"
    },
    "project": "effect",
    "name": "isRedacted",
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "refinements",
    "signature": "declare const isRedacted: (u: unknown) => u is Redacted<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Redacted.ts#L59"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Redacted.ts",
      "path": "src/Redacted.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "This function creates a `Redacted<A>` instance from a given value `A`,\nsecurely hiding its content.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Redacted } from \"effect\"\n\nconst API_KEY = Redacted.make(\"1234567890\")\n```"
    ],
    "since": "3.3.0",
    "category": "constructors",
    "signature": "declare const make: <A>(value: A) => Redacted<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Redacted.ts#L75"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Redacted.ts",
      "path": "src/Redacted.ts"
    },
    "project": "effect",
    "name": "value",
    "description": "Retrieves the original value from a `Redacted` instance. Use this function\nwith caution, as it exposes the sensitive data.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Redacted } from \"effect\"\n\nconst API_KEY = Redacted.make(\"1234567890\")\n\nassert.equal(Redacted.value(API_KEY), \"1234567890\")\n```"
    ],
    "since": "3.3.0",
    "category": "getters",
    "signature": "declare const value: <A>(self: Redacted<A>) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Redacted.ts#L94"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Redacted.ts",
      "path": "src/Redacted.ts"
    },
    "project": "effect",
    "name": "unsafeWipe",
    "description": "Erases the underlying value of a `Redacted` instance, rendering it unusable.\nThis function is intended to ensure that sensitive data does not remain in\nmemory longer than necessary.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Redacted } from \"effect\"\n\nconst API_KEY = Redacted.make(\"1234567890\")\n\nassert.equal(Redacted.value(API_KEY), \"1234567890\")\n\nRedacted.unsafeWipe(API_KEY)\n\nassert.throws(() => Redacted.value(API_KEY), new Error(\"Unable to get redacted value\"))\n```"
    ],
    "since": "3.3.0",
    "category": "unsafe",
    "signature": "declare const unsafeWipe: <A>(self: Redacted<A>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Redacted.ts#L118"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Redacted.ts",
      "path": "src/Redacted.ts"
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": "Generates an equivalence relation for `Redacted<A>` values based on an\nequivalence relation for the underlying values `A`. This function is useful\nfor comparing `Redacted` instances without exposing their contents.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Redacted, Equivalence } from \"effect\"\n\nconst API_KEY1 = Redacted.make(\"1234567890\")\nconst API_KEY2 = Redacted.make(\"1-34567890\")\nconst API_KEY3 = Redacted.make(\"1234567890\")\n\nconst equivalence = Redacted.getEquivalence(Equivalence.string)\n\nassert.equal(equivalence(API_KEY1, API_KEY2), false)\nassert.equal(equivalence(API_KEY1, API_KEY3), true)\n```"
    ],
    "since": "3.3.0",
    "category": "equivalence",
    "signature": "declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Redacted<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Redacted.ts#L143"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Redacted.ts",
      "path": "src/Redacted.ts"
    },
    "project": "effect",
    "name": "Redacted",
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "models",
    "signature": "export interface Redacted<out A = string> extends Redacted.Variance<A>, Equal.Equal, Pipeable {\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Redacted.ts#L31"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Redacted.ts",
      "path": "src/Redacted.ts"
    },
    "project": "effect",
    "name": "RedactedTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "symbols",
    "signature": "type RedactedTypeId = typeof RedactedTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Redacted.ts#L25"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Redacted.ts",
      "path": "src/Redacted.ts"
    },
    "project": "effect",
    "name": "Redacted.Variance",
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "models",
    "signature": "export interface Variance<out A> {\n    readonly [RedactedTypeId]: {\n      readonly _A: Covariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Redacted.ts#L42"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Redacted.ts",
      "path": "src/Redacted.ts"
    },
    "project": "effect",
    "name": "Redacted.Value",
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "type-level",
    "signature": "type Value<T> = [T] extends [Redacted<infer _A>] ? _A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Redacted.ts#L52"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "Direction",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constants",
    "signature": "declare const Direction: { readonly Forward: RedBlackTree.Direction; readonly Backward: RedBlackTree.Direction; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L26"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "isRedBlackTree",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isRedBlackTree: { <K, V>(u: Iterable<readonly [K, V]>): u is RedBlackTree<K, V>; (u: unknown): u is RedBlackTree<unknown, unknown>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L57"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates an empty `RedBlackTree`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <K, V = never>(ord: Order<K>) => RedBlackTree<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L68"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `RedBlackTree` from an iterable collection of key/value pairs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: { <B>(ord: Order<B>): <K extends B, V>(entries: Iterable<readonly [K, V]>) => RedBlackTree<K, V>; <K extends B, V, B>(entries: Iterable<readonly [K, V]>, ord: Order<B>): RedBlackTree<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L76"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new `RedBlackTree` from the specified entries.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <K>(ord: Order<K>) => <Entries extends Array<readonly [K, any]>>(...entries: Entries) => RedBlackTree<K, Entries[number] extends readonly [any, infer V] ? V : never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L87"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "at",
    "description": "Returns an iterator that points to the element at the specified index of the\ntree.\n\n**Note**: The iterator will run through elements in order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const at: { (index: number): <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, index: number): Iterable<[K, V]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L102"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "atReversed",
    "description": "Returns an iterator that points to the element at the specified index of the\ntree.\n\n**Note**: The iterator will run through elements in reverse order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const atReversed: { (index: number): <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, index: number): Iterable<[K, V]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L116"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "findAll",
    "description": "Finds all values in the tree associated with the specified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findAll: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Chunk<V>; <K, V>(self: RedBlackTree<K, V>, key: K): Chunk<V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L127"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Finds the first value in the tree associated with the specified key, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirst: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Option<V>; <K, V>(self: RedBlackTree<K, V>, key: K): Option<V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L138"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "first",
    "description": "Returns the first entry in the tree, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const first: <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L149"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "getAt",
    "description": "Returns the element at the specified index within the tree or `None` if the\nspecified index does not exist.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const getAt: { (index: number): <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>; <K, V>(self: RedBlackTree<K, V>, index: number): Option<[K, V]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L158"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "getOrder",
    "description": "Gets the `Order<K>` that the `RedBlackTree<K, V>` is using.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const getOrder: <K, V>(self: RedBlackTree<K, V>) => Order<K>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L169"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "greaterThan",
    "description": "Returns an iterator that traverse entries in order with keys greater than the\nspecified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const greaterThan: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L178"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "greaterThanReversed",
    "description": "Returns an iterator that traverse entries in reverse order with keys greater\nthan the specified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const greaterThanReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L190"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "greaterThanEqual",
    "description": "Returns an iterator that traverse entries in order with keys greater than or\nequal to the specified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const greaterThanEqual: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L202"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "greaterThanEqualReversed",
    "description": "Returns an iterator that traverse entries in reverse order with keys greater\nthan or equal to the specified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const greaterThanEqualReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L214"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "has",
    "description": "Finds the item with key, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const has: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => boolean; <K, V>(self: RedBlackTree<K, V>, key: K): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L225"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "insert",
    "description": "Insert a new item into the tree.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const insert: { <K, V>(key: K, value: V): (self: RedBlackTree<K, V>) => RedBlackTree<K, V>; <K, V>(self: RedBlackTree<K, V>, key: K, value: V): RedBlackTree<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L235"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "keys",
    "description": "Get all the keys present in the tree in order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const keys: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<K>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L246"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "keysReversed",
    "description": "Get all the keys present in the tree in reverse order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const keysReversed: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<K>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L254"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "last",
    "description": "Returns the last entry in the tree, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const last: <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L262"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "lessThan",
    "description": "Returns an iterator that traverse entries in order with keys less than the\nspecified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const lessThan: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L271"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "lessThanReversed",
    "description": "Returns an iterator that traverse entries in reverse order with keys less\nthan the specified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const lessThanReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L283"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "lessThanEqual",
    "description": "Returns an iterator that traverse entries in order with keys less than or\nequal to the specified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const lessThanEqual: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L295"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "lessThanEqualReversed",
    "description": "Returns an iterator that traverse entries in reverse order with keys less\nthan or equal to the specified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const lessThanEqualReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L307"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "Execute the specified function for each node of the tree, in order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const forEach: { <K, V>(f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, f: (key: K, value: V) => void): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L318"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "forEachGreaterThanEqual",
    "description": "Visit each node of the tree in order with key greater then or equal to max.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const forEachGreaterThanEqual: { <K, V>(min: K, f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, min: K, f: (key: K, value: V) => void): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L329"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "forEachLessThan",
    "description": "Visit each node of the tree in order with key lower then max.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const forEachLessThan: { <K, V>(max: K, f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, max: K, f: (key: K, value: V) => void): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L340"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "forEachBetween",
    "description": "Visit each node of the tree in order with key lower than max and greater\nthan or equal to min.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const forEachBetween: { <K, V>(options: { readonly min: K; readonly max: K; readonly body: (key: K, value: V) => void; }): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, options: { readonly min: K; readonly max: K; readonly body: (key: K, value: V) => void; }): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L352"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "reduce",
    "description": "Reduce a state over the entries of the tree.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduce: { <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: RedBlackTree<K, V>) => Z; <Z, V, K>(self: RedBlackTree<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L376"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "removeFirst",
    "description": "Removes the entry with the specified key, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const removeFirst: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => RedBlackTree<K, V>; <K, V>(self: RedBlackTree<K, V>, key: K): RedBlackTree<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L386"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "reversed",
    "description": "Traverse the tree in reverse order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const reversed: <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L397"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the size of the tree.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <K, V>(self: RedBlackTree<K, V>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L405"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "values",
    "description": "Get all values present in the tree in order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const values: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L413"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "valuesReversed",
    "description": "Get all values present in the tree in reverse order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const valuesReversed: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L421"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "RedBlackTree",
    "description": "A Red-Black Tree.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RedBlackTree<in out Key, out Value> extends Iterable<[Key, Value]>, Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _Key: Types.Invariant<Key>\n    readonly _Value: Types.Covariant<Value>\n  }\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L34"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L20"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RedBlackTree.ts",
      "path": "src/RedBlackTree.ts"
    },
    "project": "effect",
    "name": "RedBlackTree.Direction",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Direction = number & {\n    readonly Direction: unique symbol\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RedBlackTree.ts#L48"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "RefTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const RefTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L15"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A>(value: A) => Effect.Effect<Ref<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L69"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "get",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const get: <A>(self: Ref<A>) => Effect.Effect<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L75"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "getAndSet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndSet: { <A>(value: A): (self: Ref<A>) => Effect.Effect<A>; <A>(self: Ref<A>, value: A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L81"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "getAndUpdate",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndUpdate: { <A>(f: (a: A) => A): (self: Ref<A>) => Effect.Effect<A>; <A>(self: Ref<A>, f: (a: A) => A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L90"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "getAndUpdateSome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndUpdateSome: { <A>(pf: (a: A) => Option.Option<A>): (self: Ref<A>) => Effect.Effect<A>; <A>(self: Ref<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L99"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "modify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const modify: { <A, B>(f: (a: A) => readonly [B, A]): (self: Ref<A>) => Effect.Effect<B>; <A, B>(self: Ref<A>, f: (a: A) => readonly [B, A]): Effect.Effect<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L108"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "modifySome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const modifySome: { <B, A>(fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): (self: Ref<A>) => Effect.Effect<B>; <A, B>(self: Ref<A>, fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): Effect.Effect<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L117"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "set",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const set: { <A>(value: A): (self: Ref<A>) => Effect.Effect<void>; <A>(self: Ref<A>, value: A): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L126"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "setAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const setAndGet: { <A>(value: A): (self: Ref<A>) => Effect.Effect<A>; <A>(self: Ref<A>, value: A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L135"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "update",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const update: { <A>(f: (a: A) => A): (self: Ref<A>) => Effect.Effect<void>; <A>(self: Ref<A>, f: (a: A) => A): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L144"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "updateAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateAndGet: { <A>(f: (a: A) => A): (self: Ref<A>) => Effect.Effect<A>; <A>(self: Ref<A>, f: (a: A) => A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L153"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "updateSome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateSome: { <A>(f: (a: A) => Option.Option<A>): (self: Ref<A>) => Effect.Effect<void>; <A>(self: Ref<A>, f: (a: A) => Option.Option<A>): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L162"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "updateSomeAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateSomeAndGet: { <A>(pf: (a: A) => Option.Option<A>): (self: Ref<A>) => Effect.Effect<A>; <A>(self: Ref<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L171"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "unsafeMake",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeMake: <A>(value: A) => Ref<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L180"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "Ref",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Ref<in out A> extends Ref.Variance<A>, Effect.Effect<A>, Readable.Readable<A> {\n  modify<B>(f: (a: A) => readonly [B, A]): Effect.Effect<B>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: RefUnify<this>\n  readonly [Unify.ignoreSymbol]?: RefUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L27"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "RefUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface RefUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Ref?: () => Extract<A[Unify.typeSymbol], Ref<any>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L38"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "RefUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface RefUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L46"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "RefTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type RefTypeId = typeof RefTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L21"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Ref.ts",
      "path": "src/Ref.ts"
    },
    "project": "effect",
    "name": "Ref.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface Variance<in out A> {\n    readonly [RefTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Ref.ts#L58"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RegExp.ts",
      "path": "src/RegExp.ts"
    },
    "project": "effect",
    "name": "isRegExp",
    "description": "Tests if a value is a `RegExp`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { RegExp } from \"effect\"\n\nassert.deepStrictEqual(RegExp.isRegExp(/a/), true)\nassert.deepStrictEqual(RegExp.isRegExp(\"a\"), false)\n```"
    ],
    "since": "3.9.0",
    "category": "guards",
    "signature": "declare const isRegExp: (input: unknown) => input is RegExp",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RegExp.ts#L23"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "RegExp.ts",
      "path": "src/RegExp.ts"
    },
    "project": "effect",
    "name": "escape",
    "description": "Escapes special characters in a regular expression pattern.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { RegExp } from \"effect\"\n\nassert.deepStrictEqual(RegExp.escape(\"a*b\"), \"a\\\\*b\")\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const escape: (string: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RegExp.ts#L38"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable.ts",
      "path": "src/Reloadable.ts"
    },
    "project": "effect",
    "name": "ReloadableTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const ReloadableTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L16"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable.ts",
      "path": "src/Reloadable.ts"
    },
    "project": "effect",
    "name": "auto",
    "description": "Makes a new reloadable service from a layer that describes the construction\nof a static service. The service is automatically reloaded according to the\nprovided schedule.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const auto: <I, S, E, In, R>(tag: Context.Tag<I, S>, options: { readonly layer: Layer.Layer<I, E, In>; readonly schedule: Schedule.Schedule<unknown, unknown, R>; }) => Layer.Layer<Reloadable<I>, E, R | In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L65"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable.ts",
      "path": "src/Reloadable.ts"
    },
    "project": "effect",
    "name": "autoFromConfig",
    "description": "Makes a new reloadable service from a layer that describes the construction\nof a static service. The service is automatically reloaded according to a\nschedule, which is extracted from the input to the layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const autoFromConfig: <I, S, E, In, R>(tag: Context.Tag<I, S>, options: { readonly layer: Layer.Layer<I, E, In>; readonly scheduleFromConfig: (context: Context.Context<In>) => Schedule.Schedule<unknown, unknown, R>; }) => Layer.Layer<Reloadable<I>, E, R | In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L78"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable.ts",
      "path": "src/Reloadable.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves the current version of the reloadable service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const get: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<S, never, Reloadable<I>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L92"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable.ts",
      "path": "src/Reloadable.ts"
    },
    "project": "effect",
    "name": "manual",
    "description": "Makes a new reloadable service from a layer that describes the construction\nof a static service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const manual: <I, S, In, E>(tag: Context.Tag<I, S>, options: { readonly layer: Layer.Layer<I, E, In>; }) => Layer.Layer<Reloadable<I>, E, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L101"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable.ts",
      "path": "src/Reloadable.ts"
    },
    "project": "effect",
    "name": "reload",
    "description": "Reloads the specified service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const reload: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<void, unknown, Reloadable<I>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L112"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable.ts",
      "path": "src/Reloadable.ts"
    },
    "project": "effect",
    "name": "tag",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const tag: <I, S>(tag: Context.Tag<I, S>) => Context.Tag<Reloadable<I>, Reloadable<S>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L118"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable.ts",
      "path": "src/Reloadable.ts"
    },
    "project": "effect",
    "name": "reloadFork",
    "description": "Forks the reload of the service in the background, ignoring any errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const reloadFork: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<void, unknown, Reloadable<I>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L126"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Reloadable.ts",
      "path": "src/Reloadable.ts"
    },
    "project": "effect",
    "name": "Reloadable",
    "description": "A `Reloadable` is an implementation of some service that can be dynamically\nreloaded, or swapped out for another implementation on-the-fly.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Reloadable<in out A> extends Reloadable.Variance<A> {\n  /**\n   * @internal\n   */\n  readonly scopedRef: ScopedRef.ScopedRef<A>\n  /**\n   * @internal\n   */\n  readonly reload: Effect.Effect<void, unknown>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L31"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Reloadable.ts",
      "path": "src/Reloadable.ts"
    },
    "project": "effect",
    "name": "ReloadableTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type ReloadableTypeId = typeof ReloadableTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L22"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Reloadable.ts",
      "path": "src/Reloadable.ts"
    },
    "project": "effect",
    "name": "Reloadable.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out A> {\n    readonly [ReloadableTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Reloadable.ts#L50"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "RequestTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const RequestTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L23"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "isRequest",
    "description": "Returns `true` if the specified value is a `Request`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isRequest: (u: unknown) => u is Request<unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L104"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "of",
    "description": "Constructs a new `Request`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const of: <R extends Request<any, any>>() => Request.Constructor<R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L112"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "tagged",
    "description": "Constructs a new `Request`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const tagged: <R extends Request<any, any> & { _tag: string; }>(tag: R[\"_tag\"]) => Request.Constructor<R, \"_tag\">",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L120"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "Class",
    "description": "Provides a constructor for a Request Class.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Request } from \"effect\"\n\ntype Success = string\ntype Error = never\n\nclass MyRequest extends Request.Class<Success, Error, {\n  readonly id: string\n}> {}\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Class: new <Success, Error, A extends Record<string, any>>(args: Types.Equals<Omit<A, keyof Request<unknown, unknown>>, {}> extends true ? void : { readonly [P in keyof A as P extends keyof Request<unknown, unknown> ? never : P]: A[P]; }) => Request<Success, Error> & Readonly<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L142"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "TaggedClass",
    "description": "Provides a Tagged constructor for a Request Class.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Request } from \"effect\"\n\ntype Success = string\ntype Error = never\n\nclass MyRequest extends Request.TaggedClass(\"MyRequest\")<Success, Error, {\n  readonly name: string\n}> {}\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const TaggedClass: <Tag extends string>(tag: Tag) => new <Success, Error, A extends Record<string, any>>(args: Types.Equals<Omit<A, keyof Request<unknown, unknown>>, {}> extends true ? void : { readonly [P in keyof A as P extends \"_tag\" | keyof Request<unknown, unknown> ? never : P]: A[P]; }) => Request<Success, Error> & Readonly<A> & { readonly _tag: Tag; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L165"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "complete",
    "description": "Complete a `Request` with the specified result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "request completion",
    "signature": "declare const complete: { <A extends Request<any, any>>(result: Request.Result<A>): (self: A) => Effect.Effect<void>; <A extends Request<any, any>>(self: A, result: Request.Result<A>): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L178"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "interruptWhenPossible",
    "description": "Interrupts the child effect when requests are no longer needed",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "request completion",
    "signature": "declare const interruptWhenPossible: { (all: Iterable<Request<any, any>>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<void, E, R>; <A, E, R>(self: Effect.Effect<A, E, R>, all: Iterable<Request<any, any>>): Effect.Effect<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L189"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "completeEffect",
    "description": "Complete a `Request` with the specified effectful computation, failing the\nrequest with the error from the effect workflow if it fails, and completing\nthe request with the value of the effect workflow if it succeeds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "request completion",
    "signature": "declare const completeEffect: { <A extends Request<any, any>, R>(effect: Effect.Effect<Request.Success<A>, Request.Error<A>, R>): (self: A) => Effect.Effect<void, never, R>; <A extends Request<any, any>, R>(self: A, effect: Effect.Effect<Request.Success<A>, Request.Error<A>, R>): Effect.Effect<void, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L202"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "fail",
    "description": "Complete a `Request` with the specified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "request completion",
    "signature": "declare const fail: { <A extends Request<any, any>>(error: Request.Error<A>): (self: A) => Effect.Effect<void>; <A extends Request<any, any>>(self: A, error: Request.Error<A>): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L218"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "failCause",
    "description": "Complete a `Request` with the specified cause.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "request completion",
    "signature": "declare const failCause: { <A extends Request<any, any>>(cause: Cause<Request.Error<A>>): (self: A) => Effect.Effect<void>; <A extends Request<any, any>>(self: A, cause: Cause<Request.Error<A>>): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L229"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "succeed",
    "description": "Complete a `Request` with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "request completion",
    "signature": "declare const succeed: { <A extends Request<any, any>>(value: Request.Success<A>): (self: A) => Effect.Effect<void>; <A extends Request<any, any>>(self: A, value: Request.Success<A>): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L240"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "EntryTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const EntryTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L290"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "isEntry",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isEntry: (u: unknown) => u is Entry<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L341"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "makeEntry",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeEntry: <A extends Request<any, any>>(options: { readonly request: A; readonly result: Deferred<Request.Success<A>, Request.Error<A>>; readonly listeners: Listeners; readonly ownerId: FiberId; readonly state: { completed: boolean; }; }) => Entry<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L347"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "makeCache",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "declare const makeCache: (options: { readonly capacity: number; readonly timeToLive: DurationInput; }) => Effect.Effect<Cache>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L274"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "Request",
    "description": "A `Request<A, E>` is a request from a data source for a value of type `A`\nthat may fail with an `E`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Request<out A, out E = never> extends Request.Variance<A, E> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L38"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "Listeners",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Listeners {\n  readonly count: number\n  readonly observers: Set<(count: number) => void>\n  interrupted: boolean\n  addObserver(f: (count: number) => void): void\n  removeObserver(f: (count: number) => void): void\n  increment(): void\n  decrement(): void\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L249"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "Cache",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Cache extends\n  _Cache.ConsumerCache<Request<any, any>, {\n    listeners: Listeners\n    handle: Deferred<unknown, unknown>\n  }>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L263"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "Entry",
    "description": "A `Entry<A>` keeps track of a request of type `A` along with a\n`Ref` containing the result of the request, existentially hiding the result\ntype. This is used internally by the library to support data sources that\nreturn different result types for different requests while guaranteeing that\nresults will be of the type requested.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Entry<out R> extends Entry.Variance<R> {\n  readonly request: R\n  readonly result: Deferred<\n    [R] extends [Request<infer _A, infer _E>] ? _A : never,\n    [R] extends [Request<infer _A, infer _E>] ? _E : never\n  >\n  readonly listeners: Listeners\n  readonly ownerId: FiberId\n  readonly state: {\n    completed: boolean\n  }\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L308"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "RequestTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type RequestTypeId = typeof RequestTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L29"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "EntryTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type EntryTypeId = typeof EntryTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L296"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "Request.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out A, out E> {\n    readonly [RequestTypeId]: {\n      readonly _A: Types.Covariant<A>\n      readonly _E: Types.Covariant<E>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L48"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "Request.Constructor",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Constructor<R extends Request<any, any>, T extends keyof R = never> {\n    (args: Omit<R, T | keyof (Request.Variance<Request.Success<R>, Request.Error<R>>)>): R\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L59"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "Request.Error",
    "description": "A utility type to extract the error type from a `Request`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type-level",
    "signature": "type Error<T> = [T] extends [Request<infer _A, infer _E>] ? _E : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L69"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "Request.Success",
    "description": "A utility type to extract the value type from a `Request`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type-level",
    "signature": "type Success<T> = [T] extends [Request<infer _A, infer _E>] ? _A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L77"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "Request.Result",
    "description": "A utility type to extract the result type from a `Request`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type-level",
    "signature": "type Result<T> = T extends Request<infer A, infer E> ? Exit.Exit<A, E> : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L85"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "Request.OptionalResult",
    "description": "A utility type to extract the optional result type from a `Request`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type-level",
    "signature": "type OptionalResult<T> = T extends Request<infer A, infer E>\n    ? Exit.Exit<Option.Option<A>, E>\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L93"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Request.ts",
      "path": "src/Request.ts"
    },
    "project": "effect",
    "name": "Entry.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out R> {\n    readonly [EntryTypeId]: {\n      readonly _R: Types.Covariant<R>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Request.ts#L330"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestBlock.ts",
      "path": "src/RequestBlock.ts"
    },
    "project": "effect",
    "name": "single",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const single: <A>(dataSource: RequestResolver.RequestResolver<A>, blockedRequest: Request.Entry<A>) => RequestBlock",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestBlock.ts#L82"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestBlock.ts",
      "path": "src/RequestBlock.ts"
    },
    "project": "effect",
    "name": "empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: RequestBlock",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestBlock.ts#L91"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestBlock.ts",
      "path": "src/RequestBlock.ts"
    },
    "project": "effect",
    "name": "mapRequestResolvers",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const mapRequestResolvers: <A>(self: RequestBlock, f: (dataSource: RequestResolver.RequestResolver<A>) => RequestResolver.RequestResolver<A>) => RequestBlock",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestBlock.ts#L97"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestBlock.ts",
      "path": "src/RequestBlock.ts"
    },
    "project": "effect",
    "name": "parallel",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const parallel: (self: RequestBlock, that: RequestBlock) => RequestBlock",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestBlock.ts#L106"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestBlock.ts",
      "path": "src/RequestBlock.ts"
    },
    "project": "effect",
    "name": "reduce",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const reduce: <Z>(self: RequestBlock, reducer: RequestBlock.Reducer<Z>) => Z",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestBlock.ts#L112"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestBlock.ts",
      "path": "src/RequestBlock.ts"
    },
    "project": "effect",
    "name": "sequential",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sequential: (self: RequestBlock, that: RequestBlock) => RequestBlock",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestBlock.ts#L118"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RequestBlock.ts",
      "path": "src/RequestBlock.ts"
    },
    "project": "effect",
    "name": "Empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Empty {\n  readonly _tag: \"Empty\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestBlock.ts#L44"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RequestBlock.ts",
      "path": "src/RequestBlock.ts"
    },
    "project": "effect",
    "name": "Par",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Par {\n  readonly _tag: \"Par\"\n  readonly left: RequestBlock\n  readonly right: RequestBlock\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestBlock.ts#L52"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RequestBlock.ts",
      "path": "src/RequestBlock.ts"
    },
    "project": "effect",
    "name": "Seq",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Seq {\n  readonly _tag: \"Seq\"\n  readonly left: RequestBlock\n  readonly right: RequestBlock\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestBlock.ts#L62"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RequestBlock.ts",
      "path": "src/RequestBlock.ts"
    },
    "project": "effect",
    "name": "Single",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Single {\n  readonly _tag: \"Single\"\n  readonly dataSource: RequestResolver.RequestResolver<unknown>\n  readonly blockedRequest: Request.Entry<unknown>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestBlock.ts#L72"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RequestBlock.ts",
      "path": "src/RequestBlock.ts"
    },
    "project": "effect",
    "name": "RequestBlock",
    "description": "`RequestBlock` captures a collection of blocked requests as a data\nstructure. By doing this the library is able to preserve information about\nwhich requests must be performed sequentially and which can be performed in\nparallel, allowing for maximum possible batching and pipelining while\npreserving ordering guarantees.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type RequestBlock = Empty | Par | Seq | Single",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestBlock.ts#L18"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RequestBlock.ts",
      "path": "src/RequestBlock.ts"
    },
    "project": "effect",
    "name": "RequestBlock.Reducer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Reducer<in out Z> {\n    emptyCase(): Z\n    parCase(left: Z, right: Z): Z\n    singleCase(\n      dataSource: RequestResolver.RequestResolver<unknown>,\n      blockedRequest: Request.Entry<unknown>\n    ): Z\n    seqCase(left: Z, right: Z): Z\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestBlock.ts#L29"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "RequestResolverTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const RequestResolverTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L21"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "isRequestResolver",
    "description": "Returns `true` if the specified value is a `RequestResolver`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isRequestResolver: (u: unknown) => u is RequestResolver<unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L109"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a data source with the specified identifier and method to run\nrequests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A, R>(runAll: (requests: Array<Array<A>>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L118"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "makeWithEntry",
    "description": "Constructs a data source with the specified identifier and method to run\nrequests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeWithEntry: <A, R>(runAll: (requests: Array<Array<Request.Entry<A>>>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L129"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "makeBatched",
    "description": "Constructs a data source from a function taking a collection of requests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeBatched: <A extends Request.Request<any, any>, R>(run: (requests: NonEmptyArray<A>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L139"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "around",
    "description": "A data source aspect that executes requests between two effects, `before`\nand `after`, where the result of `before` can be used by `after`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const around: { <A2, R2, X, R3>(before: Effect.Effect<A2, never, R2>, after: (a: A2) => Effect.Effect<X, never, R3>): <A, R>(self: RequestResolver<A, R>) => RequestResolver<A, R2 | R3 | R>; <A, R, A2, R2, X, R3>(self: RequestResolver<A, R>, before: Effect.Effect<A2, never, R2>, after: (a: A2) => Effect.Effect<X, never, R3>): RequestResolver<A, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L150"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "aroundRequests",
    "description": "A data source aspect that executes requests between two effects, `before`\nand `after`, where the result of `before` can be used by `after`.\n\nThe `before` and `after` effects are provided with the requests being executed.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Request, RequestResolver } from \"effect\"\n\ninterface GetUserById extends Request.Request<unknown> {\n  readonly id: number\n}\n\nconst resolver = RequestResolver.fromFunction(\n  (request: GetUserById) => ({ id: request.id, name: \"John\" })\n)\n\nRequestResolver.aroundRequests(\n  resolver,\n  (requests) => Effect.log(`got ${requests.length} requests`),\n  (requests, _) => Effect.log(`finised running ${requests.length} requests`)\n)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const aroundRequests: { <A, A2, R2, X, R3>(before: (requests: ReadonlyArray<Types.NoInfer<A>>) => Effect.Effect<A2, never, R2>, after: (requests: ReadonlyArray<Types.NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>): <R>(self: RequestResolver<A, R>) => RequestResolver<A, R2 | R3 | R>; <A, R, A2, R2, X, R3>(self: RequestResolver<A, R>, before: (requests: ReadonlyArray<Types.NoInfer<A>>) => Effect.Effect<A2, never, R2>, after: (requests: ReadonlyArray<Types.NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>): RequestResolver<A, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L189"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "batchN",
    "description": "Returns a data source that executes at most `n` requests in parallel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const batchN: { (n: number): <A, R>(self: RequestResolver<A, R>) => RequestResolver<A, R>; <A, R>(self: RequestResolver<A, R>, n: number): RequestResolver<A, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L207"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "mapInputContext",
    "description": "Provides this data source with part of its required context.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const mapInputContext: { <R0, R>(f: (context: Context.Context<R0>) => Context.Context<R>): <A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => RequestResolver<A, R0>; <R, A extends Request.Request<any, any>, R0>(self: RequestResolver<A, R>, f: (context: Context.Context<R0>) => Context.Context<R>): RequestResolver<A, R0>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L218"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "eitherWith",
    "description": "Returns a new data source that executes requests of type `C` using the\nspecified function to transform `C` requests into requests that either this\ndata source or that data source can execute.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const eitherWith: { <A extends Request.Request<any, any>, R2, B extends Request.Request<any, any>, C extends Request.Request<any, any>>(that: RequestResolver<B, R2>, f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>): <R>(self: RequestResolver<A, R>) => RequestResolver<C, R2 | R>; <R, A extends Request.Request<any, any>, R2, B extends Request.Request<any, any>, C extends Request.Request<any, any>>(self: RequestResolver<A, R>, that: RequestResolver<B, R2>, f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>): RequestResolver<C, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L236"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "fromFunction",
    "description": "Constructs a data source from a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromFunction: <A extends Request.Request<any>>(f: (request: A) => Request.Request.Success<A>) => RequestResolver<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L260"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "fromFunctionBatched",
    "description": "Constructs a data source from a pure function that takes a list of requests\nand returns a list of results of the same size. Each item in the result\nlist must correspond to the item at the same index in the request list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromFunctionBatched: <A extends Request.Request<any>>(f: (chunk: NonEmptyArray<A>) => Iterable<Request.Request.Success<A>>) => RequestResolver<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L272"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "fromEffect",
    "description": "Constructs a data source from an effectual function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromEffect: <R, A extends Request.Request<any, any>>(f: (a: A) => Effect.Effect<Request.Request.Success<A>, Request.Request.Error<A>, R>) => RequestResolver<A, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L282"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "fromEffectTagged",
    "description": "Constructs a data source from a list of tags paired to functions, that takes\na list of requests and returns a list of results of the same size. Each item\nin the result list must correspond to the item at the same index in the\nrequest list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromEffectTagged: <A extends Request.Request<any, any> & { readonly _tag: string; }>() => <Fns extends { readonly [Tag in A[\"_tag\"]]: [Extract<A, { readonly _tag: Tag; }>] extends [infer Req] ? Req extends Request.Request<infer ReqA, infer ReqE> ? (requests: Array<Req>) => Effect.Effect<Iterable<ReqA>, ReqE, any> : never : never; }>(fns: Fns) => RequestResolver<A, ReturnType<Fns[keyof Fns]> extends Effect.Effect<infer _A, infer _E, infer R> ? R : never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L295"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "never",
    "description": "A data source that never executes requests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const never: RequestResolver<never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L314"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "provideContext",
    "description": "Provides this data source with its required context.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideContext: { <R>(context: Context.Context<R>): <A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => RequestResolver<A>; <R, A extends Request.Request<any, any>>(self: RequestResolver<A, R>, context: Context.Context<R>): RequestResolver<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L322"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "race",
    "description": "Returns a new data source that executes requests by sending them to this\ndata source and that data source, returning the results from the first data\nsource to complete and safely interrupting the loser.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const race: { <A2 extends Request.Request<any, any>, R2>(that: RequestResolver<A2, R2>): <A extends Request.Request<any, any>, R>(self: RequestResolver<A, R>) => RequestResolver<A2 | A, R2 | R>; <A extends Request.Request<any, any>, R, A2 extends Request.Request<any, any>, R2>(self: RequestResolver<A, R>, that: RequestResolver<A2, R2>): RequestResolver<A | A2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L340"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "locally",
    "description": "Returns a new data source with a localized FiberRef",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const locally: { <A>(self: FiberRef<A>, value: A): <R, B extends Request.Request<any, any>>(use: RequestResolver<B, R>) => RequestResolver<B, R>; <R, B extends Request.Request<any, any>, A>(use: RequestResolver<B, R>, self: FiberRef<A>, value: A): RequestResolver<B, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L356"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "contextFromEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const contextFromEffect: <R, A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => Effect.Effect<RequestResolver<A, never>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L86"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "contextFromServices",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const contextFromServices: <Services extends Array<Context.Tag<any, any>>>(...services: Services) => <R, A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => Effect.Effect<RequestResolver<A, Exclude<R, { [k in keyof Services]: Effect.Effect.Context<Services[k]>; }[number]>>, never, { [k in keyof Services]: Effect.Effect.Context<Services[k]>; }[number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L93"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "RequestResolver",
    "description": "The `RequestResolver<A, R>` interface requires an environment `R` and handles\nthe execution of requests of type `A`.\n\nImplementations must provide a `runAll` method, which processes a collection\nof requests and produces an effect that fulfills these requests. Requests are\norganized into a `Array<Array<A>>`, where the outer `Array` groups requests\ninto batches that are executed sequentially, and each inner `Array` contains\nrequests that can be executed in parallel. This structure allows\nimplementations to analyze all incoming requests collectively and optimize\nquery execution accordingly.\n\nImplementations are typically specialized for a subtype of `Request<A, E>`.\nHowever, they are not strictly limited to these subtypes as long as they can\nmap any given request type to `Request<A, E>`. Implementations should inspect\nthe collection of requests to identify the needed information and execute the\ncorresponding queries. It is imperative that implementations resolve all the\nrequests they receive. Failing to do so will lead to a `QueryFailure` error\nduring query execution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RequestResolver<in A, out R = never> extends RequestResolver.Variance<A, R>, Equal.Equal, Pipeable {\n  /**\n   * Execute a collection of requests. The outer `Array` represents batches\n   * of requests that must be performed sequentially. The inner `Array`\n   * represents a batch of requests that can be performed in parallel.\n   */\n  runAll(requests: Array<Array<Request.Entry<A>>>): Effect.Effect<void, never, R>\n\n  /**\n   * Identify the data source using the specific identifier\n   */\n  identified(...identifiers: Array<unknown>): RequestResolver<A, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L52"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "RequestResolverTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type RequestResolverTypeId = typeof RequestResolverTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L27"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RequestResolver.ts",
      "path": "src/RequestResolver.ts"
    },
    "project": "effect",
    "name": "RequestResolver.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in A, out R> {\n    readonly [RequestResolverTypeId]: {\n      readonly _A: Types.Contravariant<A>\n      readonly _R: Types.Covariant<R>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RequestResolver.ts#L74"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Resource.ts",
      "path": "src/Resource.ts"
    },
    "project": "effect",
    "name": "ResourceTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const ResourceTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L17"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Resource.ts",
      "path": "src/Resource.ts"
    },
    "project": "effect",
    "name": "auto",
    "description": "Creates a new `Resource` value that is automatically refreshed according to\nthe specified policy. Note that error retrying is not performed\nautomatically, so if you want to retry on errors, you should first apply\nretry policies to the acquisition effect before passing it to this\nconstructor.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const auto: <A, E, R, Out, R2>(acquire: Effect.Effect<A, E, R>, policy: Schedule.Schedule<Out, unknown, R2>) => Effect.Effect<Resource<A, E>, never, R | R2 | Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L85"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Resource.ts",
      "path": "src/Resource.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves the current value stored in the cache.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const get: <A, E>(self: Resource<A, E>) => Effect.Effect<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L96"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Resource.ts",
      "path": "src/Resource.ts"
    },
    "project": "effect",
    "name": "manual",
    "description": "Creates a new `Resource` value that must be manually refreshed by calling\nthe refresh method. Note that error retrying is not performed\nautomatically, so if you want to retry on errors, you should first apply\nretry policies to the acquisition effect before passing it to this\nconstructor.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const manual: <A, E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<Resource<A, E>, never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L108"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Resource.ts",
      "path": "src/Resource.ts"
    },
    "project": "effect",
    "name": "refresh",
    "description": "Refreshes the cache. This method will not return until either the refresh\nis successful, or the refresh operation fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const refresh: <A, E>(self: Resource<A, E>) => Effect.Effect<void, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L119"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Resource.ts",
      "path": "src/Resource.ts"
    },
    "project": "effect",
    "name": "Resource",
    "description": "A `Resource` is a possibly resourceful value that is loaded into memory, and\nwhich can be refreshed either manually or automatically.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Resource<in out A, in out E = never> extends Effect.Effect<A, E>, Resource.Variance<A, E> {\n  /** @internal */\n  readonly scopedRef: ScopedRef.ScopedRef<Exit.Exit<A, E>>\n  /** @internal */\n  readonly acquire: Effect.Effect<A, E, Scope.Scope>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: ResourceUnify<this>\n  readonly [Unify.ignoreSymbol]?: ResourceUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L32"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Resource.ts",
      "path": "src/Resource.ts"
    },
    "project": "effect",
    "name": "ResourceUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface ResourceUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Resource?: () => Extract<A[Unify.typeSymbol], Resource<any, any>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L47"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Resource.ts",
      "path": "src/Resource.ts"
    },
    "project": "effect",
    "name": "ResourceUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface ResourceUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L55"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Resource.ts",
      "path": "src/Resource.ts"
    },
    "project": "effect",
    "name": "ResourceTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type ResourceTypeId = typeof ResourceTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L23"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Resource.ts",
      "path": "src/Resource.ts"
    },
    "project": "effect",
    "name": "Resource.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out A, in out E> {\n    readonly [ResourceTypeId]: {\n      _A: Types.Invariant<A>\n      _E: Types.Invariant<E>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Resource.ts#L67"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "runFork",
    "description": "Executes the effect using the provided Scheduler or using the global\nScheduler if not provided",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "execution",
    "signature": "declare const runFork: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: RunForkOptions | undefined) => Fiber.RuntimeFiber<A, E>; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: RunForkOptions | undefined): Fiber.RuntimeFiber<A, E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L84"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "runSyncExit",
    "description": "Executes the effect synchronously returning the exit.\n\nThis method is effectful and should only be invoked at the edges of your\nprogram.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "execution",
    "signature": "declare const runSyncExit: { <A, E, R>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>): Exit.Exit<A, E>; <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>) => Exit.Exit<A, E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L104"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "runSync",
    "description": "Executes the effect synchronously throwing in case of errors or async boundaries.\n\nThis method is effectful and should only be invoked at the edges of your\nprogram.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "execution",
    "signature": "declare const runSync: { <A, E, R>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>): A; <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>) => A; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L118"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "runCallback",
    "description": "Executes the effect asynchronously, eventually passing the exit value to\nthe specified callback.\n\nThis method is effectful and should only be invoked at the edges of your\nprogram.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "execution",
    "signature": "declare const runCallback: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: RunCallbackOptions<A, E> | undefined) => (fiberId?: FiberId.FiberId, options?: RunCallbackOptions<A, E> | undefined) => void; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: RunCallbackOptions<A, E> | undefined): (fiberId?: FiberId.FiberId, options?: RunCallbackOptions<A, E> | undefined) => void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L141"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "runPromise",
    "description": "Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\nwith the value of the effect once the effect has been executed, or will be\nrejected with the first error or exception throw by the effect.\n\nThis method is effectful and should only be used at the edges of your\nprogram.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "execution",
    "signature": "declare const runPromise: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<A>; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined): Promise<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L166"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "runPromiseExit",
    "description": "Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\nwith the `Exit` state of the effect once the effect has been executed.\n\nThis method is effectful and should only be used at the edges of your\nprogram.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "execution",
    "signature": "declare const runPromiseExit: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<Exit.Exit<A, E>>; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined): Promise<Exit.Exit<A, E>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L187"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "defaultRuntime",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const defaultRuntime: Runtime<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L205"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "defaultRuntimeFlags",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const defaultRuntimeFlags: RuntimeFlags.RuntimeFlags",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L211"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <R>(options: { readonly context: Context.Context<R>; readonly runtimeFlags: RuntimeFlags.RuntimeFlags; readonly fiberRefs: FiberRefs.FiberRefs; }) => Runtime<R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L217"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "FiberFailureId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const FiberFailureId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L229"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "FiberFailureCauseId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const FiberFailureCauseId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L240"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "isAsyncFiberException",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isAsyncFiberException: (u: unknown) => u is AsyncFiberException<unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L261"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "isFiberFailure",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isFiberFailure: (u: unknown) => u is FiberFailure",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L268"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "makeFiberFailure",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeFiberFailure: <E>(cause: Cause<E>) => FiberFailure",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L274"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "updateRuntimeFlags",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "runtime flags",
    "signature": "declare const updateRuntimeFlags: { (f: (flags: RuntimeFlags.RuntimeFlags) => RuntimeFlags.RuntimeFlags): <R>(self: Runtime<R>) => Runtime<R>; <R>(self: Runtime<R>, f: (flags: RuntimeFlags.RuntimeFlags) => RuntimeFlags.RuntimeFlags): Runtime<R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L280"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "enableRuntimeFlag",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "runtime flags",
    "signature": "declare const enableRuntimeFlag: { (flag: RuntimeFlags.RuntimeFlag): <R>(self: Runtime<R>) => Runtime<R>; <R>(self: Runtime<R>, flag: RuntimeFlags.RuntimeFlag): Runtime<R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L289"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "disableRuntimeFlag",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "runtime flags",
    "signature": "declare const disableRuntimeFlag: { (flag: RuntimeFlags.RuntimeFlag): <R>(self: Runtime<R>) => Runtime<R>; <R>(self: Runtime<R>, flag: RuntimeFlags.RuntimeFlag): Runtime<R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L298"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "updateContext",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const updateContext: { <R, R2>(f: (context: Context.Context<R>) => Context.Context<R2>): (self: Runtime<R>) => Runtime<R2>; <R, R2>(self: Runtime<R>, f: (context: Context.Context<R>) => Context.Context<R2>): Runtime<R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L307"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "provideService",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Context, Runtime } from \"effect\"\n\nclass Name extends Context.Tag(\"Name\")<Name, string>() {}\n\nconst runtime: Runtime.Runtime<Name> = Runtime.defaultRuntime.pipe(\n  Runtime.provideService(Name, \"John\")\n)\n```"
    ],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: S): <R>(self: Runtime<R>) => Runtime<I | R>; <R, I, S>(self: Runtime<R>, tag: Context.Tag<I, S>, service: S): Runtime<R | I>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L326"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "updateFiberRefs",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiber refs",
    "signature": "declare const updateFiberRefs: { (f: (fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs): <R>(self: Runtime<R>) => Runtime<R>; <R>(self: Runtime<R>, f: (fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs): Runtime<R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L335"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "setFiberRef",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, FiberRef, Runtime } from \"effect\"\n\nconst ref = FiberRef.unsafeMake(0)\n\nconst updatedRuntime = Runtime.defaultRuntime.pipe(\n  Runtime.setFiberRef(ref, 1)\n)\n\n// returns 1\nconst result = Runtime.runSync(updatedRuntime)(FiberRef.get(ref))\n```"
    ],
    "since": "2.0.0",
    "category": "fiber refs",
    "signature": "declare const setFiberRef: { <A>(fiberRef: FiberRef.FiberRef<A>, value: A): <R>(self: Runtime<R>) => Runtime<R>; <R, A>(self: Runtime<R>, fiberRef: FiberRef.FiberRef<A>, value: A): Runtime<R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L357"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "deleteFiberRef",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, FiberRef, Runtime } from \"effect\"\n\nconst ref = FiberRef.unsafeMake(0)\n\nconst updatedRuntime = Runtime.defaultRuntime.pipe(\n  Runtime.setFiberRef(ref, 1),\n  Runtime.deleteFiberRef(ref)\n)\n\n// returns 0\nconst result = Runtime.runSync(updatedRuntime)(FiberRef.get(ref))\n```"
    ],
    "since": "2.0.0",
    "category": "fiber refs",
    "signature": "declare const deleteFiberRef: { <A>(fiberRef: FiberRef.FiberRef<A>): <R>(self: Runtime<R>) => Runtime<R>; <R, A>(self: Runtime<R>, fiberRef: FiberRef.FiberRef<A>): Runtime<R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L380"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "AsyncFiberException",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface AsyncFiberException<out A, out E = never> {\n  readonly _tag: \"AsyncFiberException\"\n  readonly fiber: Fiber.RuntimeFiber<A, E>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L23"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "Cancel",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Cancel<out A, out E = never> {\n  (fiberId?: FiberId.FiberId, options?: RunCallbackOptions<A, E> | undefined): void\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L32"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "Runtime",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Runtime<in R> extends Pipeable {\n  /**\n   * The context used as initial for forks\n   */\n  readonly context: Context.Context<R>\n  /**\n   * The runtime flags used as initial for forks\n   */\n  readonly runtimeFlags: RuntimeFlags.RuntimeFlags\n  /**\n   * The fiber references used as initial for forks\n   */\n  readonly fiberRefs: FiberRefs.FiberRefs\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L40"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "RunForkOptions",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RunForkOptions {\n  readonly scheduler?: Scheduler | undefined\n  readonly updateRefs?: ((refs: FiberRefs.FiberRefs, fiberId: FiberId.Runtime) => FiberRefs.FiberRefs) | undefined\n  readonly immediate?: boolean\n  readonly scope?: Scope\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L70"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "RunCallbackOptions",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RunCallbackOptions<in A, in E = never> extends RunForkOptions {\n  readonly onExit?: ((exit: Exit.Exit<A, E>) => void) | undefined\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L127"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "FiberFailure",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface FiberFailure extends Error, Inspectable {\n  readonly [FiberFailureId]: FiberFailureId\n  readonly [FiberFailureCauseId]: Cause<unknown>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L252"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "FiberFailureId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type FiberFailureId = typeof FiberFailureId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L234"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "FiberFailureCauseId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "type FiberFailureCauseId = typeof FiberFailureCauseId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L246"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Runtime.ts",
      "path": "src/Runtime.ts"
    },
    "project": "effect",
    "name": "Runtime.Context",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "Type Extractors",
    "signature": "type Context<T> = [T] extends [Runtime<infer R>] ? R : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Runtime.ts#L63"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "None",
    "description": "No runtime flags.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const None: RuntimeFlag",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L40"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "Interruption",
    "description": "The interruption flag determines whether or not the Effect runtime system will\ninterrupt a fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Interruption: RuntimeFlag",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L49"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "OpSupervision",
    "description": "The op supervision flag determines whether or not the Effect runtime system\nwill supervise all operations of the Effect runtime. Use of this flag will\nnegatively impact performance, but is required for some operations, such as\nprofiling.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const OpSupervision: RuntimeFlag",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L60"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "RuntimeMetrics",
    "description": "The runtime metrics flag determines whether or not the Effect runtime system\nwill collect metrics about the Effect runtime. Use of this flag will have a\nvery small negative impact on performance, but generates very helpful\noperational insight into running Effect applications that can be exported to\nPrometheus or other tools via Effect Metrics.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const RuntimeMetrics: RuntimeFlag",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L72"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "WindDown",
    "description": "The wind down flag determines whether the Effect runtime system will execute\neffects in wind-down mode. In wind-down mode, even if interruption is\nenabled and a fiber has been interrupted, the fiber will continue its\nexecution uninterrupted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const WindDown: RuntimeFlag",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L83"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "CooperativeYielding",
    "description": "The cooperative yielding flag determines whether the Effect runtime will\nyield to another fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const CooperativeYielding: RuntimeFlag",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L92"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "cooperativeYielding",
    "description": "Returns `true` if the `CooperativeYielding` `RuntimeFlag` is enabled, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const cooperativeYielding: (self: RuntimeFlags) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L101"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "diff",
    "description": "Creates a `RuntimeFlagsPatch` which describes the difference between `self`\nand `that`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "diffing",
    "signature": "declare const diff: { (that: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlagsPatch.RuntimeFlagsPatch; (self: RuntimeFlags, that: RuntimeFlags): RuntimeFlagsPatch.RuntimeFlagsPatch; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L110"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "differ",
    "description": "Constructs a differ that knows how to diff `RuntimeFlags` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const differ: Differ.Differ<RuntimeFlags, RuntimeFlagsPatch.RuntimeFlagsPatch>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L121"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "disable",
    "description": "Disables the specified `RuntimeFlag`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const disable: { (flag: RuntimeFlag): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flag: RuntimeFlag): RuntimeFlags; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L129"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "disableAll",
    "description": "Disables all of the `RuntimeFlag`s in the specified set of `RuntimeFlags`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const disableAll: { (flags: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flags: RuntimeFlags): RuntimeFlags; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L140"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "disableCooperativeYielding",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const disableCooperativeYielding: Layer.Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L149"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "disableInterruption",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const disableInterruption: Layer.Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L155"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "disableOpSupervision",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const disableOpSupervision: Layer.Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L161"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "disableRuntimeMetrics",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const disableRuntimeMetrics: Layer.Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L167"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "disableWindDown",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const disableWindDown: Layer.Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L173"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "enable",
    "description": "Enables the specified `RuntimeFlag`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const enable: { (flag: RuntimeFlag): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flag: RuntimeFlag): RuntimeFlags; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L181"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "enableAll",
    "description": "Enables all of the `RuntimeFlag`s in the specified set of `RuntimeFlags`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const enableAll: { (flags: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flags: RuntimeFlags): RuntimeFlags; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L192"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "enableCooperativeYielding",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const enableCooperativeYielding: Layer.Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L201"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "enableInterruption",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const enableInterruption: Layer.Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L207"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "enableOpSupervision",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const enableOpSupervision: Layer.Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L213"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "enableRuntimeMetrics",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const enableRuntimeMetrics: Layer.Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L219"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "enableWindDown",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const enableWindDown: Layer.Layer<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L225"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "interruptible",
    "description": "Returns true only if the `Interruption` flag is **enabled** and the\n`WindDown` flag is **disabled**.\n\nA fiber is said to be interruptible if interruption is enabled and the fiber\nis not in its wind-down phase, in which it takes care of cleanup activities\nrelated to fiber shutdown.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const interruptible: (self: RuntimeFlags) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L238"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "interruption",
    "description": "Returns `true` if the `Interruption` `RuntimeFlag` is enabled, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const interruption: (self: RuntimeFlags) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L247"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "isEnabled",
    "description": "Returns `true` if the specified `RuntimeFlag` is enabled, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const isEnabled: { (flag: RuntimeFlag): (self: RuntimeFlags) => boolean; (self: RuntimeFlags, flag: RuntimeFlag): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L255"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "isDisabled",
    "description": "Returns `true` if the specified `RuntimeFlag` is disabled, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const isDisabled: { (flag: RuntimeFlag): (self: RuntimeFlags) => boolean; (self: RuntimeFlags, flag: RuntimeFlag): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L266"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (...flags: ReadonlyArray<RuntimeFlag>) => RuntimeFlags",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L275"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "none",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const none: RuntimeFlags",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L281"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "opSupervision",
    "description": "Returns `true` if the `OpSupervision` `RuntimeFlag` is enabled, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const opSupervision: (self: RuntimeFlags) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L290"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "patch",
    "description": "Patches a set of `RuntimeFlag`s with a `RuntimeFlagsPatch`, returning the\npatched set of `RuntimeFlag`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const patch: { (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, patch: RuntimeFlagsPatch.RuntimeFlagsPatch): RuntimeFlags; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L299"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "render",
    "description": "Converts the provided `RuntimeFlags` into a `string`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const render: (self: RuntimeFlags) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L310"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "runtimeMetrics",
    "description": "Returns `true` if the `RuntimeMetrics` `RuntimeFlag` is enabled, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const runtimeMetrics: (self: RuntimeFlags) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L319"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "toSet",
    "description": "Converts the provided `RuntimeFlags` into a `ReadonlySet<number>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "declare const toSet: (self: RuntimeFlags) => ReadonlySet<RuntimeFlag>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L327"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "windDown",
    "description": "Returns `true` if the `WindDown` `RuntimeFlag` is enabled, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const windDown: (self: RuntimeFlags) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L336"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "RuntimeFlags",
    "description": "Represents a set of `RuntimeFlag`s. `RuntimeFlag`s affect the operation of\nthe Effect runtime system. They are exposed to application-level code because\nthey affect the behavior and performance of application code.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type RuntimeFlags = number & {\n  readonly RuntimeFlags: unique symbol\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L19"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RuntimeFlags.ts",
      "path": "src/RuntimeFlags.ts"
    },
    "project": "effect",
    "name": "RuntimeFlag",
    "description": "Represents a flag that can be set to enable or disable a particular feature\nof the Effect runtime.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type RuntimeFlag = number & {\n  readonly RuntimeFlag: unique symbol\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlags.ts#L30"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "The empty `RuntimeFlagsPatch`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: RuntimeFlagsPatch",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L22"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (active: number, enabled: number) => RuntimeFlagsPatch",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L28"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "enable",
    "description": "Creates a `RuntimeFlagsPatch` describing enabling the provided `RuntimeFlag`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const enable: (flag: RuntimeFlags.RuntimeFlag) => RuntimeFlagsPatch",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L36"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "disable",
    "description": "Creates a `RuntimeFlagsPatch` describing disabling the provided `RuntimeFlag`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const disable: (flag: RuntimeFlags.RuntimeFlag) => RuntimeFlagsPatch",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L44"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the specified `RuntimeFlagsPatch` is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isEmpty: (patch: RuntimeFlagsPatch) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L52"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "isActive",
    "description": "Returns `true` if the `RuntimeFlagsPatch` describes the specified\n`RuntimeFlag` as active.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const isActive: { (flag: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlagsPatch): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L61"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "isEnabled",
    "description": "Returns `true` if the `RuntimeFlagsPatch` describes the specified\n`RuntimeFlag` as enabled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const isEnabled: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L73"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "isDisabled",
    "description": "Returns `true` if the `RuntimeFlagsPatch` describes the specified\n`RuntimeFlag` as disabled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const isDisabled: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L85"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "includes",
    "description": "Returns `true` if the `RuntimeFlagsPatch` includes the specified\n`RuntimeFlag`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const includes: { (flag: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlagsPatch): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L97"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "andThen",
    "description": "Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,\nfollowed by `that` patch.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const andThen: { (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L109"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "both",
    "description": "Creates a `RuntimeFlagsPatch` describing application of both the `self` patch\nand `that` patch.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const both: { (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L121"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "either",
    "description": "Creates a `RuntimeFlagsPatch` describing application of either the `self`\npatch or `that` patch.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const either: { (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L133"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "exclude",
    "description": "Creates a `RuntimeFlagsPatch` which describes exclusion of the specified\n`RuntimeFlag` from the set of `RuntimeFlags`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const exclude: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): RuntimeFlagsPatch; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L145"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "inverse",
    "description": "Creates a `RuntimeFlagsPatch` which describes the inverse of the patch\nspecified by the provided `RuntimeFlagsPatch`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const inverse: (patch: RuntimeFlagsPatch) => RuntimeFlagsPatch",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L157"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "enabledSet",
    "description": "Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\nenabled by the specified `RuntimeFlagsPatch`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const enabledSet: (self: RuntimeFlagsPatch) => ReadonlySet<RuntimeFlags.RuntimeFlag>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L166"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "disabledSet",
    "description": "Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\ndisabled by the specified `RuntimeFlagsPatch`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const disabledSet: (self: RuntimeFlagsPatch) => ReadonlySet<RuntimeFlags.RuntimeFlag>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L175"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "render",
    "description": "Renders the provided `RuntimeFlagsPatch` to a string.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const render: (self: RuntimeFlagsPatch) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L183"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RuntimeFlagsPatch.ts",
      "path": "src/RuntimeFlagsPatch.ts"
    },
    "project": "effect",
    "name": "RuntimeFlagsPatch",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type RuntimeFlagsPatch = number & {\n  readonly RuntimeFlagsPatch: unique symbol\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/RuntimeFlagsPatch.ts#L12"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "ScheduleTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "declare const ScheduleTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L25"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "ScheduleDriverTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "declare const ScheduleDriverTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L37"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "makeWithState",
    "description": "Creates a new schedule with a custom state and step function.\n\n**Details**\n\nThis function constructs a `Schedule` by defining its initial state and a\nstep function, which determines how the schedule progresses over time. The\nstep function is called on each iteration with the current time, an input\nvalue, and the schedule's current state. It returns the next state, an output\nvalue, and a decision on whether the schedule should continue or stop.\n\nThis function is useful for creating custom scheduling logic that goes beyond\npredefined schedules like fixed intervals or exponential backoff. It allows\nfull control over how the schedule behaves at each step.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const makeWithState: <S, In, Out, R = never>(initial: S, step: (now: number, input: In, state: S) => Effect.Effect<readonly [S, Out, ScheduleDecision.ScheduleDecision], never, R>) => Schedule<Out, In, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L166"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "isSchedule",
    "description": "Checks whether a given value is a `Schedule`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "declare const isSchedule: (u: unknown) => u is Schedule<unknown, never, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L181"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "addDelay",
    "description": "Adds a delay to every interval in a schedule.\n\n**Details**\n\nThis function modifies a given schedule by applying an additional delay to\nevery interval it defines. The delay is determined by the provided function,\nwhich takes the schedule's output and returns a delay duration.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "declare const addDelay: { <Out>(f: (out: Out) => Duration.DurationInput): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (out: Out) => Duration.DurationInput): Schedule<Out, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L197"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "addDelayEffect",
    "description": "Adds an effectfully computed delay to every interval in a schedule.\n\n**Details**\n\nThis function modifies a given schedule by applying an additional delay to\neach interval, where the delay is determined by an effectful function. The\nfunction takes the schedules output and returns an effect that produces a\ndelay duration.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "declare const addDelayEffect: { <Out, R2>(f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>): Schedule<Out, In, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L217"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "andThen",
    "description": "Runs two schedules sequentially, merging their outputs.\n\n**Details**\n\nThis function executes two schedules one after the other. The first schedule\nruns to completion, and then the second schedule begins execution. Unlike\n{@link andThenEither}, this function merges the outputs instead of wrapping\nthem in `Either`, allowing both schedules to contribute their results\ndirectly.\n\nThis is useful when a workflow consists of two phases where the second phase\nshould start only after the first one has fully completed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequential Composition",
    "signature": "declare const andThen: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2 | Out, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out | Out2, In & In2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L247"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "andThenEither",
    "description": "Runs two schedules sequentially, collecting results in an `Either`.\n\n**Details**\n\nThis function combines two schedules in sequence. The first schedule runs to\ncompletion, and then the second schedule starts and runs to completion as\nwell. The outputs of both schedules are collected into an `Either` structure:\n- `Either.Left` contains the output of the second schedule.\n- `Either.Right` contains the output of the first schedule.\n\nThis is useful when you need to switch from one schedule to another after the\nfirst one finishes, while still keeping track of which schedule produced each\nresult.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequential Composition",
    "signature": "declare const andThenEither: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Either.Either<Out2, Out>, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Either.Either<Out2, Out>, In & In2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L277"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "as",
    "description": "Transforms a schedule to always produce a constant output.\n\n**Details**\n\nThis function modifies a given schedule so that instead of returning its\ncomputed outputs, it always returns a constant value.\n\nThis is useful when you need a schedule for timing but dont care about its\nactual output, or when you want to standardize results across different\nscheduling strategies.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const as: { <Out2>(out: Out2): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>; <Out, In, R, Out2>(self: Schedule<Out, In, R>, out: Out2): Schedule<Out2, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L302"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "asVoid",
    "description": "Transforms a schedule to always return `void` instead of its output.\n\n**Details**\n\nThis function modifies a given schedule so that it no longer returns\nmeaningful outputeach execution produces `void`. This is useful when the\nschedule is used only for timing purposes and the actual output of the\nschedule is irrelevant.\n\nThe schedule still determines when executions should occur, but the results\nare discarded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const asVoid: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<void, In, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L323"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "bothInOut",
    "description": "Combines two schedules, preserving both their inputs and outputs.\n\n**Details**\n\nThis function merges two schedules so that both their input types and output\ntypes are retained. When executed, the resulting schedule will take inputs\nfrom both original schedules and produce a tuple containing both outputs.\n\nIt recurs if either schedule wants to continue, using the shorter delay.\n\nThis is useful when you want to track multiple schedules simultaneously,\nensuring that both receive the same inputs and produce combined results.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "declare const bothInOut: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], readonly [In, In2], R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], readonly [In, In2], R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L343"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "check",
    "description": "Filters schedule executions based on a custom condition.\n\n**Details**\n\nThis function modifies a schedule by applying a custom test function to each\ninput-output pair. The test function determines whether the schedule should\ncontinue or stop. If the function returns `true`, the schedule proceeds as\nusual; if it returns `false`, the schedule terminates.\n\nThis is useful for conditional retries, custom stop conditions, or\ndynamically controlling execution based on observed inputs and outputs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const check: { <In, Out>(test: (input: In, output: Out) => boolean): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, test: (input: In, output: Out) => boolean): Schedule<Out, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L371"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "checkEffect",
    "description": "Conditionally filters schedule executions using an effectful function.\n\n**Details**\n\nThis function modifies a schedule by applying a custom effectful test\nfunction to each input-output pair. The test function determines whether the\nschedule should continue (`true`) or stop (`false`).\n\nThis is useful when the decision to continue depends on external factors such\nas database lookups, API calls, or other asynchronous computations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const checkEffect: { <In, Out, R2>(test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L393"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "collectAllInputs",
    "description": "A schedule that collects all inputs into a `Chunk`.\n\n**Details**\n\nThis function creates a schedule that never terminates and continuously\ncollects every input it receives into a `Chunk`. Each time the schedule runs,\nit appends the new input to the collected list.\n\nThis is useful when you need to track all received inputs over time, such as\nlogging user actions, recording retry attempts, or accumulating data for\nlater processing.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const collectAllInputs: <A>() => Schedule<Chunk.Chunk<A>, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L422"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "collectAllOutputs",
    "description": "Collects all outputs of a schedule into a `Chunk`.\n\n**Details**\n\nThis function modifies a given schedule so that instead of returning\nindividual outputs, it accumulates them into a `Chunk`. The schedule\ncontinues to run, appending each output to the collected list.\n\nThis is useful when you need to track all results over time, such as logging\noutputs, aggregating data, or keeping a history of previous values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const collectAllOutputs: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Chunk.Chunk<Out>, In, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L442"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "collectUntil",
    "description": "Collects all inputs into a `Chunk` until a condition fails.\n\n**Details**\n\nThis function creates a schedule that continuously collects inputs into a\n`Chunk` until the given predicate function `f` evaluates to `false`. Once the\ncondition fails, the schedule stops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const collectUntil: <A>(f: Predicate<A>) => Schedule<Chunk.Chunk<A>, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L457"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "collectUntilEffect",
    "description": "Collects all inputs into a `Chunk` until an effectful condition fails.\n\n**Details**\n\nThis function creates a schedule that continuously collects inputs into a\n`Chunk` until the given effectful predicate `f` returns `false`. The\npredicate runs as an effect, meaning it can involve asynchronous computations\nlike API calls, database lookups, or randomness.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const collectUntilEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<Chunk.Chunk<A>, A, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L472"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "collectWhile",
    "description": "Collects all inputs into a `Chunk` while a condition holds.\n\n**Details**\n\nThis function creates a schedule that continuously collects inputs into a\n`Chunk` while the given predicate function `f` evaluates to `true`. As soon\nas the condition fails, the schedule stops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const collectWhile: <A>(f: Predicate<A>) => Schedule<Chunk.Chunk<A>, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L488"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "collectWhileEffect",
    "description": "Collects all inputs into a `Chunk` while an effectful condition holds.\n\n**Details**\n\nThis function creates a schedule that continuously collects inputs into a\n`Chunk` while the given effectful predicate `f` returns `true`. The predicate\nreturns an effect, meaning it can depend on external state, such as database\nqueries, API responses, or real-time user conditions.\n\nAs soon as the effectful condition returns `false`, the schedule stops. This\nis useful for dynamically controlled data collection, where stopping depends\non an external or asynchronous factor.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "declare const collectWhileEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<Chunk.Chunk<A>, A, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L507"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "compose",
    "description": "Chains two schedules, passing the output of the first as the input to the\nsecond, while selecting the shorter delay between them.\n\n**Details**\n\nThis function composes two schedules so that the output of the first schedule\nbecomes the input of the second schedule. The first schedule executes first,\nand once it produces a result, the second schedule receives that result and\ncontinues execution based on it.\n\nThis is useful for building complex scheduling workflows where one schedule's\nbehavior determines how the next schedule behaves.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "declare const compose: { <Out2, Out, R2>(that: Schedule<Out2, Out, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>; <Out, In, R, Out2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, Out, R2>): Schedule<Out2, In, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L528"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "mapInput",
    "description": "Transforms the input type of a schedule.\n\n**Details**\n\nThis function modifies a given schedule by applying a transformation function\nto its inputs. Instead of directly receiving values of type `In`, the\nschedule will now accept values of type `In2`, which are converted to `In`\nusing the provided mapping function `f`.\n\nThis is useful when you have a schedule that expects a specific input type\nbut you need to adapt it to work with a different type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const mapInput: { <In, In2>(f: (in2: In2) => In): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R>; <Out, In, R, In2>(self: Schedule<Out, In, R>, f: (in2: In2) => In): Schedule<Out, In2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L551"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "mapInputEffect",
    "description": "Transforms the input type of a schedule using an effectful function.\n\n**Details**\n\nThis function modifies a schedule by applying an effectful transformation to\nits inputs. Instead of directly receiving values of type `In`, the schedule\nwill now accept values of type `In2`, which are converted to `In` via an\neffectful function `f`.\n\nThis is useful when the input transformation involves external dependencies,\nsuch as API calls, database lookups, or other asynchronous computations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const mapInputEffect: { <In2, In, R2>(f: (in2: In2) => Effect.Effect<In, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R2 | R>; <Out, In, R, In2, R2>(self: Schedule<Out, In, R>, f: (in2: In2) => Effect.Effect<In, never, R2>): Schedule<Out, In2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L574"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "mapInputContext",
    "description": "Transforms the required context of a schedule.\n\n**Details**\n\nThis function modifies a schedule by mapping its required context (`R`) into\na new context (`R0`) using the provided function `f`.\n\nThis is useful when you need to adapt a schedule to work with a different\ndependency environment without changing its core logic.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const mapInputContext: { <R0, R>(f: (env0: Context.Context<R0>) => Context.Context<R>): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, R0>; <Out, In, R, R0>(self: Schedule<Out, In, R>, f: (env0: Context.Context<R0>) => Context.Context<R>): Schedule<Out, In, R0>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L598"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "count",
    "description": "A schedule that recurs indefinitely, counting the number of recurrences.\n\n**Details**\n\nThis schedule never stops and simply counts how many times it has executed.\nEach recurrence increases the count, starting from `0`.\n\nThis is useful when tracking the number of attempts in retry policies,\nmeasuring execution loops, or implementing infinite polling scenarios.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const count: Schedule<number, unknown, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L622"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "cron",
    "description": "Creates a schedule that recurs based on a cron expression.\n\n**Details**\n\nThis schedule automatically executes at intervals defined by a cron\nexpression. It triggers at the beginning of each matched interval and\nproduces timestamps representing the start and end of the cron window.\n\nThe cron `expression` is validated lazily, meaning errors may only be\ndetected when the schedule is executed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Cron",
    "signature": "declare const cron: { (cron: Cron.Cron): Schedule<[number, number]>; (expression: string, tz?: DateTime.TimeZone | string): Schedule<[number, number]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L639"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "secondOfMinute",
    "description": "Cron-like schedule that recurs at a specific second of each minute.\n\n**Details**\n\nThis schedule triggers at the specified `second` of each minute,\nstarting at zero nanoseconds. It produces a count of executions\n(0, 1, 2, ...). The `second` parameter is validated lazily, meaning\ninvalid values will only be caught at runtime.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Cron",
    "signature": "declare const secondOfMinute: (second: number) => Schedule<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L657"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "minuteOfHour",
    "description": "Creates a schedule that recurs every specified minute of each hour.\n\n**Details**\n\nThis schedule triggers once per hour at the specified `minute`, starting\nexactly at `minute:00` (zero seconds). The schedule produces a count of\nexecutions (`0, 1, 2, ...`), representing how many times it has run.\n\nThe `minute` parameter must be between `0` and `59`. It is validated lazily,\nmeaning an invalid value will cause errors only when the schedule is\nexecuted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Cron",
    "signature": "declare const minuteOfHour: (minute: number) => Schedule<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L675"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "hourOfDay",
    "description": "Creates a schedule that recurs at a specific hour of each day.\n\n**Details**\n\nThis schedule triggers once per day at the specified `hour`, starting at zero\nminutes of that hour. The schedule produces a count of executions (`0, 1, 2,\n...`), indicating how many times it has been triggered.\n\nThe `hour` parameter must be between `0` (midnight) and `23` (11 PM). It is\nvalidated lazily, meaning an invalid value will cause errors only when the\nschedule is executed.\n\nThis is useful for scheduling daily recurring tasks at a fixed time, such as\nrunning batch jobs or refreshing data.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Cron",
    "signature": "declare const hourOfDay: (hour: number) => Schedule<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L696"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "dayOfMonth",
    "description": "Creates a schedule that recurs on a specific day of the month.\n\n**Details**\n\nThis schedule triggers at midnight on the specified day of each month. It\nwill not execute in months that have fewer days than the given day. For\nexample, if the schedule is set to run on the 31st, it will not execute in\nmonths with only 30 days.\n\nThe schedule produces a count of executions, starting at 0 and incrementing\nwith each recurrence.\n\nThe `day` parameter is validated lazily, meaning errors may only be detected\nwhen the schedule is executed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Cron",
    "signature": "declare const dayOfMonth: (day: number) => Schedule<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L717"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "dayOfWeek",
    "description": "Creates a schedule that recurs on a specific day of the week.\n\n**Details**\n\nThis schedule triggers at midnight on the specified day of the week. The\n`day` parameter follows the standard convention where `Monday = 1` and\n`Sunday = 7`. The schedule produces a count of executions, starting at 0 and\nincrementing with each recurrence.\n\nThe `day` parameter is validated lazily, meaning errors may only be detected\nwhen the schedule is executed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Cron",
    "signature": "declare const dayOfWeek: (day: number) => Schedule<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L735"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "delayed",
    "description": "Modifies a schedule by adding a computed delay before each execution.\n\n**Details**\n\nThis function adjusts an existing schedule by applying a transformation to\nits delays. Instead of using the default interval, each delay is modified\nusing the provided function `f`, which takes the current delay and returns a\nnew delay.\n\nThis is useful for dynamically adjusting wait times between executions, such\nas introducing jitter, exponential backoff, or custom delay logic.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "declare const delayed: { (f: (duration: Duration.Duration) => Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (duration: Duration.Duration) => Duration.DurationInput): Schedule<Out, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L755"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "delayedEffect",
    "description": "Modifies a schedule by adding an effectfully computed delay before each\nexecution.\n\n**Details**\n\nThis function adjusts an existing schedule by introducing a delay that is\ncomputed via an effect. Instead of using a fixed delay, each interval is\ndynamically adjusted based on an effectful function `f`, which takes the\ncurrent delay and returns a new delay wrapped in an `Effect`.\n\nThis is useful for adaptive scheduling where delays depend on external\nfactors, such as API calls, database queries, or dynamic system conditions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "declare const delayedEffect: { <R2>(f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): Schedule<Out, In, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L784"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "delayedSchedule",
    "description": "Uses the delays produced by a schedule to further delay its intervals.\n\n**Details**\n\nThis function modifies a schedule by using its own output delays to control\nits execution timing. Instead of executing immediately at each interval, the\nschedule will be delayed by the duration it produces.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "declare const delayedSchedule: <In, R>(schedule: Schedule<Duration.Duration, In, R>) => Schedule<Duration.Duration, In, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L806"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "delays",
    "description": "Transforms a schedule to output the delay between each occurrence.\n\n**Details**\n\nThis function modifies an existing schedule so that instead of producing its\noriginal output, it now returns the delay between each scheduled execution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Monitoring",
    "signature": "declare const delays: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Duration.Duration, In, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L821"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "mapBoth",
    "description": "Transforms both the input and output of a schedule.\n\n**Details**\n\nThis function modifies an existing schedule by applying a transformation to\nboth its input values and its output values. The provided transformation\nfunctions `onInput` and `onOutput` allow you to map the schedule to work with\na different input type while modifying its outputs as well.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const mapBoth: { <In2, In, Out, Out2>(options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2; }): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R>; <Out, In, R, In2, Out2>(self: Schedule<Out, In, R>, options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2; }): Schedule<Out2, In2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L838"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "mapBothEffect",
    "description": "Transforms both the input and output of a schedule using effectful\ncomputations.\n\n**Details**\n\nThis function modifies an existing schedule by applying effectful\ntransformations to both its input values and its output values. The provided\neffectful functions `onInput` and `onOutput` allow you to transform inputs\nand outputs using computations that may involve additional logic, resource\naccess, or side effects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const mapBothEffect: { <In2, In, R2, Out, R3, Out2>(options: { readonly onInput: (input: In2) => Effect.Effect<In, never, R2>; readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>; }): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R2 | R3 | R>; <Out, In, R, In2, R2, Out2, R3>(self: Schedule<Out, In, R>, options: { readonly onInput: (input: In2) => Effect.Effect<In, never, R2>; readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>; }): Schedule<Out2, In2, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L865"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "driver",
    "description": "Creates a driver to manually control the execution of a schedule.\n\n**Details**\n\nThis function returns a `ScheduleDriver`, which allows stepping through a\nschedule manually while handling delays and sleeping appropriately. A driver\nis useful when you need fine-grained control over how a schedule progresses,\nrather than relying on automatic execution.\n\nThe returned driver exposes methods for retrieving the current state,\nexecuting the next step, and resetting the schedule when needed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getter",
    "signature": "declare const driver: <Out, In, R>(self: Schedule<Out, In, R>) => Effect.Effect<ScheduleDriver<Out, In, R>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L897"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "duration",
    "description": "Alias of {@link fromDelay}.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const duration: (duration: Duration.DurationInput) => Schedule<Duration.Duration>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L908"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "either",
    "description": "Alias of {@link union}.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Alternatives",
    "signature": "declare const either: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L917"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "eitherWith",
    "description": "Alias of {@link unionWith}.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Alternatives",
    "signature": "declare const eitherWith: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L934"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "elapsed",
    "description": "Creates a schedule that tracks the total elapsed duration since it started.\n\n**Details**\n\nThis schedule executes continuously and returns the total time that has\npassed since the first execution. The duration keeps increasing with each\nstep, providing a way to measure elapsed time.\n\nThis is useful for tracking execution time, monitoring delays, or\nimplementing logic based on how long a process has been running.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const elapsed: Schedule<Duration.Duration, unknown, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L961"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "ensuring",
    "description": "Attaches a finalizer to a schedule that runs when the schedule completes.\n\n**Details**\n\nThis function returns a new schedule that executes a given finalizer when the\nschedule reaches completion. Unlike `Effect.ensuring`, this method does not\nguarantee the finalizer will run in all cases. If the schedule never\ninitializes or is not driven to completion, the finalizer may not execute.\nHowever, if the schedule decides not to continue, the finalizer will be\ninvoked.\n\nThis is useful for cleaning up resources, logging, or executing other side\neffects when a schedule completes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Finalization",
    "signature": "declare const ensuring: { <X>(finalizer: Effect.Effect<X, never, never>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R, X>(self: Schedule<Out, In, R>, finalizer: Effect.Effect<X, never, never>): Schedule<Out, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L981"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "exponential",
    "description": "Creates a schedule that recurs indefinitely with exponentially increasing\ndelays.\n\n**Details**\n\nThis schedule starts with an initial delay of `base` and increases the delay\nexponentially on each repetition using the formula `base * factor^n`, where\n`n` is the number of times the schedule has executed so far. If no `factor`\nis provided, it defaults to `2`, causing the delay to double after each\nexecution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const exponential: (base: Duration.DurationInput, factor?: number) => Schedule<Duration.Duration>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1001"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "fibonacci",
    "description": "Creates a schedule that recurs indefinitely with Fibonacci-based increasing\ndelays.\n\n**Details**\n\nThis schedule starts with an initial delay of `one` and increases subsequent\ndelays by summing the two previous delays, following the Fibonacci sequence.\nThe delay pattern follows: `one, one, one + one, (one + one) + one, ...`,\nresulting in `1s, 1s, 2s, 3s, 5s, 8s, 13s, ...` if `one = 1s`.\n\nThis is useful for progressive backoff strategies, where delays grow\nnaturally over time without increasing as aggressively as an exponential\nschedule.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const fibonacci: (one: Duration.DurationInput) => Schedule<Duration.Duration>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1024"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "fixed",
    "description": "Creates a schedule that recurs at a fixed interval.\n\n**Details**\n\nThis schedule executes at regular, evenly spaced intervals, returning the\nnumber of times it has run so far. If the action being executed takes longer\nthan the interval, the next execution will happen immediately to prevent\n\"pile-ups,\" ensuring that the schedule remains consistent without overlapping\nexecutions.\n\n```text\n|-----interval-----|-----interval-----|-----interval-----|\n|---------action--------||action|-----|action|-----------|\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const fixed: (interval: Duration.DurationInput) => Schedule<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1047"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "forever",
    "description": "Creates a schedule that recurs indefinitely, producing a count of\nrepetitions.\n\n**Details**\n\nThis schedule runs indefinitely, returning an increasing count of executions\n(`0, 1, 2, 3, ...`). Each step increments the count by one, allowing tracking\nof how many times it has executed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const forever: Schedule<number, unknown, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1062"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "fromDelay",
    "description": "Creates a schedule that recurs once after a specified duration.\n\n**Details**\n\nThis schedule executes a single time after waiting for the given duration.\nOnce it has executed, it does not repeat.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const fromDelay: (delay: Duration.DurationInput) => Schedule<Duration.Duration>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1077"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "fromDelays",
    "description": "Creates a schedule that recurs once for each specified duration, applying the\ngiven delays sequentially.\n\n**Details**\n\nThis schedule executes multiple times, each time waiting for the\ncorresponding duration from the provided list of delays. The first execution\nwaits for `delay`, the next for the second value in `delays`, and so on. Once\nall delays have been used, the schedule stops executing.\n\nThis is useful for defining a custom delay sequence that does not follow a\nfixed pattern like exponential or Fibonacci backoff.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const fromDelays: (delay: Duration.DurationInput, ...delays: Array<Duration.DurationInput>) => Schedule<Duration.Duration>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1096"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "fromFunction",
    "description": "Creates a schedule that always recurs, transforming input values using the\nspecified function.\n\n**Details**\n\nThis schedule continuously executes and applies the given function `f` to\neach input value, producing a transformed output. The schedule itself does\nnot control delays or stopping conditions; it simply transforms the input\nvalues as they are processed.\n\nThis is useful when defining schedules that map inputs to outputs, allowing\ndynamic transformations of incoming data.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const fromFunction: <A, B>(f: (a: A) => B) => Schedule<B, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1118"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "identity",
    "description": "Creates a schedule that always recurs, passing inputs directly as outputs.\n\n**Details**\n\nThis schedule runs indefinitely, returning each input value as its output\nwithout modification. It effectively acts as a pass-through that simply\nechoes its input values at each step.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const identity: <A>() => Schedule<A, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1132"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "passthrough",
    "description": "Transforms a schedule to pass through its inputs as outputs.\n\n**Details**\n\nThis function modifies an existing schedule so that it returns its input\nvalues instead of its original output values. The schedule's timing remains\nunchanged, but its outputs are replaced with whatever inputs it receives.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const passthrough: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<In, In, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1145"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "intersect",
    "description": "Combines two schedules, continuing only if both schedules want to continue,\nusing the longer delay.\n\n**Details**\n\nThis function takes two schedules and creates a new schedule that only\ncontinues execution if both schedules allow it. The interval between\nrecurrences is determined by the longer delay between the two schedules.\n\nThe output of the resulting schedule is a tuple containing the outputs of\nboth schedules. The input type is the intersection of both schedules' input\ntypes.\n\nThis is useful when coordinating multiple scheduling conditions where\nexecution should proceed only when both schedules permit it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "declare const intersect: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1169"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "intersectWith",
    "description": "Combines two schedules, continuing only if both want to continue, merging\nintervals using a custom function.\n\n**Details**\n\nThis function takes two schedules and creates a new schedule that only\ncontinues execution if both schedules allow it. Instead of automatically\nusing the longer delay (like {@link intersect}), this function applies a\nuser-provided merge function `f` to determine the next interval between\nexecutions.\n\nThe output of the resulting schedule is a tuple containing the outputs of\nboth schedules, and the input type is the intersection of both schedules'\ninput types.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "declare const intersectWith: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1198"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "jittered",
    "description": "Returns a new schedule that randomly adjusts the interval size within a\nrange.\n\n**Details**\n\nThis function modifies a schedule so that its delay between executions is\nrandomly varied within a range. By default, the delay is adjusted between\n`80%` (`0.8 * interval`) and `120%` (`1.2 * interval`) of the original\ninterval size.\n\nThis is useful for adding randomness to repeated executions, reducing\ncontention in distributed systems, and avoiding synchronized execution\npatterns that can cause bottlenecks.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "declare const jittered: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1230"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "jitteredWith",
    "description": "Returns a new schedule that randomly adjusts the interval size within a\nuser-defined range.\n\n**Details**\n\nThis function modifies a schedule so that its delay between executions is\nrandomly varied within a specified range. Instead of using the default `0.8 -\n1.2` range like {@link jittered}, this function allows customizing the `min`\nand `max` multipliers.\n\nThe delay for each step will be adjusted within `min * original_interval` and\n`max * original_interval`. If `min` and `max` are not provided, the defaults\nare `0.8` and `1.2`, respectively.\n\nThis is useful for introducing randomness into scheduling behavior while\nhaving precise control over the jitter range.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "declare const jitteredWith: { (options: { min?: number | undefined; max?: number | undefined; }): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, options: { min?: number | undefined; max?: number | undefined; }): Schedule<Out, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1253"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "linear",
    "description": "Creates a schedule that recurs indefinitely, increasing the delay linearly.\n\n**Details**\n\nThis schedule starts with an initial delay of `base` and increases the delay\non each recurrence in a linear fashion, following the formula:\n\n`delay = base * n`\n\nwhere `n` is the number of times the schedule has executed so far. This\nresults in increasing intervals between executions.\n\nThis is useful for implementing linear backoff strategies where the wait time\nbetween retries increases at a steady rate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const linear: (base: Duration.DurationInput) => Schedule<Duration.Duration>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1282"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Returns a new schedule that transforms its output using the specified\nfunction.\n\n**Details**\n\nThis function modifies an existing schedule so that its outputs are\ntransformed by the provided function `f`. The timing and recurrence behavior\nof the schedule remain unchanged, but the values it produces are mapped to\nnew values.\n\nThis is useful when composing schedules where you need to adjust the output\nformat or apply additional processing.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const map: { <Out, Out2>(f: (out: Out) => Out2): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>; <Out, In, R, Out2>(self: Schedule<Out, In, R>, f: (out: Out) => Out2): Schedule<Out2, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1304"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "mapEffect",
    "description": "Returns a new schedule that applies an effectful transformation to its\noutput.\n\n**Details**\n\nThis function modifies an existing schedule by applying an effectful function\n`f` to its output values. The timing and recurrence behavior of the schedule\nremain unchanged, but each output is mapped to a new value within an\n`Effect`.\n\nThis is useful when you need to perform side effects or asynchronous\ntransformations before passing the output forward.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "declare const mapEffect: { <Out, Out2, R2>(f: (out: Out) => Effect.Effect<Out2, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>; <Out, In, R, Out2, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<Out2, never, R2>): Schedule<Out2, In, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1328"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "modifyDelay",
    "description": "Returns a new schedule that modifies the delay between executions using a\ncustom function.\n\n**Details**\n\nThis function transforms an existing schedule by applying `f` to modify the\ndelay before each execution. The function receives both the schedule's output\n(`out`) and the originally computed delay (`duration`), and returns a new\nadjusted delay.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "declare const modifyDelay: { <Out>(f: (out: Out, duration: Duration.Duration) => Duration.DurationInput): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (out: Out, duration: Duration.Duration) => Duration.DurationInput): Schedule<Out, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1354"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "modifyDelayEffect",
    "description": "Returns a new schedule that modifies the delay before execution using an\neffectful function.\n\n**Details**\n\nThis function takes an existing schedule and applies an effectful function\n`f` to dynamically adjust the delay before each execution. The function\nreceives both the schedule's output (`out`) and the originally computed delay\n(`duration`), returning a new adjusted delay wrapped in an `Effect`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "declare const modifyDelayEffect: { <Out, R2>(f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): Schedule<Out, In, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1380"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "onDecision",
    "description": "Returns a new schedule that executes an effect every time the schedule makes\na decision.\n\n**Details**\n\nThis function enhances an existing schedule by running an effectful function\n`f` whenever a scheduling decision is made. The function receives the current\nschedule output (`out`) and the decision (`ScheduleDecision`), allowing\nadditional logic to be executed, such as logging, monitoring, or side\neffects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const onDecision: { <Out, X, R2>(f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, X, R2>(self: Schedule<Out, In, R>, f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>): Schedule<Out, In, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1404"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "once",
    "description": "A schedule that executes only once and then stops.\n\n**Details**\n\nThis schedule triggers a single execution and then terminates. It does not\nrepeat or apply any additional logic.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const once: Schedule<void, unknown, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1425"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "provideContext",
    "description": "Returns a new schedule with a provided context, eliminating the need for\nexternal dependencies.\n\n**Details**\n\nThis function supplies a required `context` to a schedule, allowing it to run\nwithout requiring external dependencies. After calling this function, the\nschedule can be used freely without needing to pass a context at execution\ntime.\n\nThis is useful when working with schedules that rely on contextual\ninformation, such as logging services, database connections, or configuration\nsettings.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const provideContext: { <R>(context: Context.Context<R>): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, never>; <Out, In, R>(self: Schedule<Out, In, R>, context: Context.Context<R>): Schedule<Out, In, never>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1445"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "provideService",
    "description": "Returns a new schedule with a single required service provided, eliminating\nthe need for external dependencies.\n\n**Details**\n\nThis function supplies a single service dependency to a schedule, allowing it\nto run without requiring that service externally. If a schedule depends on\nmultiple services, consider using `provideContext` instead.\n\nThis is useful when working with schedules that require a specific service,\nsuch as logging, metrics, or configuration retrieval.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: Types.NoInfer<S>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, Exclude<R, I>>; <Out, In, R, I, S>(self: Schedule<Out, In, R>, tag: Context.Tag<I, S>, service: Types.NoInfer<S>): Schedule<Out, In, Exclude<R, I>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1466"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "recurUntil",
    "description": "A schedule that recurs until the given predicate evaluates to true.\n\n**Details**\n\nThis schedule will continue executing as long as the provided predicate `f`\nreturns `false` for the input value. Once `f` evaluates to `true`, the\nschedule stops recurring.\n\nThis is useful for defining schedules that should stop when a certain\ncondition is met, such as detecting a success state, reaching a threshold, or\navoiding unnecessary retries.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const recurUntil: <A>(f: Predicate<A>) => Schedule<A, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1496"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "recurUntilEffect",
    "description": "A schedule that recurs until the given effectful predicate evaluates to true.\n\n**Details**\n\nThis schedule continues executing as long as the provided effectful predicate\n`f` returns `false`. Once `f` evaluates to `true`, the schedule stops\nrecurring. Unlike {@link recurUntil}, this function allows the stopping\ncondition to be computed asynchronously or based on external dependencies.\n\nThis is useful when the stopping condition depends on an effectful\ncomputation, such as checking a database, making an API call, or retrieving\nsystem state dynamically.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const recurUntilEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<A, A, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1517"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "recurUntilOption",
    "description": "A schedule that recurs until the input value matches a partial function, then\nmaps the value.\n\n**Details**\n\nThis schedule continues executing until the provided partial function `pf`\nreturns `Some(value)`. At that point, it stops and maps the resulting value\nto an `Option<B>`. If `pf` returns `None`, the schedule continues.\n\nThis is useful when defining schedules that should stop once a certain\ncondition is met and transform the final value before completion.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const recurUntilOption: <A, B>(pf: (a: A) => Option.Option<B>) => Schedule<Option.Option<B>, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1536"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "recurUpTo",
    "description": "A schedule that recurs until the specified duration has elapsed.\n\n**Details**\n\nThis schedule continues executing for the given `duration`, after which it\nstops. The schedule outputs the elapsed time on each recurrence.\n\nThis is useful for limiting the duration of retries, enforcing time-based\nconstraints, or ensuring that an operation does not run indefinitely.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const recurUpTo: (duration: Duration.DurationInput) => Schedule<Duration.Duration>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1553"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "recurWhile",
    "description": "A schedule that recurs as long as the given predicate evaluates to true.\n\n**Details*\n\nThis schedule continues executing as long as the provided predicate `f`\nreturns `true` for the input value. Once `f` evaluates to `false`, the\nschedule stops recurring.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const recurWhile: <A>(f: Predicate<A>) => Schedule<A, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1569"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "recurWhileEffect",
    "description": "A schedule that recurs as long as the given effectful predicate evaluates to\ntrue.\n\n**Details**\n\nThis schedule continues executing as long as the provided effectful predicate\n`f` returns `true`. Once `f` evaluates to `false`, the schedule stops\nrecurring. Unlike {@link recurWhile}, this function allows the condition to\nbe computed dynamically using an effectful computation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const recurWhileEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<A, A, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1587"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "recurs",
    "description": "A schedule that recurs a fixed number of times before terminating.\n\n**Details**\n\nThis schedule will continue executing until it has been stepped `n` times,\nafter which it will stop. The output of the schedule is the current count of\nrecurrences.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const recurs: (n: number) => Schedule<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1602"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "reduce",
    "description": "Returns a new schedule that folds over the outputs of this one.\n\n**Details**\n\nThis schedule transforms the output by accumulating values over time using a\nreducer function `f`. It starts with an initial value `zero` and updates it\neach time the schedule produces an output.\n\nThis is useful for tracking statistics, aggregating results, or summarizing\ndata across multiple executions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Reducing",
    "signature": "declare const reduce: { <Out, Z>(zero: Z, f: (z: Z, out: Out) => Z): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R>; <Out, In, R, Z>(self: Schedule<Out, In, R>, zero: Z, f: (z: Z, out: Out) => Z): Schedule<Z, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1621"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "reduceEffect",
    "description": "Returns a new schedule that effectfully folds over the outputs of this one.\n\n**Details**\n\nThis schedule accumulates outputs over time using an effectful reducer\nfunction `f`. It starts with an initial value `zero` and updates it\nasynchronously or based on external dependencies.\n\nThis is useful for asynchronous state tracking, logging, external metrics\naggregation, or any scenario where accumulation needs to involve an effectful\ncomputation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Reducing",
    "signature": "declare const reduceEffect: { <Z, Out, R2>(zero: Z, f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R2 | R>; <Out, In, R, Z, R2>(self: Schedule<Out, In, R>, zero: Z, f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>): Schedule<Z, In, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1644"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "repeatForever",
    "description": "Alias of {@link forever}.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const repeatForever: Schedule<number, unknown, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1663"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "repetitions",
    "description": "Returns a new schedule that outputs the number of repetitions of this one.\n\n**Details**\n\nThis schedule tracks how many times the given schedule has executed and\noutputs the count instead of the original values. The first execution starts\nat `0`, and the count increases with each recurrence.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Monitoring",
    "signature": "declare const repetitions: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<number, In, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1677"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "resetAfter",
    "description": "Returns a new schedule that automatically resets to its initial state after a\nperiod of inactivity defined by `duration`.\n\n**Details**\n\nThis function modifies a schedule so that if no inputs are received for the\nspecified `duration`, the schedule resets as if it were new.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "State Management",
    "signature": "declare const resetAfter: { (duration: Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, duration: Duration.DurationInput): Schedule<Out, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1693"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "resetWhen",
    "description": "Resets the schedule when the specified predicate on the schedule output\nevaluates to `true`.\n\n**Details**\n\nThis function modifies a schedule so that it resets to its initial state\nwhenever the provided predicate `f` returns `true` for an output value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "State Management",
    "signature": "declare const resetWhen: { <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1712"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "run",
    "description": "Runs a schedule using the provided inputs and collects all outputs.\n\n**Details**\n\nThis function executes a given schedule with a sequence of input values and\naccumulates all outputs into a `Chunk`. The schedule starts execution at the\nspecified `now` timestamp and proceeds according to its defined behavior.\n\nThis is useful for batch processing, simulating execution, or testing\nschedules with predefined input sequences.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Execution",
    "signature": "declare const run: { <In>(now: number, input: Iterable<In>): <Out, R>(self: Schedule<Out, In, R>) => Effect.Effect<Chunk.Chunk<Out>, never, R>; <Out, In, R>(self: Schedule<Out, In, R>, now: number, input: Iterable<In>): Effect.Effect<Chunk.Chunk<Out>, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1732"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "spaced",
    "description": "Returns a schedule that recurs continuously, with each repetition\nspaced by the specified `duration` from the last run.\n\n**Details**\n\nThis schedule ensures that executions occur at a fixed interval,\nmaintaining a consistent delay between repetitions. The delay starts\nfrom the end of the last execution, not from the schedule start time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const spaced: (duration: Duration.DurationInput) => Schedule<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1755"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "stop",
    "description": "A schedule that does not recur and stops immediately.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const stop: Schedule<void, unknown, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1763"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "succeed",
    "description": "Returns a schedule that recurs indefinitely, always producing the specified\nconstant value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const succeed: <A>(value: A) => Schedule<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1772"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "sync",
    "description": "Returns a schedule that recurs indefinitely, evaluating the given function to\nproduce a constant value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const sync: <A>(evaluate: LazyArg<A>) => Schedule<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1781"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "tapInput",
    "description": "Returns a new schedule that runs the given effectful function for each input\nbefore continuing execution.\n\n**Details**\n\nThis function allows side effects to be performed on each input processed by\nthe schedule. It does not modify the schedules behavior but ensures that the\nprovided function `f` runs before each step.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tapping",
    "signature": "declare const tapInput: { <In2, X, R2>(f: (input: In2) => Effect.Effect<X, never, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>; <Out, In, R, In2, X, R2>(self: Schedule<Out, In, R>, f: (input: In2) => Effect.Effect<X, never, R2>): Schedule<Out, In & In2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1796"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "tapOutput",
    "description": "Returns a new schedule that runs the given effectful function for each output\nbefore continuing execution.\n\n**Details**\n\nThis function allows side effects to be performed on each output produced by\nthe schedule. It does not modify the schedules behavior but ensures that the\nprovided function `f` runs after each step.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tapping",
    "signature": "declare const tapOutput: { <X, R2, Out>(f: (out: Types.NoInfer<Out>) => Effect.Effect<X, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, X, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<X, never, R2>): Schedule<Out, In, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1819"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "unfold",
    "description": "Creates a schedule that repeatedly applies a function to transform a state\nvalue, producing a sequence of values.\n\n**Details**\n\nThis function starts with an `initial` value and applies `f` recursively to\ngenerate the next state at each step. The schedule continues indefinitely,\nproducing a stream of values by unfolding the state over time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const unfold: <A>(initial: A, f: (a: A) => A) => Schedule<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1842"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "union",
    "description": "Combines two schedules, continuing execution as long as at least one of them\nallows it, using the shorter delay.\n\n**Details**\n\nThis function combines two schedules into a single schedule that executes in\nparallel. If either schedule allows continuation, the merged schedule\ncontinues. When both schedules produce delays, the schedule selects the\nshorter delay to determine the next step.\n\nThe output of the new schedule is a tuple containing the outputs of both\nschedules. The input type is the intersection of both schedules' input types.\n\nThis is useful for scenarios where multiple scheduling conditions should be\nconsidered, ensuring execution proceeds if at least one schedule permits it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "declare const union: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1866"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "unionWith",
    "description": "Combines two schedules, continuing execution as long as at least one of them\nwants to continue, merging their intervals using a custom merge function.\n\n**Details**\n\nThis function allows you to combine two schedules while defining how their\nintervals should be merged. Unlike {@link union}, which simply selects the\nshorter delay, this function lets you specify a custom merging strategy for\nthe schedules intervals.\n\nThe merged schedule continues execution as long as at least one of the input\nschedules allows it. The next interval is determined by applying the provided\nmerge function to the intervals of both schedules.\n\nThe output of the resulting schedule is a tuple containing the outputs of\nboth schedules. The input type is the intersection of both schedules' input\ntypes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "declare const unionWith: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1900"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "untilInput",
    "description": "Returns a new schedule that stops execution when the given predicate on the\ninput evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it continues executing\nonly while the provided predicate returns `false` for incoming inputs. Once\nan input satisfies the condition, the schedule terminates immediately.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const untilInput: { <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1927"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "untilInputEffect",
    "description": "Returns a new schedule that stops execution when the given effectful\npredicate on the input evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it continues executing\nonly while the provided effectful predicate returns `false` for incoming\ninputs. The predicate is an `Effect`, meaning it can involve asynchronous\ncomputations or dependency-based logic.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const untilInputEffect: { <In, R2>(f: (input: In) => Effect.Effect<boolean, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (input: In) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1948"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "untilOutput",
    "description": "Returns a new schedule that stops execution when the given predicate on the\noutput evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecuting while the given predicate returns false for its output values. Once\nthe predicate evaluates to `true`, execution stops.\n\nThe output of the resulting schedule remains the same, but its duration is\nnow constrained by a stopping condition based on its own output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const untilOutput: { <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1976"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "untilOutputEffect",
    "description": "Returns a new schedule that stops execution when the given effectful\npredicate on the output evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecuting while the provided effectful predicate returns `false` for its\noutput values. Once the predicate returns `true`, execution stops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const untilOutputEffect: { <Out, R2>(f: (out: Out) => Effect.Effect<boolean, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L1996"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "upTo",
    "description": "Returns a new schedule that limits execution to a fixed duration.\n\n**Details**\n\nThis function modifies an existing schedule to stop execution after a\nspecified duration has passed. The schedule continues as normal until the\nduration is reached, at which point it stops automatically.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const upTo: { (duration: Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, duration: Duration.DurationInput): Schedule<Out, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2018"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "whileInput",
    "description": "Returns a new schedule that continues execution as long as the given\npredicate on the input is true.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecution while a specified predicate holds true for its input. If the\npredicate evaluates to `false` at any step, the schedule stops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const whileInput: { <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2038"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "whileInputEffect",
    "description": "Returns a new schedule that continues execution for as long as the given\neffectful predicate on the input evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecution while an effectful predicate holds true for its input. If the\npredicate evaluates to `false` at any step, the schedule stops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const whileInputEffect: { <In, R2>(f: (input: In) => Effect.Effect<boolean, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (input: In) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2058"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "whileOutput",
    "description": "Returns a new schedule that continues execution for as long as the given\npredicate on the output evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecution while a provided condition holds true for its output. If the\npredicate returns `false`, the schedule stops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const whileOutput: { <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2083"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "whileOutputEffect",
    "description": "Returns a new schedule that continues execution for as long as the given\neffectful predicate on the output evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecution while an effectful condition holds true for its output. If the\neffectful predicate returns `false`, the schedule stops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "declare const whileOutputEffect: { <Out, R2>(f: (out: Out) => Effect.Effect<boolean, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2103"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "windowed",
    "description": "Creates a schedule that divides time into fixed `interval`-long windows,\ntriggering execution at the start of each new window.\n\n**Details**\n\nThis function produces a schedule that waits until the next time window\nboundary before executing. Each window spans a fixed duration specified by\n`interval`. If an action completes midway through a window, the schedule\nwaits until the next full window starts before proceeding.\n\nFor example, `windowed(Duration.seconds(10))` would produce a schedule as\nfollows:\n\n```text\n     10s        10s        10s       10s\n|----------|----------|----------|----------|\n|action------|sleep---|act|-sleep|action----|\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "declare const windowed: (interval: Duration.DurationInput) => Schedule<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2136"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "The same as {@link intersect} but ignores the right output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "declare const zipLeft: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out, In & In2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2144"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "zipRight",
    "description": "The same as {@link intersect} but ignores the left output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "declare const zipRight: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out2, In & In2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2160"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Equivalent to {@link intersect} followed by {@link map}.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "declare const zipWith: { <Out2, In2, R2, Out, Out3>(that: Schedule<Out2, In2, R2>, f: (out: Out, out2: Out2) => Out3): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out3, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2, Out3>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (out: Out, out2: Out2) => Out3): Schedule<Out3, In & In2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L2176"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "Schedule",
    "description": "A `Schedule<Out, In, R>` defines a recurring schedule, which consumes values\nof type `In`, and which returns values of type `Out`.\n\nThe `Schedule` type is structured as follows:\n\n```ts skip-type-checking\n//         The type of output produced by the schedule\n//            The type of input consumed by the schedule\n//                 Additional requirements for the schedule\n//                \nSchedule<Out, In, Requirements>\n```\n\nA schedule operates by consuming values of type `In` (such as errors in the\ncase of `Effect.retry`, or values in the case of `Effect.repeat`) and\nproducing values of type `Out`. It determines when to halt or continue the\nexecution based on input values and its internal state.\n\nThe inclusion of a `Requirements` parameter allows the schedule to leverage\nadditional services or resources as needed.\n\nSchedules are defined as a possibly infinite set of intervals spread out over\ntime. Each interval defines a window in which recurrence is possible.\n\nWhen schedules are used to repeat or retry effects, the starting boundary of\neach interval produced by a schedule is used as the moment when the effect\nwill be executed again.\n\nSchedules can be composed in different ways:\n\n- Union: Combines two schedules and recurs if either schedule wants to\n  continue, using the shorter delay.\n- Intersection: Combines two schedules and recurs only if both schedules want\n  to continue, using the longer delay.\n- Sequencing: Combines two schedules by running the first one fully, then\n  switching to the second.\n\nIn addition, schedule inputs and outputs can be transformed, filtered (to\nterminate a schedule early in response to some input or output), and so\nforth.\n\nA variety of other operators exist for transforming and combining schedules,\nand the companion object for `Schedule` contains all common types of\nschedules, both for performing retrying, as well as performing repetition.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Model",
    "signature": "export interface Schedule<out Out, in In = unknown, out R = never> extends Schedule.Variance<Out, In, R>, Pipeable {\n  /**\n   * Initial State\n   */\n  readonly initial: any\n  /**\n   * Schedule Step\n   */\n  step(\n    now: number,\n    input: In,\n    state: any\n  ): Effect.Effect<readonly [any, Out, ScheduleDecision.ScheduleDecision], never, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L94"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "ScheduleDriver",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface ScheduleDriver<out Out, in In = unknown, out R = never> extends Schedule.DriverVariance<Out, In, R> {\n  readonly state: Effect.Effect<unknown>\n  readonly last: Effect.Effect<Out, Cause.NoSuchElementException>\n  readonly reset: Effect.Effect<void>\n  next(input: In): Effect.Effect<Out, Option.Option<never>, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L141"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "ScheduleTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "type ScheduleTypeId = typeof ScheduleTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L31"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "ScheduleDriverTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "type ScheduleDriverTypeId = typeof ScheduleDriverTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L43"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "Schedule.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Variance<out Out, in In, out R> {\n    readonly [ScheduleTypeId]: {\n      readonly _Out: Types.Covariant<Out>\n      readonly _In: Types.Contravariant<In>\n      readonly _R: Types.Covariant<R>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L117"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schedule.ts",
      "path": "src/Schedule.ts"
    },
    "project": "effect",
    "name": "Schedule.DriverVariance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface DriverVariance<out Out, in In, out R> {\n    readonly [ScheduleDriverTypeId]: {\n      readonly _Out: Types.Covariant<Out>\n      readonly _In: Types.Contravariant<In>\n      readonly _R: Types.Covariant<R>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schedule.ts#L128"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleDecision.ts",
      "path": "src/ScheduleDecision.ts"
    },
    "project": "effect",
    "name": "continueWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const continueWith: (interval: Interval.Interval) => ScheduleDecision",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleDecision.ts#L44"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleDecision.ts",
      "path": "src/ScheduleDecision.ts"
    },
    "project": "effect",
    "name": "done",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const done: ScheduleDecision",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleDecision.ts#L50"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleDecision.ts",
      "path": "src/ScheduleDecision.ts"
    },
    "project": "effect",
    "name": "isContinue",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isContinue: (self: ScheduleDecision) => self is Continue",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleDecision.ts#L56"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleDecision.ts",
      "path": "src/ScheduleDecision.ts"
    },
    "project": "effect",
    "name": "isDone",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isDone: (self: ScheduleDecision) => self is Done",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleDecision.ts#L62"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScheduleDecision.ts",
      "path": "src/ScheduleDecision.ts"
    },
    "project": "effect",
    "name": "Continue",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Continue {\n  readonly _tag: \"Continue\"\n  readonly intervals: Intervals.Intervals\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleDecision.ts#L18"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScheduleDecision.ts",
      "path": "src/ScheduleDecision.ts"
    },
    "project": "effect",
    "name": "Done",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Done {\n  readonly _tag: \"Done\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleDecision.ts#L27"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ScheduleDecision.ts",
      "path": "src/ScheduleDecision.ts"
    },
    "project": "effect",
    "name": "ScheduleDecision",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type ScheduleDecision = Continue | Done",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleDecision.ts#L12"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "IntervalTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const IntervalTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L12"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new interval from the two specified endpoints. If the start\nendpoint greater than the end endpoint, then a zero size interval will be\nreturned.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (startMillis: number, endMillis: number) => Interval",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L41"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "An `Interval` of zero-width.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: Interval",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L49"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "lessThan",
    "description": "Returns `true` if this `Interval` is less than `that` interval, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "declare const lessThan: { (that: Interval): (self: Interval) => boolean; (self: Interval, that: Interval): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L58"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "min",
    "description": "Returns the minimum of two `Interval`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "declare const min: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L69"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "max",
    "description": "Returns the maximum of two `Interval`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "declare const max: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L80"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the specified `Interval` is empty, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "declare const isEmpty: (self: Interval) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L91"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "isNonEmpty",
    "description": "Returns `true` if the specified `Interval` is non-empty, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "declare const isNonEmpty: (self: Interval) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L99"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "intersect",
    "description": "Computes a new `Interval` which is the intersection of this `Interval` and\nthat `Interval`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "declare const intersect: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L108"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Calculates the size of the `Interval` as the `Duration` from the start of the\ninterval to the end of the interval.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: (self: Interval) => Duration.Duration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L120"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "union",
    "description": "Computes a new `Interval` which is the union of this `Interval` and that\n`Interval` as a `Some`, otherwise returns `None` if the two intervals cannot\nform a union.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const union: { (that: Interval): (self: Interval) => Option.Option<Interval>; (self: Interval, that: Interval): Option.Option<Interval>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L130"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "after",
    "description": "Construct an `Interval` that includes all time equal to and after the\nspecified start time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const after: (startMilliseconds: number) => Interval",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L142"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "before",
    "description": "Construct an `Interval` that includes all time equal to and before the\nspecified end time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const before: (endMilliseconds: number) => Interval",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L151"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "Interval",
    "description": "An `Interval` represents an interval of time. Intervals can encompass all\ntime, or no time at all.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Interval {\n  readonly [IntervalTypeId]: IntervalTypeId\n  readonly startMillis: number\n  readonly endMillis: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L27"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ScheduleInterval.ts",
      "path": "src/ScheduleInterval.ts"
    },
    "project": "effect",
    "name": "IntervalTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type IntervalTypeId = typeof IntervalTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleInterval.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals.ts",
      "path": "src/ScheduleIntervals.ts"
    },
    "project": "effect",
    "name": "IntervalsTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const IntervalsTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L12"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals.ts",
      "path": "src/ScheduleIntervals.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new `Intervals` from a `List` of `Interval`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (intervals: Check.Chunk<Interval.Interval>) => Intervals",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L37"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals.ts",
      "path": "src/ScheduleIntervals.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Constructs an empty list of `Interval`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: Intervals",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L45"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals.ts",
      "path": "src/ScheduleIntervals.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates `Intervals` from the specified `Iterable<Interval>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: (intervals: Iterable<Interval.Interval>) => Intervals",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L53"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals.ts",
      "path": "src/ScheduleIntervals.ts"
    },
    "project": "effect",
    "name": "union",
    "description": "Computes the union of this `Intervals` and  that `Intervals`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const union: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L61"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals.ts",
      "path": "src/ScheduleIntervals.ts"
    },
    "project": "effect",
    "name": "intersect",
    "description": "Produces the intersection of this `Intervals` and that `Intervals`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const intersect: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L72"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals.ts",
      "path": "src/ScheduleIntervals.ts"
    },
    "project": "effect",
    "name": "start",
    "description": "The start of the earliest interval in the specified `Intervals`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const start: (self: Intervals) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L83"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals.ts",
      "path": "src/ScheduleIntervals.ts"
    },
    "project": "effect",
    "name": "end",
    "description": "The end of the latest interval in the specified `Intervals`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const end: (self: Intervals) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L91"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals.ts",
      "path": "src/ScheduleIntervals.ts"
    },
    "project": "effect",
    "name": "lessThan",
    "description": "Returns `true` if the start of this `Intervals` is before the start of that\n`Intervals`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "declare const lessThan: { (that: Intervals): (self: Intervals) => boolean; (self: Intervals, that: Intervals): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L100"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals.ts",
      "path": "src/ScheduleIntervals.ts"
    },
    "project": "effect",
    "name": "isNonEmpty",
    "description": "Returns `true` if this `Intervals` is non-empty, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isNonEmpty: (self: Intervals) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L111"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals.ts",
      "path": "src/ScheduleIntervals.ts"
    },
    "project": "effect",
    "name": "max",
    "description": "Returns the maximum of the two `Intervals` (i.e. which has the latest start).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "declare const max: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L119"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScheduleIntervals.ts",
      "path": "src/ScheduleIntervals.ts"
    },
    "project": "effect",
    "name": "Intervals",
    "description": "An `Intervals` represents a list of several `Interval`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Intervals {\n  readonly [IntervalsTypeId]: IntervalsTypeId\n  readonly intervals: Check.Chunk<Interval.Interval>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L26"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ScheduleIntervals.ts",
      "path": "src/ScheduleIntervals.ts"
    },
    "project": "effect",
    "name": "IntervalsTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type IntervalsTypeId = typeof IntervalsTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScheduleIntervals.ts#L18"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Scheduler.ts",
      "path": "src/Scheduler.ts"
    },
    "project": "effect",
    "name": "PriorityBuckets",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare class PriorityBuckets<T>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scheduler.ts#L31"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Scheduler.ts",
      "path": "src/Scheduler.ts"
    },
    "project": "effect",
    "name": "MixedScheduler",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare class MixedScheduler { constructor(\n    /**\n     * @since 2.0.0\n     */\n    readonly maxNextTickBeforeTimer: number\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scheduler.ts#L64"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Scheduler.ts",
      "path": "src/Scheduler.ts"
    },
    "project": "effect",
    "name": "SyncScheduler",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare class SyncScheduler",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scheduler.ts#L144"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Scheduler.ts",
      "path": "src/Scheduler.ts"
    },
    "project": "effect",
    "name": "ControlledScheduler",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare class ControlledScheduler",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scheduler.ts#L196"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scheduler.ts",
      "path": "src/Scheduler.ts"
    },
    "project": "effect",
    "name": "defaultScheduler",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "schedulers",
    "signature": "declare const defaultScheduler: Scheduler",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scheduler.ts#L135"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Scheduler.ts",
      "path": "src/Scheduler.ts"
    },
    "project": "effect",
    "name": "makeMatrix",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeMatrix: (...record: Array<[number, Scheduler]>) => Scheduler",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scheduler.ts#L245"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Scheduler.ts",
      "path": "src/Scheduler.ts"
    },
    "project": "effect",
    "name": "defaultShouldYield",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utilities",
    "signature": "declare const defaultShouldYield: (fiber: RuntimeFiber<unknown, unknown>) => number | false",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scheduler.ts#L275"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Scheduler.ts",
      "path": "src/Scheduler.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (scheduleTask: Scheduler[\"scheduleTask\"], shouldYield?: Scheduler[\"shouldYield\"]) => Scheduler",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scheduler.ts#L285"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Scheduler.ts",
      "path": "src/Scheduler.ts"
    },
    "project": "effect",
    "name": "makeBatched",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeBatched: (callback: (runBatch: () => void) => void, shouldYield?: Scheduler[\"shouldYield\"]) => Scheduler",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scheduler.ts#L297"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Scheduler.ts",
      "path": "src/Scheduler.ts"
    },
    "project": "effect",
    "name": "timer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const timer: (ms: number, shouldYield?: Scheduler[\"shouldYield\"]) => Scheduler",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scheduler.ts#L333"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Scheduler.ts",
      "path": "src/Scheduler.ts"
    },
    "project": "effect",
    "name": "timerBatched",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const timerBatched: (ms: number, shouldYield?: Scheduler[\"shouldYield\"]) => Scheduler",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scheduler.ts#L340"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Scheduler.ts",
      "path": "src/Scheduler.ts"
    },
    "project": "effect",
    "name": "Scheduler",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Scheduler {\n  shouldYield(fiber: RuntimeFiber<unknown, unknown>): number | false\n  scheduleTask(task: Task, priority: number): void\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scheduler.ts#L22"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Scheduler.ts",
      "path": "src/Scheduler.ts"
    },
    "project": "effect",
    "name": "Task",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Task = () => void",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scheduler.ts#L16"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Undefined",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "declare class Undefined",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1172"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Void",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "declare class Void",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1178"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Null",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "declare class Null",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1184"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Never",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "declare class Never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1190"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Unknown",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "declare class Unknown",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1196"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Any",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "declare class Any",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1202"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BigIntFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "declare class BigIntFromSelf",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1208"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "SymbolFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "declare class SymbolFromSelf",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1214"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PropertySignatureDeclaration",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare class PropertySignatureDeclaration { constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1722"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "FromPropertySignature",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare class FromPropertySignature { constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly fromKey?: PropertyKey | undefined\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1750"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ToPropertySignature",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare class ToPropertySignature { constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1766"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PropertySignatureTransformation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare class PropertySignatureTransformation { constructor(\n    readonly from: FromPropertySignature,\n    readonly to: ToPropertySignature,\n    readonly decode: AST.PropertySignatureTransformation[\"decode\"],\n    readonly encode: AST.PropertySignatureTransformation[\"encode\"]\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1792"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Lowercased",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "declare class Lowercased",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4543"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Uppercased",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "declare class Uppercased",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4576"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Capitalized",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "declare class Capitalized",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4609"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Uncapitalized",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "declare class Uncapitalized",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4642"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Char",
    "description": "A schema representing a single character.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "declare class Char",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4652"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Lowercase",
    "description": "This schema converts a string to lowercase.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "declare class Lowercase",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4673"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Uppercase",
    "description": "This schema converts a string to uppercase.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "declare class Uppercase",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4689"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Capitalize",
    "description": "This schema converts a string to capitalized one.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "declare class Capitalize",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4705"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Uncapitalize",
    "description": "This schema converts a string to uncapitalized one.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "declare class Uncapitalize",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4721"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Trimmed",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "declare class Trimmed",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4735"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonEmptyTrimmedString",
    "description": "Useful for validating strings that must contain meaningful characters without\nleading or trailing whitespace.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Schema } from \"effect\"\n\nconsole.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"\")) // Option.none()\nconsole.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\" a \")) // Option.none()\nconsole.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")\n```"
    ],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "declare class NonEmptyTrimmedString",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4755"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Trim",
    "description": "This schema allows removing whitespaces from the beginning and end of a string.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "declare class Trim",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4765"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonEmptyString",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "declare class NonEmptyString",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4857"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "UUID",
    "description": "Represents a Universally Unique Identifier (UUID).\n\nThis schema ensures that the provided string adheres to the standard UUID format.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "declare class UUID",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4877"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ULID",
    "description": "Represents a Universally Unique Lexicographically Sortable Identifier (ULID).\n\nULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.\nThis schema ensures that the provided string adheres to the standard ULID format.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "declare class ULID",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4907"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "URLFromSelf",
    "description": "Defines a schema that represents a `URL` object.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "URL constructors",
    "signature": "declare class URLFromSelf",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4922"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NumberFromString",
    "description": "This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.\n\nIt returns an error if the value can't be converted (for example when non-numeric characters are provided).\n\nThe following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number transformations",
    "signature": "declare class NumberFromString",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5341"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Finite",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "declare class Finite",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5349"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Int",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "declare class Int",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5355"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonNaN",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "declare class NonNaN",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5361"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Positive",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "declare class Positive",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5367"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Negative",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "declare class Negative",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5375"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonPositive",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "declare class NonPositive",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5383"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonNegative",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "declare class NonNegative",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5391"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "JsonNumber",
    "description": "The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid\nnumber by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON\nformat.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport * as Schema from \"effect/Schema\"\n\nconst is = Schema.is(S.JsonNumber)\n\nassert.deepStrictEqual(is(42), true)\nassert.deepStrictEqual(is(Number.NaN), false)\nassert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)\nassert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)\n```"
    ],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "declare class JsonNumber",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5428"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Not",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "boolean transformations",
    "signature": "declare class Not",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5439"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BigIntFromNumber",
    "description": "This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.\n\nIt returns an error if the value can't be safely encoded as a `number` due to being out of range.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint transformations",
    "signature": "declare class BigIntFromNumber",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5790"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DurationFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration constructors",
    "signature": "declare class DurationFromSelf",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5893"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DurationFromNanos",
    "description": "A schema that transforms a non negative `bigint` into a `Duration`. Treats\nthe value as the number of nanoseconds.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration transformations",
    "signature": "declare class DurationFromNanos",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5915"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DurationFromMillis",
    "description": "A schema that transforms a (possibly Infinite) non negative number into a\n`Duration`. Treats the value as the number of milliseconds.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration transformations",
    "signature": "declare class DurationFromMillis",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5944"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Duration",
    "description": "A schema that converts a JSON-compatible tagged union into a `Duration`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration transformations",
    "signature": "declare class Duration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6009"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Uint8ArrayFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Uint8Array constructors",
    "signature": "declare class Uint8ArrayFromSelf",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6196"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Uint8",
    "deprecated": false,
    "examples": [],
    "since": "3.11.10",
    "category": "number constructors",
    "signature": "declare class Uint8",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6210"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DateFromSelf",
    "description": "Describes a schema that accommodates potentially invalid `Date` instances,\nsuch as `new Date(\"Invalid Date\")`, without rejection.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date constructors",
    "signature": "declare class DateFromSelf",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6783"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ValidDateFromSelf",
    "description": "Defines a schema that ensures only valid dates are accepted. This schema\nrejects values like `new Date(\"Invalid Date\")`, which, despite being a `Date`\ninstance, represents an invalid date. Such stringent validation ensures that\nall date objects processed through this schema are properly formed and\nrepresent real dates.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date constructors",
    "signature": "declare class ValidDateFromSelf",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6806"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DateFromString",
    "description": "Defines a schema that attempts to convert a `string` to a `Date` object using\nthe `new Date` constructor. This conversion is lenient, meaning it does not\nreject strings that do not form valid dates (e.g., using `new Date(\"Invalid\nDate\")` results in a `Date` object, despite being invalid).",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date transformations",
    "signature": "declare class DateFromString",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6822"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DateFromNumber",
    "description": "Defines a schema that converts a `number` into a `Date` object using the `new\nDate` constructor. This schema does not validate the numerical input,\nallowing potentially invalid values such as `NaN`, `Infinity`, and\n`-Infinity` to be converted into `Date` objects. During the encoding process,\nany invalid `Date` object will be encoded to `NaN`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date transformations",
    "signature": "declare class DateFromNumber",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6860"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DateTimeUtcFromSelf",
    "description": "Describes a schema that represents a `DateTime.Utc` instance.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "DateTime.Utc constructors",
    "signature": "declare class DateTimeUtcFromSelf",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6876"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DateTimeUtcFromNumber",
    "description": "Defines a schema that attempts to convert a `number` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "DateTime.Utc transformations",
    "signature": "declare class DateTimeUtcFromNumber",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6900"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DateTimeUtcFromDate",
    "description": "Defines a schema that attempts to convert a `Date` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "DateTime.Utc transformations",
    "signature": "declare class DateTimeUtcFromDate",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6916"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DateTimeUtc",
    "description": "Defines a schema that attempts to convert a `string` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "DateTime.Utc transformations",
    "signature": "declare class DateTimeUtc",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6932"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TimeZoneOffsetFromSelf",
    "description": "Describes a schema that represents a `TimeZone.Offset` instance.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "TimeZone constructors",
    "signature": "declare class TimeZoneOffsetFromSelf",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6951"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TimeZoneOffset",
    "description": "Defines a schema that converts a `number` to a `TimeZone.Offset` instance using the `DateTime.zoneMakeOffset` constructor.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "TimeZone transformations",
    "signature": "declare class TimeZoneOffset",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6967"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TimeZoneNamedFromSelf",
    "description": "Describes a schema that represents a `TimeZone.Named` instance.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "TimeZone constructors",
    "signature": "declare class TimeZoneNamedFromSelf",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6986"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TimeZoneNamed",
    "description": "Defines a schema that attempts to convert a `string` to a `TimeZone.Named` instance using the `DateTime.zoneUnsafeMakeNamed` constructor.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "TimeZone transformations",
    "signature": "declare class TimeZoneNamed",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7002"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TimeZoneFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "TimeZone constructors",
    "signature": "declare class TimeZoneFromSelf",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7020"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TimeZone",
    "description": "Defines a schema that attempts to convert a `string` to a `TimeZone` using the `DateTime.zoneFromString` constructor.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "TimeZone transformations",
    "signature": "declare class TimeZone",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7028"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DateTimeZonedFromSelf",
    "description": "Describes a schema that represents a `DateTime.Zoned` instance.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "DateTime.Zoned constructors",
    "signature": "declare class DateTimeZonedFromSelf",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7055"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DateTimeZoned",
    "description": "Defines a schema that attempts to convert a `string` to a `DateTime.Zoned` instance.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "DateTime.Zoned transformations",
    "signature": "declare class DateTimeZoned",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7080"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "OptionFromNonEmptyTrimmedString",
    "description": "Transforms strings into an Option type, effectively filtering out empty or\nwhitespace-only strings by trimming them and checking their length. Returns\n`none` for invalid inputs and `some` for valid non-empty strings.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Schema } from \"effect\"\n\nconsole.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"\")) // Option.none()\nconsole.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\" a \")) // Option.some(\"a\")\nconsole.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")\n```"
    ],
    "since": "3.10.0",
    "category": "Option transformations",
    "signature": "declare class OptionFromNonEmptyTrimmedString",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7316"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BigDecimalFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal constructors",
    "signature": "declare class BigDecimalFromSelf",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7896"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BigDecimal",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal transformations",
    "signature": "declare class BigDecimal",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7910"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BigDecimalFromNumber",
    "description": "A schema that transforms a `number` into a `BigDecimal`.\nWhen encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal transformations",
    "signature": "declare class BigDecimalFromNumber",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7932"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "FiberIdFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "FiberId constructors",
    "signature": "declare class FiberIdFromSelf",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9177"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "FiberId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "FiberId transformations",
    "signature": "declare class FiberId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9216"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Defect",
    "description": "Defines a schema for handling JavaScript errors (`Error` instances) and other types of defects.\nIt decodes objects into Error instances if they match the expected structure (i.e., have a `message` and optionally a `name` and `stack`),\nor converts other values to their string representations.\n\nWhen encoding, it converts `Error` instances back into plain objects containing only the error's name and message,\nor other values into their string forms.\n\nThis is useful for serializing and deserializing errors across network boundaries where error objects do not natively serialize.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "defect",
    "signature": "declare class Defect",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9489"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BooleanFromUnknown",
    "description": "Converts an arbitrary value to a `boolean` by testing whether it is truthy.\nUses `!!val` to coerce the value to a `boolean`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "boolean constructors",
    "signature": "declare class BooleanFromUnknown",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10072"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BooleanFromString",
    "description": "Converts an `string` value into its corresponding `boolean`\n(\"true\" as `true` and \"false\" as `false`).",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "boolean transformations",
    "signature": "declare class BooleanFromString",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10089"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ArrayFormatterIssue",
    "deprecated": false,
    "examples": [],
    "since": "3.12.5",
    "category": "ArrayFormatter",
    "signature": "declare class ArrayFormatterIssue",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10843"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L71"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "encode",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encode: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L532"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "encodeEither",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encodeEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L541"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "encodePromise",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encodePromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => Promise<I>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L550"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "decode",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decode: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L597"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "decodeEither",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decodeEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L606"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "decodePromise",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decodePromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => Promise<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L615"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "declare",
    "description": "The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\nThis ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const declare: { <A>(is: (input: unknown) => input is A, annotations?: Annotations.Schema<A>): declare<A>; <A, I, const P extends ReadonlyArray<Schema.All>>(typeParameters: P, options: { readonly decode: (...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never>; }) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<A, ParseResult.ParseIssue, never>; readonly encode: (...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never>; }) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<I, ParseResult.ParseIssue, never>; }, annotations?: Annotations.Schema<A, { readonly [K in keyof P]: Schema.Type<P[K]>; }>): declare<A, I, P>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1064"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BrandSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const BrandSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1105"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "InstanceOfSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const InstanceOfSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1140"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PropertySignatureTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "declare const PropertySignatureTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1850"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "withConstructorDefault",
    "description": "Enhances a property signature with a default constructor value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare const withConstructorDefault: { <Type>(defaultValue: () => Types.NoInfer<Type>): <TypeToken extends PropertySignature.Token, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, R>(self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>; <TypeToken extends PropertySignature.Token, Type, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, R>(self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>, defaultValue: () => Types.NoInfer<Type>): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1994"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "withDecodingDefault",
    "description": "Enhances a property signature with a default decoding value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare const withDecodingDefault: { <Type>(defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>): <Key extends PropertyKey, Encoded, R>(self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R>; <Type, Key extends PropertyKey, Encoded, R>(self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>, defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2064"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "withDefaults",
    "description": "Enhances a property signature with a default decoding value and a default constructor value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare const withDefaults: { <Type>(defaults: { constructor: () => Types.NoInfer<Exclude<Type, undefined>>; decoding: () => Types.NoInfer<Exclude<Type, undefined>>; }): <Key extends PropertyKey, Encoded, R>(self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>; <Type, Key extends PropertyKey, Encoded, R>(self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>, defaults: { constructor: () => Types.NoInfer<Exclude<Type, undefined>>; decoding: () => Types.NoInfer<Exclude<Type, undefined>>; }): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2129"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "fromKey",
    "description": "Enhances a property signature by specifying a different key for it in the Encoded type.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare const fromKey: { <Key extends PropertyKey>(key: Key): <TypeToken extends PropertySignature.Token, Type, EncodedToken extends PropertySignature.Token, Encoded, HasDefault extends boolean, R>(self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>; <Type, TypeToken extends PropertySignature.Token, Encoded, EncodedToken extends PropertySignature.Token, HasDefault extends boolean, R, Key extends PropertyKey>(self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>, key: Key): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2172"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "optionalWith",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare const optionalWith: { <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(options: Options): (self: S) => optionalWith<S, Options>; <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(self: S, options: Options): optionalWith<S, Options>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2554"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "pluck",
    "description": "Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\nproducing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as Schema from \"effect/Schema\"\n\n// ---------------------------------------------\n// use case: pull out a single field from a\n// struct through a transformation\n// ---------------------------------------------\n\nconst mytable = Schema.Struct({\n  column1: Schema.NumberFromString,\n  column2: Schema.Number\n})\n\n// const pullOutColumn: S.Schema<number, {\n//     readonly column1: string;\n// }, never>\nconst pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n\nconsole.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n// Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }\n```"
    ],
    "since": "3.10.0",
    "category": "struct transformations",
    "signature": "declare const pluck: { <A, I, K extends keyof A & keyof I>(key: K): <R>(schema: Schema<A, I, R>) => SchemaClass<A[K], Simplify<Pick<I, K>>, R>; <A, I, R, K extends keyof A & keyof I>(schema: Schema<A, I, R>, key: K): SchemaClass<A[K], Simplify<Pick<I, K>>, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3113"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "partialWith",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "declare const partialWith: { <const Options extends { readonly exact: true; }>(options: Options): <A, I, R>(self: Schema<A, I, R>) => SchemaClass<{ [K in keyof A]?: A[K]; }, { [K in keyof I]?: I[K]; }, R>; <A, I, R, const Options extends { readonly exact: true; } | undefined>(self: Schema<A, I, R>, options: Options): SchemaClass<{ [K in keyof A]?: A[K]; }, { [K in keyof I]?: I[K]; }, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3230"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "extend",
    "description": "Extends a schema with another schema.\n\nNot all extensions are supported, and their support depends on the nature of\nthe involved schemas.\n\nPossible extensions include:\n- `Schema.String` with another `Schema.String` refinement or a string literal\n- `Schema.Number` with another `Schema.Number` refinement or a number literal\n- `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean\n  literal\n- A struct with another struct where overlapping fields support extension\n- A struct with in index signature\n- A struct with a union of supported schemas\n- A refinement of a struct with a supported schema\n- A suspend of a struct with a supported schema\n- A transformation between structs where the from and to sides have no\n  overlapping fields with the target struct",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as Schema from \"effect/Schema\"\n\nconst schema = Schema.Struct({\n  a: Schema.String,\n  b: Schema.String\n})\n\n// const extended: Schema<\n//   {\n//     readonly a: string\n//     readonly b: string\n//   } & {\n//     readonly c: string\n//   } & {\n//     readonly [x: string]: string\n//   }\n// >\nconst extended = Schema.asSchema(schema.pipe(\n  Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n  Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n))\n```"
    ],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "declare const extend: { <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>; <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3507"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "compose",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "declare const compose: { <To extends Schema.Any, From extends Schema.Any, C extends Schema.Type<From>>(to: To & Schema<Schema.Type<To>, C, Schema.Context<To>>): (from: From) => transform<From, To>; <To extends Schema.Any>(to: To): <From extends Schema.Any, B extends Schema.Encoded<To>>(from: From & Schema<B, Schema.Encoded<From>, Schema.Context<From>>) => transform<From, To>; <To extends Schema.Any>(to: To, options?: { readonly strict: true; }): <From extends Schema.Any>(from: From & Schema<Schema.Encoded<To>, Schema.Encoded<From>, Schema.Context<From>>) => transform<From, To>; <To extends Schema.Any>(to: To, options: { readonly strict: false; }): <From extends Schema.Any>(from: From) => transform<From, To>; <From extends Schema.Any, To extends Schema.Any, C extends Schema.Type<From>>(from: From, to: To & Schema<Schema.Type<To>, C, Schema.Context<To>>): transform<From, To>; <From extends Schema.Any, B extends Schema.Encoded<To>, To extends Schema.Any>(from: From & Schema<B, Schema.Encoded<From>, Schema.Context<From>>, to: To): transform<From, To>; <From extends Schema.Any, To extends Schema.Any>(from: From & Schema<Schema.Encoded<To>, Schema.Encoded<From>, Schema.Context<From>>, to: To, options?: { readonly strict: true; }): transform<From, To>; <From extends Schema.Any, To extends Schema.Any>(from: From, to: To, options: { readonly strict: false; }): transform<From, To>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3519"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "RefineSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "declare const RefineSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3579"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "filterEffect",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "transformations",
    "signature": "declare const filterEffect: { <S extends Schema.Any, FD>(f: (a: Types.NoInfer<Schema.Type<S>>, options: ParseOptions, self: AST.Transformation) => Effect.Effect<FilterReturnType, never, FD>): (self: S) => filterEffect<S, FD>; <S extends Schema.Any, RD>(self: S, f: (a: Types.NoInfer<Schema.Type<S>>, options: ParseOptions, self: AST.Transformation) => Effect.Effect<FilterReturnType, never, RD>): filterEffect<S, RD>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3745"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "transformOrFail",
    "description": "Create a new `Schema` by transforming the input and output of an existing `Schema`\nusing the provided decoding functions.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "transformations",
    "signature": "declare const transformOrFail: { <To extends Schema.Any, From extends Schema.Any, RD, RE>(to: To, options: { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>; readonly strict: false; }): (from: From) => transformOrFail<From, To, RD | RE>; <To extends Schema.Any, From extends Schema.Any, RD, RE>(from: From, to: To, options: { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>; readonly strict: false; }): transformOrFail<From, To, RD | RE>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3832"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "transform",
    "description": "Create a new `Schema` by transforming the input and output of an existing `Schema`\nusing the provided mapping functions.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "transformations",
    "signature": "declare const transform: { <To extends Schema.Any, From extends Schema.Any>(to: To, options: { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown; readonly strict: false; }): (from: From) => transform<From, To>; <To extends Schema.Any, From extends Schema.Any>(from: From, to: To, options: { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown; readonly strict: false; }): transform<From, To>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3941"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "attachPropertySignature",
    "description": "Attaches a property signature with the specified key and value to the schema.\nThis API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\nbut rather maps to another schema, for example when you want to add a discriminant to a simple union.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport * as S from \"effect/Schema\"\nimport { pipe } from \"effect/Function\"\n\nconst Circle = S.Struct({ radius: S.Number })\nconst Square = S.Struct({ sideLength: S.Number })\nconst Shape = S.Union(\n  Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n  Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n)\n\nassert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n  kind: \"circle\",\n  radius: 10\n})\n```"
    ],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "declare const attachPropertySignature: { <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(key: K, value: V, annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V; }>>): <I, R>(schema: SchemaClass<A, I, R>) => SchemaClass<Simplify<A & { readonly [k in K]: V; }>, I, R>; <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(schema: Schema<A, I, R>, key: K, value: V, annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V; }>>): SchemaClass<Simplify<A & { readonly [k in K]: V; }>, I, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4087"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "annotations",
    "description": "Merges a set of new annotations with existing ones, potentially overwriting\nany duplicates.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const annotations: { <S extends Annotable.All>(annotations: Annotations.GenericSchema<Schema.Type<S>>): (self: S) => Annotable.Self<S>; <S extends Annotable.All>(self: S, annotations: Annotations.GenericSchema<Schema.Type<S>>): Annotable.Self<S>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4190"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "rename",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "renaming",
    "signature": "declare const rename: { <A, const M extends { readonly [K in keyof A]?: PropertyKey; } & { readonly [K in Exclude<keyof M, keyof A>]: never; }>(mapping: M): <I, R>(self: Schema<A, I, R>) => SchemaClass<Simplify<Rename<A, M>>, I, R>; <A, I, R, const M extends { readonly [K in keyof A]?: PropertyKey; } & { readonly [K in Exclude<keyof M, keyof A>]: never; }>(self: Schema<A, I, R>, mapping: M): SchemaClass<Simplify<Rename<A, M>>, I, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4211"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TrimmedSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const TrimmedSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4250"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "MaxLengthSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const MaxLengthSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4279"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "MinLengthSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const MinLengthSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4311"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LengthSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const LengthSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4345"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PatternSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const PatternSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4390"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "StartsWithSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const StartsWithSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4425"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "EndsWithSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const EndsWithSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4456"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "IncludesSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const IncludesSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4487"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LowercasedSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const LowercasedSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4518"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "UppercasedSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const UppercasedSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4551"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "CapitalizedSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const CapitalizedSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4584"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "UncapitalizedSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const UncapitalizedSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4617"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "UUIDSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const UUIDSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4865"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ULIDSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const ULIDSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4894"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "FiniteSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const FiniteSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4966"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "GreaterThanSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const GreaterThanSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4997"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "GreaterThanOrEqualToSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const GreaterThanOrEqualToSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5030"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "MultipleOfSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const MultipleOfSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5063"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "IntSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const IntSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5090"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LessThanSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const LessThanSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5121"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LessThanOrEqualToSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const LessThanOrEqualToSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5152"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BetweenSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const BetweenSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5185"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonNaNSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const NonNaNSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5219"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "JsonNumberSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const JsonNumberSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5399"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "GreaterThanBigIntSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const GreaterThanBigIntSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5481"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "GreaterThanOrEqualToBigIntSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const GreaterThanOrEqualToBigIntSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5512"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LessThanBigIntSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const LessThanBigIntSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5545"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LessThanOrEqualToBigIntSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const LessThanOrEqualToBigIntSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5576"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BetweenBigIntSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const BetweenBigIntSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5607"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PositiveBigIntFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "declare const PositiveBigIntFromSelf: filter<Schema<bigint, bigint, never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5722"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PositiveBigInt",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "declare const PositiveBigInt: filter<Schema<bigint, string, never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5730"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NegativeBigIntFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "declare const NegativeBigIntFromSelf: filter<Schema<bigint, bigint, never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5738"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NegativeBigInt",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "declare const NegativeBigInt: filter<Schema<bigint, string, never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5746"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonPositiveBigIntFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "declare const NonPositiveBigIntFromSelf: filter<Schema<bigint, bigint, never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5754"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonPositiveBigInt",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "declare const NonPositiveBigInt: filter<Schema<bigint, string, never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5762"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonNegativeBigIntFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "declare const NonNegativeBigIntFromSelf: filter<Schema<bigint, bigint, never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5770"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonNegativeBigInt",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "declare const NonNegativeBigInt: filter<Schema<bigint, string, never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5778"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonNegativeInt",
    "description": "A non-negative integer. +Infinity is excluded.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.10",
    "category": "number constructors",
    "signature": "declare const NonNegativeInt: refine<number, typeof NonNegative>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5935"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LessThanDurationSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const LessThanDurationSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6066"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LessThanOrEqualToDurationSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const LessThanOrEqualToDurationSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6091"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "GreaterThanDurationSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const GreaterThanDurationSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6118"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "GreaterThanOrEqualToDurationSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const GreaterThanOrEqualToDurationSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6143"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BetweenDurationSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const BetweenDurationSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6170"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Uint8ArrayFromBase64",
    "description": "Decodes a base64 (RFC4648) encoded string into a `Uint8Array`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Uint8Array transformations",
    "signature": "declare const Uint8ArrayFromBase64: Schema<Uint8Array<ArrayBufferLike>, string, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6265"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Uint8ArrayFromBase64Url",
    "description": "Decodes a base64 (URL) encoded string into a `Uint8Array`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Uint8Array transformations",
    "signature": "declare const Uint8ArrayFromBase64Url: Schema<Uint8Array<ArrayBufferLike>, string, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6277"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Uint8ArrayFromHex",
    "description": "Decodes a hex encoded string into a `Uint8Array`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Uint8Array transformations",
    "signature": "declare const Uint8ArrayFromHex: Schema<Uint8Array<ArrayBufferLike>, string, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6289"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "StringFromBase64",
    "description": "Decodes a base64 (RFC4648) encoded string into a UTF-8 string.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "declare const StringFromBase64: Schema<string, string, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6322"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "StringFromBase64Url",
    "description": "Decodes a base64 (URL) encoded string into a UTF-8 string.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "declare const StringFromBase64Url: Schema<string, string, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6334"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "StringFromHex",
    "description": "Decodes a hex encoded string into a UTF-8 string.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "declare const StringFromHex: Schema<string, string, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6346"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "StringFromUriComponent",
    "description": "Decodes a URI component encoded string into a UTF-8 string.\nCan be used to store data in a URL.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Schema } from \"effect\"\n\nconst PaginationSchema = Schema.Struct({\n  maxItemPerPage: Schema.Number,\n  page: Schema.Number\n})\n\nconst UrlSchema = Schema.compose(Schema.StringFromUriComponent, Schema.parseJson(PaginationSchema))\n\nconsole.log(Schema.encodeSync(UrlSchema)({ maxItemPerPage: 10, page: 1 }))\n// Output: %7B%22maxItemPerPage%22%3A10%2C%22page%22%3A1%7D\n```"
    ],
    "since": "3.12.0",
    "category": "string transformations",
    "signature": "declare const StringFromUriComponent: transformOrFail<SchemaClass<string, string, never>, typeof String$, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6374"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "MinItemsSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const MinItemsSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6398"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "MaxItemsSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const MaxItemsSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6440"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ItemsCountSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const ItemsCountSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6479"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "headOrElse",
    "description": "Retrieves the first element of a `ReadonlyArray`.\n\nIf the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyArray transformations",
    "signature": "declare const headOrElse: { <S extends Schema.Any, A extends ReadonlyArray<unknown>>(fallback?: LazyArg<A[number]>): (self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, SchemaClass<A[number]>>; <S extends Schema.Any, A extends ReadonlyArray<unknown>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>, fallback?: LazyArg<A[number]>): transform<S, SchemaClass<A[number]>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6574"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ValidDateSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const ValidDateSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6610"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LessThanDateSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const LessThanDateSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6638"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LessThanOrEqualToDateSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const LessThanOrEqualToDateSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6663"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "GreaterThanDateSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const GreaterThanDateSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6690"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "GreaterThanOrEqualToDateSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const GreaterThanOrEqualToDateSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6715"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BetweenDateSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const BetweenDateSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6742"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DateFromSelfSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.11.8",
    "category": "schema id",
    "signature": "declare const DateFromSelfSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6768"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "GreaterThanBigDecimalSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const GreaterThanBigDecimalSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7946"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "GreaterThanOrEqualToBigDecimalSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const GreaterThanOrEqualToBigDecimalSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7971"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LessThanBigDecimalSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const LessThanBigDecimalSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7998"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LessThanOrEqualToBigDecimalSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const LessThanOrEqualToBigDecimalSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8023"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PositiveBigDecimalSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const PositiveBigDecimalSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8050"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PositiveBigDecimalFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal constructors",
    "signature": "declare const PositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal, bigDecimal_.BigDecimal, never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8074"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonNegativeBigDecimalSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const NonNegativeBigDecimalSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8082"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonNegativeBigDecimalFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal constructors",
    "signature": "declare const NonNegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal, bigDecimal_.BigDecimal, never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8106"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NegativeBigDecimalSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const NegativeBigDecimalSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8114"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NegativeBigDecimalFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal constructors",
    "signature": "declare const NegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal, bigDecimal_.BigDecimal, never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8138"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonPositiveBigDecimalSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const NonPositiveBigDecimalSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8146"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonPositiveBigDecimalFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal constructors",
    "signature": "declare const NonPositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal, bigDecimal_.BigDecimal, never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8170"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BetweenBigDecimalSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const BetweenBigDecimalSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8178"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "symbolSerializable",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "declare const symbolSerializable: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10122"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "deserialize",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const deserialize: { (value: unknown): <A, I, R>(self: Serializable<A, I, R>) => Effect.Effect<A, ParseResult.ParseError, R>; <A, I, R>(self: Serializable<A, I, R>, value: unknown): Effect.Effect<A, ParseResult.ParseError, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10192"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "symbolWithResult",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "declare const symbolWithResult: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10205"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "serializeFailure",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const serializeFailure: { <FA>(value: FA): <SA, SI, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<FI, ParseResult.ParseError, R>; <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: FA): Effect.Effect<FI, ParseResult.ParseError, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10328"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "deserializeFailure",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const deserializeFailure: { (value: unknown): <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<FA, ParseResult.ParseError, R>; <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<FA, ParseResult.ParseError, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10343"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "serializeSuccess",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const serializeSuccess: { <SA>(value: SA): <SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<SI, ParseResult.ParseError, R>; <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: SA): Effect.Effect<SI, ParseResult.ParseError, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10360"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "deserializeSuccess",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const deserializeSuccess: { (value: unknown): <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<SA, ParseResult.ParseError, R>; <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<SA, ParseResult.ParseError, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10375"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "serializeExit",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const serializeExit: { <SA, FA>(value: exit_.Exit<SA, FA>): <SI, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R>; <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: exit_.Exit<SA, FA>): Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10392"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "deserializeExit",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const deserializeExit: { (value: unknown): <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R>; <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10409"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const make: <A, I = A, R = never>(ast: AST.AST) => SchemaClass<A, I, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L121"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "asSchema",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const asSchema: <S extends Schema.All>(schema: S) => Schema<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L303"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Literal",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const Literal: { <Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(...literals: Literals): Literal<Literals>; (): Never; <Literals extends ReadonlyArray<AST.LiteralValue>>(...literals: Literals): SchemaClass<Literals[number]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L708"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Union",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "declare const Union: { <Members extends AST.Members<Schema.All>>(...members: Members): Union<Members>; <Member extends Schema.All>(member: Member): Member; (): typeof Never; <Members extends ReadonlyArray<Schema.All>>(...members: Members): Schema<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1296"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Tuple",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const Tuple: { <const Elements extends TupleType.Elements, Rest extends array_.NonEmptyReadonlyArray<TupleType.Rest[number]>>(elements: Elements, ...rest: Rest): TupleType<Elements, Rest>; <Fst extends Schema.Any, Snd extends Schema.Any>(fst: Fst, snd: Snd): Tuple2<Fst, Snd>; <Elements extends TupleType.Elements>(...elements: Elements): Tuple<Elements>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1555"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ArrayEnsure",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const ArrayEnsure: <Value extends Schema.Any>(value: Value) => ArrayEnsure<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1642"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonEmptyArrayEnsure",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const NonEmptyArrayEnsure: <Value extends Schema.Any>(value: Value) => NonEmptyArrayEnsure<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1662"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Struct",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const Struct: { <Fields extends Struct.Fields, const Records extends IndexSignature.NonEmptyRecords>(fields: Fields, ...records: Records): TypeLiteral<Fields, Records>; <Fields extends Struct.Fields>(fields: Fields): Struct<Fields>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2942"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "filter",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "filtering",
    "signature": "declare const filter: { <C extends A, B extends A, A = C>(refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B, annotations?: Annotations.Filter<C & B, C>): <I, R>(self: Schema<C, I, R>) => refine<C & B, Schema<A, I, R>>; <A, B extends A>(refinement: (a: A, options: ParseOptions, self: AST.Refinement) => a is B, annotations?: Annotations.Filter<B, A>): <I, R>(self: Schema<A, I, R>) => refine<B, Schema<A, I, R>>; <S extends Schema.Any>(predicate: (a: Types.NoInfer<Schema.Type<S>>, options: ParseOptions, self: AST.Refinement) => FilterReturnType, annotations?: Annotations.Filter<Types.NoInfer<Schema.Type<S>>>): (self: S) => filter<S>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3712"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "transformLiteral",
    "description": "Creates a new `Schema` which transforms literal values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport * as S from \"effect/Schema\"\n\nconst schema = S.transformLiteral(0, \"a\")\n\nassert.deepStrictEqual(S.decodeSync(schema)(0), \"a\")\n```"
    ],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const transformLiteral: <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(from: Encoded, to: Type) => transformLiteral<Type, Encoded>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4014"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "transformLiterals",
    "description": "Creates a new `Schema` which maps between corresponding literal values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport * as S from \"effect/Schema\"\n\nconst Animal = S.transformLiterals(\n  [0, \"cat\"],\n  [1, \"dog\"],\n  [2, \"cow\"]\n)\n\nassert.deepStrictEqual(S.decodeSync(Animal)(1), \"dog\")\n```"
    ],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const transformLiterals: { <const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(...pairs: A): Union<{ -readonly [I in keyof A]: transformLiteral<A[I][1], A[I][0]>; }>; <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(pairs: [Encoded, Type]): transformLiteral<Type, Encoded>; <const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(...pairs: A): Schema<A[number][1], A[number][0]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4054"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "parseNumber",
    "description": "Transforms a `string` into a `number` by parsing the string using the `parse`\nfunction of the `effect/Number` module.\n\nIt returns an error if the value can't be converted (for example when\nnon-numeric characters are provided).\n\nThe following special string values are supported: \"NaN\", \"Infinity\",\n\"-Infinity\".",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number transformations",
    "signature": "declare const parseNumber: <S extends Schema.Any, A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transformOrFail<S, typeof Number$>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5313"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Redacted",
    "description": "A transformation that transform a `Schema<A, I, R>` into a\n`RedactedFromSelf<A>`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Redacted transformations",
    "signature": "declare const Redacted: <Value extends Schema.Any>(value: Value) => Redacted<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5877"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "head",
    "description": "Get the first element of a `ReadonlyArray`, or `None` if the array is empty.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyArray transformations",
    "signature": "declare const head: <S extends Schema.Any, A extends ReadonlyArray<unknown>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, OptionFromSelf<SchemaClass<A[number]>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6528"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "headNonEmpty",
    "description": "Get the first element of a `NonEmptyReadonlyArray`.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "NonEmptyReadonlyArray transformations",
    "signature": "declare const headNonEmpty: <S extends Schema.Any, A extends array_.NonEmptyReadonlyArray<unknown>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, SchemaClass<A[number]>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6552"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Option",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Option transformations",
    "signature": "declare const Option: <Value extends Schema.Any>(value: Value) => Option<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7212"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "OptionFromNullOr",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Option transformations",
    "signature": "declare const OptionFromNullOr: <Value extends Schema.Any>(value: Value) => OptionFromNullOr<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7242"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "OptionFromNullishOr",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Option transformations",
    "signature": "declare const OptionFromNullishOr: <Value extends Schema.Any>(value: Value, onNoneEncoding: null | undefined) => OptionFromNullishOr<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7262"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "OptionFromUndefinedOr",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Option transformations",
    "signature": "declare const OptionFromUndefinedOr: <Value extends Schema.Any>(value: Value) => OptionFromUndefinedOr<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7291"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ReadonlyMap",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyMap transformations",
    "signature": "declare const ReadonlyMap: <K extends Schema.Any, V extends Schema.Any>({ key, value }: { readonly key: K; readonly value: V; }) => ReadonlyMap$<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7666"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ReadonlySet",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlySet transformations",
    "signature": "declare const ReadonlySet: <Value extends Schema.Any>(value: Value) => ReadonlySet$<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7844"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Chunk",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Chunk transformations",
    "signature": "declare const Chunk: <Value extends Schema.Any>(value: Value) => Chunk<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8288"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonEmptyChunk",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Chunk transformations",
    "signature": "declare const NonEmptyChunk: <Value extends Schema.Any>(value: Value) => NonEmptyChunk<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8359"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "HashSet",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "HashSet transformations",
    "signature": "declare const HashSet: <Value extends Schema.Any>(value: Value) => HashSet<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9772"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "List",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "List transformations",
    "signature": "declare const List: <Value extends Schema.Any>(value: Value) => List<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9957"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "SortedSet",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "SortedSet transformations",
    "signature": "declare const SortedSet: <Value extends Schema.Any>(value: Value, ordA: Order.Order<Schema.Type<Value>>) => SortedSet<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10047"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "standardSchemaV1",
    "description": "Returns a \"Standard Schema\" object conforming to the [Standard Schema\nv1](https://standardschema.dev/) specification.\n\nThis function creates a schema whose `validate` method attempts to decode and\nvalidate the provided input synchronously. If the underlying `Schema`\nincludes any asynchronous components (e.g., asynchronous message resolutions\nor checks), then validation will necessarily return a `Promise` instead.\n\nAny detected defects will be reported via a single issue containing no\n`path`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Schema } from \"effect\"\n\nconst schema = Schema.Struct({\n  name: Schema.String\n})\n\n//       StandardSchemaV1<{ readonly name: string; }>\n//      \nconst standardSchema = Schema.standardSchemaV1(schema)\n```"
    ],
    "since": "3.13.0",
    "category": "Standard Schema",
    "signature": "declare const standardSchemaV1: <A, I>(schema: Schema<A, I, never>, overrideOptions?: AST.ParseOptions) => StandardSchemaV1<I, A> & SchemaClass<A, I, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L195"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "format",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "formatting",
    "signature": "declare const format: <S extends Schema.All>(schema: S) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L313"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "encodedSchema",
    "description": "The `encodedSchema` function allows you to extract the `Encoded` portion of a\nschema, creating a new schema that conforms to the properties defined in the\noriginal schema without retaining any refinements or transformations that\nwere applied previously.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const encodedSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<I>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L394"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "encodedBoundSchema",
    "description": "The `encodedBoundSchema` function is similar to `encodedSchema` but preserves\nthe refinements up to the first transformation point in the original schema.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const encodedBoundSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<I>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L402"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "typeSchema",
    "description": "The `typeSchema` function allows you to extract the `Type` portion of a\nschema, creating a new schema that conforms to the properties defined in the\noriginal schema without considering the initial encoding or transformation\nprocesses.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const typeSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L413"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "encodeUnknown",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encodeUnknown: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L494"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "encodeUnknownEither",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encodeUnknownEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L507"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "encodeUnknownPromise",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const encodeUnknownPromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Promise<I>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L520"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "decodeUnknown",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decodeUnknown: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L559"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "decodeUnknownEither",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decodeUnknownEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L572"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "decodeUnknownPromise",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "declare const decodeUnknownPromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Promise<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L585"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "validate",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": "declare const validate: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L624"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "validateEither",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": "declare const validateEither: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L637"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "validatePromise",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": "declare const validatePromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Promise<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L650"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "isSchema",
    "description": "Tests if a value is a `Schema`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isSchema: (u: unknown) => u is Schema.Any",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L664"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "pickLiteral",
    "description": "Creates a new `Schema` from a literal schema.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Either, Schema } from \"effect\"\n\nconst schema = Schema.Literal(\"a\", \"b\", \"c\").pipe(Schema.pickLiteral(\"a\", \"b\"))\n\nassert.deepStrictEqual(Schema.decodeSync(schema)(\"a\"), \"a\")\nassert.deepStrictEqual(Schema.decodeSync(schema)(\"b\"), \"b\")\nassert.strictEqual(Either.isLeft(Schema.decodeUnknownEither(schema)(\"c\")), true)\n```"
    ],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const pickLiteral: <A extends AST.LiteralValue, L extends array_.NonEmptyReadonlyArray<A>>(...literals: L) => <I, R>(_schema: Schema<A, I, R>) => Literal<[...L]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L732"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "UniqueSymbolFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const UniqueSymbolFromSelf: <S extends symbol>(symbol: S) => SchemaClass<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L740"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Enums",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const Enums: <A extends EnumsDefinition>(enums: A) => Enums<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L777"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TemplateLiteral",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "template literal",
    "signature": "declare const TemplateLiteral: <Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParameter>>(...[head, ...tail]: Params) => TemplateLiteral<GetTemplateLiteralType<Params>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L802"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TemplateLiteralParser",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "template literal",
    "signature": "declare const TemplateLiteralParser: <Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>(...params: Params) => TemplateLiteralParser<Params>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L921"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "fromBrand",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const fromBrand: <C extends Brand<string | symbol>, A extends Brand.Unbranded<C>>(constructor: Brand.Constructor<C>, annotations?: Annotations.Filter<C, A>) => <I, R>(self: Schema<A, I, R>) => BrandSchema<A & C, I, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1111"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "instanceOf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const instanceOf: <A extends abstract new (...args: any) => any>(constructor: A, annotations?: Annotations.Schema<InstanceType<A>>) => instanceOf<InstanceType<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1152"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NullOr",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "declare const NullOr: <S extends Schema.All>(self: S) => NullOr<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1318"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "UndefinedOr",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "declare const UndefinedOr: <S extends Schema.All>(self: S) => UndefinedOr<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1332"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NullishOr",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "declare const NullishOr: <S extends Schema.All>(self: S) => NullishOr<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1346"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "keyof",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "declare const keyof: <A, I, R>(self: Schema<A, I, R>) => SchemaClass<keyof A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1352"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "element",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const element: <S extends Schema.Any>(self: S) => Element<S, \"\">",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1387"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "optionalElement",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const optionalElement: <S extends Schema.Any>(self: S) => Element<S, \"?\">",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1393"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonEmptyArray",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const NonEmptyArray: <Value extends Schema.Any>(value: Value) => NonEmptyArray<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1627"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "isPropertySignature",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isPropertySignature: (u: unknown) => u is PropertySignature.All",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1862"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "makePropertySignature",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare const makePropertySignature: <TypeToken extends PropertySignature.Token, Type, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, HasDefault extends boolean = false, R = never>(ast: PropertySignature.AST) => PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1929"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "propertySignature",
    "description": "Lifts a `Schema` into a `PropertySignature`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare const propertySignature: <S extends Schema.All>(self: S) => propertySignature<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1980"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "optionalToRequired",
    "description": "Converts an optional property to a required one through a transformation `Option -> Type`.\n\n- `decode`: `none` as argument means the value is missing in the input.\n- `encode`: `none` as return value means the value will be missing in the output.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare const optionalToRequired: <FA, FI, FR, TA, TI, TR>(from: Schema<FA, FI, FR>, to: Schema<TA, TI, TR>, options: { readonly decode: (o: option_.Option<FA>) => TI; readonly encode: (ti: TI) => option_.Option<FA>; }) => PropertySignature<\":\", TA, never, \"?:\", FI, false, FR | TR>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2252"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "requiredToOptional",
    "description": "Converts an optional property to a required one through a transformation `Type -> Option`.\n\n- `decode`: `none` as return value means the value will be missing in the output.\n- `encode`: `none` as argument means the value is missing in the input.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare const requiredToOptional: <FA, FI, FR, TA, TI, TR>(from: Schema<FA, FI, FR>, to: Schema<TA, TI, TR>, options: { readonly decode: (fa: FA) => option_.Option<TI>; readonly encode: (o: option_.Option<TI>) => FA; }) => PropertySignature<\"?:\", TA, never, \":\", FI, false, FR | TR>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2278"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "optionalToOptional",
    "description": "Converts an optional property to another optional property through a transformation `Option -> Option`.\n\n- `decode`:\n  - `none` as argument means the value is missing in the input.\n  - `none` as return value means the value will be missing in the output.\n- `encode`:\n  - `none` as argument means the value is missing in the input.\n  - `none` as return value means the value will be missing in the output.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare const optionalToOptional: <FA, FI, FR, TA, TI, TR>(from: Schema<FA, FI, FR>, to: Schema<TA, TI, TR>, options: { readonly decode: (o: option_.Option<FA>) => option_.Option<TI>; readonly encode: (o: option_.Option<TI>) => option_.Option<FA>; }) => PropertySignature<\"?:\", TA, never, \"?:\", FI, false, FR | TR>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2308"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "optional",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "declare const optional: <S extends Schema.All>(self: S) => optional<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2543"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "tag",
    "description": "Returns a property signature that represents a tag.\nA tag is a literal value that is used to distinguish between different types of objects.\nThe tag is optional when using the `make` method.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Schema } from \"effect\"\n\nconst User = Schema.Struct({\n  _tag: Schema.tag(\"User\"),\n  name: Schema.String,\n  age: Schema.Number\n})\n\nassert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n```"
    ],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const tag: <Tag extends AST.LiteralValue>(tag: Tag) => tag<Tag>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2978"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TaggedStruct",
    "description": "A tagged struct is a struct that has a tag property that is used to distinguish between different types of objects.\n\nThe tag is optional when using the `make` method.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Schema } from \"effect\"\n\nconst User = Schema.TaggedStruct(\"User\", {\n  name: Schema.String,\n  age: Schema.Number\n})\n\nassert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })\n```"
    ],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const TaggedStruct: <Tag extends AST.LiteralValue, Fields extends Struct.Fields>(value: Tag, fields: Fields) => TaggedStruct<Tag, Fields>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3010"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Record",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const Record: <K extends Schema.All, V extends Schema.All>(options: { readonly key: K; readonly value: V; }) => Record$<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3061"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "pick",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "struct transformations",
    "signature": "declare const pick: <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) => <R>(self: Schema<A, I, R>) => SchemaClass<Simplify<Pick<A, Keys[number]>>, Simplify<Pick<I, Keys[number]>>, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3069"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "omit",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "struct transformations",
    "signature": "declare const omit: <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) => <R>(self: Schema<A, I, R>) => SchemaClass<Simplify<Omit<A, Keys[number]>>, Simplify<Omit<I, Keys[number]>>, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3078"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "brand",
    "description": "Returns a nominal branded schema by applying a brand to a given schema.\n\n```\nSchema<A> + B -> Schema<A & Brand<B>>\n```",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as Schema from \"effect/Schema\"\n\nconst Int = Schema.Number.pipe(Schema.int(), Schema.brand(\"Int\"))\ntype Int = Schema.Schema.Type<typeof Int> // number & Brand<\"Int\">\n```"
    ],
    "since": "3.10.0",
    "category": "branding",
    "signature": "declare const brand: <S extends Schema.AnyNoContext, B extends string | symbol>(brand: B, annotations?: Annotations.Schema<Schema.Type<S> & Brand<B>>) => (self: S) => brand<S, B>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3198"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "partial",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "declare const partial: <A, I, R>(self: Schema<A, I, R>) => SchemaClass<{ [K in keyof A]?: A[K] | undefined; }, { [K in keyof I]?: I[K] | undefined; }, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3221"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "required",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "declare const required: <A, I, R>(self: Schema<A, I, R>) => SchemaClass<{ [K in keyof A]-?: A[K]; }, { [K in keyof I]-?: I[K]; }, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3247"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "mutable",
    "description": "Creates a new schema with shallow mutability applied to its properties.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "declare const mutable: <S extends Schema.Any>(schema: S) => mutable<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3270"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "suspend",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const suspend: <A, I, R>(f: () => Schema<A, I, R>) => suspend<A, I, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3573"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "trimmed",
    "description": "Verifies that a string contains no leading or trailing whitespaces.\n\nNote. This combinator does not make any transformations, it only validates.\nIf what you were looking for was a combinator to trim strings, then check out the `trim` combinator.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": "declare const trimmed: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4261"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "maxLength",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": "declare const maxLength: <S extends Schema.Any>(maxLength: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4291"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "minLength",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": "declare const minLength: <S extends Schema.Any>(minLength: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4323"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "length",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": "declare const length: <S extends Schema.Any>(length: number | { readonly min: number; readonly max: number; }, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4357"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "pattern",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": "declare const pattern: <S extends Schema.Any>(regex: RegExp, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4396"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "startsWith",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": "declare const startsWith: <S extends Schema.Any>(startsWith: string, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4431"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "endsWith",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": "declare const endsWith: <S extends Schema.Any>(endsWith: string, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4462"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "includes",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": "declare const includes: <S extends Schema.Any>(searchString: string, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4493"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "lowercased",
    "description": "Verifies that a string is lowercased.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": "declare const lowercased: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4526"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "uppercased",
    "description": "Verifies that a string is uppercased.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": "declare const uppercased: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4559"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "capitalized",
    "description": "Verifies that a string is capitalized.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": "declare const capitalized: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4592"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "uncapitalized",
    "description": "Verifies that a string is uncapitalized.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": "declare const uncapitalized: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4625"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "nonEmptyString",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": "declare const nonEmptyString: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4658"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "split",
    "description": "Returns a schema that allows splitting a string into an array of strings.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "declare const split: (separator: string) => transform<SchemaClass<string>, Array$<typeof String$>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4781"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "parseJson",
    "description": "The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\nfunctionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n\nYou can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n\nOptionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport * as Schema from \"effect/Schema\"\n\nassert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\nassert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })\n```"
    ],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "declare const parseJson: { <S extends Schema.Any>(schema: S, options?: ParseJsonOptions): transform<SchemaClass<unknown, string>, S>; (options?: ParseJsonOptions): SchemaClass<unknown, string>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4845"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "finite",
    "description": "Ensures that the provided value is a finite number (excluding NaN, +Infinity, and -Infinity).",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": "declare const finite: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4980"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "greaterThan",
    "description": "This filter checks whether the provided number is greater than the specified minimum.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": "declare const greaterThan: <S extends Schema.Any>(exclusiveMinimum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5011"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "greaterThanOrEqualTo",
    "description": "This filter checks whether the provided number is greater than or equal to the specified minimum.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": "declare const greaterThanOrEqualTo: <S extends Schema.Any>(minimum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5044"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "multipleOf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": "declare const multipleOf: <S extends Schema.Any>(divisor: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5069"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "int",
    "description": "Ensures that the provided value is an integer number (excluding NaN, +Infinity, and -Infinity).",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": "declare const int: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5104"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "lessThan",
    "description": "This filter checks whether the provided number is less than the specified maximum.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": "declare const lessThan: <S extends Schema.Any>(exclusiveMaximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5135"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "lessThanOrEqualTo",
    "description": "This schema checks whether the provided number is less than or equal to the specified maximum.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": "declare const lessThanOrEqualTo: <S extends Schema.Any>(maximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5166"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "between",
    "description": "This filter checks whether the provided number falls within the specified minimum and maximum values.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": "declare const between: <S extends Schema.Any>(minimum: number, maximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5199"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "nonNaN",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": "declare const nonNaN: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5231"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "positive",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": "declare const positive: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5247"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "negative",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": "declare const negative: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5256"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "nonPositive",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": "declare const nonPositive: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5265"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "nonNegative",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": "declare const nonNegative: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5274"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "clamp",
    "description": "Clamps a number between a minimum and a maximum value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number transformations",
    "signature": "declare const clamp: (minimum: number, maximum: number) => <S extends Schema.Any, A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5285"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "greaterThanBigInt",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": "declare const greaterThanBigInt: <S extends Schema.Any>(min: bigint, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5493"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "greaterThanOrEqualToBigInt",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": "declare const greaterThanOrEqualToBigInt: <S extends Schema.Any>(min: bigint, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5524"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "lessThanBigInt",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": "declare const lessThanBigInt: <S extends Schema.Any>(max: bigint, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5557"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "lessThanOrEqualToBigInt",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": "declare const lessThanOrEqualToBigInt: <S extends Schema.Any>(max: bigint, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5588"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "betweenBigInt",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": "declare const betweenBigInt: <S extends Schema.Any>(min: bigint, max: bigint, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5619"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "positiveBigInt",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": "declare const positiveBigInt: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5639"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "negativeBigInt",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": "declare const negativeBigInt: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5648"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "nonNegativeBigInt",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": "declare const nonNegativeBigInt: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5657"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "nonPositiveBigInt",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": "declare const nonPositiveBigInt: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5666"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "clampBigInt",
    "description": "Clamps a bigint between a minimum and a maximum value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint transformations",
    "signature": "declare const clampBigInt: (minimum: bigint, maximum: bigint) => <S extends Schema.Any, A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5677"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "RedactedFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Redacted constructors",
    "signature": "declare const RedactedFromSelf: <Value extends Schema.Any>(value: Value) => RedactedFromSelf<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5847"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "clampDuration",
    "description": "Clamps a `Duration` between a minimum and a maximum value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration transformations",
    "signature": "declare const clampDuration: (minimum: duration_.DurationInput, maximum: duration_.DurationInput) => <S extends Schema.Any, A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6047"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "lessThanDuration",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration filters",
    "signature": "declare const lessThanDuration: <S extends Schema.Any>(max: duration_.DurationInput, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6072"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "lessThanOrEqualToDuration",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration filters",
    "signature": "declare const lessThanOrEqualToDuration: <S extends Schema.Any>(max: duration_.DurationInput, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6099"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "greaterThanDuration",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration filters",
    "signature": "declare const greaterThanDuration: <S extends Schema.Any>(min: duration_.DurationInput, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6124"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "greaterThanOrEqualToDuration",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration filters",
    "signature": "declare const greaterThanOrEqualToDuration: <S extends Schema.Any>(min: duration_.DurationInput, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6151"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "betweenDuration",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration filters",
    "signature": "declare const betweenDuration: <S extends Schema.Any>(minimum: duration_.DurationInput, maximum: duration_.DurationInput, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6176"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "minItems",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyArray filters",
    "signature": "declare const minItems: <S extends Schema.Any>(n: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends ReadonlyArray<any>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6410"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "maxItems",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyArray filters",
    "signature": "declare const maxItems: <S extends Schema.Any>(n: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends ReadonlyArray<any>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6452"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "itemsCount",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyArray filters",
    "signature": "declare const itemsCount: <S extends Schema.Any>(n: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends ReadonlyArray<any>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6491"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "getNumberIndexedAccess",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyArray transformations",
    "signature": "declare const getNumberIndexedAccess: <A extends ReadonlyArray<any>, I extends ReadonlyArray<any>, R>(self: Schema<A, I, R>) => SchemaClass<A[number], I[number], R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6518"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "validDate",
    "description": "Defines a filter that specifically rejects invalid dates, such as `new\nDate(\"Invalid Date\")`. This filter ensures that only properly formatted and\nvalid date objects are accepted, enhancing data integrity by preventing\nerroneous date values from being processed.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date filters",
    "signature": "declare const validDate: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6621"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "lessThanDate",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date filters",
    "signature": "declare const lessThanDate: <S extends Schema.Any>(max: Date, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6644"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "lessThanOrEqualToDate",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date filters",
    "signature": "declare const lessThanOrEqualToDate: <S extends Schema.Any>(max: Date, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6671"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "greaterThanDate",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date filters",
    "signature": "declare const greaterThanDate: <S extends Schema.Any>(min: Date, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6696"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "greaterThanOrEqualToDate",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date filters",
    "signature": "declare const greaterThanOrEqualToDate: <S extends Schema.Any>(min: Date, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6723"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "betweenDate",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date filters",
    "signature": "declare const betweenDate: <S extends Schema.Any>(min: Date, max: Date, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6748"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "OptionFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Option transformations",
    "signature": "declare const OptionFromSelf: <Value extends Schema.Any>(value: Value) => OptionFromSelf<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7169"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "EitherFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Either transformations",
    "signature": "declare const EitherFromSelf: <R extends Schema.All, L extends Schema.All>({ left, right }: { readonly left: L; readonly right: R; }) => EitherFromSelf<R, L>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7417"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Either",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Either transformations",
    "signature": "declare const Either: <R extends Schema.All, L extends Schema.All>({ left, right }: { readonly left: L; readonly right: R; }) => Either<R, L>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7469"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "EitherFromUnion",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as Schema from \"effect/Schema\"\n\n// Schema<string | number, Either<string, number>>\nSchema.EitherFromUnion({ left: Schema.String, right: Schema.Number })\n```"
    ],
    "since": "3.10.0",
    "category": "Either transformations",
    "signature": "declare const EitherFromUnion: <Right extends Schema.All, Left extends Schema.All>({ left, right }: { readonly left: Left; readonly right: Right; }) => EitherFromUnion<Right, Left>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7517"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ReadonlyMapFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyMap",
    "signature": "declare const ReadonlyMapFromSelf: <K extends Schema.Any, V extends Schema.Any>({ key, value }: { readonly key: K; readonly value: V; }) => ReadonlyMapFromSelf<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7627"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "MapFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Map",
    "signature": "declare const MapFromSelf: <K extends Schema.Any, V extends Schema.Any>({ key, value }: { readonly key: K; readonly value: V; }) => MapFromSelf<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7649"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ReadonlyMapFromRecord",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyMap transformations",
    "signature": "declare const ReadonlyMapFromRecord: <KA, KR, VA, VI, VR>({ key, value }: { key: Schema<KA, string, KR>; value: Schema<VA, VI, VR>; }) => SchemaClass<ReadonlyMap<KA, VA>, { readonly [x: string]: VI; }, KR | VR>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7717"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "MapFromRecord",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Map transformations",
    "signature": "declare const MapFromRecord: <KA, KR, VA, VI, VR>({ key, value }: { key: Schema<KA, string, KR>; value: Schema<VA, VI, VR>; }) => SchemaClass<Map<KA, VA>, { readonly [x: string]: VI; }, KR | VR>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7737"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ReadonlySetFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlySet",
    "signature": "declare const ReadonlySetFromSelf: <Value extends Schema.Any>(value: Value) => ReadonlySetFromSelf<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7809"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "SetFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Set",
    "signature": "declare const SetFromSelf: <Value extends Schema.Any>(value: Value) => SetFromSelf<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7829"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "greaterThanBigDecimal",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": "declare const greaterThanBigDecimal: <S extends Schema.Any>(min: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7952"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "greaterThanOrEqualToBigDecimal",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": "declare const greaterThanOrEqualToBigDecimal: <S extends Schema.Any>(min: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7979"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "lessThanBigDecimal",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": "declare const lessThanBigDecimal: <S extends Schema.Any>(max: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8004"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "lessThanOrEqualToBigDecimal",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": "declare const lessThanOrEqualToBigDecimal: <S extends Schema.Any>(max: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8031"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "positiveBigDecimal",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": "declare const positiveBigDecimal: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8058"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "nonNegativeBigDecimal",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": "declare const nonNegativeBigDecimal: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8090"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "negativeBigDecimal",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": "declare const negativeBigDecimal: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8122"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "nonPositiveBigDecimal",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": "declare const nonPositiveBigDecimal: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8154"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "betweenBigDecimal",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": "declare const betweenBigDecimal: <S extends Schema.Any>(minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8184"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "clampBigDecimal",
    "description": "Clamps a `BigDecimal` between a minimum and a maximum value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal transformations",
    "signature": "declare const clampBigDecimal: (minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal) => <S extends Schema.Any, A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8209"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ChunkFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Chunk",
    "signature": "declare const ChunkFromSelf: <Value extends Schema.Any>(value: Value) => ChunkFromSelf<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8260"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonEmptyChunkFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Chunk",
    "signature": "declare const NonEmptyChunkFromSelf: <Value extends Schema.Any>(value: Value) => NonEmptyChunkFromSelf<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8331"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DataFromSelf",
    "description": "Type and Encoded must extend `Readonly<Record<string, any>> |\nReadonlyArray<any>` to be compatible with this API.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Data transformations",
    "signature": "declare const DataFromSelf: <S extends Schema.Any, A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>, I extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(value: S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>>) => DataFromSelf<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8412"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Data",
    "description": "Type and Encoded must extend `Readonly<Record<string, any>> |\nReadonlyArray<any>` to be compatible with this API.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Data transformations",
    "signature": "declare const Data: <S extends Schema.Any, A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>, I extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(value: S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>>) => Data<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8446"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Class",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Schema } from \"effect\"\n\nclass MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n someField: Schema.String\n}) {\n someMethod() {\n   return this.someField + \"bar\"\n }\n}\n```"
    ],
    "since": "3.10.0",
    "category": "classes",
    "signature": "declare const Class: <Self = never>(identifier: string) => <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>, annotations?: ClassAnnotations<Self, Simplify<Struct.Type<Fields>>>) => [Self] extends [never] ? MissingSelfGeneric<\"Class\"> : Class<Self, Fields, Struct.Encoded<Fields>, Struct.Context<Fields>, Struct.Constructor<Fields>, {}, {}>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8690"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TaggedClass",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Schema } from \"effect\"\n\nclass MyClass extends Schema.TaggedClass<MyClass>(\"MyClass\")(\"MyClass\", {\n a: Schema.String\n}) {}\n```"
    ],
    "since": "3.10.0",
    "category": "classes",
    "signature": "declare const TaggedClass: <Self = never>(identifier?: string) => <Tag extends string, Fields extends Struct.Fields>(tag: Tag, fieldsOr: Fields | HasFields<Fields>, annotations?: ClassAnnotations<Self, Simplify<Struct.Type<{ readonly _tag: tag<Tag>; } & Fields>>>) => [Self] extends [never] ? MissingSelfGeneric<\"TaggedClass\", `\"Tag\", `> : TaggedClass<Self, Tag, { readonly _tag: tag<Tag>; } & Fields>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8748"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TaggedError",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Schema } from \"effect\"\n\nclass MyError extends Schema.TaggedError<MyError>(\"MyError\")(\n  \"MyError\",\n  {\n    module: Schema.String,\n    method: Schema.String,\n    description: Schema.String\n  }\n) {\n  get message(): string {\n    return `${this.module}.${this.method}: ${this.description}`\n  }\n}\n```"
    ],
    "since": "3.10.0",
    "category": "classes",
    "signature": "declare const TaggedError: <Self = never>(identifier?: string) => <Tag extends string, Fields extends Struct.Fields>(tag: Tag, fieldsOr: Fields | HasFields<Fields>, annotations?: ClassAnnotations<Self, Simplify<Struct.Type<{ readonly _tag: tag<Tag>; } & Fields>>>) => [Self] extends [never] ? MissingSelfGeneric<\"TaggedError\", `\"Tag\", `> : TaggedErrorClass<Self, Tag, { readonly _tag: tag<Tag>; } & Fields>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8811"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "CauseFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Cause transformations",
    "signature": "declare const CauseFromSelf: <E extends Schema.All, D extends Schema.All>({ defect, error }: { readonly error: E; readonly defect: D; }) => CauseFromSelf<E, D>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9379"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Cause",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Cause transformations",
    "signature": "declare const Cause: <E extends Schema.All, D extends Schema.All>({ defect, error }: { readonly error: E; readonly defect: D; }) => Cause<E, D>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9458"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ExitFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Exit transformations",
    "signature": "declare const ExitFromSelf: <A extends Schema.All, E extends Schema.All, D extends Schema.All>({ defect, failure, success }: { readonly failure: E; readonly success: A; readonly defect: D; }) => ExitFromSelf<A, E, D>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9618"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Exit",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Exit transformations",
    "signature": "declare const Exit: <A extends Schema.All, E extends Schema.All, D extends Schema.All>({ defect, failure, success }: { readonly failure: E; readonly success: A; readonly defect: D; }) => Exit<A, E, D>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9674"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "HashSetFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "HashSet transformations",
    "signature": "declare const HashSetFromSelf: <Value extends Schema.Any>(value: Value) => HashSetFromSelf<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9742"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "HashMapFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "HashMap transformations",
    "signature": "declare const HashMapFromSelf: <K extends Schema.Any, V extends Schema.Any>({ key, value }: { readonly key: K; readonly value: V; }) => HashMapFromSelf<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9840"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "HashMap",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "HashMap transformations",
    "signature": "declare const HashMap: <K extends Schema.Any, V extends Schema.Any>({ key, value }: { readonly key: K; readonly value: V; }) => HashMap<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9871"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ListFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "List transformations",
    "signature": "declare const ListFromSelf: <Value extends Schema.Any>(value: Value) => ListFromSelf<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9927"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "SortedSetFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "SortedSet transformations",
    "signature": "declare const SortedSetFromSelf: <Value extends Schema.Any>(value: Value, ordA: Order.Order<Schema.Type<Value>>, ordI: Order.Order<Schema.Encoded<Value>>) => SortedSetFromSelf<Value>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10015"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Config",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Config validations",
    "signature": "declare const Config: <A, I extends string>(name: string, schema: Schema<A, I>) => config_.Config<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10103"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "asSerializable",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const asSerializable: <S extends Serializable.All>(serializable: S) => Serializable<Serializable.Type<S>, Serializable.Encoded<S>, Serializable.Context<S>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10171"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "serializableSchema",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "accessor",
    "signature": "declare const serializableSchema: <A, I, R>(self: Serializable<A, I, R>) => Schema<A, I, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10179"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "serialize",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "declare const serialize: <A, I, R>(self: Serializable<A, I, R>) => Effect.Effect<I, ParseResult.ParseError, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10185"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "asWithResult",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const asWithResult: <WR extends WithResult.All>(withExit: WR) => WithResult<WithResult.Success<WR>, WithResult.SuccessEncoded<WR>, WithResult.Failure<WR>, WithResult.FailureEncoded<WR>, WithResult.Context<WR>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10266"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "failureSchema",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "accessor",
    "signature": "declare const failureSchema: <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Schema<FA, FI, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10280"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "successSchema",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "accessor",
    "signature": "declare const successSchema: <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Schema<SA, SI, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10287"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "exitSchema",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "accessor",
    "signature": "declare const exitSchema: <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Schema<exit_.Exit<SA, FA>, ExitEncoded<SI, FI, unknown>, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10299"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "asSerializableWithResult",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const asSerializableWithResult: <SWR extends SerializableWithResult.All>(procedure: SWR) => SerializableWithResult<Serializable.Type<SWR>, Serializable.Encoded<SWR>, Serializable.Context<SWR>, WithResult.Success<SWR>, WithResult.SuccessEncoded<SWR>, WithResult.Failure<SWR>, WithResult.FailureEncoded<SWR>, WithResult.Context<SWR>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10475"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TaggedRequest",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Schema } from \"effect\"\n\nclass MyRequest extends Schema.TaggedRequest<MyRequest>(\"MyRequest\")(\"MyRequest\", {\n failure: Schema.String,\n success: Schema.Number,\n payload: { id: Schema.String }\n}) {}\n```"
    ],
    "since": "3.10.0",
    "category": "classes",
    "signature": "declare const TaggedRequest: <Self = never>(identifier?: string) => <Tag extends string, Payload extends Struct.Fields, Success extends Schema.All, Failure extends Schema.All>(tag: Tag, options: { failure: Failure; success: Success; payload: Payload; }, annotations?: ClassAnnotations<Self, Simplify<Struct.Type<{ readonly _tag: tag<Tag>; } & Payload>>>) => [Self] extends [never] ? MissingSelfGeneric<\"TaggedRequest\", `\"Tag\", SuccessSchema, FailureSchema, `> : TaggedRequestClass<Self, Tag, { readonly _tag: tag<Tag>; } & Payload, Success, Failure>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10584"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "equivalence",
    "description": "Given a schema `Schema<A, I, R>`, returns an `Equivalence` instance for `A`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Equivalence",
    "signature": "declare const equivalence: <A, I, R>(schema: Schema<A, I, R>) => Equivalence.Equivalence<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10637"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Schema",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface Schema<in out A, in out I = A, out R = never> extends Schema.Variance<A, I, R>, Pipeable {\n  readonly Type: A\n  readonly Encoded: I\n  readonly Context: R\n  readonly ast: AST.AST\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   */\n  annotations(annotations: Annotations.GenericSchema<A>): Schema<A, I, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L83"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Annotable",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export interface Annotable<Self extends Schema<A, I, R>, A, I = A, R = never> extends Schema<A, I, R> {\n  annotations(annotations: Annotations.GenericSchema<A>): Self\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L99"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "AnnotableClass",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export interface AnnotableClass<Self extends Schema<A, I, R>, A, I = A, R = never> extends Annotable<Self, A, I, R> {\n  new(_: never): Schema.Variance<A, I, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L107"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "SchemaClass",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface SchemaClass<A, I = A, R = never> extends AnnotableClass<SchemaClass<A, I, R>, A, I, R> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L115"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Literal",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>\n  extends AnnotableClass<Literal<Literals>, Literals[number]>\n{\n  readonly literals: Readonly<Literals>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L671"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Enums",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Enums<A extends EnumsDefinition> extends AnnotableClass<Enums<A>, A[keyof A]> {\n  readonly enums: A\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L746"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TemplateLiteral",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "API interface",
    "signature": "export interface TemplateLiteral<A> extends SchemaClass<A> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L794"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TemplateLiteralParser",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "API interface",
    "signature": "export interface TemplateLiteralParser<Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>\n  extends\n    Schema<\n      GetTemplateLiteralParserType<Params>,\n      GetTemplateLiteralParserEncoded<Params>,\n      Schema.Context<Params[number]>\n    >\n{\n  readonly params: Params\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L872"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "declare",
    "deprecated": false,
    "examples": [],
    "since": "3.13.3",
    "category": "api interface",
    "signature": "export interface declare<\n  A,\n  I = A,\n  P extends ReadonlyArray<Schema.All> = readonly [],\n  R = Schema.Context<P[number]>\n> extends AnnotableClass<declare<A, I, P, R>, A, I, R> {\n  readonly typeParameters: Readonly<P>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1022"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "AnnotableDeclare",
    "deprecated": false,
    "examples": [],
    "since": "3.13.3",
    "category": "api interface",
    "signature": "export interface AnnotableDeclare<\n  Self extends declare<A, I, P, R>,\n  A,\n  I = A,\n  P extends ReadonlyArray<Schema.All> = readonly [],\n  R = Schema.Context<P[number]>\n> extends declare<A, I, P, R> {\n  annotations(annotations: Annotations.Schema<A>): Self\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1035"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "instanceOf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface instanceOf<A> extends AnnotableDeclare<instanceOf<A>, A> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1146"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Union",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Union<Members extends ReadonlyArray<Schema.All>> extends\n  AnnotableClass<\n    Union<Members>,\n    Schema.Type<Members[number]>,\n    Schema.Encoded<Members[number]>,\n    Schema.Context<Members[number]>\n  >\n{\n  readonly members: Readonly<Members>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1255"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NullOr",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface NullOr<S extends Schema.All> extends Union<[S, typeof Null]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null>): NullOr<S>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1310"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "UndefinedOr",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface UndefinedOr<S extends Schema.All> extends Union<[S, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | undefined>): UndefinedOr<S>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1324"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NullishOr",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface NullishOr<S extends Schema.All> extends Union<[S, typeof Null, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null | undefined>): NullishOr<S>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1338"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Element",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "API interface",
    "signature": "export interface Element<S extends Schema.Any, Token extends Element.Token>\n  extends Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  readonly _Token: Token\n  readonly ast: AST.OptionalType\n  readonly from: S\n  annotations(annotations: Element.Annotations<Schema.Type<S>>): Element<S, Token>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1375"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TupleType",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface TupleType<Elements extends TupleType.Elements, Rest extends TupleType.Rest> extends\n  AnnotableClass<\n    TupleType<Elements, Rest>,\n    TupleType.Type<Elements, Rest>,\n    TupleType.Encoded<Elements, Rest>,\n    Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n  >\n{\n  readonly elements: Readonly<Elements>\n  readonly rest: Readonly<Rest>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1477"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Tuple",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Tuple<Elements extends TupleType.Elements> extends TupleType<Elements, []> {\n  annotations(annotations: Annotations.Schema<TupleType.Type<Elements, []>>): Tuple<Elements>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1525"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Tuple2",
    "deprecated": false,
    "examples": [],
    "since": "3.13.3",
    "category": "api interface",
    "signature": "export interface Tuple2<Fst extends Schema.Any, Snd extends Schema.Any> extends\n  AnnotableClass<\n    Tuple2<Fst, Snd>,\n    readonly [Schema.Type<Fst>, Schema.Type<Snd>],\n    readonly [Schema.Encoded<Fst>, Schema.Encoded<Snd>],\n    Schema.Context<Fst> | Schema.Context<Snd>\n  >\n{\n  readonly elements: readonly [Fst, Snd]\n  readonly rest: readonly []\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1533"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Array$",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Array$<Value extends Schema.Any> extends TupleType<[], [Value]> {\n  readonly value: Value\n  annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>): Array$<Value>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1565"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonEmptyArray",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface NonEmptyArray<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyArray<Value>,\n    array_.NonEmptyReadonlyArray<Schema.Type<Value>>,\n    array_.NonEmptyReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{\n  readonly elements: readonly [Value]\n  readonly rest: readonly [Value]\n  readonly value: Value\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1597"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ArrayEnsure",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ArrayEnsure<Value extends Schema.Any>\n  extends transform<Union<[Value, Array$<Value>]>, Array$<SchemaClass<Schema.Type<Value>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1634"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonEmptyArrayEnsure",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface NonEmptyArrayEnsure<Value extends Schema.Any>\n  extends transform<Union<[Value, NonEmptyArray<Value>]>, NonEmptyArray<SchemaClass<Schema.Type<Value>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1654"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PropertySignature",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "export interface PropertySignature<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> extends Schema.Variance<Type, Encoded, R>, Pipeable {\n  readonly [PropertySignatureTypeId]: null\n  readonly _TypeToken: TypeToken\n  readonly _EncodedToken: EncodedToken\n  readonly _HasDefault: HasDefault\n  readonly _Key: Key\n  readonly ast: PropertySignature.AST\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1869"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "propertySignature",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "API interface",
    "signature": "export interface propertySignature<S extends Schema.All>\n  extends PropertySignature<\":\", Schema.Type<S>, never, \":\", Schema.Encoded<S>, false, Schema.Context<S>>\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S>>): propertySignature<S>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1967"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "optional",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface optional<S extends Schema.All> extends\n  PropertySignature<\n    \"?:\",\n    Schema.Type<S> | undefined,\n    never,\n    \"?:\",\n    Schema.Encoded<S> | undefined,\n    false,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S> | undefined>): optional<S>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2368"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "optionalWith",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface optionalWith<S extends Schema.All, Options> extends\n  PropertySignature<\n    Types.Has<Options, \"as\" | \"default\"> extends true ? \":\" : \"?:\",\n    | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n    | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined),\n    never,\n    \"?:\",\n    | Schema.Encoded<S>\n    | (Types.Has<Options, \"nullable\"> extends true ? null : never)\n    | (Types.Has<Options, \"exact\"> extends true ? never : undefined),\n    Types.Has<Options, \"default\">,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(\n    annotations: PropertySignature.Annotations<\n      | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n      | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined)\n    >\n  ): optionalWith<S, Options>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2387"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TypeLiteral",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface TypeLiteral<\n  Fields extends Struct.Fields,\n  Records extends IndexSignature.Records\n> extends\n  AnnotableClass<\n    TypeLiteral<Fields, Records>,\n    Simplify<TypeLiteral.Type<Fields, Records>>,\n    Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >\n{\n  readonly fields: Readonly<Fields>\n  readonly records: Readonly<Records>\n  annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>\n  ): TypeLiteral<Fields, Records>\n  make(\n    props: RequiredKeys<TypeLiteral.Constructor<Fields, Records>> extends never\n      ? void | Simplify<TypeLiteral.Constructor<Fields, Records>>\n      : Simplify<TypeLiteral.Constructor<Fields, Records>>,\n    options?: MakeOptions\n  ): Simplify<TypeLiteral.Type<Fields, Records>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2745"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Struct",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Struct<Fields extends Struct.Fields> extends\n  AnnotableClass<\n    Struct<Fields>,\n    Simplify<Struct.Type<Fields>>,\n    Simplify<Struct.Encoded<Fields>>,\n    Struct.Context<Fields>\n  >\n{\n  readonly fields: Readonly<Fields>\n  readonly records: readonly []\n  make(\n    props: RequiredKeys<Struct.Constructor<Fields>> extends never ? void | Simplify<Struct.Constructor<Fields>>\n      : Simplify<Struct.Constructor<Fields>>,\n    options?: MakeOptions\n  ): Simplify<Struct.Type<Fields>>\n\n  annotations(annotations: Annotations.Schema<Simplify<Struct.Type<Fields>>>): Struct<Fields>\n  pick<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Pick<Fields, Keys[number]>>>\n  omit<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Omit<Fields, Keys[number]>>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2912"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "tag",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface tag<Tag extends AST.LiteralValue> extends PropertySignature<\":\", Tag, never, \":\", Tag, true, never> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2953"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Record$",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Record$<K extends Schema.All, V extends Schema.All> extends\n  AnnotableClass<\n    Record$<K, V>,\n    { readonly [P in Schema.Type<K>]: Schema.Type<V> },\n    { readonly [P in Schema.Encoded<K>]: Schema.Encoded<V> },\n    | Schema.Context<K>\n    | Schema.Context<V>\n  >\n{\n  readonly fields: {}\n  readonly records: readonly [{ readonly key: K; readonly value: V }]\n  readonly key: K\n  readonly value: V\n  make(\n    props: void | { readonly [P in Schema.Type<K>]: Schema.Type<V> },\n    options?: MakeOptions\n  ): { readonly [P in Schema.Type<K>]: Schema.Type<V> }\n  annotations(annotations: Annotations.Schema<{ readonly [P in Schema.Type<K>]: Schema.Type<V> }>): Record$<K, V>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3019"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BrandSchema",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "branding",
    "signature": "export interface BrandSchema<A extends Brand<any>, I = A, R = never>\n  extends AnnotableClass<BrandSchema<A, I, R>, A, I, R>\n{\n  make(a: Brand.Unbranded<A>, options?: MakeOptions): A\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3146"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "brand",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface brand<S extends Schema.Any, B extends string | symbol>\n  extends BrandSchema<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  readonly from: S\n  annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3156"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "mutable",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface mutable<S extends Schema.Any> extends\n  AnnotableClass<\n    mutable<S>,\n    SimplifyMutable<Schema.Type<S>>,\n    SimplifyMutable<Schema.Encoded<S>>,\n    Schema.Context<S>\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3255"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "extend",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface extend<Self extends Schema.Any, That extends Schema.Any> extends\n  AnnotableClass<\n    extend<Self, That>,\n    Schema.Type<Self> & Schema.Type<That>,\n    Schema.Encoded<Self> & Schema.Encoded<That>,\n    Schema.Context<Self> | Schema.Context<That>\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3451"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "suspend",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface suspend<A, I, R> extends AnnotableClass<suspend<A, I, R>, A, I, R> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3567"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "refine",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface refine<A, From extends Schema.Any>\n  extends AnnotableClass<refine<A, From>, A, Schema.Encoded<From>, Schema.Context<From>>\n{\n  /** The following is required for {@link HasFields} to work */\n  readonly [RefineSchemaId]: From\n  readonly from: From\n  readonly filter: (\n    a: Schema.Type<From>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => option_.Option<ParseResult.ParseIssue>\n  make(a: Schema.Type<From>, options?: MakeOptions): A\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3591"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "filter",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface filter<From extends Schema.Any> extends refine<Schema.Type<From>, From> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3631"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "FilterIssue",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "filtering",
    "signature": "export interface FilterIssue {\n  readonly path: ReadonlyArray<PropertyKey>\n  readonly message: string\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3679"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "filterEffect",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface filterEffect<S extends Schema.Any, FD = never>\n  extends transformOrFail<S, SchemaClass<Schema.Type<S>>, FD>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3737"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "transformOrFail",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface transformOrFail<From extends Schema.All, To extends Schema.All, R = never> extends\n  AnnotableClass<\n    transformOrFail<From, To, R>,\n    Schema.Type<To>,\n    Schema.Encoded<From>,\n    Schema.Context<From> | Schema.Context<To> | R\n  >\n{\n  readonly from: From\n  readonly to: To\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3791"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "transform",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface transform<From extends Schema.All, To extends Schema.All> extends transformOrFail<From, To> {\n  annotations(annotations: Annotations.Schema<Schema.Type<To>>): transform<From, To>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3930"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "transformLiteral",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface transformLiteral<Type extends AST.LiteralValue, Encoded extends AST.LiteralValue>\n  extends transform<Literal<[Encoded]>, Literal<[Type]>>\n{\n  annotations(annotations: Annotations.Schema<Type>): transformLiteral<Type, Encoded>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3992"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "RedactedFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface RedactedFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    RedactedFromSelf<Value>,\n    redacted_.Redacted<Schema.Type<Value>>,\n    redacted_.Redacted<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5834"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Redacted",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Redacted<Value extends Schema.Any>\n  extends transform<Value, RedactedFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5866"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "OptionFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface OptionFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    OptionFromSelf<Value>,\n    option_.Option<Schema.Type<Value>>,\n    option_.Option<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7156"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Option",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Option<Value extends Schema.Any> extends\n  transform<\n    Union<[\n      Struct<{ _tag: Literal<[\"None\"]> }>,\n      Struct<{ _tag: Literal<[\"Some\"]>; value: Value }>\n    ]>,\n    OptionFromSelf<SchemaClass<Schema.Type<Value>>>\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7189"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "OptionFromNullOr",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface OptionFromNullOr<Value extends Schema.Any>\n  extends transform<NullOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7234"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "OptionFromNullishOr",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface OptionFromNullishOr<Value extends Schema.Any>\n  extends transform<NullishOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7254"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "OptionFromUndefinedOr",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface OptionFromUndefinedOr<Value extends Schema.Any>\n  extends transform<UndefinedOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7283"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "EitherFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface EitherFromSelf<R extends Schema.All, L extends Schema.All> extends\n  AnnotableDeclare<\n    EitherFromSelf<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    either_.Either<Schema.Encoded<R>, Schema.Encoded<L>>,\n    [R, L]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7404"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Either",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Either<Right extends Schema.All, Left extends Schema.All> extends\n  transform<\n    Union<[\n      Struct<{\n        _tag: Literal<[\"Right\"]>\n        right: Right\n      }>,\n      Struct<{\n        _tag: Literal<[\"Left\"]>\n        left: Left\n      }>\n    ]>,\n    EitherFromSelf<SchemaClass<Schema.Type<Right>>, SchemaClass<Schema.Type<Left>>>\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7449"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "EitherFromUnion",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface EitherFromUnion<Right extends Schema.All, Left extends Schema.All> extends\n  transform<\n    Union<[\n      transform<Right, Struct<{ _tag: Literal<[\"Right\"]>; right: SchemaClass<Schema.Type<Right>> }>>,\n      transform<Left, Struct<{ _tag: Literal<[\"Left\"]>; right: SchemaClass<Schema.Type<Left>> }>>\n    ]>,\n    EitherFromSelf<SchemaClass<Schema.Type<Right>>, SchemaClass<Schema.Type<Left>>>\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7495"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ReadonlyMapFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ReadonlyMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableDeclare<\n    ReadonlyMapFromSelf<K, V>,\n    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    [K, V]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7595"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "MapFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface MapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableDeclare<\n    MapFromSelf<K, V>,\n    Map<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    [K, V]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7636"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ReadonlyMap$",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ReadonlyMap$<K extends Schema.Any, V extends Schema.Any>\n  extends transform<Array$<Tuple2<K, V>>, ReadonlyMapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7658"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Map$",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Map$<K extends Schema.Any, V extends Schema.Any>\n  extends transform<Array$<Tuple2<K, V>>, MapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7685"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ReadonlySetFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ReadonlySetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    ReadonlySetFromSelf<Value>,\n    ReadonlySet<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7781"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "SetFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface SetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    SetFromSelf<Value>,\n    Set<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7816"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ReadonlySet$",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ReadonlySet$<Value extends Schema.Any>\n  extends transform<Array$<Value>, ReadonlySetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7836"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Set$",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Set$<Value extends Schema.Any>\n  extends transform<Array$<Value>, SetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7860"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ChunkFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    ChunkFromSelf<Value>,\n    chunk_.Chunk<Schema.Type<Value>>,\n    chunk_.Chunk<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8247"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Chunk",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Chunk<Value extends Schema.Any>\n  extends transform<Array$<Value>, ChunkFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8280"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonEmptyChunkFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface NonEmptyChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    NonEmptyChunkFromSelf<Value>,\n    chunk_.NonEmptyChunk<Schema.Type<Value>>,\n    chunk_.NonEmptyChunk<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8304"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonEmptyChunk",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface NonEmptyChunk<Value extends Schema.Any>\n  extends transform<NonEmptyArray<Value>, NonEmptyChunkFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8351"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DataFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.13.3",
    "category": "api interface",
    "signature": "export interface DataFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    DataFromSelf<Value>,\n    Schema.Type<Value>,\n    Schema.Encoded<Value>,\n    [Value]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8396"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Data",
    "deprecated": false,
    "examples": [],
    "since": "3.13.3",
    "category": "api interface",
    "signature": "export interface Data<Value extends Schema.Any>\n  extends transform<Value, DataFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8435"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Class",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Class<Self, Fields extends Struct.Fields, I, R, C, Inherited, Proto>\n  extends Schema<Self, Simplify<I>, R>\n{\n  new(\n    props: RequiredKeys<C> extends never ? void | Simplify<C> : Simplify<C>,\n    options?: MakeOptions\n  ): Struct.Type<Fields> & Inherited & Proto\n\n  /** @since 3.10.0 */\n  readonly ast: AST.Transformation\n\n  make<Args extends Array<any>, X>(this: { new(...args: Args): X }, ...args: Args): X\n\n  annotations(annotations: Annotations.Schema<Self>): SchemaClass<Self, Simplify<I>, R>\n\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n\n  readonly identifier: string\n\n  /**\n   * @example\n   * ```ts\n   * import { Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *  myField: Schema.String\n   * }) {\n   *  myMethod() {\n   *    return this.myField + \"my\"\n   *  }\n   * }\n   *\n   * class NextClass extends MyClass.extend<NextClass>(\"NextClass\")({\n   *  nextField: Schema.Number\n   * }) {\n   *  nextMethod() {\n   *    return this.myMethod() + this.myField + this.nextField\n   *  }\n   * }\n   * ```\n   */\n  extend<Extended = never>(identifier: string): <NewFields extends Struct.Fields>(\n    fields: NewFields | HasFields<NewFields>,\n    annotations?: ClassAnnotations<Extended, Simplify<Struct.Type<Fields & NewFields>>>\n  ) => [Extended] extends [never] ? MissingSelfGeneric<\"Base.extend\">\n    : Class<\n      Extended,\n      Fields & NewFields,\n      I & Struct.Encoded<NewFields>,\n      R | Struct.Context<NewFields>,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n\n  /**\n   * @example\n   * ```ts\n   * import { Effect, Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *   myField: Schema.String\n   * }) {\n   *   myMethod() {\n   *     return this.myField + \"my\"\n   *   }\n   * }\n   *\n   * class NextClass extends MyClass.transformOrFail<NextClass>(\"NextClass\")({\n   *   nextField: Schema.Number\n   * }, {\n   *   decode: (i) =>\n   *     Effect.succeed({\n   *       myField: i.myField,\n   *       nextField: i.myField.length\n   *     }),\n   *   encode: (a) => Effect.succeed({ myField: a.myField })\n   * }) {\n   *   nextMethod() {\n   *     return this.myMethod() + this.myField + this.nextField\n   *   }\n   * }\n   * ```\n   */\n  transformOrFail<Transformed = never>(identifier: string): <\n    NewFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: NewFields,\n    options: {\n      readonly decode: (\n        input: Simplify<Struct.Type<Fields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<Struct.Type<Fields & NewFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<Struct.Type<Fields & NewFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Struct.Type<Fields>, ParseResult.ParseIssue, R3>\n    },\n    annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformOrFail\">\n    : Class<\n      Transformed,\n      Fields & NewFields,\n      I,\n      R | Struct.Context<NewFields> | R2 | R3,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n\n  /**\n   * @example\n   * ```ts\n   * import { Effect, Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *   myField: Schema.String\n   * }) {\n   *   myMethod() {\n   *     return this.myField + \"my\"\n   *   }\n   * }\n   *\n   * class NextClass extends MyClass.transformOrFailFrom<NextClass>(\"NextClass\")({\n   *   nextField: Schema.Number\n   * }, {\n   *   decode: (i) =>\n   *     Effect.succeed({\n   *       myField: i.myField,\n   *       nextField: i.myField.length\n   *     }),\n   *   encode: (a) => Effect.succeed({ myField: a.myField })\n   * }) {\n   *   nextMethod() {\n   *     return this.myMethod() + this.myField + this.nextField\n   *   }\n   * }\n   * ```\n   */\n  transformOrFailFrom<Transformed = never>(identifier: string): <\n    NewFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: NewFields,\n    options: {\n      readonly decode: (\n        input: Simplify<I>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<I & Struct.Encoded<NewFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<I & Struct.Encoded<NewFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<I, ParseResult.ParseIssue, R3>\n    },\n    annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformOrFailFrom\">\n    : Class<\n      Transformed,\n      Fields & NewFields,\n      I,\n      R | Struct.Context<NewFields> | R2 | R3,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8481"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TaggedClass",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface TaggedClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    {}\n  >\n{\n  readonly _tag: Tag\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8721"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TaggedErrorClass",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface TaggedErrorClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    cause_.YieldableError\n  >\n{\n  readonly _tag: Tag\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8776"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "CauseFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface CauseFromSelf<E extends Schema.All, D extends Schema.All> extends\n  AnnotableDeclare<\n    CauseFromSelf<E, D>,\n    cause_.Cause<Schema.Type<E>>,\n    cause_.Cause<Schema.Encoded<E>>,\n    [E, D]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9366"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Cause",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Cause<E extends Schema.All, D extends Schema.All> extends\n  transform<\n    SchemaClass<\n      CauseEncoded<Schema.Type<E>, Schema.Type<Defect>>,\n      CauseEncoded<Schema.Encoded<E>, Schema.Encoded<Defect>>,\n      Schema.Context<E> | Schema.Context<D>\n    >,\n    CauseFromSelf<SchemaClass<Schema.Type<E>>, SchemaClass<Schema.Type<D>>>\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9443"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ExitFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ExitFromSelf<A extends Schema.All, E extends Schema.All, D extends Schema.All>\n  extends\n    AnnotableDeclare<\n      ExitFromSelf<A, E, D>,\n      exit_.Exit<Schema.Type<A>, Schema.Type<E>>,\n      exit_.Exit<Schema.Encoded<A>, Schema.Encoded<E>>,\n      [A, E, D]\n    >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9604"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Exit",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Exit<A extends Schema.All, E extends Schema.All, D extends Schema.All> extends\n  transform<\n    Union<[\n      Struct<{\n        _tag: Literal<[\"Failure\"]>\n        cause: SchemaClass<\n          CauseEncoded<Schema.Type<E>, Schema.Type<D>>,\n          CauseEncoded<Schema.Encoded<E>, Schema.Encoded<D>>,\n          Schema.Context<E> | Schema.Context<D>\n        >\n      }>,\n      Struct<{\n        _tag: Literal<[\"Success\"]>\n        value: A\n      }>\n    ]>,\n    ExitFromSelf<SchemaClass<Schema.Type<A>>, SchemaClass<Schema.Type<E>>, SchemaClass<Schema.Type<D>>>\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9650"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "HashSetFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface HashSetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    HashSetFromSelf<Value>,\n    hashSet_.HashSet<Schema.Type<Value>>,\n    hashSet_.HashSet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9729"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "HashSet",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface HashSet<Value extends Schema.Any>\n  extends transform<Array$<Value>, HashSetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9764"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "HashMapFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface HashMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableDeclare<\n    HashMapFromSelf<K, V>,\n    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,\n    hashMap_.HashMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    [K, V]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9827"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "HashMap",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface HashMap<K extends Schema.Any, V extends Schema.Any>\n  extends transform<Array$<Tuple2<K, V>>, HashMapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9863"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ListFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ListFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    ListFromSelf<Value>,\n    list_.List<Schema.Type<Value>>,\n    list_.List<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9914"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "List",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface List<Value extends Schema.Any>\n  extends transform<Array$<Value>, ListFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9949"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "SortedSetFromSelf",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface SortedSetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    SortedSetFromSelf<Value>,\n    sortedSet_.SortedSet<Schema.Type<Value>>,\n    sortedSet_.SortedSet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10002"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "SortedSet",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface SortedSet<Value extends Schema.Any>\n  extends transform<Array$<Value>, SortedSetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10039"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Serializable",
    "description": "The `Serializable` trait allows objects to define their own schema for\nserialization.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface Serializable<A, I, R> {\n  readonly [symbolSerializable]: Schema<A, I, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10133"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "WithResult",
    "description": "The `WithResult` trait is designed to encapsulate the outcome of an\noperation, distinguishing between success and failure cases. Each case is\nassociated with a schema that defines the structure and types of the success\nor failure data.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {\n  readonly [symbolWithResult]: {\n    readonly success: Schema<Success, SuccessEncoded, ResultR>\n    readonly failure: Schema<Failure, FailureEncoded, ResultR>\n  }\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10218"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "SerializableWithResult",
    "description": "The `SerializableWithResult` trait is specifically designed to model remote\nprocedures that require serialization of their input and output, managing\nboth successful and failed outcomes.\n\nThis trait combines functionality from both the `Serializable` and `WithResult`\ntraits to handle data serialization and the bifurcation of operation results\ninto success or failure categories.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface SerializableWithResult<\n  A,\n  I,\n  R,\n  Success,\n  SuccessEncoded,\n  Failure,\n  FailureEncoded,\n  ResultR\n> extends Serializable<A, I, R>, WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10438"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TaggedRequest",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export interface TaggedRequest<\n  Tag extends string,\n  A,\n  I,\n  R,\n  SuccessType,\n  SuccessEncoded,\n  FailureType,\n  FailureEncoded,\n  ResultR\n> extends\n  Request.Request<SuccessType, FailureType>,\n  SerializableWithResult<\n    A,\n    I,\n    R,\n    SuccessType,\n    SuccessEncoded,\n    FailureType,\n    FailureEncoded,\n    ResultR\n  >\n{\n  readonly _tag: Tag\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10491"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TaggedRequestClass",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface TaggedRequestClass<\n  Self,\n  Tag extends string,\n  Payload extends Struct.Fields,\n  Success extends Schema.All,\n  Failure extends Schema.All\n> extends\n  Class<\n    Self,\n    Payload,\n    Struct.Encoded<Payload>,\n    Struct.Context<Payload>,\n    Struct.Constructor<Omit<Payload, \"_tag\">>,\n    TaggedRequest<\n      Tag,\n      Self,\n      Struct.Encoded<Payload>,\n      Struct.Context<Payload>,\n      Schema.Type<Success>,\n      Schema.Encoded<Success>,\n      Schema.Type<Failure>,\n      Schema.Encoded<Failure>,\n      Schema.Context<Success> | Schema.Context<Failure>\n    >,\n    {}\n  >\n{\n  readonly _tag: Tag\n  readonly success: Success\n  readonly failure: Failure\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10537"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Simplify",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type { [K in keyof A]: A[K]; } = { [K in keyof A]: A[K] } & {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L58"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "SimplifyMutable",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type SimplifyMutable<A> = {\n  -readonly [K in keyof A]: A[K]\n} extends infer B ? B : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L63"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L77"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "EnumsDefinition",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type EnumsDefinition = { [x: string]: string | number }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L753"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PropertySignatureTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "type PropertySignatureTypeId = typeof PropertySignatureTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1856"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "OptionalOptions",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type OptionalOptions<A> = {\n  readonly default?: never\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly default: LazyArg<A>\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable?: never\n  readonly onNoneEncoding?: LazyArg<option_.Option<undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null | undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable?: never\n  readonly onNoneEncoding?: never\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null>>\n} | undefined",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2328"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TaggedStruct",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "type TaggedStruct<Tag, Fields> = Struct<\n  { _tag: tag<Tag> } & Fields\n>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2985"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "RefineSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "type RefineSchemaId = typeof RefineSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3585"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "FilterOutput",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "filtering",
    "signature": "type FilterOutput = undefined | boolean | string | ParseResult.ParseIssue | FilterIssue",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L3688"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "MaxLengthSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type MaxLengthSchemaId = typeof MaxLengthSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4285"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "MinLengthSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type MinLengthSchemaId = typeof MinLengthSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4317"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LengthSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type LengthSchemaId = typeof LengthSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4351"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ParseJsonOptions",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type ParseJsonOptions = {\n  readonly reviver?: Parameters<typeof JSON.parse>[1]\n  readonly replacer?: Parameters<typeof JSON.stringify>[1]\n  readonly space?: Parameters<typeof JSON.stringify>[2]\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4795"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "FiniteSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type FiniteSchemaId = typeof FiniteSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4972"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "GreaterThanSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type GreaterThanSchemaId = typeof GreaterThanSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5003"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "GreaterThanOrEqualToSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type GreaterThanOrEqualToSchemaId = typeof GreaterThanOrEqualToSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5036"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "IntSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type IntSchemaId = typeof IntSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5096"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LessThanSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type LessThanSchemaId = typeof LessThanSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5127"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LessThanOrEqualToSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type LessThanOrEqualToSchemaId = typeof LessThanOrEqualToSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5158"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BetweenSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type BetweenSchemaId = typeof BetweenSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5191"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "NonNaNSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type NonNaNSchemaId = typeof NonNaNSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5225"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "JsonNumberSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type JsonNumberSchemaId = typeof JsonNumberSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5405"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "GreaterThanBigIntSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type GreaterThanBigIntSchemaId = typeof GreaterThanBigIntSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5487"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "GreaterThanOrEqualToBigIntSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type GreaterThanOrEqualToBigIntSchemaId = typeof GreaterThanOrEqualToBigIntSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5518"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LessThanBigIntSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type LessThanBigIntSchemaId = typeof LessThanBigIntSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5551"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LessThanOrEqualToBigIntSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type LessThanOrEqualToBigIntSchemaId = typeof LessThanOrEqualToBigIntSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5582"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "BetweenBigIntSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type BetweenBigIntSchemaId = typeof BetweenBigIntSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5613"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DurationEncoded",
    "deprecated": false,
    "examples": [],
    "since": "3.12.8",
    "category": "Duration utils",
    "signature": "type DurationEncoded = | {\n    readonly _tag: \"Millis\"\n    readonly millis: number\n  }\n  | {\n    readonly _tag: \"Nanos\"\n    readonly nanos: string\n  }\n  | {\n    readonly _tag: \"Infinity\"\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L5965"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "MinItemsSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type MinItemsSchemaId = typeof MinItemsSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6404"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "MaxItemsSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type MaxItemsSchemaId = typeof MaxItemsSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6446"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ItemsCountSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "type ItemsCountSchemaId = typeof ItemsCountSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6485"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "DateFromSelfSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.11.8",
    "category": "schema id",
    "signature": "type DateFromSelfSchemaId = typeof DateFromSelfSchemaId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L6774"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "OptionEncoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Option utils",
    "signature": "type OptionEncoded<I> = | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Some\"\n    readonly value: I\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7099"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "RightEncoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Either utils",
    "signature": "type RightEncoded<IA> = {\n  readonly _tag: \"Right\"\n  readonly right: IA\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7326"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "LeftEncoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Either utils",
    "signature": "type LeftEncoded<IE> = {\n  readonly _tag: \"Left\"\n  readonly left: IE\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7335"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "EitherEncoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Either utils",
    "signature": "type EitherEncoded<IR, IL> = RightEncoded<IR> | LeftEncoded<IL>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L7344"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "MakeOptions",
    "deprecated": false,
    "examples": [],
    "since": "3.13.4",
    "category": "Constructor utils",
    "signature": "type MakeOptions = boolean | {\n  readonly disableValidation?: boolean | undefined\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L8863"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "FiberIdEncoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "FiberId",
    "signature": "type FiberIdEncoded = | {\n    readonly _tag: \"Composite\"\n    readonly left: FiberIdEncoded\n    readonly right: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Runtime\"\n    readonly id: number\n    readonly startTimeMillis: number\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9117"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "CauseEncoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Cause utils",
    "signature": "type CauseEncoded<E, D> = | {\n    readonly _tag: \"Empty\"\n  }\n  | {\n    readonly _tag: \"Fail\"\n    readonly error: E\n  }\n  | {\n    readonly _tag: \"Die\"\n    readonly defect: D\n  }\n  | {\n    readonly _tag: \"Interrupt\"\n    readonly fiberId: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"Sequential\"\n    readonly left: CauseEncoded<E, D>\n    readonly right: CauseEncoded<E, D>\n  }\n  | {\n    readonly _tag: \"Parallel\"\n    readonly left: CauseEncoded<E, D>\n    readonly right: CauseEncoded<E, D>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9230"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "ExitEncoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Exit utils",
    "signature": "type ExitEncoded<A, E, D> = | {\n    readonly _tag: \"Failure\"\n    readonly cause: CauseEncoded<E, D>\n  }\n  | {\n    readonly _tag: \"Success\"\n    readonly value: A\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L9522"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Annotable.Self",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Self<S> = ReturnType<S[\"annotations\"]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L283"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Annotable.Any",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Any = Annotable<any, any, any, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L288"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Annotable.All",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type All = | Any\n    | Annotable<any, any, never, unknown>\n    | Annotable<any, never, any, unknown>\n    | Annotable<any, never, never, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L293"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Schema.Variance",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export interface Variance<A, I, R> {\n    readonly [TypeId]: {\n      readonly _A: Types.Invariant<A>\n      readonly _I: Types.Invariant<I>\n      readonly _R: Types.Covariant<R>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L322"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Schema.Type",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Type<S> = S extends Schema.Variance<infer A, infer _I, infer _R> ? A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L333"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Schema.Encoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Encoded<S> = S extends Schema.Variance<infer _A, infer I, infer _R> ? I : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L338"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Schema.Context",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Context<S> = S extends Schema.Variance<infer _A, infer _I, infer R> ? R : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L343"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Schema.ToAsserts",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type ToAsserts<S> = (\n    input: unknown,\n    options?: AST.ParseOptions\n  ) => asserts input is Schema.Type<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L348"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Schema.Any",
    "description": "Any schema, except for `never`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Any = Schema<any, any, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L358"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Schema.AnyNoContext",
    "description": "Any schema with `Context = never`, except for `never`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type AnyNoContext = Schema<any, any, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L365"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Schema.All",
    "description": "Any schema, including `never`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type All = | Any\n    | Schema<any, never, unknown>\n    | Schema<never, any, unknown>\n    | Schema<never, never, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L372"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Schema.AsSchema",
    "description": "Type-level counterpart of `Schema.asSchema` function.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type AsSchema<S> = Schema<Type<S>, Encoded<S>, Context<S>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L383"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Element.Annotations",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export interface Annotations<A> extends Annotations.Doc<A> {\n    readonly missingMessage?: AST.MissingMessageAnnotation\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1361"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Element.Token",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Token = \"\" | \"?\"",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1368"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TupleType.Elements",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Elements = ReadonlyArray<Schema.Any | Element<Schema.Any, Element.Token>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1443"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TupleType.Rest",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Rest = ReadonlyArray<Schema.Any | Element<Schema.Any, \"\">>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1448"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TupleType.Type",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Type<Elements, Rest> = Rest extends\n    [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsType<Elements>,\n      ...ReadonlyArray<Schema.Type<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Type<Tail[K]> }\n    ]> :\n    ElementsType<Elements>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1453"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TupleType.Encoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Encoded<Elements, Rest> = Rest extends\n    [infer Head, ...infer Tail] ? Readonly<[\n      ...ElementsEncoded<Elements>,\n      ...ReadonlyArray<Schema.Encoded<Head>>,\n      ...{ readonly [K in keyof Tail]: Schema.Encoded<Tail[K]> }\n    ]> :\n    ElementsEncoded<Elements>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1464"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PropertySignature.Annotations",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export interface Annotations<A> extends Annotations.Doc<A> {\n    readonly missingMessage?: AST.MissingMessageAnnotation\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1711"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PropertySignature.Token",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Token = \"?:\" | \":\"",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1677"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PropertySignature.Any",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Any<Key> = PropertySignature<\n    Token,\n    any,\n    Key,\n    Token,\n    any,\n    boolean,\n    unknown\n  >",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1682"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PropertySignature.All",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type All<Key> = | Any<Key>\n    | PropertySignature<Token, never, Key, Token, any, boolean, unknown>\n    | PropertySignature<Token, any, Key, Token, never, boolean, unknown>\n    | PropertySignature<Token, never, Key, Token, never, boolean, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1695"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "PropertySignature.AST",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type AST = | PropertySignatureDeclaration\n    | PropertySignatureTransformation",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L1704"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Struct.Field",
    "description": "Useful for creating a type that can be used to add custom constraints to the fields of a struct.\n\n```ts\nimport { Schema } from \"effect\"\n\nconst f = <Fields extends Record<\"a\" | \"b\", Schema.Struct.Field>>(\n  schema: Schema.Struct<Fields>\n) => {\n  return schema.omit(\"a\")\n}\n\n//       Schema.Struct<{ b: typeof Schema.Number; }>\n//      \nconst result = f(Schema.Struct({ a: Schema.String, b: Schema.Number }))\n```",
    "deprecated": false,
    "examples": [],
    "since": "3.13.11",
    "category": null,
    "signature": "type Field = | Schema.All\n    | PropertySignature.All",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2588"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Struct.Fields",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Fields = { readonly [x: PropertyKey]: Field }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2595"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Struct.Type",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Type<F> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalTypePropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2621"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Struct.Encoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Encoded<F> = & { readonly [K in Exclude<keyof F, EncodedOptionalKeys<F>> as Key<F, K>]: Schema.Encoded<F[K]> }\n    & { readonly [K in EncodedOptionalKeys<F> as Key<F, K>]?: Schema.Encoded<F[K]> }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2635"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Struct.Context",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Context<F> = Schema.Context<F[keyof F]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2642"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Struct.Constructor",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Constructor<F> = Types.UnionToIntersection<\n    {\n      [K in keyof F]: F[K] extends OptionalTypePropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        F[K] extends PropertySignatureWithDefault ? { readonly [H in K]?: Schema.Type<F[H]> } :\n        { readonly [h in K]: Schema.Type<F[h]> }\n    }[keyof F]\n  > extends infer Q ? Q : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2653"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "IndexSignature.Record",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Record = { readonly key: Schema.All; readonly value: Schema.All }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2669"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "IndexSignature.Records",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Records = ReadonlyArray<Record>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2674"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "IndexSignature.NonEmptyRecords",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type NonEmptyRecords = array_.NonEmptyReadonlyArray<Record>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2679"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "IndexSignature.Type",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Type<Records> = MergeTuple<\n    {\n      readonly [K in keyof Records]: {\n        readonly [P in Schema.Type<Records[K][\"key\"]>]: Schema.Type<Records[K][\"value\"]>\n      }\n    }\n  >",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2688"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "IndexSignature.Encoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Encoded<Records> = MergeTuple<\n    {\n      readonly [K in keyof Records]: {\n        readonly [P in Schema.Encoded<Records[K][\"key\"]>]: Schema.Encoded<Records[K][\"value\"]>\n      }\n    }\n  >",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2699"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "IndexSignature.Context",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Context<Records> = {\n    [K in keyof Records]: Schema.Context<Records[K][\"key\"]> | Schema.Context<Records[K][\"value\"]>\n  }[number]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2710"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TypeLiteral.Type",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Type<Fields, Records> = & Struct.Type<Fields>\n    & IndexSignature.Type<Records>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2722"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TypeLiteral.Encoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Encoded<Fields, Records> = & Struct.Encoded<Fields>\n    & IndexSignature.Encoded<Records>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2729"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TypeLiteral.Constructor",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Constructor<Fields, Records> = & Struct.Constructor<Fields>\n    & IndexSignature.Type<Records>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L2736"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Annotations.Doc",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export interface Doc<A> extends AST.Annotations {\n    readonly title?: AST.TitleAnnotation\n    readonly description?: AST.DescriptionAnnotation\n    readonly documentation?: AST.DocumentationAnnotation\n    readonly examples?: AST.ExamplesAnnotation<A>\n    readonly default?: AST.DefaultAnnotation<A>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4141"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Annotations.Schema",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export interface Schema<A, TypeParameters extends ReadonlyArray<any> = readonly []> extends Doc<A> {\n    readonly identifier?: AST.IdentifierAnnotation\n    readonly message?: AST.MessageAnnotation\n    readonly schemaId?: AST.SchemaIdAnnotation\n    readonly jsonSchema?: AST.JSONSchemaAnnotation\n    readonly arbitrary?: ArbitraryAnnotation<A, TypeParameters>\n    readonly pretty?: pretty_.PrettyAnnotation<A, TypeParameters>\n    readonly equivalence?: AST.EquivalenceAnnotation<A, TypeParameters>\n    readonly concurrency?: AST.ConcurrencyAnnotation\n    readonly batching?: AST.BatchingAnnotation\n    readonly parseIssueTitle?: AST.ParseIssueTitleAnnotation\n    readonly parseOptions?: AST.ParseOptions\n    readonly decodingFallback?: AST.DecodingFallbackAnnotation<A>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4152"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Annotations.GenericSchema",
    "deprecated": false,
    "examples": [],
    "since": "3.11.6",
    "category": null,
    "signature": "export interface GenericSchema<A> extends Schema<A> {\n    readonly arbitrary?: (..._: any) => LazyArbitrary<A>\n    readonly pretty?: (..._: any) => pretty_.Pretty<A>\n    readonly equivalence?: (..._: any) => Equivalence.Equivalence<A>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4170"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Annotations.Filter",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export interface Filter<A, P = A> extends Schema<A, readonly [P]> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L4180"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Serializable.Type",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Type<T> = T extends Serializable<infer A, infer _I, infer _R> ? A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10145"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Serializable.Encoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Encoded<T> = T extends Serializable<infer _A, infer I, infer _R> ? I : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10149"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Serializable.Context",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Context<T> = T extends Serializable<infer _A, infer _I, infer R> ? R : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10153"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Serializable.Any",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Any = Serializable<any, any, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10157"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "Serializable.All",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type All = | Any\n    | Serializable<any, never, unknown>\n    | Serializable<never, any, unknown>\n    | Serializable<never, never, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10161"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "WithResult.Success",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Success<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10233"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "WithResult.SuccessEncoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type SuccessEncoded<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _I : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10237"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "WithResult.Failure",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Failure<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _E : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10241"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "WithResult.FailureEncoded",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type FailureEncoded<T> = T extends WithResult<infer _A, infer _I, infer _E, infer _EI, infer _R> ? _EI : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10245"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "WithResult.Context",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Context<T> = T extends WithResult<infer _SA, infer _SI, infer _FA, infer _FI, infer R> ? R : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10250"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "WithResult.Any",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Any = WithResult<any, any, any, any, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10254"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "WithResult.All",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type All = | Any\n    | WithResult<any, any, never, never, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10258"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "SerializableWithResult.Context",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Context<P> = P extends\n    SerializableWithResult<infer _S, infer _SI, infer SR, infer _A, infer _AI, infer _E, infer _EI, infer RR> ? SR | RR\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10457"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "SerializableWithResult.Any",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Any = SerializableWithResult<any, any, any, any, any, any, any, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10463"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "SerializableWithResult.All",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type All = | Any\n    | SerializableWithResult<any, any, any, any, any, never, never, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10467"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TaggedRequest.Any",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Any = TaggedRequest<string, any, any, any, any, any, any, any, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10524"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema.ts",
      "path": "src/Schema.ts"
    },
    "project": "effect",
    "name": "TaggedRequest.All",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type All = | Any\n    | TaggedRequest<string, any, any, any, any, any, never, never, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Schema.ts#L10528"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "Declaration",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Declaration { constructor(\n    readonly typeParameters: ReadonlyArray<AST>,\n    readonly decodeUnknown: (\n      ...typeParameters: ReadonlyArray<AST>\n    ) => (input: unknown, options: ParseOptions, self: Declaration) => Effect<any, ParseIssue, any>,\n    readonly encodeUnknown: (\n      ...typeParameters: ReadonlyArray<AST>\n    ) => (input: unknown, options: ParseOptions, self: Declaration) => Effect<any, ParseIssue, any>,\n    readonly annotations: Annotations = {}\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L474"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "Literal",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Literal { constructor(readonly literal: LiteralValue, readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L526"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "UniqueSymbol",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class UniqueSymbol { constructor(readonly symbol: symbol, readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L570"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "UndefinedKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class UndefinedKeyword { constructor(readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L604"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "VoidKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class VoidKeyword { constructor(readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L645"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "NeverKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class NeverKeyword { constructor(readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L686"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "UnknownKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class UnknownKeyword { constructor(readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L727"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "AnyKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class AnyKeyword { constructor(readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L768"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "StringKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class StringKeyword { constructor(readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L809"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "NumberKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class NumberKeyword { constructor(readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L851"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "BooleanKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class BooleanKeyword { constructor(readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L893"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "BigIntKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class BigIntKeyword { constructor(readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L935"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "SymbolKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class SymbolKeyword { constructor(readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L977"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "ObjectKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class ObjectKeyword { constructor(readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1019"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "Enums",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Enums { constructor(\n    readonly enums: ReadonlyArray<readonly [string, string | number]>,\n    readonly annotations: Annotations = {}\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1061"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "TemplateLiteralSpan",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class TemplateLiteralSpan { constructor(type: AST, readonly literal: string) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1148"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "TemplateLiteral",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class TemplateLiteral { constructor(\n    readonly head: string,\n    readonly spans: Arr.NonEmptyReadonlyArray<TemplateLiteralSpan>,\n    readonly annotations: Annotations = {}\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1181"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "Type",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Type { constructor(\n    readonly type: AST,\n    readonly annotations: Annotations = {}\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1224"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "OptionalType",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class OptionalType { constructor(\n    type: AST,\n    readonly isOptional: boolean,\n    annotations: Annotations = {}\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1250"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "TupleType",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class TupleType { constructor(\n    readonly elements: ReadonlyArray<OptionalType>,\n    readonly rest: ReadonlyArray<Type>,\n    readonly isReadonly: boolean,\n    readonly annotations: Annotations = {}\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1282"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "PropertySignature",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class PropertySignature { constructor(\n    readonly name: PropertyKey,\n    type: AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations?: Annotations\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1364"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "IndexSignature",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class IndexSignature { constructor(\n    parameter: AST,\n    readonly type: AST,\n    readonly isReadonly: boolean\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1419"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "TypeLiteral",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class TypeLiteral { constructor(\n    propertySignatures: ReadonlyArray<PropertySignature>,\n    indexSignatures: ReadonlyArray<IndexSignature>,\n    readonly annotations: Annotations = {}\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1457"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "Union",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Union<M> { private constructor(readonly types: Members<M>, readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1676"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "Suspend",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Suspend { constructor(readonly f: () => AST, readonly annotations: Annotations = {}) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1728"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "Refinement",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Refinement<From> { constructor(\n    readonly from: From,\n    readonly filter: (\n      input: any,\n      options: ParseOptions,\n      self: Refinement\n    ) => Option.Option<ParseIssue>,\n    readonly annotations: Annotations = {}\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1780"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "Transformation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class Transformation { constructor(\n    readonly from: AST,\n    readonly to: AST,\n    readonly transformation: TransformationKind,\n    readonly annotations: Annotations = {}\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1902"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "FinalTransformation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class FinalTransformation { constructor(\n    readonly decode: (\n      fromA: any,\n      options: ParseOptions,\n      self: Transformation,\n      fromI: any\n    ) => Effect<any, ParseIssue, any>,\n    readonly encode: (toI: any, options: ParseOptions, self: Transformation, toA: any) => Effect<any, ParseIssue, any>\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1954"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "ComposeTransformation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class ComposeTransformation",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1986"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "PropertySignatureTransformation",
    "description": "Represents a `PropertySignature -> PropertySignature` transformation\n\nThe semantic of `decode` is:\n- `none()` represents the absence of the key/value pair\n- `some(value)` represents the presence of the key/value pair\n\nThe semantic of `encode` is:\n- `none()` you don't want to output the key/value pair\n- `some(value)` you want to output the key/value pair",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class PropertySignatureTransformation { constructor(\n    readonly from: PropertyKey,\n    readonly to: PropertyKey,\n    readonly decode: (o: Option.Option<any>) => Option.Option<any>,\n    readonly encode: (o: Option.Option<any>) => Option.Option<any>\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2022"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "TypeLiteralTransformation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "declare class TypeLiteralTransformation { constructor(\n    readonly propertySignatureTransformations: ReadonlyArray<\n      PropertySignatureTransformation\n    >\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2038"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "BrandAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const BrandAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L64"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "SchemaIdAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const SchemaIdAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L76"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "MessageAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const MessageAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L91"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "MissingMessageAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const MissingMessageAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L103"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "IdentifierAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const IdentifierAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L115"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "TitleAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const TitleAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L127"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "DescriptionAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const DescriptionAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L142"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "ExamplesAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const ExamplesAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L154"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "DefaultAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const DefaultAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L166"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "JSONSchemaAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const JSONSchemaAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L178"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "ArbitraryAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const ArbitraryAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L184"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "PrettyAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const PrettyAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L190"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "EquivalenceAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const EquivalenceAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L204"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "DocumentationAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const DocumentationAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L216"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "ConcurrencyAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const ConcurrencyAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L228"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "BatchingAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const BatchingAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L240"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "ParseIssueTitleAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const ParseIssueTitleAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L252"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "ParseOptionsAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const ParseOptionsAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L258"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "DecodingFallbackAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const DecodingFallbackAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L270"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "SurrogateAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const SurrogateAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L276"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getAnnotation: { <A>(key: symbol): (annotated: Annotated) => Option.Option<A>; <A>(annotated: Annotated, key: symbol): Option.Option<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L317"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getBrandAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getBrandAnnotation: (annotated: Annotated) => Option.Option<readonly [string | symbol, ...(string | symbol)[]]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L332"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getSchemaIdAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.14.2",
    "category": "annotations",
    "signature": "declare const getSchemaIdAnnotation: (annotated: Annotated) => Option.Option<SchemaIdAnnotation>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L338"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getMessageAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getMessageAnnotation: (annotated: Annotated) => Option.Option<MessageAnnotation>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L344"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getMissingMessageAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getMissingMessageAnnotation: (annotated: Annotated) => Option.Option<MissingMessageAnnotation>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L350"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getTitleAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getTitleAnnotation: (annotated: Annotated) => Option.Option<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L356"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getIdentifierAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getIdentifierAnnotation: (annotated: Annotated) => Option.Option<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L365"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getDescriptionAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getDescriptionAnnotation: (annotated: Annotated) => Option.Option<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L371"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getExamplesAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getExamplesAnnotation: (annotated: Annotated) => Option.Option<readonly [unknown, ...unknown[]]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L377"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getDefaultAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getDefaultAnnotation: (annotated: Annotated) => Option.Option<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L383"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getJSONSchemaAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getJSONSchemaAnnotation: (annotated: Annotated) => Option.Option<object>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L389"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getDocumentationAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getDocumentationAnnotation: (annotated: Annotated) => Option.Option<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L395"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getConcurrencyAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getConcurrencyAnnotation: (annotated: Annotated) => Option.Option<ConcurrencyAnnotation>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L401"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getBatchingAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getBatchingAnnotation: (annotated: Annotated) => Option.Option<BatchingAnnotation>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L407"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getParseIssueTitleAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getParseIssueTitleAnnotation: (annotated: Annotated) => Option.Option<ParseIssueTitleAnnotation>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L413"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getParseOptionsAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getParseOptionsAnnotation: (annotated: Annotated) => Option.Option<ParseOptions>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L419"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getDecodingFallbackAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getDecodingFallbackAnnotation: (annotated: Annotated) => Option.Option<DecodingFallbackAnnotation<unknown>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L425"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getSurrogateAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getSurrogateAnnotation: (annotated: Annotated) => Option.Option<AST>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L433"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "JSONIdentifierAnnotationId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const JSONIdentifierAnnotationId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L445"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getJSONIdentifierAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getJSONIdentifierAnnotation: (annotated: Annotated) => Option.Option<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L451"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "ParseJsonSchemaId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "declare const ParseJsonSchemaId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L468"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isDeclaration",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isDeclaration: (ast: AST) => ast is Declaration",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L514"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isLiteral",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isLiteral: (ast: AST) => ast is Literal",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L554"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isUniqueSymbol",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isUniqueSymbol: (ast: AST) => ast is UniqueSymbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L598"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "undefinedKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const undefinedKeyword: UndefinedKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L631"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isUndefinedKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isUndefinedKeyword: (ast: AST) => ast is UndefinedKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L639"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "voidKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const voidKeyword: VoidKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L672"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isVoidKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isVoidKeyword: (ast: AST) => ast is VoidKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L680"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "neverKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const neverKeyword: NeverKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L713"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isNeverKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isNeverKeyword: (ast: AST) => ast is NeverKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L721"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "unknownKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const unknownKeyword: UnknownKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L754"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isUnknownKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isUnknownKeyword: (ast: AST) => ast is UnknownKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L762"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "anyKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const anyKeyword: AnyKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L795"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isAnyKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isAnyKeyword: (ast: AST) => ast is AnyKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L803"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "stringKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const stringKeyword: StringKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L836"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isStringKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isStringKeyword: (ast: AST) => ast is StringKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L845"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "numberKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const numberKeyword: NumberKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L878"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isNumberKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isNumberKeyword: (ast: AST) => ast is NumberKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L887"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "booleanKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const booleanKeyword: BooleanKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L920"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isBooleanKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isBooleanKeyword: (ast: AST) => ast is BooleanKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L929"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "bigIntKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const bigIntKeyword: BigIntKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L962"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isBigIntKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isBigIntKeyword: (ast: AST) => ast is BigIntKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L971"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "symbolKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const symbolKeyword: SymbolKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1004"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isSymbolKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isSymbolKeyword: (ast: AST) => ast is SymbolKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1013"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "objectKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const objectKeyword: ObjectKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1046"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isObjectKeyword",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isObjectKeyword: (ast: AST) => ast is ObjectKeyword",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1055"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isEnums",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isEnums: (ast: AST) => ast is Enums",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1095"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isTemplateLiteral",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isTemplateLiteral: (ast: AST) => ast is TemplateLiteral",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1218"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isTupleType",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isTupleType: (ast: AST) => ast is TupleType",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1358"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isTypeLiteral",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isTypeLiteral: (ast: AST) => ast is TypeLiteral",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1549"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isUnion",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isUnion: (ast: AST) => ast is Union",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1717"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isSuspend",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isSuspend: (ast: AST) => ast is Suspend",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1774"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isRefinement",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isRefinement: (ast: AST) => ast is Refinement<AST>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1821"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "defaultParseOption",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const defaultParseOption: ParseOptions",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1896"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isTransformation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isTransformation: (ast: AST) => ast is Transformation",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1939"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isFinalTransformation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isFinalTransformation: (ast: TransformationKind) => ast is FinalTransformation",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1978"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "composeTransformation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const composeTransformation: ComposeTransformation",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1997"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isComposeTransformation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isComposeTransformation: (ast: TransformationKind) => ast is ComposeTransformation",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2003"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isTypeLiteralTransformation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "declare const isTypeLiteralTransformation: (ast: TransformationKind) => ast is TypeLiteralTransformation",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2070"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getJSONIdentifier",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "declare const getJSONIdentifier: (annotated: Annotated) => Option.Option<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L457"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "isParameter",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const isParameter: (ast: AST) => ast is Parameter",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1403"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "annotations",
    "description": "Merges a set of new annotations with existing ones, potentially overwriting\nany duplicates.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const annotations: (ast: AST, overrides: Annotations) => AST",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2083"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "keyof",
    "description": "Equivalent at runtime to the TypeScript type-level `keyof` operator.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const keyof: (ast: AST) => AST",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2099"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getTemplateLiteralRegExp",
    "description": "Generates a regular expression from a `TemplateLiteral` AST node.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const getTemplateLiteralRegExp: (ast: TemplateLiteral) => RegExp",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2161"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getTemplateLiteralCapturingRegExp",
    "description": "Generates a regular expression that captures the pattern defined by the given `TemplateLiteral` AST.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const getTemplateLiteralCapturingRegExp: (ast: TemplateLiteral) => RegExp",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2171"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getPropertySignatures",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const getPropertySignatures: (ast: AST) => Array<PropertySignature>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2177"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "pick",
    "description": "Equivalent at runtime to the built-in TypeScript utility type `Pick`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const pick: (ast: AST, keys: ReadonlyArray<PropertyKey>) => TypeLiteral | Transformation",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2378"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "omit",
    "description": "Equivalent at runtime to the built-in TypeScript utility type `Omit`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const omit: (ast: AST, keys: ReadonlyArray<PropertyKey>) => TypeLiteral | Transformation",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2448"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "partial",
    "description": "Equivalent at runtime to the built-in TypeScript utility type `Partial`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const partial: (ast: AST, options?: { readonly exact: true; }) => AST",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2467"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "required",
    "description": "Equivalent at runtime to the built-in TypeScript utility type `Required`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const required: (ast: AST) => AST",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2511"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "mutable",
    "description": "Creates a new AST with shallow mutability applied to its properties.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const mutable: (ast: AST) => AST",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2549"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "getCompiler",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const getCompiler: <A>(match: Match<A>) => Compiler<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2607"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "typeAST",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const typeAST: (ast: AST) => AST",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2649"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "encodedAST",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const encodedAST: (ast: AST) => AST",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2819"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "encodedBoundAST",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "declare const encodedBoundAST: (ast: AST) => AST",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2824"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "Annotations",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export interface Annotations {\n  readonly [_: string]: unknown\n  readonly [_: symbol]: unknown\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L300"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "Annotated",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export interface Annotated {\n  readonly annotations: Annotations\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L309"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "ParseOptions",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface ParseOptions {\n  /**\n   * The `errors` option allows you to receive all parsing errors when\n   * attempting to parse a value using a schema. By default only the first error\n   * is returned, but by setting the `errors` option to `\"all\"`, you can receive\n   * all errors that occurred during the parsing process. This can be useful for\n   * debugging or for providing more comprehensive error messages to the user.\n   *\n   * default: \"first\"\n   *\n   * @since 3.10.0\n   */\n  readonly errors?: \"first\" | \"all\" | undefined\n  /**\n   * When using a `Schema` to parse a value, by default any properties that are\n   * not specified in the `Schema` will be stripped out from the output. This is\n   * because the `Schema` is expecting a specific shape for the parsed value,\n   * and any excess properties do not conform to that shape.\n   *\n   * However, you can use the `onExcessProperty` option (default value:\n   * `\"ignore\"`) to trigger a parsing error. This can be particularly useful in\n   * cases where you need to detect and handle potential errors or unexpected\n   * values.\n   *\n   * If you want to allow excess properties to remain, you can use\n   * `onExcessProperty` set to `\"preserve\"`.\n   *\n   * default: \"ignore\"\n   *\n   * @since 3.10.0\n   */\n  readonly onExcessProperty?: \"ignore\" | \"error\" | \"preserve\" | undefined\n  /**\n   * The `propertyOrder` option provides control over the order of object fields\n   * in the output. This feature is particularly useful when the sequence of\n   * keys is important for the consuming processes or when maintaining the input\n   * order enhances readability and usability.\n   *\n   * By default, the `propertyOrder` option is set to `\"none\"`. This means that\n   * the internal system decides the order of keys to optimize parsing speed.\n   * The order of keys in this mode should not be considered stable, and it's\n   * recommended not to rely on key ordering as it may change in future updates\n   * without notice.\n   *\n   * Setting `propertyOrder` to `\"original\"` ensures that the keys are ordered\n   * as they appear in the input during the decoding/encoding process.\n   *\n   * default: \"none\"\n   *\n   * @since 3.10.0\n   */\n  readonly propertyOrder?: \"none\" | \"original\" | undefined\n  /**\n   * Handles missing properties in data structures. By default, missing\n   * properties are treated as if present with an `undefined` value. To treat\n   * missing properties as errors, set the `exact` option to `true`. This\n   * setting is already enabled by default for `is` and `asserts` functions,\n   * treating absent properties strictly unless overridden.\n   *\n   * default: false\n   *\n   * @since 3.10.0\n   */\n  readonly exact?: boolean | undefined\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1827"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "AST",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "type AST = | Declaration\n  | Literal\n  | UniqueSymbol\n  | UndefinedKeyword\n  | VoidKeyword\n  | NeverKeyword\n  | UnknownKeyword\n  | AnyKeyword\n  | StringKeyword\n  | NumberKeyword\n  | BooleanKeyword\n  | BigIntKeyword\n  | SymbolKeyword\n  | ObjectKeyword\n  | Enums\n  | TemplateLiteral\n  // possible transformations\n  | Refinement\n  | TupleType\n  | TypeLiteral\n  | Union\n  | Suspend\n  // transformations\n  | Transformation",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L24"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "BrandAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type BrandAnnotation = Arr.NonEmptyReadonlyArray<string | symbol>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L58"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "SchemaIdAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type SchemaIdAnnotation = string | symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L70"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "MessageAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type MessageAnnotation = (issue: ParseIssue) => string | Effect<string> | {\n  readonly message: string | Effect<string>\n  readonly override: boolean\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L82"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "MissingMessageAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type MissingMessageAnnotation = () => string | Effect<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L97"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "IdentifierAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type IdentifierAnnotation = string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L109"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "TitleAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type TitleAnnotation = string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L121"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "DescriptionAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type DescriptionAnnotation = string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L136"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "ExamplesAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type readonly [A, ...A[]] = Arr.NonEmptyReadonlyArray<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L148"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "DefaultAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type A = A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L160"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "JSONSchemaAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type JSONSchemaAnnotation = object",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L172"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "EquivalenceAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type EquivalenceAnnotation<A, TypeParameters> = (\n  ...equivalences: { readonly [K in keyof TypeParameters]: Equivalence<TypeParameters[K]> }\n) => Equivalence<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L196"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "DocumentationAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type DocumentationAnnotation = string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L210"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "ConcurrencyAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type ConcurrencyAnnotation = Concurrency | undefined",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L222"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "BatchingAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type BatchingAnnotation = boolean | \"inherit\" | undefined",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L234"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "ParseIssueTitleAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type ParseIssueTitleAnnotation = (issue: ParseIssue) => string | undefined",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L246"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "DecodingFallbackAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type DecodingFallbackAnnotation<A> = (issue: ParseIssue) => Effect<A, ParseIssue>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L264"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "SurrogateAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "type SurrogateAnnotation = AST",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L282"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "LiteralValue",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "type LiteralValue = string | number | boolean | null | bigint",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L520"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "Parameter",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Parameter = StringKeyword | SymbolKeyword | TemplateLiteral | Refinement<Parameter>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1398"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "Members",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type readonly [A, A, ...A[]] = readonly [A, A, ...Array<A>]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1554"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "TransformationKind",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "type TransformationKind = | FinalTransformation\n  | ComposeTransformation\n  | TypeLiteralTransformation",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L1945"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "Compiler",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Compiler<A> = (ast: AST, path: ReadonlyArray<PropertyKey>) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2595"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST.ts",
      "path": "src/SchemaAST.ts"
    },
    "project": "effect",
    "name": "Match",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "type Match<A> = {\n  [K in AST[\"_tag\"]]: (ast: Extract<AST, { _tag: K }>, compile: Compiler<A>, path: ReadonlyArray<PropertyKey>) => A\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SchemaAST.ts#L2600"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "ScopeTypeId",
    "description": "A unique identifier for the `Scope` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const ScopeTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L19"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "CloseableScopeTypeId",
    "description": "A unique identifier for the `CloseableScope` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const CloseableScopeTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L35"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "Scope",
    "description": "A tag representing the current `Scope` in the environment.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const Scope: Context.Tag<Scope, Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L95"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "addFinalizer",
    "description": "Adds a finalizer to this scope. The finalizer is guaranteed to be run when\nthe scope is closed. Use this when the finalizer does not need to know the\n`Exit` value that the scope is closed with.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const addFinalizer: (self: Scope, finalizer: Effect.Effect<unknown>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L127"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "addFinalizerExit",
    "description": "Adds a finalizer to this scope. The finalizer receives the `Exit` value\nwhen the scope is closed, allowing it to perform different actions based\non the exit status.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const addFinalizerExit: (self: Scope, finalizer: Scope.Finalizer) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L142"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "close",
    "description": "Closes this scope with the specified exit value, running all finalizers that\nhave been added to the scope.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const close: (self: CloseableScope, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L152"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "extend",
    "description": "Extends the scope of an `Effect` that requires a scope into this scope.\nIt provides this scope to the effect but does not close the scope when the\neffect completes execution. This allows extending a scoped value into a\nlarger scope.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const extend: { (scope: Scope): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope>>; <A, E, R>(effect: Effect.Effect<A, E, R>, scope: Scope): Effect.Effect<A, E, Exclude<R, Scope>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L163"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "fork",
    "description": "Forks a new child scope with the specified execution strategy. The child scope\nwill automatically be closed when this scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const fork: (self: Scope, strategy: ExecutionStrategy.ExecutionStrategy) => Effect.Effect<CloseableScope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L175"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "use",
    "description": "Provides this closeable scope to an `Effect` that requires a scope,\nguaranteeing that the scope is closed with the result of that effect as\nsoon as the effect completes execution, whether by success, failure, or\ninterruption.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const use: { (scope: CloseableScope): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope>>; <A, E, R>(effect: Effect.Effect<A, E, R>, scope: CloseableScope): Effect.Effect<A, E, Exclude<R, Scope>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L189"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new closeable scope where finalizers will run according to the\nspecified `ExecutionStrategy`. If no execution strategy is provided, `sequential`\nwill be used by default.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (executionStrategy?: ExecutionStrategy.ExecutionStrategy) => Effect.Effect<CloseableScope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L202"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "Scope",
    "description": "Represents a scope that manages finalizers and can fork child scopes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Scope extends Pipeable {\n  readonly [ScopeTypeId]: ScopeTypeId\n  /**\n   * The execution strategy for running finalizers in this scope.\n   */\n  readonly strategy: ExecutionStrategy.ExecutionStrategy\n  /**\n   * Forks a new child scope with the specified execution strategy. The child scope\n   * will automatically be closed when this scope is closed.\n   *\n   * @internal\n   */\n  fork(strategy: ExecutionStrategy.ExecutionStrategy): Effect.Effect<Scope.Closeable>\n  /**\n   * Adds a finalizer to this scope. The finalizer will be run when the scope is closed.\n   *\n   * @internal\n   */\n  addFinalizer(finalizer: Scope.Finalizer): Effect.Effect<void>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L51"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "CloseableScope",
    "description": "A scope that can be explicitly closed with a specified exit value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface CloseableScope extends Scope, Pipeable {\n  readonly [CloseableScopeTypeId]: CloseableScopeTypeId\n\n  /**\n   * Closes this scope with the given exit value, running all finalizers.\n   *\n   * @internal\n   */\n  close(exit: Exit.Exit<unknown, unknown>): Effect.Effect<void>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L78"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "ScopeTypeId",
    "description": "The type of the unique identifier for `Scope`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type ScopeTypeId = typeof ScopeTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L27"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "CloseableScopeTypeId",
    "description": "The type of the unique identifier for `CloseableScope`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type CloseableScopeTypeId = typeof CloseableScopeTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L43"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "Scope.Finalizer",
    "description": "A finalizer function that takes an `Exit` value and returns an `Effect`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "type Finalizer = (exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L107"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Scope.ts",
      "path": "src/Scope.ts"
    },
    "project": "effect",
    "name": "Scope.Closeable",
    "description": "A closeable scope that can be explicitly closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "type Closeable = CloseableScope",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Scope.ts#L114"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedCache.ts",
      "path": "src/ScopedCache.ts"
    },
    "project": "effect",
    "name": "ScopedCacheTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const ScopedCacheTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedCache.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedCache.ts",
      "path": "src/ScopedCache.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new cache with the specified capacity, time to live, and\nlookup function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Key, Value, Error = never, Environment = never>(options: { readonly lookup: Lookup<Key, Value, Error, Environment>; readonly capacity: number; readonly timeToLive: Duration.DurationInput; }) => Effect.Effect<ScopedCache<Key, Value, Error>, never, Scope.Scope | Environment>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedCache.ts#L119"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedCache.ts",
      "path": "src/ScopedCache.ts"
    },
    "project": "effect",
    "name": "makeWith",
    "description": "Constructs a new cache with the specified capacity, time to live, and\nlookup function, where the time to live can depend on the `Exit` value\nreturned by the lookup function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeWith: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly lookup: Lookup<Key, Value, Error, Environment>; readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput; }) => Effect.Effect<ScopedCache<Key, Value, Error>, never, Scope.Scope | Environment>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedCache.ts#L135"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScopedCache.ts",
      "path": "src/ScopedCache.ts"
    },
    "project": "effect",
    "name": "ScopedCache",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ScopedCache<in Key, out Value, out Error = never>\n  extends ScopedCache.Variance<Key, Value, Error>, Pipeable\n{\n  /**\n   * Retrieves the value associated with the specified key if it exists.\n   * Otherwise returns `Option.none`.\n   */\n  getOption(key: Key): Effect.Effect<Option.Option<Value>, Error, Scope.Scope>\n\n  /**\n   * Retrieves the value associated with the specified key if it exists and the\n   * lookup function has completed. Otherwise returns `Option.none`.\n   */\n  getOptionComplete(key: Key): Effect.Effect<Option.Option<Value>, never, Scope.Scope>\n\n  /**\n   * Returns statistics for this cache.\n   */\n  readonly cacheStats: Effect.Effect<Cache.CacheStats>\n\n  /**\n   * Return whether a resource associated with the specified key exists in the\n   * cache. Sometime `contains` can return true if the resource is currently\n   * being created but not yet totally created.\n   */\n  contains(key: Key): Effect.Effect<boolean>\n\n  /**\n   * Return statistics for the specified entry.\n   */\n  entryStats(key: Key): Effect.Effect<Option.Option<Cache.EntryStats>>\n\n  /**\n   * Gets the value from the cache if it exists or otherwise computes it, the\n   * release action signals to the cache that the value is no longer being used\n   * and can potentially be finalized subject to the policies of the cache.\n   */\n  get(key: Key): Effect.Effect<Value, Error, Scope.Scope>\n\n  /**\n   * Invalidates the resource associated with the specified key.\n   */\n  invalidate(key: Key): Effect.Effect<void>\n\n  /**\n   * Invalidates all values in the cache.\n   */\n  readonly invalidateAll: Effect.Effect<void>\n\n  /**\n   * Force the reuse of the lookup function to compute the returned scoped\n   * effect associated with the specified key immediately. Once the new resource\n   * is recomputed, the old resource associated to the key is cleaned (once all\n   * fiber using it are done with it). During the time the new resource is\n   * computed, concurrent call the .get will use the old resource if this one is\n   * not expired.\n   */\n  refresh(key: Key): Effect.Effect<void, Error>\n\n  /**\n   * Returns the approximate number of values in the cache.\n   */\n  readonly size: Effect.Effect<number>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedCache.ts#L30"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ScopedCache.ts",
      "path": "src/ScopedCache.ts"
    },
    "project": "effect",
    "name": "ScopedCacheTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type ScopedCacheTypeId = typeof ScopedCacheTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedCache.ts#L24"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ScopedCache.ts",
      "path": "src/ScopedCache.ts"
    },
    "project": "effect",
    "name": "Lookup",
    "description": "Similar to `Cache.Lookup`, but executes the lookup function within a `Scope`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Lookup<Key, Value, Error, Environment> = (\n  key: Key\n) => Effect.Effect<Value, Error, Environment | Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedCache.ts#L149"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScopedCache.ts",
      "path": "src/ScopedCache.ts"
    },
    "project": "effect",
    "name": "ScopedCache.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in Key, out Value, out Error> {\n    readonly [ScopedCacheTypeId]: {\n      _Key: Types.Contravariant<Key>\n      _Error: Types.Covariant<Error>\n      _Value: Types.Covariant<Value>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedCache.ts#L103"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedRef.ts",
      "path": "src/ScopedRef.ts"
    },
    "project": "effect",
    "name": "ScopedRefTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const ScopedRefTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L17"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedRef.ts",
      "path": "src/ScopedRef.ts"
    },
    "project": "effect",
    "name": "fromAcquire",
    "description": "Creates a new `ScopedRef` from an effect that resourcefully produces a\nvalue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromAcquire: <A, E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<ScopedRef<A>, E, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L82"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedRef.ts",
      "path": "src/ScopedRef.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves the current value of the scoped reference.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const get: <A>(self: ScopedRef<A>) => Effect.Effect<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L92"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedRef.ts",
      "path": "src/ScopedRef.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new `ScopedRef` from the specified value. This method should\nnot be used for values whose creation require the acquisition of resources.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A>(evaluate: LazyArg<A>) => Effect.Effect<ScopedRef<A>, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L101"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedRef.ts",
      "path": "src/ScopedRef.ts"
    },
    "project": "effect",
    "name": "set",
    "description": "Sets the value of this reference to the specified resourcefully-created\nvalue. Any resources associated with the old value will be released.\n\nThis method will not return until either the reference is successfully\nchanged to the new value, with old resources released, or until the attempt\nto acquire a new value fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const set: { <A, R, E>(acquire: Effect.Effect<A, E, R>): (self: ScopedRef<A>) => Effect.Effect<void, E, Exclude<R, Scope.Scope>>; <A, R, E>(self: ScopedRef<A>, acquire: Effect.Effect<A, E, R>): Effect.Effect<void, E, Exclude<R, Scope.Scope>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L114"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScopedRef.ts",
      "path": "src/ScopedRef.ts"
    },
    "project": "effect",
    "name": "ScopedRef",
    "description": "A `ScopedRef` is a reference whose value is associated with resources,\nwhich must be released properly. You can both get the current value of any\n`ScopedRef`, as well as set it to a new value (which may require new\nresources). The reference itself takes care of properly releasing resources\nfor the old value whenever a new value is obtained.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ScopedRef<in out A> extends Effect.Effect<A>, ScopedRef.Variance<A>, Pipeable {\n  /** @internal */\n  readonly ref: Synchronized.SynchronizedRef<readonly [Scope.Scope.Closeable, A]>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: ScopedRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: ScopedRefUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L35"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScopedRef.ts",
      "path": "src/ScopedRef.ts"
    },
    "project": "effect",
    "name": "ScopedRefUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface ScopedRefUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  ScopedRef?: () => Extract<A[Unify.typeSymbol], ScopedRef<any>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L48"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScopedRef.ts",
      "path": "src/ScopedRef.ts"
    },
    "project": "effect",
    "name": "ScopedRefUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface ScopedRefUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L56"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ScopedRef.ts",
      "path": "src/ScopedRef.ts"
    },
    "project": "effect",
    "name": "ScopedRefTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type ScopedRefTypeId = typeof ScopedRefTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L23"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScopedRef.ts",
      "path": "src/ScopedRef.ts"
    },
    "project": "effect",
    "name": "ScopedRef.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out A> {\n    readonly [ScopedRefTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/ScopedRef.ts#L68"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Secret.ts",
      "path": "src/Secret.ts"
    },
    "project": "effect",
    "name": "SecretTypeId",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const SecretTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Secret.ts#L14"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Secret.ts",
      "path": "src/Secret.ts"
    },
    "project": "effect",
    "name": "isSecret",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isSecret: (u: unknown) => u is Secret",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Secret.ts#L53"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Secret.ts",
      "path": "src/Secret.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (bytes: Array<number>) => Secret",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Secret.ts#L60"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Secret.ts",
      "path": "src/Secret.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: (iterable: Iterable<string>) => Secret",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Secret.ts#L67"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Secret.ts",
      "path": "src/Secret.ts"
    },
    "project": "effect",
    "name": "fromString",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromString: (text: string) => Secret",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Secret.ts#L74"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Secret.ts",
      "path": "src/Secret.ts"
    },
    "project": "effect",
    "name": "value",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const value: (self: Secret) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Secret.ts#L81"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Secret.ts",
      "path": "src/Secret.ts"
    },
    "project": "effect",
    "name": "unsafeWipe",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeWipe: (self: Secret) => void",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Secret.ts#L88"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Secret.ts",
      "path": "src/Secret.ts"
    },
    "project": "effect",
    "name": "Secret",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Secret extends Redacted.Redacted, Secret.Proto, Equal.Equal {\n  /** @internal */\n  readonly raw: Array<number>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Secret.ts#L28"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Secret.ts",
      "path": "src/Secret.ts"
    },
    "project": "effect",
    "name": "SecretTypeId",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type SecretTypeId = typeof SecretTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Secret.ts#L21"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Secret.ts",
      "path": "src/Secret.ts"
    },
    "project": "effect",
    "name": "Secret.Proto",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Proto {\n    readonly [SecretTypeId]: SecretTypeId\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Secret.ts#L43"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SingleProducerAsyncInput.ts",
      "path": "src/SingleProducerAsyncInput.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Err, Elem, Done>() => Effect.Effect<SingleProducerAsyncInput<Err, Elem, Done>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SingleProducerAsyncInput.ts#L67"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SingleProducerAsyncInput.ts",
      "path": "src/SingleProducerAsyncInput.ts"
    },
    "project": "effect",
    "name": "SingleProducerAsyncInput",
    "description": "An MVar-like abstraction for sending data to channels asynchronously which is\ndesigned for one producer and multiple consumers.\n\nFeatures the following semantics:\n  - Buffer of size 1.\n  - When emitting, the producer waits for a consumer to pick up the value to\n    prevent \"reading ahead\" too much.\n  - Once an emitted element is read by a consumer, it is cleared from the\n    buffer, so that at most one consumer sees every emitted element.\n  - When sending a done or error signal, the producer does not wait for a\n    consumer to pick up the signal. The signal stays in the buffer after\n    being read by a consumer, so it can be propagated to multiple consumers.\n  - Trying to publish another emit/error/done after an error/done have\n    already been published results in an interruption.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SingleProducerAsyncInput<in out Err, in out Elem, in out Done>\n  extends AsyncInputProducer<Err, Elem, Done>, AsyncInputConsumer<Err, Elem, Done>\n{\n  readonly close: Effect.Effect<unknown>\n  readonly take: Effect.Effect<Exit.Exit<Elem, Either.Either<Done, Err>>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SingleProducerAsyncInput.ts#L29"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SingleProducerAsyncInput.ts",
      "path": "src/SingleProducerAsyncInput.ts"
    },
    "project": "effect",
    "name": "AsyncInputProducer",
    "description": "Producer-side view of `SingleProducerAsyncInput` for variance purposes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface AsyncInputProducer<in Err, in Elem, in Done> {\n  awaitRead(): Effect.Effect<unknown>\n  done(value: Done): Effect.Effect<unknown>\n  emit(element: Elem): Effect.Effect<unknown>\n  error(cause: Cause.Cause<Err>): Effect.Effect<unknown>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SingleProducerAsyncInput.ts#L42"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SingleProducerAsyncInput.ts",
      "path": "src/SingleProducerAsyncInput.ts"
    },
    "project": "effect",
    "name": "AsyncInputConsumer",
    "description": "Consumer-side view of `SingleProducerAsyncInput` for variance purposes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface AsyncInputConsumer<out Err, out Elem, out Done> {\n  takeWith<A>(\n    onError: (cause: Cause.Cause<Err>) => A,\n    onElement: (element: Elem) => A,\n    onDone: (value: Done) => A\n  ): Effect.Effect<A>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SingleProducerAsyncInput.ts#L55"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "SinkTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const SinkTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L30"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "as",
    "description": "Replaces this sink's result with the provided value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const as: { <A2>(a: A2): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E, R>; <A, In, L, E, R, A2>(self: Sink<A, In, L, E, R>, a: A2): Sink<A2, In, L, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L118"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "collectAll",
    "description": "A sink that collects all elements into a `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const collectAll: <In>() => Sink<Chunk.Chunk<In>, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L129"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "collectAllN",
    "description": "A sink that collects first `n` elements into a chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const collectAllN: <In>(n: number) => Sink<Chunk.Chunk<In>, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L137"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "collectAllFrom",
    "description": "Repeatedly runs the sink and accumulates its results into a `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const collectAllFrom: <A, In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<Chunk.Chunk<A>, In, L, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L145"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "collectAllToMap",
    "description": "A sink that collects all of its inputs into a map. The keys are extracted\nfrom inputs using the keying function `key`; if multiple inputs use the\nsame key, they are merged using the `merge` function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const collectAllToMap: <In, K>(key: (input: In) => K, merge: (x: In, y: In) => In) => Sink<HashMap.HashMap<K, In>, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L157"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "collectAllToMapN",
    "description": "A sink that collects first `n` keys into a map. The keys are calculated\nfrom inputs using the keying function `key`; if multiple inputs use the the\nsame key, they are merged using the `merge` function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const collectAllToMapN: <In, K>(n: number, key: (input: In) => K, merge: (x: In, y: In) => In) => Sink<HashMap.HashMap<K, In>, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L170"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "collectAllToSet",
    "description": "A sink that collects all of its inputs into a set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const collectAllToSet: <In>() => Sink<HashSet.HashSet<In>, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L182"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "collectAllToSetN",
    "description": "A sink that collects first `n` distinct inputs into a set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const collectAllToSetN: <In>(n: number) => Sink<HashSet.HashSet<In>, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L190"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "collectAllUntil",
    "description": "Accumulates incoming elements into a chunk until predicate `p` is\nsatisfied.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const collectAllUntil: <In>(p: Predicate<In>) => Sink<Chunk.Chunk<In>, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L199"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "collectAllUntilEffect",
    "description": "Accumulates incoming elements into a chunk until effectful predicate `p` is\nsatisfied.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const collectAllUntilEffect: <In, E, R>(p: (input: In) => Effect.Effect<boolean, E, R>) => Sink<Chunk.Chunk<In>, In, In, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L208"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "collectAllWhile",
    "description": "Accumulates incoming elements into a chunk as long as they verify predicate\n`p`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const collectAllWhile: { <In, Out extends In>(refinement: Refinement<In, Out>): Sink<Chunk.Chunk<Out>, In, In>; <In>(predicate: Predicate<In>): Sink<Chunk.Chunk<In>, In, In>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L219"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "collectAllWhileEffect",
    "description": "Accumulates incoming elements into a chunk as long as they verify effectful\npredicate `p`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const collectAllWhileEffect: <In, E, R>(predicate: (input: In) => Effect.Effect<boolean, E, R>) => Sink<Chunk.Chunk<In>, In, In, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L231"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "collectAllWhileWith",
    "description": "Repeatedly runs the sink for as long as its results satisfy the predicate\n`p`. The sink's results will be accumulated using the stepping function `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const collectAllWhileWith: { <A, S>(options: { readonly initial: S; readonly while: Predicate<A>; readonly body: (s: S, a: A) => S; }): <In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<S, In, L, E, R>; <A, In, L extends In, E, R, S>(self: Sink<A, In, L, E, R>, options: { readonly initial: S; readonly while: Predicate<A>; readonly body: (s: S, a: A) => S; }): Sink<S, In, L, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L242"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "collectLeftover",
    "description": "Collects the leftovers from the stream when the sink succeeds and returns\nthem as part of the sink's result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const collectLeftover: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, Chunk.Chunk<L>], In, never, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L259"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "mapInput",
    "description": "Transforms this sink's input elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapInput: { <In0, In>(f: (input: In0) => In): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E, R>; <A, In, L, E, R, In0>(self: Sink<A, In, L, E, R>, f: (input: In0) => In): Sink<A, In0, L, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L269"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "mapInputEffect",
    "description": "Effectfully transforms this sink's input elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapInputEffect: { <In0, In, E2, R2>(f: (input: In0) => Effect.Effect<In, E2, R2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E2 | E, R2 | R>; <A, In, L, E, R, In0, E2, R2>(self: Sink<A, In, L, E, R>, f: (input: In0) => Effect.Effect<In, E2, R2>): Sink<A, In0, L, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L280"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "mapInputChunks",
    "description": "Transforms this sink's input chunks. `f` must preserve chunking-invariance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapInputChunks: { <In0, In>(f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E, R>; <A, In, L, E, R, In0>(self: Sink<A, In, L, E, R>, f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>): Sink<A, In0, L, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L296"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "mapInputChunksEffect",
    "description": "Effectfully transforms this sink's input chunks. `f` must preserve\nchunking-invariance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapInputChunksEffect: { <In0, In, E2, R2>(f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E2 | E, R2 | R>; <A, In, L, E, R, In0, E2, R2>(self: Sink<A, In, L, E, R>, f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>): Sink<A, In0, L, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L313"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "count",
    "description": "A sink that counts the number of elements fed to it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const count: Sink<number, unknown, never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L329"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "die",
    "description": "Creates a sink halting with the specified defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const die: (defect: unknown) => Sink<never, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L337"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "dieMessage",
    "description": "Creates a sink halting with the specified message, wrapped in a\n`RuntimeException`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dieMessage: (message: string) => Sink<never, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L346"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "dieSync",
    "description": "Creates a sink halting with the specified defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dieSync: (evaluate: LazyArg<unknown>) => Sink<never, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L354"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "dimap",
    "description": "Transforms both inputs and result of this sink using the provided\nfunctions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const dimap: { <In0, In, A, A2>(options: { readonly onInput: (input: In0) => In; readonly onDone: (a: A) => A2; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E, R>; <A, In, L, E, R, In0, A2>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (input: In0) => In; readonly onDone: (a: A) => A2; }): Sink<A2, In0, L, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L363"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "dimapEffect",
    "description": "Effectfully transforms both inputs and result of this sink using the\nprovided functions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const dimapEffect: { <In0, In, E2, R2, A, A2, E3, R3>(options: { readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>; <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): Sink<A2, In0, L, E | E2 | E3, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L380"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "dimapChunks",
    "description": "Transforms both input chunks and result of this sink using the provided\nfunctions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const dimapChunks: { <In0, In, A, A2>(options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>; readonly onDone: (a: A) => A2; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E, R>; <A, In, L, E, R, In0, A2>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>; readonly onDone: (a: A) => A2; }): Sink<A2, In0, L, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L403"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "dimapChunksEffect",
    "description": "Effectfully transforms both input chunks and result of this sink using the\nprovided functions. `f` and `g` must preserve chunking-invariance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const dimapChunksEffect: { <In0, In, E2, R2, A, A2, E3, R3>(options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>; <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): Sink<A2, In0, L, E | E2 | E3, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L420"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "drain",
    "description": "A sink that ignores its inputs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const drain: Sink<void, unknown, never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L442"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "drop",
    "description": "Creates a sink that drops `n` elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const drop: <In>(n: number) => Sink<unknown, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L450"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "dropUntil",
    "description": "Drops incoming elements until the predicate is satisfied.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dropUntil: <In>(predicate: Predicate<In>) => Sink<unknown, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L458"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "dropUntilEffect",
    "description": "Drops incoming elements until the effectful predicate is satisfied.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dropUntilEffect: <In, E, R>(predicate: (input: In) => Effect.Effect<boolean, E, R>) => Sink<unknown, In, In, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L466"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "dropWhile",
    "description": "Drops incoming elements as long as the predicate is satisfied.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dropWhile: <In>(predicate: Predicate<In>) => Sink<unknown, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L476"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "dropWhileEffect",
    "description": "Drops incoming elements as long as the effectful predicate is satisfied.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dropWhileEffect: <In, E, R>(predicate: (input: In) => Effect.Effect<boolean, E, R>) => Sink<unknown, In, In, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L484"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "ensuring",
    "description": "Returns a new sink with an attached finalizer. The finalizer is guaranteed\nto be executed so long as the sink begins execution (and regardless of\nwhether or not it completes).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "finalization",
    "signature": "declare const ensuring: { <X, R2>(finalizer: Effect.Effect<X, never, R2>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, R2 | R>; <A, In, L, E, R, X, R2>(self: Sink<A, In, L, E, R>, finalizer: Effect.Effect<X, never, R2>): Sink<A, In, L, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L496"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "ensuringWith",
    "description": "Returns a new sink with an attached finalizer. The finalizer is guaranteed\nto be executed so long as the sink begins execution (and regardless of\nwhether or not it completes).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "finalization",
    "signature": "declare const ensuringWith: { <A, E, X, R2>(finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>): <In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, R2 | R>; <A, In, L, E, R, X, R2>(self: Sink<A, In, L, E, R>, finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>): Sink<A, In, L, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L511"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "context",
    "description": "Accesses the whole context of the sink.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const context: <R>() => Sink<Context.Context<R>, unknown, never, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L527"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "contextWith",
    "description": "Accesses the context of the sink.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const contextWith: <R, Z>(f: (context: Context.Context<R>) => Z) => Sink<Z, unknown, never, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L535"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "contextWithEffect",
    "description": "Accesses the context of the sink in the context of an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const contextWithEffect: <R0, A, E, R>(f: (context: Context.Context<R0>) => Effect.Effect<A, E, R>) => Sink<A, unknown, never, E, R0 | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L544"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "contextWithSink",
    "description": "Accesses the context of the sink in the context of a sink.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const contextWithSink: <R0, A, In, L, E, R>(f: (context: Context.Context<R0>) => Sink<A, In, L, E, R>) => Sink<A, In, L, E, R0 | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L554"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "every",
    "description": "A sink that returns whether all elements satisfy the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const every: <In>(predicate: Predicate<In>) => Sink<boolean, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L564"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "fail",
    "description": "A sink that always fails with the specified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fail: <E>(e: E) => Sink<never, unknown, never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L572"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "failSync",
    "description": "A sink that always fails with the specified lazily evaluated error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failSync: <E>(evaluate: LazyArg<E>) => Sink<never, unknown, never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L580"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "failCause",
    "description": "Creates a sink halting with a specified `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failCause: <E>(cause: Cause.Cause<E>) => Sink<never, unknown, never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L588"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "failCauseSync",
    "description": "Creates a sink halting with a specified lazily evaluated `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Sink<never, unknown, never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L596"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "filterInput",
    "description": "Filters the sink's input with the given predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterInput: { <In, In1 extends In, In2 extends In1>(f: Refinement<In1, In2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In2, L, E, R>; <In, In1 extends In>(f: Predicate<In1>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In1, L, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L605"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "filterInputEffect",
    "description": "Effectfully filter the input of this sink using the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterInputEffect: { <In, In1 extends In, E2, R2>(f: (input: In1) => Effect.Effect<boolean, E2, R2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In1, L, E2 | E, R2 | R>; <A, In, L, E, R, In1 extends In, E2, R2>(self: Sink<A, In, L, E, R>, f: (input: In1) => Effect.Effect<boolean, E2, R2>): Sink<A, In1, L, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L618"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "findEffect",
    "description": "Creates a sink that produces values until one verifies the predicate `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findEffect: { <A, E2, R2>(f: (a: A) => Effect.Effect<boolean, E2, R2>): <In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<Option.Option<A>, In, L, E2 | E, R2 | R>; <A, In, L extends In, E, R, E2, R2>(self: Sink<A, In, L, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Sink<Option.Option<A>, In, L, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L634"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "fold",
    "description": "A sink that folds its inputs with the provided function, termination\npredicate and initial state.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const fold: <S, In>(s: S, contFn: Predicate<S>, f: (s: S, input: In) => S) => Sink<S, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L651"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "foldSink",
    "description": "Folds over the result of the sink",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const foldSink: { <E, A1, In, In1 extends In, L1, E1, R1, A, A2, In2 extends In, L2, E2, R2>(options: { readonly onFailure: (err: E) => Sink<A1, In1, L1, E1, R1>; readonly onSuccess: (a: A) => Sink<A2, In2, L2, E2, R2>; }): <L, R>(self: Sink<A, In, L, E, R>) => Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R1 | R2 | R>; <A, In, L, E, R, A1, In1 extends In, L1, E1, R1, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, options: { readonly onFailure: (err: E) => Sink<A1, In1, L1, E1, R1>; readonly onSuccess: (a: A) => Sink<A2, In2, L2, E2, R2>; }): Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R | R1 | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L659"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "foldChunks",
    "description": "A sink that folds its input chunks with the provided function, termination\npredicate and initial state. `contFn` condition is checked only for the\ninitial value and at the end of processing of each chunk. `f` and `contFn`\nmust preserve chunking-invariance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const foldChunks: <S, In>(s: S, contFn: Predicate<S>, f: (s: S, chunk: Chunk.Chunk<In>) => S) => Sink<S, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L684"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "foldChunksEffect",
    "description": "A sink that effectfully folds its input chunks with the provided function,\ntermination predicate and initial state. `contFn` condition is checked only\nfor the initial value and at the end of processing of each chunk. `f` and\n`contFn` must preserve chunking-invariance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const foldChunksEffect: <S, In, E, R>(s: S, contFn: Predicate<S>, f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L699"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "foldEffect",
    "description": "A sink that effectfully folds its inputs with the provided function,\ntermination predicate and initial state.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const foldEffect: <S, In, E, R>(s: S, contFn: Predicate<S>, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L712"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "foldLeft",
    "description": "A sink that folds its inputs with the provided function and initial state.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const foldLeft: <S, In>(s: S, f: (s: S, input: In) => S) => Sink<S, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L724"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "foldLeftChunks",
    "description": "A sink that folds its input chunks with the provided function and initial\nstate. `f` must preserve chunking-invariance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const foldLeftChunks: <S, In>(s: S, f: (s: S, chunk: Chunk.Chunk<In>) => S) => Sink<S, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L733"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "foldLeftChunksEffect",
    "description": "A sink that effectfully folds its input chunks with the provided function\nand initial state. `f` must preserve chunking-invariance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const foldLeftChunksEffect: <S, In, E, R>(s: S, f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>) => Sink<S, In, never, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L743"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "foldLeftEffect",
    "description": "A sink that effectfully folds its inputs with the provided function and\ninitial state.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const foldLeftEffect: <S, In, E, R>(s: S, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L755"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "foldUntil",
    "description": "Creates a sink that folds elements of type `In` into a structure of type\n`S` until `max` elements have been folded.\n\nLike `Sink.foldWeighted`, but with a constant cost function of `1`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const foldUntil: <In, S>(s: S, max: number, f: (s: S, input: In) => S) => Sink<S, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L769"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "foldUntilEffect",
    "description": "Creates a sink that effectfully folds elements of type `In` into a\nstructure of type `S` until `max` elements have been folded.\n\nLike `Sink.foldWeightedEffect` but with a constant cost function of `1`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const foldUntilEffect: <S, In, E, R>(s: S, max: number, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L780"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "foldWeighted",
    "description": "Creates a sink that folds elements of type `In` into a structure of type `S`,\nuntil `max` worth of elements (determined by the `costFn`) have been folded.\n\n**Note**\n\nElements that have an individual cost larger than `max` will force the sink\nto cross the `max` cost. See `Sink.foldWeightedDecompose` for a variant\nthat can handle these cases.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const foldWeighted: <S, In>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => number; readonly body: (s: S, input: In) => S; }) => Sink<S, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L799"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "foldWeightedDecompose",
    "description": "Creates a sink that folds elements of type `In` into a structure of type\n`S`, until `max` worth of elements (determined by the `costFn`) have been\nfolded.\n\nThe `decompose` function will be used for decomposing elements that cause\nan `S` aggregate to cross `max` into smaller elements. For example:\n\n```ts skip-type-checking\npipe(\n  Stream.make(1, 5, 1),\n  Stream.transduce(\n    Sink.foldWeightedDecompose(\n      Chunk.empty<number>(),\n      4,\n      (n: number) => n,\n      (n: number) => Chunk.make(n - 1, 1),\n      (acc, el) => pipe(acc, Chunk.append(el))\n    )\n  ),\n  Stream.runCollect\n)\n```\n\nThe stream would emit the elements `Chunk(1), Chunk(4), Chunk(1, 1)`.\n\nBe vigilant with this function, it has to generate \"simpler\" values or the\nfold may never end. A value is considered indivisible if `decompose` yields\nthe empty chunk or a single-valued chunk. In these cases, there is no other\nchoice than to yield a value that will cross the threshold.\n\n`Sink.foldWeightedDecomposeEffect` allows the decompose function to return an\neffect value, and consequently it allows the sink to fail.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const foldWeightedDecompose: <S, In>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => number; readonly decompose: (input: In) => Chunk.Chunk<In>; readonly body: (s: S, input: In) => S; }) => Sink<S, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L845"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "foldWeightedDecomposeEffect",
    "description": "Creates a sink that effectfully folds elements of type `In` into a\nstructure of type `S`, until `max` worth of elements (determined by the\n`costFn`) have been folded.\n\nThe `decompose` function will be used for decomposing elements that cause\nan `S` aggregate to cross `max` into smaller elements. Be vigilant with\nthis function, it has to generate \"simpler\" values or the fold may never\nend. A value is considered indivisible if `decompose` yields the empty\nchunk or a single-valued chunk. In these cases, there is no other choice\nthan to yield a value that will cross the threshold.\n\nSee `Sink.foldWeightedDecompose` for an example.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const foldWeightedDecomposeEffect: <S, In, E, R, E2, R2, E3, R3>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>; readonly decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly body: (s: S, input: In) => Effect.Effect<S, E3, R3>; }) => Sink<S, In, In, E | E2 | E3, R | R2 | R3>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L872"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "foldWeightedEffect",
    "description": "Creates a sink that effectfully folds elements of type `In` into a\nstructure of type `S`, until `max` worth of elements (determined by the\n`costFn`) have been folded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const foldWeightedEffect: <S, In, E, R, E2, R2>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>; readonly body: (s: S, input: In) => Effect.Effect<S, E2, R2>; }) => Sink<S, In, In, E | E2, R | R2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L895"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "A sink that executes the provided effectful function for every element fed\nto it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const forEach: <In, X, E, R>(f: (input: In) => Effect.Effect<X, E, R>) => Sink<void, In, never, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L911"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "forEachChunk",
    "description": "A sink that executes the provided effectful function for every chunk fed to\nit.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const forEachChunk: <In, X, E, R>(f: (input: Chunk.Chunk<In>) => Effect.Effect<X, E, R>) => Sink<void, In, never, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L921"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "forEachChunkWhile",
    "description": "A sink that executes the provided effectful function for every chunk fed to\nit until `f` evaluates to `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const forEachChunkWhile: <In, E, R>(f: (input: Chunk.Chunk<In>) => Effect.Effect<boolean, E, R>) => Sink<void, In, In, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L932"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "forEachWhile",
    "description": "A sink that executes the provided effectful function for every element fed\nto it until `f` evaluates to `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const forEachWhile: <In, E, R>(f: (input: In) => Effect.Effect<boolean, E, R>) => Sink<void, In, In, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L943"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Runs this sink until it yields a result, then uses that result to create\nanother sink from the provided function which will continue to run until it\nyields a result.\n\nThis function essentially runs sinks in sequence.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMap: { <A, A1, In, In1 extends In, L1, E1, R1>(f: (a: A) => Sink<A1, In1, L1, E1, R1>): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A1, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1 extends In, L1, E1, R1>(self: Sink<A, In, L, E, R>, f: (a: A) => Sink<A1, In1, L1, E1, R1>): Sink<A1, In & In1, L | L1, E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L956"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "fromChannel",
    "description": "Creates a sink from a `Channel`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromChannel: <L, In, E, A, R>(channel: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>) => Sink<A, In, L, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L972"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "toChannel",
    "description": "Creates a `Channel` from a Sink.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const toChannel: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L982"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "fromEffect",
    "description": "Creates a single-value sink produced from an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Sink<A, unknown, never, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L992"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "fromPubSub",
    "description": "Create a sink which publishes each element to the specified `PubSub`.\n\nIf the `shutdown` parameter is `true`, the `PubSub` will be shutdown after\nthe sink is evaluated (defaults to `false`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromPubSub: <In>(pubsub: PubSub.PubSub<In>, options?: { readonly shutdown?: boolean | undefined; }) => Sink<void, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1004"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "fromPush",
    "description": "Creates a sink from a chunk processing function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromPush: <In, L0, R0, L, R>(push: Effect.Effect<(_: Option.Option<Chunk.Chunk<In>>) => Effect.Effect<void, readonly [Either.Either<R0, L0>, Chunk.Chunk<L>], R>, never, R>) => Sink<R0, In, L, L0, Exclude<R, Scope.Scope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1017"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "fromQueue",
    "description": "Create a sink which enqueues each element into the specified queue.\n\nIf the `shutdown` parameter is `true`, the queue will be shutdown after the\nsink is evaluated (defaults to `false`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromQueue: <In>(queue: Queue.Enqueue<In>, options?: { readonly shutdown?: boolean | undefined; }) => Sink<void, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1034"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "head",
    "description": "Creates a sink containing the first value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const head: <In>() => Sink<Option.Option<In>, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1047"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "ignoreLeftover",
    "description": "Drains the remaining elements from the stream after the sink finishes",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const ignoreLeftover: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, never, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1055"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "last",
    "description": "Creates a sink containing the last value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const last: <In>() => Sink<Option.Option<In>, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1064"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "leftover",
    "description": "Creates a sink that does not consume any input but provides the given chunk\nas its leftovers",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const leftover: <L>(chunk: Chunk.Chunk<L>) => Sink<void, unknown, L>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1073"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms this sink's result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <A, A2>(f: (a: A) => A2): <In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E, R>; <A, In, L, E, R, A2>(self: Sink<A, In, L, E, R>, f: (a: A) => A2): Sink<A2, In, L, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1081"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "mapEffect",
    "description": "Effectfully transforms this sink's result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<A2, E2, R2>): <In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E2 | E, R2 | R>; <A, In, L, E, R, A2, E2, R2>(self: Sink<A, In, L, E, R>, f: (a: A) => Effect.Effect<A2, E2, R2>): Sink<A2, In, L, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1092"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "mapError",
    "description": "Transforms the errors emitted by this sink using `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapError: { <E, E2>(f: (error: E) => E2): <A, In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E2, R>; <A, In, L, E, R, E2>(self: Sink<A, In, L, E, R>, f: (error: E) => E2): Sink<A, In, L, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1108"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "mapLeftover",
    "description": "Transforms the leftovers emitted by this sink using `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapLeftover: { <L, L2>(f: (leftover: L) => L2): <A, In, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L2, E, R>; <A, In, L, E, R, L2>(self: Sink<A, In, L, E, R>, f: (leftover: L) => L2): Sink<A, In, L2, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1119"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "mkString",
    "description": "Creates a sink which transforms it's inputs into a string.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const mkString: Sink<string, unknown, never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1130"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "never",
    "description": "Creates a sink which never terminates.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const never: Sink<never, unknown, never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1138"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "orElse",
    "description": "Switch to another sink in case of failure",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElse: { <A2, In2, L2, E2, R2>(that: LazyArg<Sink<A2, In2, L2, E2, R2>>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2 | A, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: LazyArg<Sink<A2, In2, L2, E2, R2>>): Sink<A | A2, In & In2, L | L2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1146"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "provideContext",
    "description": "Provides the sink with its required context, which eliminates its\ndependency on `R`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideContext: { <R>(context: Context.Context<R>): <A, In, L, E>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, never>; <A, In, L, E, R>(self: Sink<A, In, L, E, R>, context: Context.Context<R>): Sink<A, In, L, E, never>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1163"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "race",
    "description": "Runs both sinks in parallel on the input, , returning the result or the\nerror from the one that finishes first.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const race: { <R1, E1, In1, L1, A1>(that: Sink<A1, In1, L1, E1, R1>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A1 | A, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1, L1, E1, R1>(self: Sink<A, In, L, E, R>, that: Sink<A1, In1, L1, E1, R1>): Sink<A | A1, In & In1, L | L1, E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1175"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "raceBoth",
    "description": "Runs both sinks in parallel on the input, returning the result or the error\nfrom the one that finishes first.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const raceBoth: { <A1, In1, L1, E1, R1>(that: Sink<A1, In1, L1, E1, R1>, options?: { readonly capacity?: number | undefined; } | undefined): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<Either.Either<A1, A>, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1, L1, E1, R1>(self: Sink<A, In, L, E, R>, that: Sink<A1, In1, L1, E1, R1>, options?: { readonly capacity?: number | undefined; } | undefined): Sink<Either.Either<A1, A>, In & In1, L | L1, E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1192"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "raceWith",
    "description": "Runs both sinks in parallel on the input, using the specified merge\nfunction as soon as one result or the other has been computed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const raceWith: { <A2, In2, L2, E2, R2, A, E, A3, A4>(options: { readonly other: Sink<A2, In2, L2, E2, R2>; readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E2 | E, A3>; readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E2 | E, A4>; readonly capacity?: number | undefined; }): <In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A3 | A4, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2, L2, E2, R2, A3, A4>(self: Sink<A, In, L, E, R>, options: { readonly other: Sink<A2, In2, L2, E2, R2>; readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E | E2, A3>; readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E | E2, A4>; readonly capacity?: number | undefined; }): Sink<A3 | A4, In & In2, L | L2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1211"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "refineOrDie",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const refineOrDie: { <E, E2>(pf: (error: E) => Option.Option<E2>): <A, In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E2, R>; <A, In, L, E, R, E2>(self: Sink<A, In, L, E, R>, pf: (error: E) => Option.Option<E2>): Sink<A, In, L, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1235"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "refineOrDieWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const refineOrDieWith: { <E, E2>(pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): <A, In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E2, R>; <A, In, L, E, R, E2>(self: Sink<A, In, L, E, R>, pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): Sink<A, In, L, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1244"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "some",
    "description": "A sink that returns whether an element satisfies the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const some: <In>(predicate: Predicate<In>) => Sink<boolean, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1262"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "splitWhere",
    "description": "Splits the sink on the specified predicate, returning a new sink that\nconsumes elements until an element after the first satisfies the specified\npredicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const splitWhere: { <In>(f: Predicate<In>): <A, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, In, E, R>; <A, In, L extends In, E, R>(self: Sink<A, In, L, E, R>, f: Predicate<In>): Sink<A, In, In, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1272"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "succeed",
    "description": "A sink that immediately ends with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const succeed: <A>(a: A) => Sink<A, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1283"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "sum",
    "description": "A sink that sums incoming numeric values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sum: Sink<number, number, never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1291"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "summarized",
    "description": "Summarize a sink by running an effect when the sink starts and again when\nit completes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const summarized: { <A2, E2, R2, A3>(summary: Effect.Effect<A2, E2, R2>, f: (start: A2, end: A2) => A3): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, A3], In, L, E2 | E, R2 | R>; <A, In, L, E, R, A2, E2, R2, A3>(self: Sink<A, In, L, E, R>, summary: Effect.Effect<A2, E2, R2>, f: (start: A2, end: A2) => A3): Sink<[A, A3], In, L, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1300"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "suspend",
    "description": "Returns a lazily constructed sink that may require effects for its\ncreation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const suspend: <A, In, L, E, R>(evaluate: LazyArg<Sink<A, In, L, E, R>>) => Sink<A, In, L, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1319"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "sync",
    "description": "A sink that immediately ends with the specified lazy value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sync: <A>(evaluate: LazyArg<A>) => Sink<A, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1328"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "take",
    "description": "A sink that takes the specified number of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const take: <In>(n: number) => Sink<Chunk.Chunk<In>, In, In>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1336"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "timed",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const timed: Sink<Duration.Duration, unknown, never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1342"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "unwrap",
    "description": "Creates a sink produced from an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unwrap: <A, In, L, E2, R2, E, R>(effect: Effect.Effect<Sink<A, In, L, E2, R2>, E, R>) => Sink<A, In, L, E2 | E, R2 | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1350"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "unwrapScoped",
    "description": "Creates a sink produced from a scoped effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unwrapScoped: <A, In, L, E, R>(effect: Effect.Effect<Sink<A, In, L, E, R>, E, R>) => Sink<A, In, L, E, Exclude<R, Scope.Scope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1360"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "unwrapScopedWith",
    "description": "Constructs a `Sink` from a function which receives a `Scope` and returns\nan effect that will result in a `Sink` if successful.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "declare const unwrapScopedWith: <A, In, L, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Sink<A, In, L, E, R>, E, R>) => Sink<A, In, L, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1371"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "withDuration",
    "description": "Returns the sink that executes this one and times its execution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const withDuration: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, Duration.Duration], In, L, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1381"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Feeds inputs to this sink until it yields a result, then switches over to\nthe provided sink until it yields a result, finally combining the two\nresults into a tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zip: { <A2, In, In2 extends In, L2, E2, R2>(that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, A2], In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<[A, A2], In & In2, L | L2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1393"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Like `Sink.zip` but keeps only the result from this sink.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipLeft: { <A2, In, In2 extends In, L2, E2, R2>(that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<A, In & In2, L | L2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1411"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Like `Sink.zip` but keeps only the result from `that` sink.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipRight: { <A2, In, In2 extends In, L2, E2, R2>(that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<A2, In & In2, L | L2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1429"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Feeds inputs to this sink until it yields a result, then switches over to\nthe provided sink until it yields a result, finally combining the two\nresults with `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWith: { <A2, In, In2 extends In, L2, E2, R2, A, A3>(that: Sink<A2, In2, L2, E2, R2>, f: (a: A, a2: A2) => A3, options?: { readonly concurrent?: boolean | undefined; } | undefined): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A3, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2, A3>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, f: (a: A, a2: A2) => A3, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<A3, In & In2, L | L2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L1449"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "Sink",
    "description": "A `Sink<A, In, L, E, R>` is used to consume elements produced by a `Stream`.\nYou can think of a sink as a function that will consume a variable amount of\n`In` elements (could be 0, 1, or many), might fail with an error of type `E`,\nand will eventually yield a value of type `A` together with a remainder of\ntype `L` (i.e. any leftovers).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Sink<out A, in In = unknown, out L = never, out E = never, out R = never>\n  extends Sink.Variance<A, In, L, E, R>, Pipeable\n{}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L48"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "SinkUnify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SinkUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Sink?: () => A[Unify.typeSymbol] extends\n    | Sink<\n      infer A,\n      infer In,\n      infer L,\n      infer E,\n      infer R\n    >\n    | infer _ ? Sink<A, In, L, E, R>\n    : never\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L56"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "SinkUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SinkUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Sink?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L73"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "SinkTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type SinkTypeId = typeof SinkTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L36"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "Sink.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out A, in In, out L, out E, out R> {\n    readonly [SinkTypeId]: VarianceStruct<A, In, L, E, R>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L96"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Sink.ts",
      "path": "src/Sink.ts"
    },
    "project": "effect",
    "name": "Sink.VarianceStruct",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface VarianceStruct<out A, in In, out L, out E, out R> {\n    _A: Types.Covariant<A>\n    _In: Types.Contravariant<In>\n    _L: Types.Covariant<L>\n    _E: Types.Covariant<E>\n    _R: Types.Covariant<R>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Sink.ts#L103"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `SortedMap` from an iterable collection of key/value pairs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: { <B>(ord: Order<B>): <K extends B, V>(iterable: Iterable<readonly [K, V]>) => SortedMap<K, V>; <K extends B, V, B>(iterable: Iterable<readonly [K, V]>, ord: Order<B>): SortedMap<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L100"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "get",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const get: { <K>(key: K): <V>(self: SortedMap<K, V>) => Option.Option<V>; <K, V>(self: SortedMap<K, V>, key: K): Option.Option<V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L136"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "has",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const has: { <K>(key: K): <V>(self: SortedMap<K, V>) => boolean; <K, V>(self: SortedMap<K, V>, key: K): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L156"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "map",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <A, K, B>(f: (a: A, k: K) => B): (self: SortedMap<K, A>) => SortedMap<K, B>; <K, A, B>(self: SortedMap<K, A>, f: (a: A, k: K) => B): SortedMap<K, B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L174"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "reduce",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduce: { <B, A, K>(zero: B, f: (acc: B, value: A, key: K) => B): (self: SortedMap<K, A>) => B; <K, A, B>(self: SortedMap<K, A>, zero: B, f: (acc: B, value: A, key: K) => B): B; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L191"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "remove",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const remove: { <K>(key: K): <V>(self: SortedMap<K, V>) => SortedMap<K, V>; <K, V>(self: SortedMap<K, V>, key: K): SortedMap<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L203"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "set",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const set: { <K, V>(key: K, value: V): (self: SortedMap<K, V>) => SortedMap<K, V>; <K, V>(self: SortedMap<K, V>, key: K, value: V): SortedMap<K, V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L215"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "partition",
    "deprecated": false,
    "examples": [],
    "since": "3.1.0",
    "category": "filtering",
    "signature": "declare const partition: { <K, V>(predicate: (a: Types.NoInfer<K>) => boolean): (self: SortedMap<K, V>) => [excluded: SortedMap<K, V>, satisfying: SortedMap<K, V>]; <K, V>(self: SortedMap<K, V>, predicate: (a: K) => boolean): [excluded: SortedMap<K, V>, satisfying: SortedMap<K, V>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L264"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "isSortedMap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isSortedMap: { <K, V>(u: Iterable<readonly [K, V]>): u is SortedMap<K, V>; (u: unknown): u is SortedMap<unknown, unknown>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L83"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <K, V = never>(ord: Order<K>) => SortedMap<K, V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L92"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <K>(ord: Order<K>) => <Entries extends ReadonlyArray<readonly [K, any]>>(...entries: Entries) => SortedMap<K, Entries[number] extends (readonly [any, infer V]) ? V : never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L113"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const isEmpty: <K, V>(self: SortedMap<K, V>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L124"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "isNonEmpty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "declare const isNonEmpty: <K, V>(self: SortedMap<K, V>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L130"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "getOrder",
    "description": "Gets the `Order<K>` that the `SortedMap<K, V>` is using.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const getOrder: <K, V>(self: SortedMap<K, V>) => Order<K>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L150"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "headOption",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const headOption: <K, V>(self: SortedMap<K, V>) => Option.Option<[K, V]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L168"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "size",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <K, V>(self: SortedMap<K, V>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L230"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "keys",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const keys: <K, V>(self: SortedMap<K, V>) => IterableIterator<K>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L236"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "values",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const values: <K, V>(self: SortedMap<K, V>) => IterableIterator<V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L242"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "entries",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const entries: <K, V>(self: SortedMap<K, V>) => IterableIterator<[K, V]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L248"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "lastOption",
    "deprecated": false,
    "examples": [],
    "since": "3.1.0",
    "category": "elements",
    "signature": "declare const lastOption: <K, V>(self: SortedMap<K, V>) => Option.Option<[K, V]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L258"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "SortedMap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SortedMap<in out K, out V> extends Iterable<[K, V]>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _K: Types.Invariant<K>\n    readonly _V: Types.Covariant<V>\n  }\n  /** @internal */\n  readonly tree: RBT.RedBlackTree<K, V>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L29"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SortedMap.ts",
      "path": "src/SortedMap.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedMap.ts#L23"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `SortedSet` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: { <B>(ord: Order<B>): <A extends B>(iterable: Iterable<A>) => SortedSet<A>; <A extends B, B>(iterable: Iterable<A>, ord: Order<B>): SortedSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L100"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "add",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const add: { <A>(value: A): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, value: A): SortedSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L121"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "difference",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const difference: { <A, B extends A>(that: Iterable<B>): (self: SortedSet<A>) => SortedSet<A>; <A, B extends A>(self: SortedSet<A>, that: Iterable<B>): SortedSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L135"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "every",
    "description": "Check if a predicate holds true for every `SortedSet` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const every: { <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L155"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "filter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filter: { <A, B extends A>(predicate: Predicate<B>): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, predicate: Predicate<A>): SortedSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L171"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMap: { <B, A>(O: Order<B>, f: (a: A) => Iterable<B>): (self: SortedSet<A>) => SortedSet<B>; <A, B>(self: SortedSet<A>, O: Order<B>, f: (a: A) => Iterable<B>): SortedSet<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L189"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "forEach",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const forEach: { <A>(f: (a: A) => void): (self: SortedSet<A>) => void; <A>(self: SortedSet<A>, f: (a: A) => void): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L209"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "has",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const has: { <A>(value: A): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, value: A): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L221"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "intersection",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const intersection: { <A>(that: Iterable<A>): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, that: Iterable<A>): SortedSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L232"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "isSubset",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const isSubset: { <A>(that: SortedSet<A>): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, that: SortedSet<A>): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L253"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "map",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <B, A>(O: Order<B>, f: (a: A) => B): (self: SortedSet<A>) => SortedSet<B>; <B, A>(self: SortedSet<A>, O: Order<B>, f: (a: A) => B): SortedSet<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L265"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "partition",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const partition: { <A>(predicate: (a: NoInfer<A>) => boolean): (self: SortedSet<A>) => [excluded: SortedSet<A>, satisfying: SortedSet<A>]; <A>(self: SortedSet<A>, predicate: (a: A) => boolean): [excluded: SortedSet<A>, satisfying: SortedSet<A>]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L286"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "remove",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const remove: { <A>(value: A): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, value: A): SortedSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L312"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "some",
    "description": "Check if a predicate holds true for some `SortedSet` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const some: { <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L332"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "toggle",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const toggle: { <A>(value: A): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, value: A): SortedSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L351"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "union",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const union: { <A>(that: Iterable<A>): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, that: Iterable<A>): SortedSet<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L362"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "isSortedSet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isSortedSet: { <A>(u: Iterable<A>): u is SortedSet<A>; (u: unknown): u is SortedSet<unknown>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L83"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <A>(O: Order<A>) => SortedSet<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L92"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <K>(ord: Order<K>) => <Entries extends ReadonlyArray<K>>(...entries: Entries) => SortedSet<Entries[number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L113"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "size",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <A>(self: SortedSet<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L324"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "values",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const values: <A>(self: SortedSet<A>) => IterableIterator<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L384"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "getEquivalence",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "equivalence",
    "signature": "declare const getEquivalence: <A>() => Equivalence.Equivalence<SortedSet<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L390"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "SortedSet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SortedSet<in out A> extends Iterable<A>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _A: Invariant<A>\n  }\n  /** @internal */\n  readonly keyTree: RBT.RedBlackTree<A, boolean>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L31"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SortedSet.ts",
      "path": "src/SortedSet.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SortedSet.ts#L25"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "STMTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const STMTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L25"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "isSTM",
    "description": "Returns `true` if the provided value is an `STM`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isSTM: (u: unknown) => u is STM<unknown, unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L162"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "acquireUseRelease",
    "description": "Treats the specified `acquire` transaction as the acquisition of a\nresource. The `acquire` transaction will be executed interruptibly. If it\nis a success and is committed the specified `release` workflow will be\nexecuted uninterruptibly as soon as the `use` workflow completes execution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const acquireUseRelease: { <A, A2, E2, R2, A3, E3, R3>(use: (resource: A) => STM<A2, E2, R2>, release: (resource: A) => STM<A3, E3, R3>): <E, R>(acquire: STM<A, E, R>) => Effect.Effect<A2, E2 | E3 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(acquire: STM<A, E, R>, use: (resource: A) => STM<A2, E2, R2>, release: (resource: A) => STM<A3, E3, R3>): Effect.Effect<A2, E | E2 | E3, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L173"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "all",
    "description": "Runs all the provided transactional effects in sequence respecting the\nstructure provided in input.\n\nSupports multiple arguments, a single argument tuple / array or record /\nstruct.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const all: All.Signature",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L256"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "as",
    "description": "Maps the success value of this effect to the specified constant value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const as: { <A2>(value: A2): <A, E, R>(self: STM<A, E, R>) => STM<A2, E, R>; <A, E, R, A2>(self: STM<A, E, R>, value: A2): STM<A2, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L264"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "asSome",
    "description": "Maps the success value of this effect to an optional value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const asSome: <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L275"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "asSomeError",
    "description": "Maps the error value of this effect to an optional value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const asSomeError: <A, E, R>(self: STM<A, E, R>) => STM<A, Option.Option<E>, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L283"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "asVoid",
    "description": "This function maps the success value of an `STM` to `void`. If the original\n`STM` succeeds, the returned `STM` will also succeed. If the original `STM`\nfails, the returned `STM` will fail with the same error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const asVoid: <A, E, R>(self: STM<A, E, R>) => STM<void, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L293"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "attempt",
    "description": "Creates an `STM` value from a partial (but pure) function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const attempt: <A>(evaluate: LazyArg<A>) => STM<A, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L301"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "catchAll",
    "description": "Recovers from all errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const catchAll: { <E, B, E1, R1>(f: (e: E) => STM<B, E1, R1>): <A, R>(self: STM<A, E, R>) => STM<B | A, E1, R1 | R>; <A, E, R, B, E1, R1>(self: STM<A, E, R>, f: (e: E) => STM<B, E1, R1>): STM<A | B, E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L309"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "catchSome",
    "description": "Recovers from some or all of the error cases.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const catchSome: { <E, A2, E2, R2>(pf: (error: E) => Option.Option<STM<A2, E2, R2>>): <A, R>(self: STM<A, E, R>) => STM<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<STM<A2, E2, R2>>): STM<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L320"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "catchTag",
    "description": "Recovers from the specified tagged error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const catchTag: { <K extends E[\"_tag\"] & string, E extends { _tag: string; }, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => STM<A1, E1, R1>): <A, R>(self: STM<A, E, R>) => STM<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E extends { _tag: string; }, R, K extends E[\"_tag\"] & string, A1, E1, R1>(self: STM<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => STM<A1, E1, R1>): STM<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L336"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "catchTags",
    "description": "Recovers from multiple tagged errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const catchTags: { <E extends { _tag: string; }, Cases extends { [K in E[\"_tag\"]]+?: ((error: Extract<E, { _tag: K; }>) => STM<any, any, any>); }>(cases: Cases): <A, R>(self: STM<A, E, R>) => STM<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, any, infer R> ? R : never; }[keyof Cases]>; <R, E extends { _tag: string; }, A, Cases extends { [K in E[\"_tag\"]]+?: ((error: Extract<E, { _tag: K; }>) => STM<any, any, any>); }>(self: STM<A, E, R>, cases: Cases): STM<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, any, infer R> ? R : never; }[keyof Cases]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L354"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "check",
    "description": "Checks the condition, and if it's true, returns unit, otherwise, retries.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const check: (predicate: LazyArg<boolean>) => STM<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L394"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "collect",
    "description": "Simultaneously filters and maps the value produced by this effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const collect: { <A, A2>(pf: (a: A) => Option.Option<A2>): <E, R>(self: STM<A, E, R>) => STM<A2, E, R>; <A, E, R, A2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<A2>): STM<A2, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L402"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "collectSTM",
    "description": "Simultaneously filters and maps the value produced by this effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const collectSTM: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<STM<A2, E2, R2>>): <E, R>(self: STM<A, E, R>) => STM<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<STM<A2, E2, R2>>): STM<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L413"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "commit",
    "description": "Commits this transaction atomically.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const commit: <A, E, R>(self: STM<A, E, R>) => Effect.Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L424"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "commitEither",
    "description": "Commits this transaction atomically, regardless of whether the transaction\nis a success or a failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const commitEither: <A, E, R>(self: STM<A, E, R>) => Effect.Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L433"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "cond",
    "description": "Similar to Either.cond, evaluate the predicate, return the given A as\nsuccess if predicate returns true, and the given E as error otherwise",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const cond: <A, E>(predicate: LazyArg<boolean>, error: LazyArg<E>, result: LazyArg<A>) => STM<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L442"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "context",
    "description": "Retrieves the environment inside an stm.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const context: <R>() => STM<Context.Context<R>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L450"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "contextWith",
    "description": "Accesses the environment of the transaction to perform a transaction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const contextWith: <R0, R>(f: (environment: Context.Context<R0>) => R) => STM<R, never, R0>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L458"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "contextWithSTM",
    "description": "Accesses the environment of the transaction to perform a transaction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const contextWithSTM: <R0, A, E, R>(f: (environment: Context.Context<R0>) => STM<A, E, R>) => STM<A, E, R0 | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L466"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "mapInputContext",
    "description": "Transforms the environment being provided to this effect with the specified\nfunction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const mapInputContext: { <R0, R>(f: (context: Context.Context<R0>) => Context.Context<R>): <A, E>(self: STM<A, E, R>) => STM<A, E, R0>; <A, E, R0, R>(self: STM<A, E, R>, f: (context: Context.Context<R0>) => Context.Context<R>): STM<A, E, R0>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L477"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "die",
    "description": "Fails the transactional effect with the specified defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const die: (defect: unknown) => STM<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L488"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "dieMessage",
    "description": "Kills the fiber running the effect with a `Cause.RuntimeException` that\ncontains the specified message.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dieMessage: (message: string) => STM<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L497"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "dieSync",
    "description": "Fails the transactional effect with the specified lazily evaluated defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dieSync: (evaluate: LazyArg<unknown>) => STM<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L505"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "either",
    "description": "Converts the failure channel into an `Either`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const either: <A, E, R>(self: STM<A, E, R>) => STM<Either.Either<A, E>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L513"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "ensuring",
    "description": "Executes the specified finalization transaction whether or not this effect\nsucceeds. Note that as with all STM transactions, if the full transaction\nfails, everything will be rolled back.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "finalization",
    "signature": "declare const ensuring: { <R1, B>(finalizer: STM<B, never, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E, R1 | R>; <A, E, R, R1, B>(self: STM<A, E, R>, finalizer: STM<B, never, R1>): STM<A, E, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L523"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "eventually",
    "description": "Returns an effect that ignores errors and runs repeatedly until it\neventually succeeds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const eventually: <A, E, R>(self: STM<A, E, R>) => STM<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L535"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "every",
    "description": "Determines whether all elements of the `Iterable<A>` satisfy the effectual\npredicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const every: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<boolean, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<boolean, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L544"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "exists",
    "description": "Determines whether any element of the `Iterable[A]` satisfies the effectual\npredicate `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const exists: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<boolean, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<boolean, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L556"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "fail",
    "description": "Fails the transactional effect with the specified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fail: <E>(error: E) => STM<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L567"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "failSync",
    "description": "Fails the transactional effect with the specified lazily evaluated error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failSync: <E>(evaluate: LazyArg<E>) => STM<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L575"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "fiberId",
    "description": "Returns the fiber id of the fiber committing the transaction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fiberId: STM<FiberId.FiberId, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L583"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters the collection using the specified effectual predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const filter: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<Array<A>, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<Array<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L591"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "filterNot",
    "description": "Filters the collection using the specified effectual predicate, removing\nall elements that satisfy the predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const filterNot: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<Array<A>, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<Array<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L603"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "filterOrDie",
    "description": "Dies with specified defect if the predicate fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterOrDie: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, defect: LazyArg<unknown>): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, defect: LazyArg<unknown>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>, defect: LazyArg<unknown>): STM<B, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>, defect: LazyArg<unknown>): STM<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L614"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "filterOrDieMessage",
    "description": "Dies with a `Cause.RuntimeException` having the specified  message if the\npredicate fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterOrDieMessage: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>, message: string): STM<B, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>, message: string): STM<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L631"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "filterOrElse",
    "description": "Supplies `orElse` if the predicate fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterOrElse: { <A, B extends A, C, E2, R2>(refinement: Refinement<NoInfer<A>, B>, orElse: (a: NoInfer<A>) => STM<C, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<B | C, E2 | E, R2 | R>; <A, B, E2, R2>(predicate: Predicate<NoInfer<A>>, orElse: (a: NoInfer<A>) => STM<B, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<A | B, E2 | E, R2 | R>; <A, E, R, B extends A, C, E2, R2>(self: STM<A, E, R>, refinement: Refinement<A, B>, orElse: (a: A) => STM<C, E2, R2>): STM<B | C, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: STM<A, E, R>, predicate: Predicate<A>, orElse: (a: A) => STM<B, E2, R2>): STM<A | B, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L644"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "filterOrFail",
    "description": "Fails with the specified error if the predicate fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterOrFail: { <A, B extends A, E2>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: STM<A, E, R>) => STM<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R>; <A, E, R, B extends A, E2>(self: STM<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): STM<B, E | E2, R>; <A, E, R, E2>(self: STM<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): STM<A, E | E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L671"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Feeds the value produced by this effect to the specified function, and then\nruns the returned effect as well to produce its results.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMap: { <A, A2, E1, R1>(f: (a: A) => STM<A2, E1, R1>): <E, R>(self: STM<A, E, R>) => STM<A2, E1 | E, R1 | R>; <A, E, R, A2, E1, R1>(self: STM<A, E, R>, f: (a: A) => STM<A2, E1, R1>): STM<A2, E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L695"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens out a nested `STM` effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatten: <A, E2, R2, E, R>(self: STM<STM<A, E2, R2>, E, R>) => STM<A, E2 | E, R2 | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L706"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "flip",
    "description": "Flips the success and failure channels of this transactional effect. This\nallows you to use all methods on the error channel, possibly before\nflipping back.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const flip: <A, E, R>(self: STM<A, E, R>) => STM<E, A, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L716"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "flipWith",
    "description": "Swaps the error/value parameters, applies the function `f` and flips the\nparameters back",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const flipWith: { <E, A, R, E2, A2, R2>(f: (stm: STM<E, A, R>) => STM<E2, A2, R2>): (self: STM<A, E, R>) => STM<A | A2, E | E2, R | R2>; <A, E, R, E2, A2, R2>(self: STM<A, E, R>, f: (stm: STM<E, A, R>) => STM<E2, A2, R2>): STM<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L725"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Folds over the `STM` effect, handling both failure and success, but not\nretry.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const match: { <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: STM<A, E, R>) => STM<A2 | A3, never, R>; <A, E, R, A2, A3>(self: STM<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): STM<A2 | A3, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L737"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "matchSTM",
    "description": "Effectfully folds over the `STM` effect, handling both failure and success.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const matchSTM: { <E, A1, E1, R1, A, A2, E2, R2>(options: { readonly onFailure: (e: E) => STM<A1, E1, R1>; readonly onSuccess: (a: A) => STM<A2, E2, R2>; }): <R>(self: STM<A, E, R>) => STM<A1 | A2, E1 | E2, R1 | R2 | R>; <A, E, R, A1, E1, R1, A2, E2, R2>(self: STM<A, E, R>, options: { readonly onFailure: (e: E) => STM<A1, E1, R1>; readonly onSuccess: (a: A) => STM<A2, E2, R2>; }): STM<A1 | A2, E1 | E2, R | R1 | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L753"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "Applies the function `f` to each element of the `Iterable<A>` and returns\na transactional effect that produces a new `Chunk<A2>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const forEach: { <A, A2, E, R>(f: (a: A) => STM<A2, E, R>, options?: { readonly discard?: false | undefined; } | undefined): (elements: Iterable<A>) => STM<Array<A2>, E, R>; <A, A2, E, R>(f: (a: A) => STM<A2, E, R>, options: { readonly discard: true; }): (elements: Iterable<A>) => STM<void, E, R>; <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>, options?: { readonly discard?: false | undefined; } | undefined): STM<Array<A2>, E, R>; <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>, options: { readonly discard: true; }): STM<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L770"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "fromEither",
    "description": "Lifts an `Either` into a `STM`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromEither: <A, E>(either: Either.Either<A, E>) => STM<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L793"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "fromOption",
    "description": "Lifts an `Option` into a `STM`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromOption: <A>(option: Option.Option<A>) => STM<A, Option.Option<never>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L801"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "gen",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const gen: <Self, Eff extends YieldWrap<STM<any, any, any>>, AEff>(...args: [self: Self, body: (this: Self, resume: Adapter) => Generator<Eff, AEff, never>] | [body: (resume: Adapter) => Generator<Eff, AEff, never>]) => STM<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<STM<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<STM<infer _A, infer _E, infer R>>] ? R : never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1073"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "head",
    "description": "Returns a successful effect with the head of the list if the list is\nnon-empty or fails with the error `None` if the list is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const head: <A, E, R>(self: STM<Iterable<A>, E, R>) => STM<A, Option.Option<E>, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1093"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "ignore",
    "description": "Returns a new effect that ignores the success or failure of this effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const ignore: <A, E, R>(self: STM<A, E, R>) => STM<void, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1131"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "interrupt",
    "description": "Interrupts the fiber running the effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const interrupt: STM<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1139"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "interruptAs",
    "description": "Interrupts the fiber running the effect with the specified `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const interruptAs: (fiberId: FiberId.FiberId) => STM<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1147"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "isFailure",
    "description": "Returns whether this transactional effect is a failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isFailure: <A, E, R>(self: STM<A, E, R>) => STM<boolean, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1155"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "isSuccess",
    "description": "Returns whether this transactional effect is a success.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isSuccess: <A, E, R>(self: STM<A, E, R>) => STM<boolean, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1163"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "iterate",
    "description": "Iterates with the specified transactional function. The moral equivalent\nof:\n\n```ts skip-type-checking\nconst s = initial\n\nwhile (cont(s)) {\n  s = body(s)\n}\n\nreturn s\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const iterate: <Z, E, R>(initial: Z, options: { readonly while: Predicate<Z>; readonly body: (z: Z) => STM<Z, E, R>; }) => STM<Z, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1182"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "loop",
    "description": "Loops with the specified transactional function, collecting the results\ninto a list. The moral equivalent of:\n\n```ts skip-type-checking\nconst as = []\nlet s  = initial\n\nwhile (cont(s)) {\n  as.push(body(s))\n  s  = inc(s)\n}\n\nreturn as\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const loop: { <Z, A, E, R>(initial: Z, options: { readonly while: (z: Z) => boolean; readonly step: (z: Z) => Z; readonly body: (z: Z) => STM<A, E, R>; readonly discard?: false | undefined; }): STM<Array<A>, E, R>; <Z, A, E, R>(initial: Z, options: { readonly while: (z: Z) => boolean; readonly step: (z: Z) => Z; readonly body: (z: Z) => STM<A, E, R>; readonly discard: true; }): STM<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1209"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Maps the value produced by the effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A, E, R, B>(self: STM<A, E, R>, f: (a: A) => B): STM<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1236"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "mapAttempt",
    "description": "Maps the value produced by the effect with the specified function that may\nthrow exceptions but is otherwise pure, translating any thrown exceptions\ninto typed failed effects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapAttempt: { <A, B>(f: (a: A) => B): <E, R>(self: STM<A, E, R>) => STM<B, unknown, R>; <A, E, R, B>(self: STM<A, E, R>, f: (a: A) => B): STM<B, unknown, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1249"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "mapBoth",
    "description": "Returns an `STM` effect whose failure and success channels have been mapped\nby the specified pair of functions, `f` and `g`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (error: E) => E2; readonly onSuccess: (value: A) => A2; }): <R>(self: STM<A, E, R>) => STM<A2, E2, R>; <A, E, R, E2, A2>(self: STM<A, E, R>, options: { readonly onFailure: (error: E) => E2; readonly onSuccess: (value: A) => A2; }): STM<A2, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1261"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "mapError",
    "description": "Maps from one error type to another.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, f: (error: E) => E2): STM<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1277"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "merge",
    "description": "Returns a new effect where the error channel has been merged into the\nsuccess channel to their common combined type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const merge: <A, E, R>(self: STM<A, E, R>) => STM<E | A, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1289"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "mergeAll",
    "description": "Merges an `Iterable<STM>` to a single `STM`, working sequentially.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const mergeAll: { <A2, A>(zero: A2, f: (a2: A2, a: A) => A2): <E, R>(iterable: Iterable<STM<A, E, R>>) => STM<A2, E, R>; <A, E, R, A2>(iterable: Iterable<STM<A, E, R>>, zero: A2, f: (a2: A2, a: A) => A2): STM<A2, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1297"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "negate",
    "description": "Returns a new effect where boolean value of this effect is negated.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const negate: <E, R>(self: STM<boolean, E, R>) => STM<boolean, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1308"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "none",
    "description": "Requires the option produced by this value to be `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const none: <A, E, R>(self: STM<Option.Option<A>, E, R>) => STM<void, Option.Option<E>, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1316"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "option",
    "description": "Converts the failure channel into an `Option`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const option: <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1324"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "orDie",
    "description": "Translates `STM` effect failure into death of the fiber, making all\nfailures unchecked and not a part of the type of the effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orDie: <A, E, R>(self: STM<A, E, R>) => STM<A, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1333"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "orDieWith",
    "description": "Keeps none of the errors, and terminates the fiber running the `STM` effect\nwith them, using the specified function to convert the `E` into a defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orDieWith: { <E>(f: (error: E) => unknown): <A, R>(self: STM<A, E, R>) => STM<A, never, R>; <A, E, R>(self: STM<A, E, R>, f: (error: E) => unknown): STM<A, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1342"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "orElse",
    "description": "Tries this effect first, and if it fails or retries, tries the other\neffect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElse: { <A2, E2, R2>(that: LazyArg<STM<A2, E2, R2>>): <A, E, R>(self: STM<A, E, R>) => STM<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, that: LazyArg<STM<A2, E2, R2>>): STM<A | A2, E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1354"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "orElseEither",
    "description": "Returns a transactional effect that will produce the value of this effect\nin left side, unless it fails or retries, in which case, it will produce\nthe value of the specified effect in right side.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElseEither: { <A2, E2, R2>(that: LazyArg<STM<A2, E2, R2>>): <A, E, R>(self: STM<A, E, R>) => STM<Either.Either<A2, A>, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, that: LazyArg<STM<A2, E2, R2>>): STM<Either.Either<A2, A>, E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1367"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "orElseFail",
    "description": "Tries this effect first, and if it fails or retries, fails with the\nspecified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElseFail: { <E2>(error: LazyArg<E2>): <A, E, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, error: LazyArg<E2>): STM<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1379"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "orElseOptional",
    "description": "Returns an effect that will produce the value of this effect, unless it\nfails with the `None` value, in which case it will produce the value of the\nspecified effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElseOptional: { <A2, E2, R2>(that: LazyArg<STM<A2, Option.Option<E2>, R2>>): <A, E, R>(self: STM<A, Option.Option<E>, R>) => STM<A2 | A, Option.Option<E2 | E>, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, Option.Option<E>, R>, that: LazyArg<STM<A2, Option.Option<E2>, R2>>): STM<A | A2, Option.Option<E | E2>, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1392"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "orElseSucceed",
    "description": "Tries this effect first, and if it fails or retries, succeeds with the\nspecified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElseSucceed: { <A2>(value: LazyArg<A2>): <A, E, R>(self: STM<A, E, R>) => STM<A2 | A, never, R>; <A, E, R, A2>(self: STM<A, E, R>, value: LazyArg<A2>): STM<A | A2, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1409"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "orTry",
    "description": "Tries this effect first, and if it enters retry, then it tries the other\neffect. This is an equivalent of Haskell's orElse.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orTry: { <A1, E1, R1>(that: LazyArg<STM<A1, E1, R1>>): <A, E, R>(self: STM<A, E, R>) => STM<A1 | A, E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: LazyArg<STM<A1, E1, R1>>): STM<A | A1, E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1421"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "partition",
    "description": "Feeds elements of type `A` to a function `f` that returns an effect.\nCollects all successes and failures in a tupled fashion.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const partition: { <A, A2, E, R>(f: (a: A) => STM<A2, E, R>): (elements: Iterable<A>) => STM<[excluded: Array<E>, satisfying: Array<A2>], never, R>; <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>): STM<[excluded: Array<E>, satisfying: Array<A2>], never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1433"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "provideContext",
    "description": "Provides the transaction its required environment, which eliminates its\ndependency on `R`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideContext: { <R>(env: Context.Context<R>): <A, E>(self: STM<A, E, R>) => STM<A, E>; <A, E, R>(self: STM<A, E, R>, env: Context.Context<R>): STM<A, E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1450"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "provideSomeContext",
    "description": "Splits the context into two parts, providing one part using the\nspecified layer and leaving the remainder `R0`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideSomeContext: { <R>(context: Context.Context<R>): <R1, E, A>(self: STM<A, E, R1>) => STM<A, E, Exclude<R1, R>>; <R, R1, E, A>(self: STM<A, E, R1>, context: Context.Context<R>): STM<A, E, Exclude<R1, R>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1462"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "provideService",
    "description": "Provides the effect with the single service it requires. If the transactional\neffect requires more than one service use `provideEnvironment` instead.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideService: { <I, S>(tag: Context.Tag<I, S>, resource: NoInfer<S>): <A, E, R>(self: STM<A, E, R>) => STM<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: STM<A, E, R>, tag: Context.Tag<I, S>, resource: NoInfer<S>): STM<A, E, Exclude<R, I>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1474"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "provideServiceSTM",
    "description": "Provides the effect with the single service it requires. If the transactional\neffect requires more than one service use `provideEnvironment` instead.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideServiceSTM: { <I, S, E1, R1>(tag: Context.Tag<I, S>, stm: STM<NoInfer<S>, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E1 | E, R1 | Exclude<R, I>>; <A, E, R, I, S, E1, R1>(self: STM<A, E, R>, tag: Context.Tag<I, S>, stm: STM<NoInfer<S>, E1, R1>): STM<A, E1 | E, R1 | Exclude<R, I>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1486"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "reduce",
    "description": "Folds an `Iterable<A>` using an effectual function f, working sequentially\nfrom left to right.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const reduce: { <S, A, E, R>(zero: S, f: (s: S, a: A) => STM<S, E, R>): (iterable: Iterable<A>) => STM<S, E, R>; <S, A, E, R>(iterable: Iterable<A>, zero: S, f: (s: S, a: A) => STM<S, E, R>): STM<S, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1505"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "reduceAll",
    "description": "Reduces an `Iterable<STM>` to a single `STM`, working sequentially.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const reduceAll: { <A, E2, R2>(initial: STM<A, E2, R2>, f: (x: A, y: A) => A): <E, R>(iterable: Iterable<STM<A, E, R>>) => STM<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(iterable: Iterable<STM<A, E, R>>, initial: STM<A, E2, R2>, f: (x: A, y: A) => A): STM<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1516"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "reduceRight",
    "description": "Folds an `Iterable<A>` using an effectual function f, working sequentially\nfrom right to left.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const reduceRight: { <S, A, R, E>(zero: S, f: (s: S, a: A) => STM<S, E, R>): (iterable: Iterable<A>) => STM<S, E, R>; <S, A, R, E>(iterable: Iterable<A>, zero: S, f: (s: S, a: A) => STM<S, E, R>): STM<S, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1535"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "refineOrDie",
    "description": "Keeps some of the errors, and terminates the fiber with the rest.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const refineOrDie: { <E, E2>(pf: (error: E) => Option.Option<E2>): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<E2>): STM<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1546"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "refineOrDieWith",
    "description": "Keeps some of the errors, and terminates the fiber with the rest, using the\nspecified function to convert the `E` into a `Throwable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const refineOrDieWith: { <E, E2>(pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): STM<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1558"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "reject",
    "description": "Fail with the returned value if the `PartialFunction` matches, otherwise\ncontinue with our held value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const reject: { <A, E2>(pf: (a: A) => Option.Option<E2>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R>; <A, E, R, E2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<E2>): STM<A, E | E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1570"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "rejectSTM",
    "description": "Continue with the returned computation if the specified partial function\nmatches, translating the successful match into a failure, otherwise continue\nwith our held value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const rejectSTM: { <A, E2, R2>(pf: (a: A) => Option.Option<STM<E2, E2, R2>>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<STM<E2, E2, R2>>): STM<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1583"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "repeatUntil",
    "description": "Repeats this `STM` effect until its result satisfies the specified\npredicate.\n\n**WARNING**: `repeatUntil` uses a busy loop to repeat the effect and will\nconsume a thread until it completes (it cannot yield). This is because STM\ndescribes a single atomic transaction which must either complete, retry or\nfail a transaction before yielding back to the Effect runtime.\n  - Use `retryUntil` instead if you don't need to maintain transaction\n    state for repeats.\n  - Ensure repeating the STM effect will eventually satisfy the predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const repeatUntil: { <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1603"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "repeatWhile",
    "description": "Repeats this `STM` effect while its result satisfies the specified\npredicate.\n\n**WARNING**: `repeatWhile` uses a busy loop to repeat the effect and will\nconsume a thread until it completes (it cannot yield). This is because STM\ndescribes a single atomic transaction which must either complete, retry or\nfail a transaction before yielding back to the Effect runtime.\n  - Use `retryWhile` instead if you don't need to maintain transaction\n    state for repeats.\n  - Ensure repeating the STM effect will eventually not satisfy the\n    predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const repeatWhile: { <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1624"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "replicate",
    "description": "Replicates the given effect n times. If 0 or negative numbers are given, an\nempty `Chunk` will be returned.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const replicate: { (n: number): <A, E, R>(self: STM<A, E, R>) => Array<STM<A, E, R>>; <A, E, R>(self: STM<A, E, R>, n: number): Array<STM<A, E, R>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1636"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "replicateSTM",
    "description": "Performs this transaction the specified number of times and collects the\nresults.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const replicateSTM: { (n: number): <A, E, R>(self: STM<A, E, R>) => STM<Array<A>, E, R>; <A, E, R>(self: STM<A, E, R>, n: number): STM<Array<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1648"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "replicateSTMDiscard",
    "description": "Performs this transaction the specified number of times, discarding the\nresults.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const replicateSTMDiscard: { (n: number): <A, E, R>(self: STM<A, E, R>) => STM<void, E, R>; <A, E, R>(self: STM<A, E, R>, n: number): STM<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1660"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "retry",
    "description": "Abort and retry the whole transaction when any of the underlying\ntransactional variables have changed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const retry: STM<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1672"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "retryUntil",
    "description": "Filters the value produced by this effect, retrying the transaction until\nthe predicate returns `true` for the value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const retryUntil: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>): STM<B, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1681"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "retryWhile",
    "description": "Filters the value produced by this effect, retrying the transaction while\nthe predicate returns `true` for the value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const retryWhile: { <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1695"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "some",
    "description": "Converts an option on values into an option on errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const some: <A, E, R>(self: STM<Option.Option<A>, E, R>) => STM<A, Option.Option<E>, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1706"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "succeed",
    "description": "Returns an `STM` effect that succeeds with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const succeed: <A>(value: A) => STM<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1714"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "succeedNone",
    "description": "Returns an effect with the empty value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const succeedNone: STM<Option.Option<never>, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1722"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "succeedSome",
    "description": "Returns an effect with the optional value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const succeedSome: <A>(value: A) => STM<Option.Option<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1730"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "summarized",
    "description": "Summarizes a `STM` effect by computing a provided value before and after\nexecution, and then combining the values to produce a summary, together\nwith the result of execution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const summarized: { <A2, E2, R2, A3>(summary: STM<A2, E2, R2>, f: (before: A2, after: A2) => A3): <A, E, R>(self: STM<A, E, R>) => STM<[A3, A], E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: STM<A, E, R>, summary: STM<A2, E2, R2>, f: (before: A2, after: A2) => A3): STM<[A3, A], E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1740"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "suspend",
    "description": "Suspends creation of the specified transaction lazily.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const suspend: <A, E, R>(evaluate: LazyArg<STM<A, E, R>>) => STM<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1758"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "sync",
    "description": "Returns an `STM` effect that succeeds with the specified lazily evaluated\nvalue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sync: <A>(evaluate: () => A) => STM<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1767"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "tap",
    "description": "\"Peeks\" at the success of transactional effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const tap: { <A, X, E2, R2>(f: (a: A) => STM<X, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: STM<A, E, R>, f: (a: A) => STM<X, E2, R2>): STM<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1775"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "tapBoth",
    "description": "\"Peeks\" at both sides of an transactional effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const tapBoth: { <XE extends E, A2, E2, R2, XA extends A, A3, E3, R3, A, E>(options: { readonly onFailure: (error: XE) => STM<A2, E2, R2>; readonly onSuccess: (value: XA) => STM<A3, E3, R3>; }): <R>(self: STM<A, E, R>) => STM<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, XE extends E, A2, E2, R2, XA extends A, A3, E3, R3>(self: STM<A, E, R>, options: { readonly onFailure: (error: XE) => STM<A2, E2, R2>; readonly onSuccess: (value: XA) => STM<A3, E3, R3>; }): STM<A, E | E2 | E3, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1786"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "tapError",
    "description": "\"Peeks\" at the error of the transactional effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const tapError: { <E, X, E2, R2>(f: (error: NoInfer<E>) => STM<X, E2, R2>): <A, R>(self: STM<A, E, R>) => STM<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: STM<A, E, R>, f: (error: E) => STM<X, E2, R2>): STM<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1802"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "unless",
    "description": "The moral equivalent of `if (!p) exp`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const unless: { (predicate: LazyArg<boolean>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: LazyArg<boolean>): STM<Option.Option<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1832"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "unlessSTM",
    "description": "The moral equivalent of `if (!p) exp` when `p` has side-effects",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const unlessSTM: { <E2, R2>(predicate: STM<boolean, E2, R2>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: STM<A, E, R>, predicate: STM<boolean, E2, R2>): STM<Option.Option<A>, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1843"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "unsome",
    "description": "Converts an option on errors into an option on values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const unsome: <A, E, R>(self: STM<A, Option.Option<E>, R>) => STM<Option.Option<A>, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1854"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "validateAll",
    "description": "Feeds elements of type `A` to `f` and accumulates all errors in error\nchannel or successes in success channel.\n\nThis combinator is lossy meaning that if there are errors all successes\nwill be lost. To retain all information please use `STM.partition`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const validateAll: { <A, B, E, R>(f: (a: A) => STM<B, E, R>): (elements: Iterable<A>) => STM<Array<B>, [E, ...Array<E>], R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A) => STM<B, E, R>): STM<Array<B>, [E, ...Array<E>], R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1877"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "validateFirst",
    "description": "Feeds elements of type `A` to `f` until it succeeds. Returns first success\nor the accumulation of all errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const validateFirst: { <A, B, E, R>(f: (a: A) => STM<B, E, R>): (elements: Iterable<A>) => STM<B, Array<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A) => STM<B, E, R>): STM<B, Array<E>, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1889"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "when",
    "description": "The moral equivalent of `if (p) exp`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const when: { (predicate: LazyArg<boolean>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: LazyArg<boolean>): STM<Option.Option<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1900"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "whenSTM",
    "description": "The moral equivalent of `if (p) exp` when `p` has side-effects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const whenSTM: { <E2, R2>(predicate: STM<boolean, E2, R2>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: STM<A, E, R>, predicate: STM<boolean, E2, R2>): STM<Option.Option<A>, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1911"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Sequentially zips this value with the specified one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zip: { <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<[A, A1], E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<[A, A1], E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1922"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Sequentially zips this value with the specified one, discarding the second\nelement of the tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipLeft: { <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<A, E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1934"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Sequentially zips this value with the specified one, discarding the first\nelement of the tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipRight: { <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A1, E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<A1, E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1946"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Sequentially zips this value with the specified one, combining the values\nusing the specified combiner function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWith: { <A1, E1, R1, A, A2>(that: STM<A1, E1, R1>, f: (a: A, b: A1) => A2): <E, R>(self: STM<A, E, R>) => STM<A2, E1 | E, R1 | R>; <A, E, R, A1, E1, R1, A2>(self: STM<A, E, R>, that: STM<A1, E1, R1>, f: (a: A, b: A1) => A2): STM<A2, E | E1, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1958"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "Do",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "declare const Do: STM<{}, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L2000"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "bind",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "declare const bind: { <N extends string, K, A, E2, R2>(tag: Exclude<N, keyof K>, f: (_: NoInfer<K>) => STM<A, E2, R2>): <E, R>(self: STM<K, E, R>) => STM<MergeRecord<K, { [k in N]: A; }>, E2 | E, R2 | R>; <K, E, R, N extends string, A, E2, R2>(self: STM<K, E, R>, tag: Exclude<N, keyof K>, f: (_: NoInfer<K>) => STM<A, E2, R2>): STM<MergeRecord<K, { [k in N]: A; }>, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L2006"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "bindTo",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "declare const bindTo: { <N extends string>(tag: N): <A, E, R>(self: STM<A, E, R>) => STM<Record<N, A>, E, R>; <A, E, R, N extends string>(self: STM<A, E, R>, tag: N): STM<Record<N, A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L2042"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "firstSuccessOf",
    "description": "This function takes an iterable of `STM` values and returns a new\n`STM` value that represents the first `STM` value in the iterable\nthat succeeds. If all of the `Effect` values in the iterable fail, then\nthe resulting `STM` value will fail as well.\n\nThis function is sequential, meaning that the `STM` values in the\niterable will be executed in sequence, and the first one that succeeds\nwill determine the outcome of the resulting `STM` value.\n\nReturns a new `STM` value that represents the first successful\n`STM` value in the iterable, or a failed `STM` value if all of the\n`STM` values in the iterable fail.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const firstSuccessOf: <A, E, R>(effects: Iterable<STM<A, E, R>>) => STM<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L1983"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "STM",
    "description": "`STM<A, E, R>` represents an effect that can be performed transactionally,\n resulting in a failure `E` or a value `A` that may require an environment\n `R` to execute.\n\nSoftware Transactional Memory is a technique which allows composition of\narbitrary atomic operations.  It is the software analog of transactions in\ndatabase systems.\n\nThe API is lifted directly from the Haskell package Control.Concurrent.STM\nalthough the implementation does not resemble the Haskell one at all.\n\nSee http://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM.html\n\nSTM in Haskell was introduced in:\n\nComposable memory transactions, by Tim Harris, Simon Marlow, Simon Peyton\nJones, and Maurice Herlihy, in ACM Conference on Principles and Practice of\nParallel Programming 2005.\n\nSee https://www.microsoft.com/en-us/research/publication/composable-memory-transactions/\n\nSee also:\n Lock Free Data Structures using STMs in Haskell, by Anthony Discolo, Tim\n Harris, Simon Marlow, Simon Peyton Jones, Satnam Singh) FLOPS 2006: Eighth\n International Symposium on Functional and Logic Programming, Fuji Susono,\n JAPAN, April 2006\n\n https://www.microsoft.com/en-us/research/publication/lock-free-data-structures-using-stms-in-haskell/\n\nThe implemtation is based on the ZIO STM module, while JS environments have\nno race conditions from multiple threads STM provides greater benefits for\nsynchronization of Fibers and transactional data-types can be quite useful.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface STM<out A, out E = never, out R = never>\n  extends Effect.Effect<A, E, R>, STM.Variance<A, E, R>, Pipeable\n{\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: STMUnify<this>\n  [Unify.ignoreSymbol]?: STMUnifyIgnore\n  [Symbol.iterator](): Effect.EffectGenerator<STM<A, E, R>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L70"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "STMUnify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface STMUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  STM?: () => A[Unify.typeSymbol] extends STM<infer A0, infer E0, infer R0> | infer _ ? STM<A0, E0, R0> : never\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L83"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "STMUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface STMUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L91"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "STMTypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface STMTypeLambda extends TypeLambda {\n  readonly type: STM<this[\"Target\"], this[\"Out1\"], this[\"Out2\"]>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L99"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "Adapter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Adapter {\n  <A, E, R>(self: STM<A, E, R>): STM<A, E, R>\n  <A, _R, _E, _A>(a: A, ab: (a: A) => STM<_A, _E, _R>): STM<_A, _E, _R>\n  <A, B, _R, _E, _A>(a: A, ab: (a: A) => B, bc: (b: B) => STM<_A, _E, _R>): STM<_A, _E, _R>\n  <A, B, C, _R, _E, _A>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => STM<_A, _E, _R>): STM<_A, _E, _R>\n  <A, B, C, D, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: F) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (g: H) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => T,\n    tu: (s: T) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L807"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "STMTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type STMTypeId = typeof STMTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L31"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "STM.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out A, out E, out R> {\n    readonly [STMTypeId]: {\n      readonly _A: Covariant<A>\n      readonly _E: Covariant<E>\n      readonly _R: Covariant<R>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L147"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "All.Signature",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export interface Signature {\n    <\n      Arg extends ReadonlyArray<STMAny> | Iterable<STMAny> | Record<string, STMAny>,\n      O extends NoExcessProperties<Options, O>\n    >(\n      arg: Narrow<Arg>,\n      options?: O\n    ): [Arg] extends [ReadonlyArray<STMAny>] ? ReturnTuple<Arg, IsDiscard<O>>\n      : [Arg] extends [Iterable<STMAny>] ? ReturnIterable<Arg, IsDiscard<O>>\n      : [Arg] extends [Record<string, STMAny>] ? ReturnObject<Arg, IsDiscard<O>>\n      : never\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L232"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "STM.ts",
      "path": "src/STM.ts"
    },
    "project": "effect",
    "name": "All.Options",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "type Options = {\n    readonly discard?: boolean | undefined\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/STM.ts#L222"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "StreamTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const StreamTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L42"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "DefaultChunkSize",
    "description": "The default chunk size used by the various combinators and constructors of\n`Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constants",
    "signature": "declare const DefaultChunkSize: number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L172"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "accumulate",
    "description": "Collects each underlying Chunk of the stream into a new chunk, and emits it\non each pull.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const accumulate: <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L181"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "accumulateChunks",
    "description": "Re-chunks the elements of the stream by accumulating each underlying chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const accumulateChunks: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L189"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "acquireRelease",
    "description": "Creates a stream from a single value that will get cleaned up after the\nstream is consumed.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Console, Effect, Stream } from \"effect\"\n\n// Simulating File operations\nconst open = (filename: string) =>\n  Effect.gen(function*() {\n    yield* Console.log(`Opening ${filename}`)\n    return {\n      getLines: Effect.succeed([\"Line 1\", \"Line 2\", \"Line 3\"]),\n      close: Console.log(`Closing ${filename}`)\n    }\n  })\n\nconst stream = Stream.acquireRelease(\n  open(\"file.txt\"),\n  (file) => file.close\n).pipe(Stream.flatMap((file) => file.getLines))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Opening file.txt\n// Closing file.txt\n// { _id: 'Chunk', values: [ [ 'Line 1', 'Line 2', 'Line 3' ] ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const acquireRelease: <A, E, R, R2, X>(acquire: Effect.Effect<A, E, R>, release: (resource: A, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<X, never, R2>) => Stream<A, E, R | R2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L223"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "aggregate",
    "description": "Aggregates elements of this stream using the provided sink for as long as\nthe downstream operators on the stream are busy.\n\nThis operator divides the stream into two asynchronous \"islands\". Operators\nupstream of this operator run on one fiber, while downstream operators run\non another. Whenever the downstream fiber is busy processing elements, the\nupstream fiber will feed elements into the sink until it signals\ncompletion.\n\nAny sink can be used here, but see `Sink.foldWeightedEffect` and\n`Sink.foldUntilEffect` for sinks that cover the common usecases.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const aggregate: { <B, A, A2, E2, R2>(sink: Sink.Sink<B, A | A2, A2, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R>; <A, E, R, B, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>): Stream<B, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L244"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "aggregateWithin",
    "description": "Like {@link aggregateWithinEither}, but only returns the `Right` results.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const aggregateWithin: { <B, A, A2, E2, R2, C, R3>(sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R3 | R>; <A, E, R, B, A2, E2, R2, C, R3>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): Stream<B, E | E2, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L255"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "aggregateWithinEither",
    "description": "Aggregates elements using the provided sink until it completes, or until\nthe delay signalled by the schedule has passed.\n\nThis operator divides the stream into two asynchronous islands. Operators\nupstream of this operator run on one fiber, while downstream operators run\non another. Elements will be aggregated by the sink until the downstream\nfiber pulls the aggregated value, or until the schedule's delay has passed.\n\nAggregated elements will be fed into the schedule to determine the delays\nbetween pulls.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const aggregateWithinEither: { <B, A, A2, E2, R2, C, R3>(sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): <E, R>(self: Stream<A, E, R>) => Stream<Either.Either<B, C>, E2 | E, R2 | R3 | R>; <A, E, R, B, A2, E2, R2, C, R3>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): Stream<Either.Either<B, C>, E | E2, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L282"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "as",
    "description": "Maps the success values of this stream to the specified constant value.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.range(1, 5).pipe(Stream.as(null))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ null, null, null, null, null ] }\n```"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const as: { <B>(value: B): <A, E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, value: B): Stream<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L310"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "asyncEffect",
    "description": "Creates a stream from an asynchronous callback that can be called multiple\ntimes The registration of the callback itself returns an effect. The\noptionality of the error type `E` can be used to signal the end of the\nstream, by setting it to `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const asyncEffect: <A, E = never, R = never>(register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<unknown, E, R>, bufferSize?: number | \"unbounded\" | { readonly bufferSize?: number | undefined; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; } | undefined) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L372"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "asyncPush",
    "description": "Creates a stream from an external push-based resource.\n\nYou can use the `emit` helper to emit values to the stream. The `emit` helper\nreturns a boolean indicating whether the value was emitted or not.\n\nYou can also use the `emit` helper to signal the end of the stream by\nusing apis such as `emit.end` or `emit.fail`.\n\nBy default it uses an \"unbounded\" buffer size.\nYou can customize the buffer size and strategy by passing an object as the\nsecond argument with the `bufferSize` and `strategy` fields.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nStream.asyncPush<string>((emit) =>\n  Effect.acquireRelease(\n    Effect.gen(function*() {\n      yield* Effect.log(\"subscribing\")\n      return setInterval(() => emit.single(\"tick\"), 1000)\n    }),\n    (handle) =>\n      Effect.gen(function*() {\n        yield* Effect.log(\"unsubscribing\")\n        clearInterval(handle)\n      })\n  ), { bufferSize: 16, strategy: \"dropping\" })\n```"
    ],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "declare const asyncPush: <A, E = never, R = never>(register: (emit: Emit.EmitOpsPush<E, A>) => Effect.Effect<unknown, E, R | Scope.Scope>, options?: { readonly bufferSize: \"unbounded\"; } | { readonly bufferSize?: number | undefined; readonly strategy?: \"dropping\" | \"sliding\" | undefined; } | undefined) => Stream<A, E, Exclude<R, Scope.Scope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L414"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "asyncScoped",
    "description": "Creates a stream from an asynchronous callback that can be called multiple\ntimes. The registration of the callback itself returns an a scoped\nresource. The optionality of the error type `E` can be used to signal the\nend of the stream, by setting it to `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const asyncScoped: <A, E = never, R = never>(register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<unknown, E, R | Scope.Scope>, bufferSize?: number | \"unbounded\" | { readonly bufferSize?: number | undefined; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; } | undefined) => Stream<A, E, Exclude<R, Scope.Scope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L431"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "branchAfter",
    "description": "Returns a `Stream` that first collects `n` elements from the input `Stream`,\nand then creates a new `Stream` using the specified function, and sends all\nthe following elements through that.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const branchAfter: { <A, A2, E2, R2>(n: number, f: (input: Chunk.Chunk<A>) => Stream<A2, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, n: number, f: (input: Chunk.Chunk<A>) => Stream<A2, E2, R2>): Stream<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L447"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "broadcast",
    "description": "Fan out the stream, producing a list of streams that have the same elements\nas this stream. The driver stream will only ever advance the `maximumLag`\nchunks before the slowest downstream stream.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Console, Effect, Fiber, Schedule, Stream } from \"effect\"\n\nconst numbers = Effect.scoped(\n  Stream.range(1, 20).pipe(\n    Stream.tap((n) => Console.log(`Emit ${n} element before broadcasting`)),\n    Stream.broadcast(2, 5),\n    Stream.flatMap(([first, second]) =>\n      Effect.gen(function*() {\n        const fiber1 = yield* Stream.runFold(first, 0, (acc, e) => Math.max(acc, e)).pipe(\n          Effect.andThen((max) => Console.log(`Maximum: ${max}`)),\n          Effect.fork\n        )\n        const fiber2 = yield* second.pipe(\n          Stream.schedule(Schedule.spaced(\"1 second\")),\n          Stream.runForEach((n) => Console.log(`Logging to the Console: ${n}`)),\n          Effect.fork\n        )\n        yield* Fiber.join(fiber1).pipe(\n          Effect.zip(Fiber.join(fiber2), { concurrent: true })\n        )\n      })\n    ),\n    Stream.runCollect\n  )\n)\n\nEffect.runPromise(numbers).then(console.log)\n// Emit 1 element before broadcasting\n// Emit 2 element before broadcasting\n// Emit 3 element before broadcasting\n// Emit 4 element before broadcasting\n// Emit 5 element before broadcasting\n// Emit 6 element before broadcasting\n// Emit 7 element before broadcasting\n// Emit 8 element before broadcasting\n// Emit 9 element before broadcasting\n// Emit 10 element before broadcasting\n// Emit 11 element before broadcasting\n// Logging to the Console: 1\n// Logging to the Console: 2\n// Logging to the Console: 3\n// Logging to the Console: 4\n// Logging to the Console: 5\n// Emit 12 element before broadcasting\n// Emit 13 element before broadcasting\n// Emit 14 element before broadcasting\n// Emit 15 element before broadcasting\n// Emit 16 element before broadcasting\n// Logging to the Console: 6\n// Logging to the Console: 7\n// Logging to the Console: 8\n// Logging to the Console: 9\n// Logging to the Console: 10\n// Emit 17 element before broadcasting\n// Emit 18 element before broadcasting\n// Emit 19 element before broadcasting\n// Emit 20 element before broadcasting\n// Logging to the Console: 11\n// Logging to the Console: 12\n// Logging to the Console: 13\n// Logging to the Console: 14\n// Logging to the Console: 15\n// Maximum: 20\n// Logging to the Console: 16\n// Logging to the Console: 17\n// Logging to the Console: 18\n// Logging to the Console: 19\n// Logging to the Console: 20\n// { _id: 'Chunk', values: [ undefined ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const broadcast: { <N extends number>(n: N, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Stream<A, E>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, n: N, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<TupleOf<N, Stream<A, E>>, never, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L540"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "share",
    "description": "Returns a new Stream that multicasts the original Stream, subscribing to it as soon as the first consumer subscribes.\nAs long as there is at least one consumer, the upstream will continue running and emitting data.\nWhen all consumers have exited, the upstream will be finalized.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "utils",
    "signature": "declare const share: { <A, E>(config: { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; }): <R>(self: Stream<A, E, R>) => Effect.Effect<Stream<A, E>, never, R | Scope.Scope>; <A, E, R>(self: Stream<A, E, R>, config: { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; }): Effect.Effect<Stream<A, E>, never, R | Scope.Scope>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L568"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "broadcastDynamic",
    "description": "Fan out the stream, producing a dynamic number of streams that have the\nsame elements as this stream. The driver stream will only ever advance the\n`maximumLag` chunks before the slowest downstream stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const broadcastDynamic: { (maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Stream<A, E>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<Stream<A, E>, never, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L604"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "broadcastedQueues",
    "description": "Converts the stream to a scoped list of queues. Every value will be\nreplicated to every queue with the slowest queue being allowed to buffer\n`maximumLag` chunks before the driver is back pressured.\n\nQueues can unsubscribe from upstream by shutting down.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const broadcastedQueues: { <N extends number>(n: N, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, n: N, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L632"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "broadcastedQueuesDynamic",
    "description": "Converts the stream to a scoped dynamic amount of queues. Every chunk will\nbe replicated to every queue with the slowest queue being allowed to buffer\n`maximumLag` chunks before the driver is back pressured.\n\nQueues can unsubscribe from upstream by shutting down.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const broadcastedQueuesDynamic: { (maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L664"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "buffer",
    "description": "Allows a faster producer to progress independently of a slower consumer by\nbuffering up to `capacity` elements in a queue.\n\nNote: This combinator destroys the chunking structure. It's recommended to\n      use rechunk afterwards. Additionally, prefer capacities that are powers\n      of 2 for better performance.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Console, Effect, Schedule, Stream } from \"effect\"\n\nconst stream = Stream.range(1, 10).pipe(\n  Stream.tap((n) => Console.log(`before buffering: ${n}`)),\n  Stream.buffer({ capacity: 4 }),\n  Stream.tap((n) => Console.log(`after buffering: ${n}`)),\n  Stream.schedule(Schedule.spaced(\"5 seconds\"))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// before buffering: 1\n// before buffering: 2\n// before buffering: 3\n// before buffering: 4\n// before buffering: 5\n// before buffering: 6\n// after buffering: 1\n// after buffering: 2\n// before buffering: 7\n// after buffering: 3\n// before buffering: 8\n// after buffering: 4\n// before buffering: 9\n// after buffering: 5\n// before buffering: 10\n// ...\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const buffer: { (options: { readonly capacity: \"unbounded\"; } | { readonly capacity: number; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly capacity: \"unbounded\"; } | { readonly capacity: number; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; }): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L725"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "bufferChunks",
    "description": "Allows a faster producer to progress independently of a slower consumer by\nbuffering up to `capacity` chunks in a queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const bufferChunks: { (options: { readonly capacity: number; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly capacity: number; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; }): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L749"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "catchAll",
    "description": "Switches over to the stream produced by the provided function in case this\none fails with a typed error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const catchAll: { <E, A2, E2, R2>(f: (error: E) => Stream<A2, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (error: E) => Stream<A2, E2, R2>): Stream<A | A2, E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L766"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "catchAllCause",
    "description": "Switches over to the stream produced by the provided function in case this\none fails. Allows recovery from all causes of failure, including\ninterruption if the stream is uninterruptible.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const catchAllCause: { <E, A2, E2, R2>(f: (cause: Cause.Cause<E>) => Stream<A2, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Stream<A2, E2, R2>): Stream<A | A2, E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L779"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "catchSome",
    "description": "Switches over to the stream produced by the provided function in case this\none fails with some typed error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const catchSome: { <E, A2, E2, R2>(pf: (error: E) => Option.Option<Stream<A2, E2, R2>>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L796"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "catchTag",
    "description": "Switches over to the stream produced by the provided function in case this\none fails with an error matching the given `_tag`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const catchTag: { <K extends E[\"_tag\"] & string, E extends { _tag: string; }, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => Stream<A1, E1, R1>): <A, R>(self: Stream<A, E, R>) => Stream<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E extends { _tag: string; }, R, K extends E[\"_tag\"] & string, A1, E1, R1>(self: Stream<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Stream<A1, E1, R1>): Stream<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L813"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "catchTags",
    "description": "Switches over to the stream produced by one of the provided functions, in\ncase this one fails with an error matching one of the given `_tag`'s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const catchTags: { <E extends { _tag: string; }, Cases extends { [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K; }>) => Stream<any, any, any>; }>(cases: Cases): <A, R>(self: Stream<A, E, R>) => Stream<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer A, infer _E, infer _R> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _A, infer E, infer _R> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _A, infer _E, infer R> ? R : never; }[keyof Cases]>; <A, E extends { _tag: string; }, R, Cases extends { [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K; }>) => Stream<any, any, any>; }>(self: Stream<A, E, R>, cases: Cases): Stream<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _R, infer _E, infer A> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _R, infer E, infer _A> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer R, infer _E, infer _A> ? R : never; }[keyof Cases]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L832"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "catchSomeCause",
    "description": "Switches over to the stream produced by the provided function in case this\none fails with some errors. Allows recovery from all causes of failure,\nincluding interruption if the stream is uninterruptible.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const catchSomeCause: { <E, A2, E2, R2>(pf: (cause: Cause.Cause<E>) => Option.Option<Stream<A2, E2, R2>>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (cause: Cause.Cause<E>) => Option.Option<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L892"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "changes",
    "description": "Returns a new stream that only emits elements that are not equal to the\nprevious element emitted, using natural equality to determine whether two\nelements are equal.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 1, 1, 2, 2, 3, 4).pipe(Stream.changes)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const changes: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L920"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "changesWith",
    "description": "Returns a new stream that only emits elements that are not equal to the\nprevious element emitted, using the specified function to determine whether\ntwo elements are equal.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const changesWith: { <A>(f: (x: A, y: A) => boolean): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, f: (x: A, y: A) => boolean): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L930"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "changesWithEffect",
    "description": "Returns a new stream that only emits elements that are not equal to the\nprevious element emitted, using the specified effectual function to\ndetermine whether two elements are equal.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const changesWithEffect: { <A, E2, R2>(f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L943"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "chunks",
    "description": "Exposes the underlying chunks of the stream as a stream of chunks of\nelements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const chunks: <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L957"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "chunksWith",
    "description": "Performs the specified stream transformation with the chunk structure of\nthe stream exposed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const chunksWith: { <A, E, R, A2, E2, R2>(f: (stream: Stream<Chunk.Chunk<A>, E, R>) => Stream<Chunk.Chunk<A2>, E2, R2>): (self: Stream<A, E, R>) => Stream<A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (stream: Stream<Chunk.Chunk<A>, E, R>) => Stream<Chunk.Chunk<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L966"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "combine",
    "description": "Combines the elements from this stream and the specified stream by\nrepeatedly applying the function `f` to extract an element using both sides\nand conceptually \"offer\" it to the destination stream. `f` can maintain\nsome internal state to control the combining process, with the initial\nstate being specified by `s`.\n\nWhere possible, prefer `Stream.combineChunks` for a more efficient\nimplementation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const combine: { <A2, E2, R2, S, R3, E, A, R4, R5, A3>(that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<A, Option.Option<E>, R3>, pullRight: Effect.Effect<A2, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>): <R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>; <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<A, Option.Option<E>, R3>, pullRight: Effect.Effect<A2, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>): Stream<A3, E2 | E, R | R2 | R3 | R4 | R5>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L989"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "combineChunks",
    "description": "Combines the chunks from this stream and the specified stream by repeatedly\napplying the function `f` to extract a chunk using both sides and\nconceptually \"offer\" it to the destination stream. `f` can maintain some\ninternal state to control the combining process, with the initial state\nbeing specified by `s`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const combineChunks: { <A2, E2, R2, S, R3, E, A, R4, R5, A3>(that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>, pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>): <R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>; <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>, pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>): Stream<A3, E2 | E, R | R2 | R3 | R4 | R5>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1021"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "concat",
    "description": "Concatenates the specified stream with this stream, resulting in a stream\nthat emits the elements from this stream and then the elements from the\nspecified stream.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3)\nconst s2 = Stream.make(4, 5)\n\nconst stream = Stream.concat(s1, s2)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const concat: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1064"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "concatAll",
    "description": "Concatenates all of the streams in the chunk to one stream.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Chunk, Effect, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3)\nconst s2 = Stream.make(4, 5)\nconst s3 = Stream.make(6, 7, 8)\n\nconst stream = Stream.concatAll(Chunk.make(s1, s2, s3))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [\n//     1, 2, 3, 4,\n//     5, 6, 7, 8\n//   ]\n// }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const concatAll: <A, E, R>(streams: Chunk.Chunk<Stream<A, E, R>>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1095"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "cross",
    "description": "Composes this stream with the specified stream to create a cartesian\nproduct of elements. The `right` stream would be run multiple times, for\nevery element in the `left` stream.\n\nSee also `Stream.zip` for the more common point-wise variant.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3)\nconst s2 = Stream.make(\"a\", \"b\")\n\nconst product = Stream.cross(s1, s2)\n\nEffect.runPromise(Stream.runCollect(product)).then(console.log)\n// {\n//   _id: \"Chunk\",\n//   values: [\n//     [ 1, \"a\" ], [ 1, \"b\" ], [ 2, \"a\" ], [ 2, \"b\" ], [ 3, \"a\" ], [ 3, \"b\" ]\n//   ]\n// }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const cross: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<[AL, AR], EL | ER, RL | RR>; <AL, ER, RR, AR, EL, RL>(left: Stream<AL, ER, RR>, right: Stream<AR, EL, RL>): Stream<[AL, AR], EL | ER, RL | RR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1125"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "crossLeft",
    "description": "Composes this stream with the specified stream to create a cartesian\nproduct of elements, but keeps only elements from `left` stream. The `right`\nstream would be run multiple times, for every element in the `left` stream.\n\nSee also `Stream.zipLeft` for the more common point-wise variant.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const crossLeft: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1140"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "crossRight",
    "description": "Composes this stream with the specified stream to create a cartesian\nproduct of elements, but keeps only elements from the `right` stream. The\n`left` stream would be run multiple times, for every element in the `right`\nstream.\n\nSee also `Stream.zipRight` for the more common point-wise variant.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const crossRight: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1156"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "crossWith",
    "description": "Composes this stream with the specified stream to create a cartesian\nproduct of elements with a specified function. The `right` stream would be\nrun multiple times, for every element in the `left` stream.\n\nSee also `Stream.zipWith` for the more common point-wise variant.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const crossWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1171"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "debounce",
    "description": "Delays the emission of values by holding new values for a set duration. If\nno new values arrive during that time the value is emitted, however if a\nnew value is received during the holding period the previous value is\ndiscarded and the process is repeated with the new value.\n\nThis operator is useful if you have a stream of \"bursty\" events which\neventually settle down and you only need the final event of the burst. For\nexample, a search engine may only want to initiate a search after a user\nhas paused typing so as to not prematurely recommend results.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nlet last = Date.now()\nconst log = (message: string) =>\n  Effect.sync(() => {\n    const end = Date.now()\n    console.log(`${message} after ${end - last}ms`)\n    last = end\n  })\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.concat(\n    Stream.fromEffect(Effect.sleep(\"200 millis\").pipe(Effect.as(4))) // Emit 4 after 200 ms\n  ),\n  Stream.concat(Stream.make(5, 6)), // Continue with more rapid values\n  Stream.concat(\n    Stream.fromEffect(Effect.sleep(\"150 millis\").pipe(Effect.as(7))) // Emit 7 after 150 ms\n  ),\n  Stream.concat(Stream.make(8)),\n  Stream.tap((n) => log(`Received ${n}`)),\n  Stream.debounce(\"100 millis\"), // Only emit values after a pause of at least 100 milliseconds,\n  Stream.tap((n) => log(`> Emitted ${n}`))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Received 1 after 5ms\n// Received 2 after 2ms\n// Received 3 after 0ms\n// > Emitted 3 after 104ms\n// Received 4 after 99ms\n// Received 5 after 1ms\n// Received 6 after 0ms\n// > Emitted 6 after 101ms\n// Received 7 after 50ms\n// Received 8 after 1ms\n// > Emitted 8 after 101ms\n// { _id: 'Chunk', values: [ 3, 6, 8 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const debounce: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1238"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "die",
    "description": "The stream that dies with the specified defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const die: (defect: unknown) => Stream<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1249"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "dieSync",
    "description": "The stream that dies with the specified lazily evaluated defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dieSync: (evaluate: LazyArg<unknown>) => Stream<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1257"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "dieMessage",
    "description": "The stream that dies with an exception described by `message`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dieMessage: (message: string) => Stream<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1265"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "distributedWith",
    "description": "More powerful version of `Stream.broadcast`. Allows to provide a function\nthat determines what queues should receive which elements. The decide\nfunction will receive the indices of the queues in the resulting list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const distributedWith: { <N extends number, A>(options: { readonly size: N; readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>>; }): <E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, options: { readonly size: N; readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>>; }): Effect.Effect<TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>, never, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1275"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "distributedWithDynamic",
    "description": "More powerful version of `Stream.distributedWith`. This returns a function\nthat will produce new queues and corresponding indices. You can also\nprovide a function that will be executed after the final events are\nenqueued in all queues. Shutdown of the queues is handled by the driver.\nDownstream users can also shutdown queues manually. In this case the driver\nwill continue but no longer backpressure on them.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const distributedWithDynamic: { <A>(options: { readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>, never, never>; }): <E, R>(self: Stream<A, E, R>) => Effect.Effect<Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>], never, never>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>, never, never>; }): Effect.Effect<Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>], never, never>, never, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1306"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "drain",
    "description": "Converts this stream to a stream that executes its effects but emits no\nelements. Useful for sequencing effects using streams:",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\n// We create a stream and immediately drain it.\nconst stream = Stream.range(1, 6).pipe(Stream.drain)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const drain: <A, E, R>(self: Stream<A, E, R>) => Stream<never, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1344"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "drainFork",
    "description": "Drains the provided stream in the background for as long as this stream is\nrunning. If this stream ends before `other`, `other` will be interrupted.\nIf `other` fails, this stream will fail with that error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const drainFork: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1354"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "drop",
    "description": "Drops the specified number of elements from this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const drop: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1365"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "dropRight",
    "description": "Drops the last specified number of elements from this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const dropRight: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1378"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "dropUntil",
    "description": "Drops all elements of the stream until the specified predicate evaluates to\n`true`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const dropUntil: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1390"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "dropUntilEffect",
    "description": "Drops all elements of the stream until the specified effectful predicate\nevaluates to `true`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const dropUntilEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1402"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "dropWhile",
    "description": "Drops all elements of the stream for as long as the specified predicate\nevaluates to `true`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const dropWhile: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1419"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "dropWhileEffect",
    "description": "Drops all elements of the stream for as long as the specified predicate\nproduces an effect that evalutates to `true`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const dropWhileEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1431"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "either",
    "description": "Returns a stream whose failures and successes have been lifted into an\n`Either`. The resulting stream cannot fail, because the failures have been\nexposed as part of the `Either` success case.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const either: <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A, E>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1451"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "The empty stream.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.empty\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: Stream<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1469"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "ensuring",
    "description": "Executes the provided finalizer after this stream's finalizers run.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Console, Effect, Stream } from \"effect\"\n\nconst program = Stream.fromEffect(Console.log(\"Application Logic.\")).pipe(\n  Stream.concat(Stream.finalizer(Console.log(\"Finalizing the stream\"))),\n  Stream.ensuring(\n    Console.log(\"Doing some other works after stream's finalization\")\n  )\n)\n\nEffect.runPromise(Stream.runCollect(program)).then(console.log)\n// Application Logic.\n// Finalizing the stream\n// Doing some other works after stream's finalization\n// { _id: 'Chunk', values: [ undefined, undefined ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const ensuring: { <X, R2>(finalizer: Effect.Effect<X, never, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, finalizer: Effect.Effect<X, never, R2>): Stream<A, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1495"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "ensuringWith",
    "description": "Executes the provided finalizer after this stream's finalizers run.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const ensuringWith: { <E, R2>(finalizer: (exit: Exit.Exit<unknown, E>) => Effect.Effect<unknown, never, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, R2>(self: Stream<A, E, R>, finalizer: (exit: Exit.Exit<unknown, E>) => Effect.Effect<unknown, never, R2>): Stream<A, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1506"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "context",
    "description": "Accesses the whole context of the stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const context: <R>() => Stream<Context.Context<R>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1522"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "contextWith",
    "description": "Accesses the context of the stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const contextWith: <R, A>(f: (env: Context.Context<R>) => A) => Stream<A, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1530"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "contextWithEffect",
    "description": "Accesses the context of the stream in the context of an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const contextWithEffect: <R0, A, E, R>(f: (env: Context.Context<R0>) => Effect.Effect<A, E, R>) => Stream<A, E, R0 | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1538"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "contextWithStream",
    "description": "Accesses the context of the stream in the context of a stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const contextWithStream: <R0, A, E, R>(f: (env: Context.Context<R0>) => Stream<A, E, R>) => Stream<A, E, R0 | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1548"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "execute",
    "description": "Creates a stream that executes the specified effect but emits no elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const execute: <X, E, R>(effect: Effect.Effect<X, E, R>) => Stream<never, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1558"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fail",
    "description": "Terminates with the specified error.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.fail(\"Uh oh!\")\n\nEffect.runPromiseExit(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }\n// }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fail: <E>(error: E) => Stream<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1580"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "failSync",
    "description": "Terminates with the specified lazily evaluated error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failSync: <E>(evaluate: LazyArg<E>) => Stream<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1588"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "failCause",
    "description": "The stream that always fails with the specified `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failCause: <E>(cause: Cause.Cause<E>) => Stream<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1596"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "failCauseSync",
    "description": "The stream that always fails with the specified lazily evaluated `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Stream<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1604"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters the elements emitted by this stream using the provided function.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.range(1, 11).pipe(Stream.filter((n) => n % 2 === 0))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 2, 4, 6, 8, 10 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, B extends A>(predicate: Predicate<B>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1622"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "filterEffect",
    "description": "Effectfully filters the elements emitted by this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterEffect: { <A, E2, R2>(f: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1635"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Performs a filter and map in a single step.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const filterMap: { <A, B>(pf: (a: A) => Option.Option<B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<B>): Stream<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1648"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "filterMapEffect",
    "description": "Performs an effectful filter and map in a single step.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const filterMapEffect: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1659"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "filterMapWhile",
    "description": "Transforms all elements of the stream for as long as the specified partial\nfunction is defined.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const filterMapWhile: { <A, A2>(pf: (a: A) => Option.Option<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<A2>): Stream<A2, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1676"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "filterMapWhileEffect",
    "description": "Effectfully transforms all elements of the stream for as long as the\nspecified partial function is defined.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const filterMapWhileEffect: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1688"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "finalizer",
    "description": "Creates a one-element stream that never fails and executes the finalizer\nwhen it ends.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Console, Effect, Stream } from \"effect\"\n\nconst application = Stream.fromEffect(Console.log(\"Application Logic.\"))\n\nconst deleteDir = (dir: string) => Console.log(`Deleting dir: ${dir}`)\n\nconst program = application.pipe(\n  Stream.concat(\n    Stream.finalizer(\n      deleteDir(\"tmp\").pipe(\n        Effect.andThen(Console.log(\"Temporary directory was deleted.\"))\n      )\n    )\n  )\n)\n\nEffect.runPromise(Stream.runCollect(program)).then(console.log)\n// Application Logic.\n// Deleting dir: tmp\n// Temporary directory was deleted.\n// { _id: 'Chunk', values: [ undefined, undefined ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const finalizer: <R, X>(finalizer: Effect.Effect<X, never, R>) => Stream<void, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1730"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "find",
    "description": "Finds the first element emitted by this stream that satisfies the provided\npredicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const find: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1739"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "findEffect",
    "description": "Finds the first element emitted by this stream that satisfies the provided\neffectful predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1753"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Returns a stream made of the concatenation in strict order of all the\nstreams produced by passing each element of this stream to `f0`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatMap: { <A, A2, E2, R2>(f: (a: A) => Stream<A2, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; readonly switch?: boolean | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Stream<A2, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; readonly switch?: boolean | undefined; } | undefined): Stream<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1770"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens this stream-of-streams into a stream made of the concatenation in\nstrict order of all the streams.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flatten: { (options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; } | undefined): <A, E2, R2, E, R>(self: Stream<Stream<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E2, R2, E, R>(self: Stream<Stream<A, E2, R2>, E, R>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; } | undefined): Stream<A, E2 | E, R2 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1797"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "flattenChunks",
    "description": "Submerges the chunks carried by this stream into the stream's structure,\nwhile still preserving them.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flattenChunks: <A, E, R>(self: Stream<Chunk.Chunk<A>, E, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1818"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "flattenEffect",
    "description": "Flattens `Effect` values into the stream's structure, preserving all\ninformation about the effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flattenEffect: { (options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly unordered?: boolean | undefined; } | undefined): <A, E2, R2, E, R>(self: Stream<Effect.Effect<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E2, R2, E, R>(self: Stream<Effect.Effect<A, E2, R2>, E, R>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly unordered?: boolean | undefined; } | undefined): Stream<A, E2 | E, R2 | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1827"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "flattenExitOption",
    "description": "Unwraps `Exit` values that also signify end-of-stream by failing with `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flattenExitOption: <A, E2, E, R>(self: Stream<Exit.Exit<A, Option.Option<E2>>, E, R>) => Stream<A, E | E2, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1847"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "flattenIterables",
    "description": "Submerges the iterables carried by this stream into the stream's structure,\nwhile still preserving them.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flattenIterables: <A, E, R>(self: Stream<Iterable<A>, E, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1858"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "flattenTake",
    "description": "Unwraps `Exit` values and flatten chunks that also signify end-of-stream\nby failing with `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const flattenTake: <A, E2, E, R>(self: Stream<Take.Take<A, E2>, E, R>) => Stream<A, E | E2, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1867"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "forever",
    "description": "Repeats this stream forever.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const forever: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1876"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromAsyncIterable",
    "description": "Creates a stream from an `AsyncIterable`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst myAsyncIterable = async function*() {\n  yield 1\n  yield 2\n}\n\nconst stream = Stream.fromAsyncIterable(\n  myAsyncIterable(),\n  (e) => new Error(String(e)) // Error Handling\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromAsyncIterable: <A, E>(iterable: AsyncIterable<A>, onError: (e: unknown) => E) => Stream<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1902"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromChannel",
    "description": "Creates a stream from a `Channel`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromChannel: <A, E, R>(channel: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1911"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "toChannel",
    "description": "Creates a channel from a `Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const toChannel: <A, E, R>(stream: Stream<A, E, R>) => Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1921"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromChunk",
    "description": "Creates a stream from a `Chunk` of values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Chunk, Effect, Stream } from \"effect\"\n\n// Creating a stream with values from a single Chunk\nconst stream = Stream.fromChunk(Chunk.make(1, 2, 3))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromChunk: <A>(chunk: Chunk.Chunk<A>) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1942"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromChunkPubSub",
    "description": "Creates a stream from a subscription to a `PubSub`.\n\n**Options**\n\n- `shutdown`: If `true`, the `PubSub` will be shutdown after the stream is evaluated (defaults to `false`)",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromChunkPubSub: { <A>(pubsub: PubSub.PubSub<Chunk.Chunk<A>>, options: { readonly scoped: true; readonly shutdown?: boolean | undefined; }): Effect.Effect<Stream<A>, never, Scope.Scope>; <A>(pubsub: PubSub.PubSub<Chunk.Chunk<A>>, options?: { readonly scoped?: false | undefined; readonly shutdown?: boolean | undefined; } | undefined): Stream<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1954"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromChunkQueue",
    "description": "Creates a stream from a `Queue` of values.\n\n**Options**\n\n- `shutdown`: If `true`, the queue will be shutdown after the stream is evaluated (defaults to `false`)",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromChunkQueue: <A>(queue: Queue.Dequeue<Chunk.Chunk<A>>, options?: { readonly shutdown?: boolean | undefined; }) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1975"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromChunks",
    "description": "Creates a stream from an arbitrary number of chunks.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Chunk, Effect, Stream } from \"effect\"\n\n// Creating a stream with values from multiple Chunks\nconst stream = Stream.fromChunks(Chunk.make(1, 2, 3), Chunk.make(4, 5, 6))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromChunks: <A>(...chunks: Array<Chunk.Chunk<A>>) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L1999"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromEffect",
    "description": "Either emits the success value of this effect or terminates the stream\nwith the failure value of this effect.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Random, Stream } from \"effect\"\n\nconst stream = Stream.fromEffect(Random.nextInt)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Example Output: { _id: 'Chunk', values: [ 922694024 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2018"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromEffectOption",
    "description": "Creates a stream from an effect producing a value of type `A` or an empty\n`Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromEffectOption: <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2027"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromPubSub",
    "description": "Creates a stream from a subscription to a `PubSub`.\n\n**Options**\n\n- `shutdown`: If `true`, the `PubSub` will be shutdown after the stream is evaluated (defaults to `false`)",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromPubSub: { <A>(pubsub: PubSub.PubSub<A>, options: { readonly scoped: true; readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; }): Effect.Effect<Stream<A>, never, Scope.Scope>; <A>(pubsub: PubSub.PubSub<A>, options?: { readonly scoped?: false | undefined; readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; } | undefined): Stream<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2040"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromTPubSub",
    "description": "Creates a stream from a subscription to a `TPubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const fromTPubSub: <A>(pubsub: TPubSub<A>) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2065"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `Stream` from an iterable collection of values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst numbers = [1, 2, 3]\n\nconst stream = Stream.fromIterable(numbers)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: <A>(iterable: Iterable<A>) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2085"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromIterableEffect",
    "description": "Creates a stream from an effect producing a value of type `Iterable<A>`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Context, Effect, Stream } from \"effect\"\n\nclass Database extends Context.Tag(\"Database\")<\n  Database,\n  { readonly getUsers: Effect.Effect<Array<string>> }\n>() {}\n\nconst getUsers = Database.pipe(Effect.andThen((_) => _.getUsers))\n\nconst stream = Stream.fromIterableEffect(getUsers)\n\nEffect.runPromise(\n  Stream.runCollect(stream.pipe(Stream.provideService(Database, { getUsers: Effect.succeed([\"user1\", \"user2\"]) })))\n).then(console.log)\n// { _id: 'Chunk', values: [ 'user1', 'user2' ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterableEffect: <A, E, R>(effect: Effect.Effect<Iterable<A>, E, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2112"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromIteratorSucceed",
    "description": "Creates a stream from an iterator",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIteratorSucceed: <A>(iterator: IterableIterator<A>, maxChunkSize?: number) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2121"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromPull",
    "description": "Creates a stream from an effect that pulls elements from another stream.\n\nSee `Stream.toPull` for reference.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromPull: <R, R2, E, A>(effect: Effect.Effect<Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R2>, never, Scope.Scope | R>) => Stream<A, E, R2 | Exclude<R, Scope.Scope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2132"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromQueue",
    "description": "Creates a stream from a queue of values\n\n**Options**\n\n- `maxChunkSize`: The maximum number of queued elements to put in one chunk in the stream\n- `shutdown`: If `true`, the queue will be shutdown after the stream is evaluated (defaults to `false`)",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromQueue: <A>(queue: Queue.Dequeue<A>, options?: { readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; }) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2147"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromTQueue",
    "description": "Creates a stream from a TQueue of values",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const fromTQueue: <A>(queue: TDequeue<A>) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2161"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromReadableStream",
    "description": "Creates a stream from a `ReadableStream`.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromReadableStream: { <A, E>(options: { readonly evaluate: LazyArg<ReadableStream<A>>; readonly onError: (error: unknown) => E; readonly releaseLockOnEnd?: boolean | undefined; }): Stream<A, E>; <A, E>(evaluate: LazyArg<ReadableStream<A>>, onError: (error: unknown) => E): Stream<A, E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2171"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromReadableStreamByob",
    "description": "Creates a stream from a `ReadableStreamBYOBReader`.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamBYOBReader.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromReadableStreamByob: { <E>(options: { readonly evaluate: LazyArg<ReadableStream<Uint8Array>>; readonly onError: (error: unknown) => E; readonly bufferSize?: number | undefined; readonly releaseLockOnEnd?: boolean | undefined; }): Stream<Uint8Array, E>; <E>(evaluate: LazyArg<ReadableStream<Uint8Array>>, onError: (error: unknown) => E, allocSize?: number): Stream<Uint8Array, E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2190"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromSchedule",
    "description": "Creates a stream from a `Schedule` that does not require any further\ninput. The stream will emit an element for each value output from the\nschedule, continuing for as long as the schedule continues.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Schedule, Stream } from \"effect\"\n\n// Emits values every 1 second for a total of 5 emissions\nconst schedule = Schedule.spaced(\"1 second\").pipe(\n  Schedule.compose(Schedule.recurs(5))\n)\n\nconst stream = Stream.fromSchedule(schedule)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromSchedule: <A, R>(schedule: Schedule.Schedule<A, unknown, R>) => Stream<A, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2230"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "groupAdjacentBy",
    "description": "Creates a pipeline that groups on adjacent keys, calculated by the\nspecified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "declare const groupAdjacentBy: { <A, K>(f: (a: A) => K): <E, R>(self: Stream<A, E, R>) => Stream<[K, Chunk.NonEmptyChunk<A>], E, R>; <A, E, R, K>(self: Stream<A, E, R>, f: (a: A) => K): Stream<[K, Chunk.NonEmptyChunk<A>], E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2240"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "groupBy",
    "description": "More powerful version of `Stream.groupByKey`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Chunk, Effect, GroupBy, Stream } from \"effect\"\n\nconst groupByKeyResult = Stream.fromIterable([\n  \"Mary\",\n  \"James\",\n  \"Robert\",\n  \"Patricia\",\n  \"John\",\n  \"Jennifer\",\n  \"Rebecca\",\n  \"Peter\"\n]).pipe(\n  Stream.groupBy((name) => Effect.succeed([name.substring(0, 1), name]))\n)\n\nconst stream = GroupBy.evaluate(groupByKeyResult, (key, stream) =>\n  Stream.fromEffect(\n    Stream.runCollect(stream).pipe(\n      Effect.andThen((chunk) => [key, Chunk.size(chunk)] as const)\n    )\n  ))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [ [ 'M', 1 ], [ 'J', 3 ], [ 'R', 2 ], [ 'P', 2 ] ]\n// }\n```"
    ],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "declare const groupBy: { <A, K, V, E2, R2>(f: (a: A) => Effect.Effect<readonly [K, V], E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => GroupBy.GroupBy<K, V, E2 | E, R2 | R>; <A, E, R, K, V, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<readonly [K, V], E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): GroupBy.GroupBy<K, V, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2282"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "groupByKey",
    "description": "Partition a stream using a function and process each stream individually.\nThis returns a data structure that can be used to further filter down which\ngroups shall be processed.\n\nAfter calling apply on the GroupBy object, the remaining groups will be\nprocessed in parallel and the resulting streams merged in a\nnondeterministic fashion.\n\nUp to `buffer` elements may be buffered in any group stream before the\nproducer is backpressured. Take care to consume from all streams in order\nto prevent deadlocks.\n\nFor example, to collect the first 2 words for every starting letter from a\nstream of words:\n\n```ts\nimport { pipe, GroupBy, Stream } from \"effect\"\n\npipe(\n  Stream.fromIterable([\"hello\", \"world\", \"hi\", \"holla\"]),\n  Stream.groupByKey((word) => word[0]),\n  GroupBy.evaluate((key, stream) =>\n    pipe(\n      stream,\n      Stream.take(2),\n      Stream.map((words) => [key, words] as const)\n    )\n  )\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "declare const groupByKey: { <A, K>(f: (a: A) => K, options?: { readonly bufferSize?: number | undefined; }): <E, R>(self: Stream<A, E, R>) => GroupBy.GroupBy<K, A, E, R>; <A, E, R, K>(self: Stream<A, E, R>, f: (a: A) => K, options?: { readonly bufferSize?: number | undefined; }): GroupBy.GroupBy<K, A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2329"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "grouped",
    "description": "Partitions the stream with specified `chunkSize`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.range(0, 8).pipe(Stream.grouped(3))\n\nEffect.runPromise(Stream.runCollect(stream)).then((chunks) => console.log(\"%o\", chunks))\n// {\n//   _id: 'Chunk',\n//   values: [\n//     { _id: 'Chunk', values: [ 0, 1, 2, [length]: 3 ] },\n//     { _id: 'Chunk', values: [ 3, 4, 5, [length]: 3 ] },\n//     { _id: 'Chunk', values: [ 6, 7, 8, [length]: 3 ] },\n//     [length]: 3\n//   ]\n// }\n```"
    ],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "declare const grouped: { (chunkSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number): Stream<Chunk.Chunk<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2369"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "groupedWithin",
    "description": "Partitions the stream with the specified `chunkSize` or until the specified\n`duration` has passed, whichever is satisfied first.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Chunk, Effect, Schedule, Stream } from \"effect\"\n\nconst stream = Stream.range(0, 9).pipe(\n  Stream.repeat(Schedule.spaced(\"1 second\")),\n  Stream.groupedWithin(18, \"1.5 seconds\"),\n  Stream.take(3)\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then((chunks) => console.log(Chunk.toArray(chunks)))\n// [\n//   {\n//     _id: 'Chunk',\n//     values: [\n//       0, 1, 2, 3, 4, 5, 6,\n//       7, 8, 9, 0, 1, 2, 3,\n//       4, 5, 6, 7\n//     ]\n//   },\n//   {\n//     _id: 'Chunk',\n//     values: [\n//       8, 9, 0, 1, 2,\n//       3, 4, 5, 6, 7,\n//       8, 9\n//     ]\n//   },\n//   {\n//     _id: 'Chunk',\n//     values: [\n//       0, 1, 2, 3, 4, 5, 6,\n//       7, 8, 9, 0, 1, 2, 3,\n//       4, 5, 6, 7\n//     ]\n//   }\n// ]\n```"
    ],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "declare const groupedWithin: { (chunkSize: number, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number, duration: Duration.DurationInput): Stream<Chunk.Chunk<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2420"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "haltAfter",
    "description": "Specialized version of haltWhen which halts the evaluation of this stream\nafter the given duration.\n\nAn element in the process of being pulled will not be interrupted when the\ngiven duration completes. See `interruptAfter` for this behavior.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const haltAfter: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2438"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "haltWhen",
    "description": "Halts the evaluation of this stream when the provided effect completes. The\ngiven effect will be forked as part of the returned stream, and its success\nwill be discarded.\n\nAn element in the process of being pulled will not be interrupted when the\neffect completes. See `interruptWhen` for this behavior.\n\nIf the effect completes with a failure, the stream will emit that failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const haltWhen: { <X, E2, R2>(effect: Effect.Effect<X, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2456"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "haltWhenDeferred",
    "description": "Halts the evaluation of this stream when the provided promise resolves.\n\nIf the promise completes with a failure, the stream will emit that failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const haltWhenDeferred: { <X, E2>(deferred: Deferred.Deferred<X, E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, X, E2>(self: Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>): Stream<A, E | E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2469"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "identity",
    "description": "The identity pipeline, which does not modify streams in any way.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const identity: <A, E = never, R = never>() => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2480"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "interleave",
    "description": "Interleaves this stream and the specified stream deterministically by\nalternating pulling values from this stream and the specified stream. When\none stream is exhausted all remaining values in the other stream will be\npulled.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3)\nconst s2 = Stream.make(4, 5, 6)\n\nconst stream = Stream.interleave(s1, s2)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 4, 2, 5, 3, 6 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const interleave: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2503"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "interleaveWith",
    "description": "Combines this stream and the specified stream deterministically using the\nstream of boolean values `pull` to control which stream to pull from next.\nA value of `true` indicates to pull from this stream and a value of `false`\nindicates to pull from the specified stream. Only consumes as many elements\nas requested by the `pull` stream. If either this stream or the specified\nstream are exhausted further requests for values from that stream will be\nignored.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 3, 5, 7, 9)\nconst s2 = Stream.make(2, 4, 6, 8, 10)\n\nconst booleanStream = Stream.make(true, false, false).pipe(Stream.forever)\n\nconst stream = Stream.interleaveWith(s1, s2, booleanStream)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [\n//     1, 2,  4, 3, 6,\n//     8, 5, 10, 7, 9\n//   ]\n// }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const interleaveWith: { <A2, E2, R2, E3, R3>(that: Stream<A2, E2, R2>, decider: Stream<boolean, E3, R3>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E3 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, E3, R3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, decider: Stream<boolean, E3, R3>): Stream<A | A2, E | E2 | E3, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2541"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "intersperse",
    "description": "Intersperse stream with provided `element`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3, 4, 5).pipe(Stream.intersperse(0))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [\n//     1, 0, 2, 0, 3,\n//     0, 4, 0, 5\n//   ]\n// }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const intersperse: { <A2>(element: A2): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, element: A2): Stream<A | A2, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2575"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "intersperseAffixes",
    "description": "Intersperse the specified element, also adding a prefix and a suffix.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3, 4, 5).pipe(\n  Stream.intersperseAffixes({\n    start: \"[\",\n    middle: \"-\",\n    end: \"]\"\n  })\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [\n//     '[', 1,   '-', 2,   '-',\n//     3,   '-', 4,   '-', 5,\n//     ']'\n//   ]\n// }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const intersperseAffixes: { <A2, A3, A4>(options: { readonly start: A2; readonly middle: A3; readonly end: A4; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A3 | A4 | A, E, R>; <A, E, R, A2, A3, A4>(self: Stream<A, E, R>, options: { readonly start: A2; readonly middle: A3; readonly end: A4; }): Stream<A | A2 | A3 | A4, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2609"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "interruptAfter",
    "description": "Specialized version of `Stream.interruptWhen` which interrupts the\nevaluation of this stream after the given `Duration`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const interruptAfter: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2626"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "interruptWhen",
    "description": "Interrupts the evaluation of this stream when the provided effect\ncompletes. The given effect will be forked as part of this stream, and its\nsuccess will be discarded. This combinator will also interrupt any\nin-progress element being pulled from upstream.\n\nIf the effect completes with a failure before the stream completes, the\nreturned stream will emit that failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const interruptWhen: { <X, E2, R2>(effect: Effect.Effect<X, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2643"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "interruptWhenDeferred",
    "description": "Interrupts the evaluation of this stream when the provided promise\nresolves. This combinator will also interrupt any in-progress element being\npulled from upstream.\n\nIf the promise completes with a failure, the stream will emit that failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const interruptWhenDeferred: { <X, E2>(deferred: Deferred.Deferred<X, E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, X, E2>(self: Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>): Stream<A, E | E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2658"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "iterate",
    "description": "The infinite stream of iterative function application: a, f(a), f(f(a)),\nf(f(f(a))), ...",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\n// An infinite Stream of numbers starting from 1 and incrementing\nconst stream = Stream.iterate(1, (n) => n + 1)\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(10)))).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const iterate: <A>(value: A, next: (value: A) => A) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2681"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a stream from an sequence of values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <As extends Array<any>>(...as: As) => Stream<As[number]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2699"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms the elements of this stream using the supplied function.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3).pipe(Stream.map((n) => n + 1))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 2, 3, 4 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, f: (a: A) => B): Stream<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2717"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mapAccum",
    "description": "Statefully maps over the elements of this stream to produce new elements.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst runningTotal = (stream: Stream.Stream<number>): Stream.Stream<number> =>\n  stream.pipe(Stream.mapAccum(0, (s, a) => [s + a, s + a]))\n\n// input:  0, 1, 2, 3, 4, 5, 6\nEffect.runPromise(Stream.runCollect(runningTotal(Stream.range(0, 6)))).then(\n  console.log\n)\n// { _id: \"Chunk\", values: [ 0, 1, 3, 6, 10, 15, 21 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapAccum: { <S, A, A2>(s: S, f: (s: S, a: A) => readonly [S, A2]): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, S, A2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => readonly [S, A2]): Stream<A2, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2742"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mapAccumEffect",
    "description": "Statefully and effectfully maps over the elements of this stream to produce\nnew elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapAccumEffect: { <S, A, A2, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, S, A2, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>): Stream<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2754"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mapBoth",
    "description": "Returns a stream whose failure and success channels have been mapped by the\nspecified `onFailure` and `onSuccess` functions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Stream<A, E, R>) => Stream<A2, E2, R>; <A, E, R, E2, A2>(self: Stream<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Stream<A2, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2773"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mapChunks",
    "description": "Transforms the chunks emitted by this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapChunks: { <A, B>(f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>): Stream<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2789"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mapChunksEffect",
    "description": "Effectfully transforms the chunks emitted by this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapChunksEffect: { <A, B, E2, R2>(f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R>; <A, E, R, B, E2, R2>(self: Stream<A, E, R>, f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>): Stream<B, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2800"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mapConcat",
    "description": "Maps each element to an iterable, and flattens the iterables into the\noutput of this stream.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst numbers = Stream.make(\"1-2-3\", \"4-5\", \"6\").pipe(\n  Stream.mapConcat((s) => s.split(\"-\")),\n  Stream.map((s) => parseInt(s))\n)\n\nEffect.runPromise(Stream.runCollect(numbers)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapConcat: { <A, A2>(f: (a: A) => Iterable<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a: A) => Iterable<A2>): Stream<A2, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2830"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mapConcatChunk",
    "description": "Maps each element to a chunk, and flattens the chunks into the output of\nthis stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapConcatChunk: { <A, A2>(f: (a: A) => Chunk.Chunk<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a: A) => Chunk.Chunk<A2>): Stream<A2, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2842"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mapConcatChunkEffect",
    "description": "Effectfully maps each element to a chunk, and flattens the chunks into the\noutput of this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapConcatChunkEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2854"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mapConcatEffect",
    "description": "Effectfully maps each element to an iterable, and flattens the iterables\ninto the output of this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapConcatEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2871"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mapEffect",
    "description": "Maps over elements of the stream with the specified effectful function.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Random, Stream } from \"effect\"\n\nconst stream = Stream.make(10, 20, 30).pipe(\n  Stream.mapEffect((n) => Random.nextIntBetween(0, n))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Example Output: { _id: 'Chunk', values: [ 7, 19, 8 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<A2, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly unordered?: boolean | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, A2, E2, R2, K>(f: (a: A) => Effect.Effect<A2, E2, R2>, options: { readonly key: (a: A) => K; readonly bufferSize?: number | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<A2, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly unordered?: boolean | undefined; } | undefined): Stream<A2, E | E2, R | R2>; <A, E, R, A2, E2, R2, K>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<A2, E2, R2>, options: { readonly key: (a: A) => K; readonly bufferSize?: number | undefined; }): Stream<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2899"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mapError",
    "description": "Transforms the errors emitted by this stream using `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, f: (error: E) => E2): Stream<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2930"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mapErrorCause",
    "description": "Transforms the full causes of failures emitted by this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapErrorCause: { <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Stream<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2941"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "merge",
    "description": "Merges this stream and the specified stream together.\n\nNew produced stream will terminate when both specified stream terminate if\nno termination strategy is specified.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Schedule, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3).pipe(\n  Stream.schedule(Schedule.spaced(\"100 millis\"))\n)\nconst s2 = Stream.make(4, 5, 6).pipe(\n  Stream.schedule(Schedule.spaced(\"200 millis\"))\n)\n\nconst stream = Stream.merge(s1, s2)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 4, 2, 3, 5, 6 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const merge: { <A2, E2, R2>(that: Stream<A2, E2, R2>, options?: { readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; } | undefined): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, options?: { readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; } | undefined): Stream<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2972"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mergeAll",
    "description": "Merges a variable list of streams in a non-deterministic fashion. Up to `n`\nstreams may be consumed in parallel and up to `outputBuffer` chunks may be\nbuffered by this operator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mergeAll: { (options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; }): <A, E, R>(streams: Iterable<Stream<A, E, R>>) => Stream<A, E, R>; <A, E, R>(streams: Iterable<Stream<A, E, R>>, options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; }): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L2992"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mergeWithTag",
    "description": "Merges a struct of streams into a single stream of tagged values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Stream } from \"effect\"\n// Stream.Stream<{ _tag: \"a\"; value: number; } | { _tag: \"b\"; value: string; }>\nconst res = Stream.mergeWithTag({\n   a: Stream.make(0),\n   b: Stream.make(\"\")\n}, { concurrency: \"unbounded\" })\n```"
    ],
    "since": "3.8.5",
    "category": "combinators",
    "signature": "declare const mergeWithTag: { <S extends { [k in string]: Stream<any, any, any>; }>(streams: S, options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; }): Stream<{ [K in keyof S]: { _tag: K; value: Stream.Success<S[K]>; }; }[keyof S], Stream.Error<S[keyof S]>, Stream.Context<S[keyof S]>>; (options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; }): <S extends { [k in string]: Stream<any, any, any>; }>(streams: S) => Stream<{ [K in keyof S]: { _tag: K; value: Stream.Success<S[K]>; }; }[keyof S], Stream.Error<S[keyof S]>, Stream.Context<S[keyof S]>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3023"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mergeWith",
    "description": "Merges this stream and the specified stream together to a common element\ntype with the specified mapping functions.\n\nNew produced stream will terminate when both specified stream terminate if\nno termination strategy is specified.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Schedule, Stream } from \"effect\"\n\nconst s1 = Stream.make(\"1\", \"2\", \"3\").pipe(\n  Stream.schedule(Schedule.spaced(\"100 millis\"))\n)\nconst s2 = Stream.make(4.1, 5.3, 6.2).pipe(\n  Stream.schedule(Schedule.spaced(\"200 millis\"))\n)\n\nconst stream = Stream.mergeWith(s1, s2, {\n  onSelf: (s) => parseInt(s),\n  onOther: (n) => Math.floor(n)\n})\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 4, 2, 3, 5, 6 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mergeWith: { <A2, E2, R2, A, A3, A4>(other: Stream<A2, E2, R2>, options: { readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A4; readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A3 | A4, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3, A4>(self: Stream<A, E, R>, other: Stream<A2, E2, R2>, options: { readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A4; readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; }): Stream<A3 | A4, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3075"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mergeEither",
    "description": "Merges this stream and the specified stream together to produce a stream of\neithers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mergeEither: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A2, A>, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<Either.Either<A2, A>, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3102"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mergeLeft",
    "description": "Merges this stream and the specified stream together, discarding the values\nfrom the right stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mergeLeft: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3116"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mergeRight",
    "description": "Merges this stream and the specified stream together, discarding the values\nfrom the left stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mergeRight: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3128"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mkString",
    "description": "Returns a combined string resulting from concatenating each of the values\nfrom the stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const mkString: <E, R>(self: Stream<string, E, R>) => Effect.Effect<string, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3140"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "never",
    "description": "The stream that never produces any value or fails with any error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const never: Stream<never, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3148"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "onEnd",
    "description": "Adds an effect to be executed at the end of the stream.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Console, Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.map((n) => n * 2),\n  Stream.tap((n) => Console.log(`after mapping: ${n}`)),\n  Stream.onEnd(Console.log(\"Stream ended\"))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// after mapping: 2\n// after mapping: 4\n// after mapping: 6\n// Stream ended\n// { _id: 'Chunk', values: [ 2, 4, 6 ] }\n```"
    ],
    "since": "3.6.0",
    "category": "sequencing",
    "signature": "declare const onEnd: { <_, E2, R2>(effect: Effect.Effect<_, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, _, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<_, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3174"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "onError",
    "description": "Runs the specified effect if this stream fails, providing the error to the\neffect if it exists.\n\nNote: Unlike `Effect.onError` there is no guarantee that the provided\neffect will not be interrupted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const onError: { <E, X, R2>(cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>): Stream<A, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3194"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "onDone",
    "description": "Runs the specified effect if this stream ends.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const onDone: { <X, R2>(cleanup: () => Effect.Effect<X, never, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, cleanup: () => Effect.Effect<X, never, R2>): Stream<A, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3210"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "onStart",
    "description": "Adds an effect to be executed at the start of the stream.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Console, Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.onStart(Console.log(\"Stream started\")),\n  Stream.map((n) => n * 2),\n  Stream.tap((n) => Console.log(`after mapping: ${n}`))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Stream started\n// after mapping: 2\n// after mapping: 4\n// after mapping: 6\n// { _id: 'Chunk', values: [ 2, 4, 6 ] }\n```"
    ],
    "since": "3.6.0",
    "category": "sequencing",
    "signature": "declare const onStart: { <_, E2, R2>(effect: Effect.Effect<_, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, _, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<_, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3239"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "orDie",
    "description": "Translates any failure into a stream termination, making the stream\ninfallible and all failures unchecked.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orDie: <A, E, R>(self: Stream<A, E, R>) => Stream<A, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3256"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "orDieWith",
    "description": "Keeps none of the errors, and terminates the stream with them, using the\nspecified function to convert the `E` into a defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orDieWith: { <E>(f: (e: E) => unknown): <A, R>(self: Stream<A, E, R>) => Stream<A, never, R>; <A, E, R>(self: Stream<A, E, R>, f: (e: E) => unknown): Stream<A, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3265"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "orElse",
    "description": "Switches to the provided stream in case this one fails with a typed error.\n\nSee also `Stream.catchAll`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElse: { <A2, E2, R2>(that: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: LazyArg<Stream<A2, E2, R2>>): Stream<A | A2, E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3278"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "orElseEither",
    "description": "Switches to the provided stream in case this one fails with a typed error.\n\nSee also `Stream.catchAll`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElseEither: { <A2, E2, R2>(that: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A2, A>, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: LazyArg<Stream<A2, E2, R2>>): Stream<Either.Either<A2, A>, E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3291"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "orElseFail",
    "description": "Fails with given error in case this one fails with a typed error.\n\nSee also `Stream.catchAll`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElseFail: { <E2>(error: LazyArg<E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, error: LazyArg<E2>): Stream<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3309"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "orElseIfEmpty",
    "description": "Produces the specified element if this stream is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElseIfEmpty: { <A2>(element: LazyArg<A2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, element: LazyArg<A2>): Stream<A | A2, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3320"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "orElseIfEmptyChunk",
    "description": "Produces the specified chunk if this stream is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElseIfEmptyChunk: { <A2>(chunk: LazyArg<Chunk.Chunk<A2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, chunk: LazyArg<Chunk.Chunk<A2>>): Stream<A | A2, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3331"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "orElseIfEmptyStream",
    "description": "Switches to the provided stream in case this one is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElseIfEmptyStream: { <A2, E2, R2>(stream: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, stream: LazyArg<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3342"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "orElseSucceed",
    "description": "Succeeds with the specified value if this one fails with a typed error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const orElseSucceed: { <A2>(value: LazyArg<A2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, never, R>; <A, E, R, A2>(self: Stream<A, E, R>, value: LazyArg<A2>): Stream<A | A2, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3353"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "paginate",
    "description": "Like `Stream.unfold`, but allows the emission of values to end one step further\nthan the unfolding of the state. This is useful for embedding paginated\nAPIs, hence the name.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Option, Stream } from \"effect\"\n\nconst stream = Stream.paginate(0, (n) => [\n  n,\n  n < 3 ? Option.some(n + 1) : Option.none()\n])\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const paginate: <S, A>(s: S, f: (s: S) => readonly [A, Option.Option<S>]) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3379"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "paginateChunk",
    "description": "Like `Stream.unfoldChunk`, but allows the emission of values to end one step\nfurther than the unfolding of the state. This is useful for embedding\npaginated APIs, hence the name.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const paginateChunk: <S, A>(s: S, f: (s: S) => readonly [Chunk.Chunk<A>, Option.Option<S>]) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3389"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "paginateChunkEffect",
    "description": "Like `Stream.unfoldChunkEffect`, but allows the emission of values to end one step\nfurther than the unfolding of the state. This is useful for embedding\npaginated APIs, hence the name.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const paginateChunkEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<readonly [Chunk.Chunk<A>, Option.Option<S>], E, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3402"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "paginateEffect",
    "description": "Like `Stream.unfoldEffect` but allows the emission of values to end one step\nfurther than the unfolding of the state. This is useful for embedding\npaginated APIs, hence the name.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const paginateEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<readonly [A, Option.Option<S>], E, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3415"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "partition",
    "description": "Splits a stream into two substreams based on a predicate.\n\n**Details**\n\nThe `Stream.partition` function splits a stream into two parts: one for\nelements that satisfy the predicate (evaluated to `true`) and another for\nthose that do not (evaluated to `false`).\n\nThe faster stream may advance up to `bufferSize` elements ahead of the slower\none.\n\n**Example** (Partitioning a Stream into Even and Odd Numbers)\n\n```ts\nimport { Effect, Stream } from \"effect\"\n\nconst partition = Stream.range(1, 9).pipe(\n  Stream.partition((n) => n % 2 === 0, { bufferSize: 5 })\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function*() {\n    const [odds, evens] = yield* partition\n    console.log(yield* Stream.runCollect(odds))\n    console.log(yield* Stream.runCollect(evens))\n  })\n)\n\nEffect.runPromise(program)\n// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }\n// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const partition: { <C extends A, B extends A, A = C>(refinement: Refinement<NoInfer<A>, B>, options?: { bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<C, E, R>) => Effect.Effect<[excluded: Stream<Exclude<C, B>, E, never>, satisfying: Stream<B, E, never>], E, R | Scope.Scope>; <A>(predicate: Predicate<A>, options?: { bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[excluded: Stream<A, E, never>, satisfying: Stream<A, E, never>], E, Scope.Scope | R>; <C extends A, E, R, B extends A, A = C>(self: Stream<C, E, R>, refinement: Refinement<A, B>, options?: { bufferSize?: number | undefined; } | undefined): Effect.Effect<[excluded: Stream<Exclude<C, B>, E, never>, satisfying: Stream<B, E, never>], E, R | Scope.Scope>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>, options?: { bufferSize?: number | undefined; } | undefined): Effect.Effect<[excluded: Stream<A, E, never>, satisfying: Stream<A, E, never>], E, R | Scope.Scope>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3460"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "partitionEither",
    "description": "Splits a stream into two substreams based on an effectful condition.\n\n**Details**\n\nThe `Stream.partitionEither` function is used to divide a stream into two\nparts: one for elements that satisfy a condition producing `Either.left`\nvalues, and another for those that produce `Either.right` values. This\nfunction applies an effectful predicate to each element in the stream to\ndetermine which substream it belongs to.\n\nThe faster stream may advance up to `bufferSize` elements ahead of the slower\none.\n\n**Example** (Partitioning a Stream with an Effectful Predicate)\n\n```ts\nimport { Effect, Either, Stream } from \"effect\"\n\nconst partition = Stream.range(1, 9).pipe(\n  Stream.partitionEither(\n    (n) => Effect.succeed(n % 2 === 0 ? Either.right(n) : Either.left(n)),\n    { bufferSize: 5 }\n  )\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function*() {\n    const [evens, odds] = yield* partition\n    console.log(yield* Stream.runCollect(evens))\n    console.log(yield* Stream.runCollect(odds))\n  })\n)\n\nEffect.runPromise(program)\n// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }\n// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const partitionEither: { <A, A3, A2, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<Either.Either<A3, A2>, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[left: Stream<A2, E2 | E, never>, right: Stream<A3, E2 | E, never>], E2 | E, Scope.Scope | R2 | R>; <A, E, R, A3, A2, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<Either.Either<A3, A2>, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): Effect.Effect<[left: Stream<A2, E | E2, never>, right: Stream<A3, E | E2, never>], E | E2, Scope.Scope | R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3529"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "peel",
    "description": "Peels off enough material from the stream to construct a `Z` using the\nprovided `Sink` and then returns both the `Z` and the rest of the\n`Stream` in a scope. Like all scoped values, the provided stream is\nvalid only within the scope.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const peel: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[A2, Stream<A, E, never>], E2 | E, Scope.Scope | R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, A, E2, R2>): Effect.Effect<[A2, Stream<A, E, never>], E | E2, Scope.Scope | R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3552"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "pipeThrough",
    "description": "Pipes all of the values from this stream through the provided sink.\n\nSee also `Stream.transduce`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const pipeThrough: { <A2, A, L, E2, R2>(sink: Sink.Sink<A2, A, L, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<L, E2 | E, R2 | R>; <A, E, R, A2, L, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, L, E2, R2>): Stream<L, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3570"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "pipeThroughChannel",
    "description": "Pipes all the values from this stream through the provided channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const pipeThroughChannel: { <R2, E, E2, A, A2>(channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): <R>(self: Stream<A, E, R>) => Stream<A2, E2, R2 | R>; <R, R2, E, E2, A, A2>(self: Stream<A, E, R>, channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): Stream<A2, E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3581"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "pipeThroughChannelOrFail",
    "description": "Pipes all values from this stream through the provided channel, passing\nthrough any error emitted by this stream unchanged.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const pipeThroughChannelOrFail: { <R2, E, E2, A, A2>(chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): <R>(self: Stream<A, E, R>) => Stream<A2, E | E2, R2 | R>; <R, R2, E, E2, A, A2>(self: Stream<A, E, R>, chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): Stream<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3598"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "prepend",
    "description": "Emits the provided chunk before emitting any other value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const prepend: { <B>(values: Chunk.Chunk<B>): <A, E, R>(self: Stream<A, E, R>) => Stream<B | A, E, R>; <A, E, R, B>(self: Stream<A, E, R>, values: Chunk.Chunk<B>): Stream<A | B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3614"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "provideContext",
    "description": "Provides the stream with its required context, which eliminates its\ndependency on `R`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideContext: { <R>(context: Context.Context<R>): <A, E>(self: Stream<A, E, R>) => Stream<A, E>; <A, E, R>(self: Stream<A, E, R>, context: Context.Context<R>): Stream<A, E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3626"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "provideLayer",
    "description": "Provides a `Layer` to the stream, which translates it to another level.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideLayer: { <RIn, E2, ROut>(layer: Layer.Layer<ROut, E2, RIn>): <A, E>(self: Stream<A, E, ROut>) => Stream<A, E2 | E, RIn>; <A, E, RIn, E2, ROut>(self: Stream<A, E, ROut>, layer: Layer.Layer<ROut, E2, RIn>): Stream<A, E | E2, RIn>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3637"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "provideService",
    "description": "Provides the stream with the single service it requires. If the stream\nrequires more than one service use `Stream.provideContext` instead.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideService: { <I, S>(tag: Context.Tag<I, S>, resource: NoInfer<S>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, resource: NoInfer<S>): Stream<A, E, Exclude<R, I>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3649"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "provideServiceEffect",
    "description": "Provides the stream with the single service it requires. If the stream\nrequires more than one service use `Stream.provideContext` instead.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideServiceEffect: { <I, S, E2, R2>(tag: Context.Tag<I, S>, effect: Effect.Effect<NoInfer<S>, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | Exclude<R, I>>; <A, E, R, I, S, E2, R2>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, effect: Effect.Effect<NoInfer<S>, E2, R2>): Stream<A, E2 | E, R2 | Exclude<R, I>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3661"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "provideServiceStream",
    "description": "Provides the stream with the single service it requires. If the stream\nrequires more than one service use `Stream.provideContext` instead.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideServiceStream: { <I, S, E2, R2>(tag: Context.Tag<I, S>, stream: Stream<NoInfer<S>, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | Exclude<R, I>>; <A, E, R, I, S, E2, R2>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, stream: Stream<NoInfer<S>, E2, R2>): Stream<A, E2 | E, R2 | Exclude<R, I>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3680"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "mapInputContext",
    "description": "Transforms the context being provided to the stream with the specified\nfunction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const mapInputContext: { <R0, R>(f: (env: Context.Context<R0>) => Context.Context<R>): <A, E>(self: Stream<A, E, R>) => Stream<A, E, R0>; <A, E, R0, R>(self: Stream<A, E, R>, f: (env: Context.Context<R0>) => Context.Context<R>): Stream<A, E, R0>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3699"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "provideSomeLayer",
    "description": "Splits the context into two parts, providing one part using the\nspecified layer and leaving the remainder `R0`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const provideSomeLayer: { <RIn, E2, ROut>(layer: Layer.Layer<ROut, E2, RIn>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, RIn | Exclude<R, ROut>>; <A, E, R, RIn, E2, ROut>(self: Stream<A, E, R>, layer: Layer.Layer<ROut, E2, RIn>): Stream<A, E | E2, RIn | Exclude<R, ROut>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3711"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "race",
    "description": "Returns a stream that mirrors the first upstream to emit an item.\nAs soon as one of the upstream emits a first value, the other is interrupted.\nThe resulting stream will forward all items from the \"winning\" source stream.\nAny upstream failures will cause the returned stream to fail.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Stream, Schedule, Console, Effect } from \"effect\"\n\nconst stream = Stream.fromSchedule(Schedule.spaced('2 millis')).pipe(\n  Stream.race(Stream.fromSchedule(Schedule.spaced('1 millis'))),\n  Stream.take(6),\n  Stream.tap(Console.log)\n)\n\nEffect.runPromise(Stream.runDrain(stream))\n// Output each millisecond from the first stream, the rest streams are interrupted\n// 0\n// 1\n// 2\n// 3\n// 4\n// 5\n```"
    ],
    "since": "3.7.0",
    "category": "racing",
    "signature": "declare const race: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL | AR, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL | AR, EL | ER, RL | RR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3749"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "raceAll",
    "description": "Returns a stream that mirrors the first upstream to emit an item.\nAs soon as one of the upstream emits a first value, all the others are interrupted.\nThe resulting stream will forward all items from the \"winning\" source stream.\nAny upstream failures will cause the returned stream to fail.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Stream, Schedule, Console, Effect } from \"effect\"\n\nconst stream = Stream.raceAll(\n  Stream.fromSchedule(Schedule.spaced('1 millis')),\n  Stream.fromSchedule(Schedule.spaced('2 millis')),\n  Stream.fromSchedule(Schedule.spaced('4 millis')),\n).pipe(Stream.take(6), Stream.tap(Console.log))\n\nEffect.runPromise(Stream.runDrain(stream))\n// Output each millisecond from the first stream, the rest streams are interrupted\n// 0\n// 1\n// 2\n// 3\n// 4\n// 5\n```"
    ],
    "since": "3.5.0",
    "category": "racing",
    "signature": "declare const raceAll: <S extends ReadonlyArray<Stream<any, any, any>>>(...streams: S) => Stream<Stream.Success<S[number]>, Stream.Error<S[number]>, Stream.Context<S[number]>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3787"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "range",
    "description": "Constructs a stream from a range of integers, including both endpoints.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\n// A Stream with a range of numbers from 1 to 5\nconst stream = Stream.range(1, 5)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const range: (min: number, max: number, chunkSize?: number) => Stream<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3812"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "rechunk",
    "description": "Re-chunks the elements of the stream into chunks of `n` elements each. The\nlast chunk might contain less than `n` elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const rechunk: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3821"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "refineOrDie",
    "description": "Keeps some of the errors, and terminates the fiber with the rest",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const refineOrDie: { <E, E2>(pf: (error: E) => Option.Option<E2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<E2>): Stream<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3832"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "refineOrDieWith",
    "description": "Keeps some of the errors, and terminates the fiber with the rest, using the\nspecified function to convert the `E` into a defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "declare const refineOrDieWith: { <E, E2>(pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): Stream<A, E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3844"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "repeat",
    "description": "Repeats the entire stream using the specified schedule. The stream will\nexecute normally, and then repeat again according to the provided schedule.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Schedule, Stream } from \"effect\"\n\nconst stream = Stream.repeat(Stream.succeed(1), Schedule.forever)\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// { _id: 'Chunk', values: [ 1, 1, 1, 1, 1 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const repeat: { <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<A, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3869"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "repeatEffect",
    "description": "Creates a stream from an effect producing a value of type `A` which repeats\nforever.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Random, Stream } from \"effect\"\n\nconst stream = Stream.repeatEffect(Random.nextInt)\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// Example Output: { _id: 'Chunk', values: [ 3891571149, 4239494205, 2352981603, 2339111046, 1488052210 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const repeatEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3891"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "repeatEffectChunk",
    "description": "Creates a stream from an effect producing chunks of `A` values which\nrepeats forever.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const repeatEffectChunk: <A, E, R>(effect: Effect.Effect<Chunk.Chunk<A>, E, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3900"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "repeatEffectChunkOption",
    "description": "Creates a stream from an effect producing chunks of `A` values until it\nfails with `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const repeatEffectChunkOption: <A, E, R>(effect: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3910"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "repeatEffectOption",
    "description": "Creates a stream from an effect producing values of type `A` until it fails\nwith `None`.",
    "deprecated": false,
    "examples": [
      "```ts\n// In this example, we're draining an Iterator to create a stream from it\nimport { Stream, Effect, Option } from \"effect\"\n\nconst drainIterator = <A>(it: Iterator<A>): Stream.Stream<A> =>\n  Stream.repeatEffectOption(\n    Effect.sync(() => it.next()).pipe(\n      Effect.andThen((res) => {\n        if (res.done) {\n          return Effect.fail(Option.none())\n        }\n        return Effect.succeed(res.value)\n      })\n    )\n  )\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const repeatEffectOption: <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3939"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "repeatEffectWithSchedule",
    "description": "Creates a stream from an effect producing a value of type `A`, which is\nrepeated using the specified schedule.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const repeatEffectWithSchedule: <A, E, R, X, A0 extends A, R2>(effect: Effect.Effect<A, E, R>, schedule: Schedule.Schedule<X, A0, R2>) => Stream<A, E, R | R2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3949"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "repeatEither",
    "description": "Repeats the entire stream using the specified schedule. The stream will\nexecute normally, and then repeat again according to the provided schedule.\nThe schedule output will be emitted at the end of each repetition.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const repeatEither: { <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A, B>, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<Either.Either<A, B>, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3962"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "repeatElements",
    "description": "Repeats each element of the stream using the provided schedule. Repetitions\nare done in addition to the first execution, which means using\n`Schedule.recurs(1)` actually results in the original effect, plus an\nadditional recurrence, for a total of two repetitions of each value in the\nstream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const repeatElements: { <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<A, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L3982"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "repeatElementsWith",
    "description": "Repeats each element of the stream using the provided schedule. When the\nschedule is finished, then the output of the schedule will be emitted into\nthe stream. Repetitions are done in addition to the first execution, which\nmeans using `Schedule.recurs(1)` actually results in the original effect,\nplus an additional recurrence, for a total of two repetitions of each value\nin the stream.\n\nThis function accepts two conversion functions, which allow the output of\nthis stream and the output of the provided schedule to be unified into a\nsingle type. For example, `Either` or similar data type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const repeatElementsWith: { <B, R2, A, C>(schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, R2, C>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4002"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "repeatValue",
    "description": "Repeats the provided value infinitely.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.repeatValue(0)\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// { _id: 'Chunk', values: [ 0, 0, 0, 0, 0 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const repeatValue: <A>(value: A) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4030"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "repeatWith",
    "description": "Repeats the entire stream using the specified schedule. The stream will\nexecute normally, and then repeat again according to the provided schedule.\nThe schedule output will be emitted at the end of each repetition and can\nbe unified with the stream elements using the provided functions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const repeatWith: { <B, R2, A, C>(schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, R2, C>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4041"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "retry",
    "description": "When the stream fails, retry it according to the given schedule\n\nThis retries the entire stream, so will re-execute all of the stream's\nacquire operations.\n\nThe schedule is reset as soon as the first element passes through the\nstream again.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const retry: { <E0 extends E, R2, E, X>(schedule: Schedule.Schedule<X, E0, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, E0 extends E, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<X, E0, R2>): Stream<A, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4065"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "run",
    "description": "Runs the sink on the stream to produce either the sink's result or an error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const run: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<A2, E2 | E, Exclude<R | R2, Scope.Scope>>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, unknown, E2, R2>): Effect.Effect<A2, E | E2, Exclude<R | R2, Scope.Scope>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4078"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runCollect",
    "description": "Runs the stream and collects all of its elements to a chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runCollect: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Chunk.Chunk<A>, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4094"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runCount",
    "description": "Runs the stream and emits the number of elements processed",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runCount: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<number, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4102"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runDrain",
    "description": "Runs the stream only for its effects. The emitted elements are discarded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runDrain: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4110"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runFold",
    "description": "Executes a pure fold over the stream of values - reduces all elements in\nthe stream to a value of type `S`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runFold: { <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect.Effect<S, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4119"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runFoldEffect",
    "description": "Executes an effectful fold over the stream of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runFoldEffect: { <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Exclude<R | R2, Scope.Scope>>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Exclude<R | R2, Scope.Scope>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4130"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runFoldScoped",
    "description": "Executes a pure fold over the stream of values. Returns a scoped value that\nrepresents the scope of the stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runFoldScoped: { <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, Scope.Scope | R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect.Effect<S, E, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4149"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runFoldScopedEffect",
    "description": "Executes an effectful fold over the stream of values. Returns a scoped\nvalue that represents the scope of the stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runFoldScopedEffect: { <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Scope.Scope | R2 | R>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Scope.Scope | R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4161"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runFoldWhile",
    "description": "Reduces the elements in the stream to a value of type `S`. Stops the fold\nearly when the condition is not fulfilled. Example:",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runFoldWhile: { <S, A>(s: S, cont: Predicate<S>, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => S): Effect.Effect<S, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4180"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runFoldWhileEffect",
    "description": "Executes an effectful fold over the stream of values. Stops the fold early\nwhen the condition is not fulfilled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runFoldWhileEffect: { <S, A, E2, R2>(s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Exclude<R | R2, Scope.Scope>>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Exclude<R | R2, Scope.Scope>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4192"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runFoldWhileScoped",
    "description": "Executes a pure fold over the stream of values. Returns a scoped value that\nrepresents the scope of the stream. Stops the fold early when the condition\nis not fulfilled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runFoldWhileScoped: { <S, A>(s: S, cont: Predicate<S>, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, Scope.Scope | R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => S): Effect.Effect<S, E, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4214"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runFoldWhileScopedEffect",
    "description": "Executes an effectful fold over the stream of values. Returns a scoped\nvalue that represents the scope of the stream. Stops the fold early when\nthe condition is not fulfilled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runFoldWhileScopedEffect: { <S, A, E2, R2>(s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, R2 | R | Scope.Scope>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Scope.Scope | R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4236"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runForEach",
    "description": "Consumes all elements of the stream, passing them to the specified\ncallback.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runForEach: { <A, X, E2, R2>(f: (a: A) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4257"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runForEachChunk",
    "description": "Consumes all elements of the stream, passing them to the specified\ncallback.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runForEachChunk: { <A, X, E2, R2>(f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4274"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runForEachChunkScoped",
    "description": "Like `Stream.runForEachChunk`, but returns a scoped effect so the\nfinalization order can be controlled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runForEachChunkScoped: { <A, X, E2, R2>(f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4291"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runForEachScoped",
    "description": "Like `Stream.forEach`, but returns a scoped effect so the finalization\norder can be controlled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runForEachScoped: { <A, X, E2, R2>(f: (a: A) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4308"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runForEachWhile",
    "description": "Consumes elements of the stream, passing them to the specified callback,\nand terminating consumption when the callback returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runForEachWhile: { <A, E2, R2>(f: (a: A) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Effect.Effect<void, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4325"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runForEachWhileScoped",
    "description": "Like `Stream.runForEachWhile`, but returns a scoped effect so the\nfinalization order can be controlled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runForEachWhileScoped: { <A, E2, R2>(f: (a: A) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4342"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runHead",
    "description": "Runs the stream to completion and yields the first value emitted by it,\ndiscarding the rest of the elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runHead: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4359"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runIntoPubSub",
    "description": "Publishes elements of this stream to a `PubSub`. Stream failure and ending will\nalso be signalled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runIntoPubSub: { <A, E>(pubsub: PubSub.PubSub<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, R>; <A, E, R>(self: Stream<A, E, R>, pubsub: PubSub.PubSub<Take.Take<A, E>>): Effect.Effect<void, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4368"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runIntoPubSubScoped",
    "description": "Like `Stream.runIntoPubSub`, but provides the result as a scoped effect to\nallow for scope composition.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runIntoPubSubScoped: { <A, E>(pubsub: PubSub.PubSub<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, pubsub: PubSub.PubSub<Take.Take<A, E>>): Effect.Effect<void, never, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4380"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runIntoQueue",
    "description": "Enqueues elements of this stream into a queue. Stream failure and ending\nwill also be signalled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runIntoQueue: { <A, E>(queue: Queue.Enqueue<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, R>; <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Take.Take<A, E>>): Effect.Effect<void, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4394"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runIntoQueueElementsScoped",
    "description": "Like `Stream.runIntoQueue`, but provides the result as a scoped [[ZIO]]\nto allow for scope composition.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runIntoQueueElementsScoped: { <A, E>(queue: Queue.Enqueue<Exit.Exit<A, Option.Option<E>>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Exit.Exit<A, Option.Option<E>>>): Effect.Effect<void, never, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4406"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runIntoQueueScoped",
    "description": "Like `Stream.runIntoQueue`, but provides the result as a scoped effect\nto allow for scope composition.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runIntoQueueScoped: { <A, E>(queue: Queue.Enqueue<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Take.Take<A, E>>): Effect.Effect<void, never, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4423"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runLast",
    "description": "Runs the stream to completion and yields the last value emitted by it,\ndiscarding the rest of the elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runLast: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4437"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runScoped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runScoped: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<A2, E2 | E, Scope.Scope | R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, unknown, E2, R2>): Effect.Effect<A2, E | E2, Scope.Scope | R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4443"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "runSum",
    "description": "Runs the stream to a sink which sums elements, provided they are Numeric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const runSum: <E, R>(self: Stream<number, E, R>) => Effect.Effect<number, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4459"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "scan",
    "description": "Statefully maps over the elements of this stream to produce all\nintermediate results of type `S` given an initial S.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.range(1, 6).pipe(Stream.scan(0, (a, b) => a + b))\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0,  1,  3, 6, 10, 15, 21 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const scan: { <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Stream<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Stream<S, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4478"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "scanEffect",
    "description": "Statefully and effectfully maps over the elements of this stream to produce\nall intermediate results of type `S` given an initial S.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const scanEffect: { <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<S, E2 | E, R2 | R>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Stream<S, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4490"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "scanReduce",
    "description": "Statefully maps over the elements of this stream to produce all\nintermediate results.\n\nSee also `Stream.scan`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const scanReduce: { <A2, A>(f: (a2: A2 | A, a: A) => A2): <E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a2: A | A2, a: A) => A2): Stream<A | A2, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4511"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "scanReduceEffect",
    "description": "Statefully and effectfully maps over the elements of this stream to produce\nall intermediate results.\n\nSee also `Stream.scanEffect`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const scanReduceEffect: { <A2, A, E2, R2>(f: (a2: A2 | A, a: A) => Effect.Effect<A2 | A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a2: A | A2, a: A) => Effect.Effect<A | A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4525"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "schedule",
    "description": "Schedules the output of the stream using the provided `schedule`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const schedule: { <X, A0 extends A, R2, A>(schedule: Schedule.Schedule<X, A0, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, A0 extends A, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<X, A0, R2>): Stream<A, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4541"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "scheduleWith",
    "description": "Schedules the output of the stream using the provided `schedule` and emits\nits output at the end (if `schedule` is finite). Uses the provided function\nto align the stream and schedule outputs on the same type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const scheduleWith: { <B, A0 extends A, R2, A, C>(schedule: Schedule.Schedule<B, A0, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, A0 extends A, R2, C>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, A0, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4556"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "scoped",
    "description": "Creates a single-valued stream from a scoped resource.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Console, Effect, Stream } from \"effect\"\n\n// Creating a single-valued stream from a scoped resource\nconst stream = Stream.scoped(\n Effect.acquireRelease(\n   Console.log(\"acquire\"),\n   () => Console.log(\"release\")\n )\n).pipe(\n Stream.flatMap(() => Console.log(\"use\"))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// acquire\n// use\n// release\n// { _id: 'Chunk', values: [ undefined ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const scoped: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, Exclude<R, Scope.Scope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4595"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "scopedWith",
    "description": "Use a function that receives a scope and returns an effect to emit an output\nelement. The output element will be the result of the returned effect, if\nsuccessful.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "declare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect.Effect<A, E, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4606"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "sliding",
    "description": "Emits a sliding window of `n` elements.\n\n```ts\nimport { pipe, Stream } from \"effect\"\n\npipe(\n  Stream.make(1, 2, 3, 4),\n  Stream.sliding(2),\n  Stream.runCollect\n)\n// => Chunk(Chunk(1, 2), Chunk(2, 3), Chunk(3, 4))\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const sliding: { (chunkSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number): Stream<Chunk.Chunk<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4626"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "slidingSize",
    "description": "Like `sliding`, but with a configurable `stepSize` parameter.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const slidingSize: { (chunkSize: number, stepSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number, stepSize: number): Stream<Chunk.Chunk<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4637"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "some",
    "description": "Converts an option on values into an option on errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const some: <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A, Option.Option<E>, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4648"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "someOrElse",
    "description": "Extracts the optional value, or returns the given 'default'.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const someOrElse: { <A2>(fallback: LazyArg<A2>): <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<Option.Option<A>, E, R>, fallback: LazyArg<A2>): Stream<A | A2, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4656"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "someOrFail",
    "description": "Extracts the optional value, or fails with the given error 'e'.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const someOrFail: { <E2>(error: LazyArg<E2>): <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<Option.Option<A>, E, R>, error: LazyArg<E2>): Stream<A, E | E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4667"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "split",
    "description": "Splits elements based on a predicate or refinement.\n\n```ts\nimport { pipe, Stream } from \"effect\"\n\npipe(\n  Stream.range(1, 10),\n  Stream.split((n) => n % 4 === 0),\n  Stream.runCollect\n)\n// => Chunk(Chunk(1, 2, 3), Chunk(5, 6, 7), Chunk(9))\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const split: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<Exclude<A, B>>, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<Chunk.Chunk<Exclude<A, B>>, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<Chunk.Chunk<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4689"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "splitOnChunk",
    "description": "Splits elements on a delimiter and transforms the splits into desired output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const splitOnChunk: { <A>(delimiter: Chunk.Chunk<A>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, delimiter: Chunk.Chunk<A>): Stream<Chunk.Chunk<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4704"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "splitLines",
    "description": "Splits strings on newlines. Handles both Windows newlines (`\\r\\n`) and UNIX\nnewlines (`\\n`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const splitLines: <E, R>(self: Stream<string, E, R>) => Stream<string, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4716"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "succeed",
    "description": "Creates a single-valued pure stream.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\n// A Stream with a single number\nconst stream = Stream.succeed(3)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 3 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const succeed: <A>(value: A) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4735"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "sync",
    "description": "Creates a single-valued pure stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sync: <A>(evaluate: LazyArg<A>) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4743"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "suspend",
    "description": "Returns a lazily constructed stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const suspend: <A, E, R>(stream: LazyArg<Stream<A, E, R>>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4751"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "take",
    "description": "Takes the specified number of elements from this stream.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.take(Stream.iterate(0, (n) => n + 1), 5)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const take: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4769"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "takeRight",
    "description": "Takes the last specified number of elements from this stream.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.takeRight(Stream.make(1, 2, 3, 4, 5, 6), 3)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 4, 5, 6 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const takeRight: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4790"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "takeUntil",
    "description": "Takes all elements of the stream until the specified predicate evaluates to\n`true`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.takeUntil(Stream.iterate(0, (n) => n + 1), (n) => n === 4)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const takeUntil: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4812"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "takeUntilEffect",
    "description": "Takes all elements of the stream until the specified effectual predicate\nevaluates to `true`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const takeUntilEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4824"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "takeWhile",
    "description": "Takes all elements of the stream for as long as the specified predicate\nevaluates to `true`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.takeWhile(Stream.iterate(0, (n) => n + 1), (n) => n < 5)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const takeWhile: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4851"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "tap",
    "description": "Adds an effect to consumption of every element of the stream.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Console, Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.tap((n) => Console.log(`before mapping: ${n}`)),\n  Stream.map((n) => n * 2),\n  Stream.tap((n) => Console.log(`after mapping: ${n}`))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// before mapping: 1\n// after mapping: 2\n// before mapping: 2\n// after mapping: 4\n// before mapping: 3\n// after mapping: 6\n// { _id: 'Chunk', values: [ 2, 4, 6 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const tap: { <A, X, E2, R2>(f: (a: NoInfer<A>) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: NoInfer<A>) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4884"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "tapBoth",
    "description": "Returns a stream that effectfully \"peeks\" at the failure or success of\nthe stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const tapBoth: { <E, X1, E2, R2, A, X2, E3, R3>(options: { readonly onFailure: (e: NoInfer<E>) => Effect.Effect<X1, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect.Effect<X2, E3, R3>; }): <R>(self: Stream<A, E, R>) => Stream<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, X1, E2, R2, X2, E3, R3>(self: Stream<A, E, R>, options: { readonly onFailure: (e: NoInfer<E>) => Effect.Effect<X1, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect.Effect<X2, E3, R3>; }): Stream<A, E | E2 | E3, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4898"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "tapError",
    "description": "Returns a stream that effectfully \"peeks\" at the failure of the stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const tapError: { <E, X, E2, R2>(f: (error: NoInfer<E>) => Effect.Effect<X, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (error: E) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4920"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "tapErrorCause",
    "description": "Returns a stream that effectfully \"peeks\" at the cause of failure of the\nstream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const tapErrorCause: { <E, X, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Effect.Effect<X, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4934"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "tapSink",
    "description": "Sends all elements emitted by this stream to the specified sink in addition\nto emitting them.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const tapSink: { <A, E2, R2>(sink: Sink.Sink<unknown, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<unknown, A, unknown, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L4951"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "throttle",
    "description": "Delays the chunks of this stream according to the given bandwidth\nparameters using the token bucket algorithm. Allows for burst in the\nprocessing of elements by allowing the token bucket to accumulate tokens up\nto a `units + burst` threshold. The weight of each chunk is determined by\nthe `cost` function.\n\nIf using the \"enforce\" strategy, chunks that do not meet the bandwidth\nconstraints are dropped. If using the \"shape\" strategy, chunks are delayed\nuntil they can be emitted without exceeding the bandwidth constraints.\n\nDefaults to the \"shape\" strategy.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Chunk, Effect, Schedule, Stream } from \"effect\"\n\nlet last = Date.now()\nconst log = (message: string) =>\n  Effect.sync(() => {\n    const end = Date.now()\n    console.log(`${message} after ${end - last}ms`)\n    last = end\n  })\n\nconst stream = Stream.fromSchedule(Schedule.spaced(\"50 millis\")).pipe(\n  Stream.take(6),\n  Stream.tap((n) => log(`Received ${n}`)),\n  Stream.throttle({\n    cost: Chunk.size,\n    duration: \"100 millis\",\n    units: 1\n  }),\n  Stream.tap((n) => log(`> Emitted ${n}`))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Received 0 after 56ms\n// > Emitted 0 after 0ms\n// Received 1 after 52ms\n// > Emitted 1 after 48ms\n// Received 2 after 52ms\n// > Emitted 2 after 49ms\n// Received 3 after 52ms\n// > Emitted 3 after 48ms\n// Received 4 after 52ms\n// > Emitted 4 after 47ms\n// Received 5 after 52ms\n// > Emitted 5 after 49ms\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4, 5 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const throttle: { <A>(options: { readonly cost: (chunk: Chunk.Chunk<A>) => number; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: \"enforce\" | \"shape\" | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly cost: (chunk: Chunk.Chunk<A>) => number; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: \"enforce\" | \"shape\" | undefined; }): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5011"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "throttleEffect",
    "description": "Delays the chunks of this stream according to the given bandwidth\nparameters using the token bucket algorithm. Allows for burst in the\nprocessing of elements by allowing the token bucket to accumulate tokens up\nto a `units + burst` threshold. The weight of each chunk is determined by\nthe effectful `costFn` function.\n\nIf using the \"enforce\" strategy, chunks that do not meet the bandwidth\nconstraints are dropped. If using the \"shape\" strategy, chunks are delayed\nuntil they can be emitted without exceeding the bandwidth constraints.\n\nDefaults to the \"shape\" strategy.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const throttleEffect: { <A, E2, R2>(options: { readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: \"enforce\" | \"shape\" | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, options: { readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: \"enforce\" | \"shape\" | undefined; }): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5049"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "tick",
    "description": "A stream that emits void values spaced by the specified duration.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nlet last = Date.now()\nconst log = (message: string) =>\n  Effect.sync(() => {\n    const end = Date.now()\n    console.log(`${message} after ${end - last}ms`)\n    last = end\n  })\n\nconst stream = Stream.tick(\"1 seconds\").pipe(Stream.tap(() => log(\"tick\")))\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// tick after 4ms\n// tick after 1003ms\n// tick after 1001ms\n// tick after 1002ms\n// tick after 1002ms\n// { _id: 'Chunk', values: [ undefined, undefined, undefined, undefined, undefined ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const tick: (interval: Duration.DurationInput) => Stream<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5100"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "timeout",
    "description": "Ends the stream if it does not produce a value after the specified duration.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const timeout: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5108"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "timeoutFail",
    "description": "Fails the stream with given error if it does not produce a value after d\nduration.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const timeoutFail: { <E2>(error: LazyArg<E2>, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<A, E, R>, error: LazyArg<E2>, duration: Duration.DurationInput): Stream<A, E | E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5120"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "timeoutFailCause",
    "description": "Fails the stream with given cause if it does not produce a value after d\nduration.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const timeoutFailCause: { <E2>(cause: LazyArg<Cause.Cause<E2>>, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<A, E, R>, cause: LazyArg<Cause.Cause<E2>>, duration: Duration.DurationInput): Stream<A, E | E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5132"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "timeoutTo",
    "description": "Switches the stream if it does not produce a value after the specified\nduration.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const timeoutTo: { <A2, E2, R2>(duration: Duration.DurationInput, that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, duration: Duration.DurationInput, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5151"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "toPubSub",
    "description": "Converts the stream to a scoped `PubSub` of chunks. After the scope is closed,\nthe `PubSub` will never again produce values and should be discarded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toPubSub: { (capacity: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, capacity: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5170"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "toPull",
    "description": "Returns in a scope a ZIO effect that can be used to repeatedly pull chunks\nfrom the stream. The pull effect fails with None when the stream is\nfinished, or with Some error if it fails, otherwise it returns a chunk of\nthe stream's output.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\n// Simulate a chunked stream\nconst stream = Stream.fromIterable([1, 2, 3, 4, 5]).pipe(Stream.rechunk(2))\n\nconst program = Effect.gen(function*() {\n  // Create an effect to get data chunks from the stream\n  const getChunk = yield* Stream.toPull(stream)\n\n  // Continuously fetch and process chunks\n  while (true) {\n    const chunk = yield* getChunk\n    console.log(chunk)\n  }\n})\n\nEffect.runPromise(Effect.scoped(program)).then(console.log, console.error)\n// { _id: 'Chunk', values: [ 1, 2 ] }\n// { _id: 'Chunk', values: [ 3, 4 ] }\n// { _id: 'Chunk', values: [ 5 ] }\n// (FiberFailure) Error: {\n//   \"_id\": \"Option\",\n//   \"_tag\": \"None\"\n// }\n```"
    ],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toPull: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>, never, Scope.Scope | R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5225"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "toQueue",
    "description": "Converts the stream to a scoped queue of chunks. After the scope is closed,\nthe queue will never again produce values and should be discarded.\n\nDefaults to the \"suspend\" back pressure strategy with a capacity of 2.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toQueue: { (options?: { readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; readonly capacity?: number | undefined; } | { readonly strategy: \"unbounded\"; } | undefined): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; readonly capacity?: number | undefined; } | { readonly strategy: \"unbounded\"; } | undefined): Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5238"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "toQueueOfElements",
    "description": "Converts the stream to a scoped queue of elements. After the scope is\nclosed, the queue will never again produce values and should be discarded.\n\nDefaults to a capacity of 2.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toQueueOfElements: { (options?: { readonly capacity?: number | undefined; } | undefined): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly capacity?: number | undefined; } | undefined): Effect.Effect<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>, never, Scope.Scope | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5263"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "toReadableStream",
    "description": "Converts the stream to a `ReadableStream`.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toReadableStream: { <A>(options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): <E>(self: Stream<A, E>) => ReadableStream<A>; <A, E>(self: Stream<A, E>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): ReadableStream<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5283"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "toReadableStreamEffect",
    "description": "Converts the stream to a `Effect<ReadableStream>`.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toReadableStreamEffect: { <A>(options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): <E, R>(self: Stream<A, E, R>) => Effect.Effect<ReadableStream<A>, never, R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): Effect.Effect<ReadableStream<A>, never, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5303"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "toReadableStreamRuntime",
    "description": "Converts the stream to a `ReadableStream` using the provided runtime.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toReadableStreamRuntime: { <A, XR>(runtime: Runtime<XR>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): <E, R extends XR>(self: Stream<A, E, R>) => ReadableStream<A>; <A, E, XR, R extends XR>(self: Stream<A, E, R>, runtime: Runtime<XR>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): ReadableStream<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5323"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "transduce",
    "description": "Applies the transducer to the stream and emits its outputs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const transduce: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, A, E2, R2>): Stream<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5341"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "unfold",
    "description": "Creates a stream by peeling off the \"layers\" of a value of type `S`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Option, Stream } from \"effect\"\n\nconst stream = Stream.unfold(1, (n) => Option.some([n, n + 1]))\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unfold: <S, A>(s: S, f: (s: S) => Option.Option<readonly [A, S]>) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5362"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "unfoldChunk",
    "description": "Creates a stream by peeling off the \"layers\" of a value of type `S`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unfoldChunk: <S, A>(s: S, f: (s: S) => Option.Option<readonly [Chunk.Chunk<A>, S]>) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5370"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "unfoldChunkEffect",
    "description": "Creates a stream by effectfully peeling off the \"layers\" of a value of type\n`S`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unfoldChunkEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<Option.Option<readonly [Chunk.Chunk<A>, S]>, E, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5382"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "unfoldEffect",
    "description": "Creates a stream by effectfully peeling off the \"layers\" of a value of type\n`S`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Option, Random, Stream } from \"effect\"\n\nconst stream = Stream.unfoldEffect(1, (n) =>\n  Random.nextBoolean.pipe(\n    Effect.map((b) => (b ? Option.some([n, -n]) : Option.some([n, n])))\n  ))\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// { _id: 'Chunk', values: [ 1, -1, -1, -1, -1 ] }\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unfoldEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<Option.Option<readonly [A, S]>, E, R>) => Stream<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5407"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "unwrap",
    "description": "Creates a stream produced from an `Effect`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unwrap: <A, E2, R2, E, R>(effect: Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R | R2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5439"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "unwrapScoped",
    "description": "Creates a stream produced from a scoped `Effect`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unwrapScoped: <A, E2, R2, E, R>(effect: Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R2 | Exclude<R, Scope.Scope>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5448"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "unwrapScopedWith",
    "description": "Creates a stream produced from a function which receives a `Scope` and\nreturns an `Effect`. The resulting stream will emit a single element, which\nwill be the result of the returned effect, if successful.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "declare const unwrapScopedWith: <A, E2, R2, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R | R2>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5460"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "updateService",
    "description": "Updates the specified service within the context of the `Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const updateService: { <I, S>(tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, I | R>; <A, E, R, I, S>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): Stream<A, E, I | R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5470"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "when",
    "description": "Returns the specified stream if the given condition is satisfied, otherwise\nreturns an empty stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const when: { (test: LazyArg<boolean>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, test: LazyArg<boolean>): Stream<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5489"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "whenCase",
    "description": "Returns the resulting stream when the given `PartialFunction` is defined\nfor the given value, otherwise returns an empty stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const whenCase: <A, A2, E, R>(evaluate: LazyArg<A>, pf: (a: A) => Option.Option<Stream<A2, E, R>>) => Stream<A2, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5501"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "whenCaseEffect",
    "description": "Returns the stream when the given partial function is defined for the given\neffectful value, otherwise returns an empty stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const whenCaseEffect: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<Stream<A2, E2, R2>>): <E, R>(self: Effect.Effect<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect.Effect<A, E, R>, pf: (a: A) => Option.Option<Stream<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5513"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "whenEffect",
    "description": "Returns the stream if the given effectful condition is satisfied, otherwise\nreturns an empty stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const whenEffect: { <E2, R2>(effect: Effect.Effect<boolean, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5530"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "withSpan",
    "description": "Wraps the stream with a new span for tracing.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "declare const withSpan: { (name: string, options?: Tracer.SpanOptions | undefined): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Stream<A, E, R>, name: string, options?: Tracer.SpanOptions | undefined): Stream<A, E, Exclude<R, Tracer.ParentSpan>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5541"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zip",
    "description": "Zips this stream with another point-wise and emits tuples of elements from\nboth streams.\n\nThe new stream will end when one of the sides ends.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\n// We create two streams and zip them together.\nconst stream = Stream.zip(\n  Stream.make(1, 2, 3, 4, 5, 6),\n  Stream.make(\"a\", \"b\", \"c\")\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ [ 1, 'a' ], [ 2, 'b' ], [ 3, 'c' ] ] }\n```"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zip: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<[A, A2], E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5576"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipFlatten",
    "description": "Zips this stream with another point-wise and emits tuples of elements from\nboth streams.\n\nThe new stream will end when one of the sides ends.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipFlatten: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A extends ReadonlyArray<any>, E, R>(self: Stream<A, E, R>) => Stream<[...A, A2], E2 | E, R2 | R>; <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<[...A, A2], E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5590"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipAll",
    "description": "Zips this stream with another point-wise, creating a new stream of pairs of\nelements from both sides.\n\nThe defaults `defaultLeft` and `defaultRight` will be used if the streams\nhave different lengths and one of the streams has ended before the other.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipAll(Stream.make(1, 2, 3, 4, 5, 6), {\n  other: Stream.make(\"a\", \"b\", \"c\"),\n  defaultSelf: 0,\n  defaultOther: \"x\"\n})\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: \"Chunk\", values: [ [ 1, \"a\" ], [ 2, \"b\" ], [ 3, \"c\" ], [ 4, \"x\" ], [ 5, \"x\" ], [ 6, \"x\" ] ] }\n```"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipAll: { <A2, E2, R2, A>(options: { readonly other: Stream<A2, E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; }): <E, R>(self: Stream<A, E, R>) => Stream<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, options: { readonly other: Stream<A2, E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; }): Stream<[A, A2], E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5624"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipAllLeft",
    "description": "Zips this stream with another point-wise, and keeps only elements from this\nstream.\n\nThe provided default value will be used if the other stream ends before\nthis one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipAllLeft: { <A2, E2, R2, A>(that: Stream<A2, E2, R2>, defaultLeft: A): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, defaultLeft: A): Stream<A, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5644"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipAllRight",
    "description": "Zips this stream with another point-wise, and keeps only elements from the\nother stream.\n\nThe provided default value will be used if this stream ends before the\nother one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipAllRight: { <A2, E2, R2>(that: Stream<A2, E2, R2>, defaultRight: A2): <A, E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, defaultRight: A2): Stream<A2, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5659"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipAllSortedByKey",
    "description": "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Combines values associated with each key into a tuple,\nusing the specified values `defaultLeft` and `defaultRight` to fill in\nmissing values.\n\nThis allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipAllSortedByKey: { <A2, E2, R2, A, K>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; readonly order: Order.Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, [A, A2]], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; readonly order: Order.Order<K>; }): Stream<[K, [A, A2]], E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5681"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipAllSortedByKeyLeft",
    "description": "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Keeps only values from this stream, using the specified\nvalue `default` to fill in missing values.\n\nThis allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipAllSortedByKeyLeft: { <A2, E2, R2, A, K>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly order: Order.Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly order: Order.Order<K>; }): Stream<[K, A], E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5714"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipAllSortedByKeyRight",
    "description": "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Keeps only values from that stream, using the specified\nvalue `default` to fill in missing values.\n\nThis allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipAllSortedByKeyRight: { <K, A2, E2, R2>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultOther: A2; readonly order: Order.Order<K>; }): <A, E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A2], E2 | E, R2 | R>; <A, E, R, K, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultOther: A2; readonly order: Order.Order<K>; }): Stream<[K, A2], E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5745"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipAllSortedByKeyWith",
    "description": "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Uses the functions `left`, `right`, and `both` to handle\nthe cases where a key and value exist in this stream, that stream, or\nboth streams.\n\nThis allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipAllSortedByKeyWith: { <K, A2, E2, R2, A, A3>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; readonly order: Order.Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A3], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2, A3>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; readonly order: Order.Order<K>; }): Stream<[K, A3], E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5777"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipAllWith",
    "description": "Zips this stream with another point-wise. The provided functions will be\nused to create elements for the composed stream.\n\nThe functions `left` and `right` will be used if the streams have different\nlengths and one of the streams has ended before the other.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipAllWith(Stream.make(1, 2, 3, 4, 5, 6), {\n  other: Stream.make(\"a\", \"b\", \"c\"),\n  onSelf: (n) => [n, \"x\"],\n  onOther: (s) => [0, s],\n  onBoth: (n, s) => [n - s.length, s]\n})\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: \"Chunk\", values: [ [ 0, \"a\" ], [ 1, \"b\" ], [ 2, \"c\" ], [ 4, \"x\" ], [ 5, \"x\" ], [ 6, \"x\" ] ] }\n```"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipAllWith: { <A2, E2, R2, A, A3>(options: { readonly other: Stream<A2, E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; }): <E, R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: Stream<A, E, R>, options: { readonly other: Stream<A2, E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; }): Stream<A3, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5824"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipLatest",
    "description": "Zips the two streams so that when a value is emitted by either of the two\nstreams, it is combined with the latest value from the other stream to\nproduce a result.\n\nNote: tracking the latest value is done on a per-chunk basis. That means\nthat emitted elements that are not the last value in chunks will never be\nused for zipping.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Schedule, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3).pipe(\n  Stream.schedule(Schedule.spaced(\"1 second\"))\n)\n\nconst s2 = Stream.make(\"a\", \"b\", \"c\", \"d\").pipe(\n  Stream.schedule(Schedule.spaced(\"500 millis\"))\n)\n\nconst stream = Stream.zipLatest(s1, s2)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: \"Chunk\", values: [ [ 1, \"a\" ], [ 1, \"b\" ], [ 2, \"b\" ], [ 2, \"c\" ], [ 2, \"d\" ], [ 3, \"d\" ] ] }\n```"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipLatest: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<[AL, AR], EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<[AL, AR], EL | ER, RL | RR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5874"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipLatestAll",
    "description": "Zips multiple streams so that when a value is emitted by any of the streams,\nit is combined with the latest values from the other streams to produce a result.\n\nNote: tracking the latest value is done on a per-chunk basis. That means\nthat emitted elements that are not the last value in chunks will never be\nused for zipping.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Stream, Schedule, Console, Effect } from \"effect\"\n\nconst stream = Stream.zipLatestAll(\n    Stream.fromSchedule(Schedule.spaced('1 millis')),\n    Stream.fromSchedule(Schedule.spaced('2 millis')),\n    Stream.fromSchedule(Schedule.spaced('4 millis')),\n).pipe(Stream.take(6), Stream.tap(Console.log))\n\nEffect.runPromise(Stream.runDrain(stream))\n// Output:\n// [ 0, 0, 0 ]\n// [ 1, 0, 0 ]\n// [ 1, 1, 0 ]\n// [ 2, 1, 0 ]\n// [ 3, 1, 0 ]\n// [ 3, 1, 1 ]\n// .....\n```"
    ],
    "since": "3.3.0",
    "category": "zipping",
    "signature": "declare const zipLatestAll: <T extends ReadonlyArray<Stream<any, any, any>>>(...streams: T) => Stream<[T[number]] extends [never] ? never : { [K in keyof T]: T[K] extends Stream<infer A, infer _E, infer _R> ? A : never; }, [T[number]] extends [never] ? never : T[number] extends Stream<infer _A, infer _E, infer _R> ? _E : never, [T[number]] extends [never] ? never : T[number] extends Stream<infer _A, infer _E, infer _R> ? _R : never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5911"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipLatestWith",
    "description": "Zips the two streams so that when a value is emitted by either of the two\nstreams, it is combined with the latest value from the other stream to\nproduce a result.\n\nNote: tracking the latest value is done on a per-chunk basis. That means\nthat emitted elements that are not the last value in chunks will never be\nused for zipping.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipLatestWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5932"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Zips this stream with another point-wise, but keeps only the outputs of\n`left` stream.\n\nThe new stream will end when one of the sides ends.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipLeft: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5953"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Zips this stream with another point-wise, but keeps only the outputs of the\n`right` stream.\n\nThe new stream will end when one of the sides ends.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipRight: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5967"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Zips this stream with another point-wise and applies the function to the\npaired elements.\n\nThe new stream will end when one of the sides ends.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\n// We create two streams and zip them with custom logic.\nconst stream = Stream.zipWith(\n  Stream.make(1, 2, 3, 4, 5, 6),\n  Stream.make(\"a\", \"b\", \"c\"),\n  (n, s) => [n - s.length, s]\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ [ 0, 'a' ], [ 1, 'b' ], [ 2, 'c' ] ] }\n```"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L5996"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipWithChunks",
    "description": "Zips this stream with another point-wise and applies the function to the\npaired elements.\n\nThe new stream will end when one of the sides ends.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWithChunks: { <A2, E2, R2, A, A3>(that: Stream<A2, E2, R2>, f: (left: Chunk.Chunk<A>, right: Chunk.Chunk<A2>) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]): <E, R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, f: (left: Chunk.Chunk<A>, right: Chunk.Chunk<A2>) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]): Stream<A3, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6017"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipWithNext",
    "description": "Zips each element with the next element if present.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Chunk, Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipWithNext(Stream.make(1, 2, 3, 4))\n\nEffect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))\n// [\n//   [ 1, { _id: 'Option', _tag: 'Some', value: 2 } ],\n//   [ 2, { _id: 'Option', _tag: 'Some', value: 3 } ],\n//   [ 3, { _id: 'Option', _tag: 'Some', value: 4 } ],\n//   [ 4, { _id: 'Option', _tag: 'None' } ]\n// ]\n```"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWithNext: <A, E, R>(self: Stream<A, E, R>) => Stream<[A, Option.Option<A>], E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6056"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipWithPrevious",
    "description": "Zips each element with the previous element. Initially accompanied by\n`None`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Chunk, Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipWithPrevious(Stream.make(1, 2, 3, 4))\n\nEffect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))\n// [\n//   [ { _id: 'Option', _tag: 'None' }, 1 ],\n//   [ { _id: 'Option', _tag: 'Some', value: 1 }, 2 ],\n//   [ { _id: 'Option', _tag: 'Some', value: 2 }, 3 ],\n//   [ { _id: 'Option', _tag: 'Some', value: 3 }, 4 ]\n// ]\n```"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWithPrevious: <A, E, R>(self: Stream<A, E, R>) => Stream<[Option.Option<A>, A], E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6080"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipWithPreviousAndNext",
    "description": "Zips each element with both the previous and next element.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Chunk, Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipWithPreviousAndNext(Stream.make(1, 2, 3, 4))\n\nEffect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))\n// [\n//   [\n//     { _id: 'Option', _tag: 'None' },\n//     1,\n//     { _id: 'Option', _tag: 'Some', value: 2 }\n//   ],\n//   [\n//     { _id: 'Option', _tag: 'Some', value: 1 },\n//     2,\n//     { _id: 'Option', _tag: 'Some', value: 3 }\n//   ],\n//   [\n//     { _id: 'Option', _tag: 'Some', value: 2 },\n//     3,\n//     { _id: 'Option', _tag: 'Some', value: 4 }\n//   ],\n//   [\n//     { _id: 'Option', _tag: 'Some', value: 3 },\n//     4,\n//     { _id: 'Option', _tag: 'None' }\n//   ]\n// ]\n```"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWithPreviousAndNext: <A, E, R>(self: Stream<A, E, R>) => Stream<[Option.Option<A>, A, Option.Option<A>], E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6120"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "zipWithIndex",
    "description": "Zips this stream together with the index of elements.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(\"Mary\", \"James\", \"Robert\", \"Patricia\")\n\nconst indexedStream = Stream.zipWithIndex(stream)\n\nEffect.runPromise(Stream.runCollect(indexedStream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [ [ 'Mary', 0 ], [ 'James', 1 ], [ 'Robert', 2 ], [ 'Patricia', 3 ] ]\n// }\n```"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "declare const zipWithIndex: <A, E, R>(self: Stream<A, E, R>) => Stream<[A, number], E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6145"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "Do",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Chunk, Effect, pipe, Stream } from \"effect\"\n\nconst result = pipe(\n  Stream.Do,\n  Stream.bind(\"x\", () => Stream.succeed(2)),\n  Stream.bind(\"y\", () => Stream.succeed(3)),\n  Stream.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))\n```"
    ],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "declare const Do: Stream<{}, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6183"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "bind",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Chunk, Effect, pipe, Stream } from \"effect\"\n\nconst result = pipe(\n  Stream.Do,\n  Stream.bind(\"x\", () => Stream.succeed(2)),\n  Stream.bind(\"y\", () => Stream.succeed(3)),\n  Stream.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))\n```"
    ],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "declare const bind: { <N extends string, A, B, E2, R2>(tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Stream<B, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E, R2 | R>; <A, E, R, N extends string, B, E2, R2>(self: Stream<A, E, R>, tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Stream<B, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; } | undefined): Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6217"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "bindEffect",
    "description": "Binds an effectful value in a `do` scope",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "declare const bindEffect: { <N extends string, A, B, E2, R2>(tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Effect.Effect<B, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in keyof A | N]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; <A, E, R, N extends string, B, E2, R2>(self: Stream<A, E, R>, tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Effect.Effect<B, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly unordered?: boolean | undefined; }): Stream<{ [K in keyof A | N]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6246"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "bindTo",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Chunk, Effect, pipe, Stream } from \"effect\"\n\nconst result = pipe(\n  Stream.Do,\n  Stream.bind(\"x\", () => Stream.succeed(2)),\n  Stream.bind(\"y\", () => Stream.succeed(3)),\n  Stream.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))\n```"
    ],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "declare const bindTo: { <N extends string>(name: N): <A, E, R>(self: Stream<A, E, R>) => Stream<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Stream<A, E, R>, name: N): Stream<{ [K in N]: A; }, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6292"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "decodeText",
    "description": "Decode Uint8Array chunks into a stream of strings using the specified encoding.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "encoding",
    "signature": "declare const decodeText: { (encoding?: string | undefined): <E, R>(self: Stream<Uint8Array, E, R>) => Stream<string, E, R>; <E, R>(self: Stream<Uint8Array, E, R>, encoding?: string | undefined): Stream<string, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6355"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "encodeText",
    "description": "Encode a stream of strings into a stream of Uint8Array chunks using the specified encoding.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "encoding",
    "signature": "declare const encodeText: <E, R>(self: Stream<string, E, R>) => Stream<Uint8Array, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6366"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "fromEventListener",
    "description": "Creates a `Stream` using addEventListener.",
    "deprecated": false,
    "examples": [],
    "since": "3.1.0",
    "category": null,
    "signature": "declare const fromEventListener: <A = unknown>(target: EventListener<A>, type: string, options?: boolean | { readonly capture?: boolean; readonly passive?: boolean; readonly once?: boolean; readonly bufferSize?: number | \"unbounded\" | undefined; } | undefined) => Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6396"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "Stream",
    "description": "A `Stream<A, E, R>` is a description of a program that, when evaluated, may\nemit zero or more values of type `A`, may fail with errors of type `E`, and\nuses an context of type `R`. One way to think of `Stream` is as a\n`Effect` program that could emit multiple values.\n\n`Stream` is a purely functional *pull* based stream. Pull based streams offer\ninherent laziness and backpressure, relieving users of the need to manage\nbuffers between operators. As an optimization, `Stream` does not emit\nsingle values, but rather an array of values. This allows the cost of effect\nevaluation to be amortized.\n\n`Stream` forms a monad on its `A` type parameter, and has error management\nfacilities for its `E` type parameter, modeled similarly to `Effect` (with\nsome adjustments for the multiple-valued nature of `Stream`). These aspects\nallow for rich and expressive composition of streams.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Stream<out A, out E = never, out R = never> extends Stream.Variance<A, E, R>, Pipeable {\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: StreamUnify<this>\n  [Unify.ignoreSymbol]?: StreamUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L70"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "StreamUnify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface StreamUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Stream?: () => A[Unify.typeSymbol] extends Stream<infer A0, infer E0, infer R0> | infer _ ? Stream<A0, E0, R0> : never\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L80"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "StreamUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface StreamUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L88"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "StreamTypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface StreamTypeLambda extends TypeLambda {\n  readonly type: Stream<this[\"Target\"], this[\"Out1\"], this[\"Out2\"]>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L104"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "EventListener",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "models",
    "signature": "export interface EventListener<A> {\n  addEventListener(\n    event: string,\n    f: (event: A) => void,\n    options?: {\n      readonly capture?: boolean\n      readonly passive?: boolean\n      readonly once?: boolean\n      readonly signal?: AbortSignal\n    } | boolean\n  ): void\n  removeEventListener(\n    event: string,\n    f: (event: A) => void,\n    options?: {\n      readonly capture?: boolean\n    } | boolean\n  ): void\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L6372"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "StreamTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type StreamTypeId = typeof StreamTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L48"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "Stream.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out A, out E, out R> {\n    readonly [StreamTypeId]: VarianceStruct<A, E, R>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L116"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "Stream.VarianceStruct",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "models",
    "signature": "export interface VarianceStruct<out A, out E, out R> {\n    readonly _A: Covariant<A>\n    readonly _E: Covariant<E>\n    readonly _R: Covariant<R>\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L124"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "Stream.Success",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "type-level",
    "signature": "type Success<T> = [T] extends [Stream<infer _A, infer _E, infer _R>] ? _A : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L134"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "Stream.Error",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "type-level",
    "signature": "type Error<T> = [T] extends [Stream<infer _A, infer _E, infer _R>] ? _E : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L140"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "Stream.Context",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "type-level",
    "signature": "type Context<T> = [T] extends [Stream<infer _A, infer _E, infer _R>] ? _R : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L146"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "Stream.DynamicTuple",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type DynamicTuple<T, N> = N extends N ? number extends N ? Array<T> : DynamicTupleOf<T, N, []>\n    : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L153"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Stream.ts",
      "path": "src/Stream.ts"
    },
    "project": "effect",
    "name": "Stream.DynamicTupleOf",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type DynamicTupleOf<T, N, R> = R[\"length\"] extends N ? R\n    : DynamicTupleOf<T, N, [T, ...R]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Stream.ts#L161"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Streamable.ts",
      "path": "src/Streamable.ts"
    },
    "project": "effect",
    "name": "Class",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare class Class<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Streamable.ts#L21"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "StreamEmit.ts",
      "path": "src/StreamEmit.ts"
    },
    "project": "effect",
    "name": "Emit",
    "description": "An `Emit<R, E, A, B>` represents an asynchronous callback that can be\ncalled multiple times. The callback can be called with a value of type\n`Effect<Chunk<A>, Option<E>, R>`, where succeeding with a `Chunk<A>`\nindicates to emit those elements, failing with `Some<E>` indicates to\nterminate with that error, and failing with `None` indicates to terminate\nwith an end of stream signal.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Emit<in R, in E, in A, out B> extends EmitOps<R, E, A, B> {\n  (f: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>): Promise<B>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamEmit.ts#L21"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "StreamEmit.ts",
      "path": "src/StreamEmit.ts"
    },
    "project": "effect",
    "name": "EmitOps",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface EmitOps<in R, in E, in A, out B> {\n  /**\n   * Emits a chunk containing the specified values.\n   */\n  chunk(chunk: Chunk.Chunk<A>): Promise<B>\n\n  /**\n   * Terminates with a cause that dies with the specified defect.\n   */\n  die<Err>(defect: Err): Promise<B>\n\n  /**\n   * Terminates with a cause that dies with a `Throwable` with the specified\n   * message.\n   */\n  dieMessage(message: string): Promise<B>\n\n  /**\n   * Either emits the specified value if this `Exit` is a `Success` or else\n   * terminates with the specified cause if this `Exit` is a `Failure`.\n   */\n  done(exit: Exit.Exit<A, E>): Promise<B>\n\n  /**\n   * Terminates with an end of stream signal.\n   */\n  end(): Promise<B>\n\n  /**\n   * Terminates with the specified error.\n   */\n  fail(error: E): Promise<B>\n\n  /**\n   * Either emits the success value of this effect or terminates the stream\n   * with the failure value of this effect.\n   */\n  fromEffect(effect: Effect.Effect<A, E, R>): Promise<B>\n\n  /**\n   * Either emits the success value of this effect or terminates the stream\n   * with the failure value of this effect.\n   */\n  fromEffectChunk(effect: Effect.Effect<Chunk.Chunk<A>, E, R>): Promise<B>\n\n  /**\n   * Terminates the stream with the specified cause.\n   */\n  halt(cause: Cause.Cause<E>): Promise<B>\n\n  /**\n   * Emits a chunk containing the specified value.\n   */\n  single(value: A): Promise<B>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamEmit.ts#L29"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "StreamEmit.ts",
      "path": "src/StreamEmit.ts"
    },
    "project": "effect",
    "name": "EmitOpsPush",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export interface EmitOpsPush<in E, in A> {\n  /**\n   * Emits a chunk containing the specified values.\n   */\n  chunk(chunk: Chunk.Chunk<A>): boolean\n\n  /**\n   * Emits a chunk containing the specified values.\n   */\n  array(chunk: ReadonlyArray<A>): boolean\n\n  /**\n   * Terminates with a cause that dies with the specified defect.\n   */\n  die<Err>(defect: Err): void\n\n  /**\n   * Terminates with a cause that dies with a `Throwable` with the specified\n   * message.\n   */\n  dieMessage(message: string): void\n\n  /**\n   * Either emits the specified value if this `Exit` is a `Success` or else\n   * terminates with the specified cause if this `Exit` is a `Failure`.\n   */\n  done(exit: Exit.Exit<A, E>): void\n\n  /**\n   * Terminates with an end of stream signal.\n   */\n  end(): void\n\n  /**\n   * Terminates with the specified error.\n   */\n  fail(error: E): void\n\n  /**\n   * Terminates the stream with the specified cause.\n   */\n  halt(cause: Cause.Cause<E>): void\n\n  /**\n   * Emits a chunk containing the specified value.\n   */\n  single(value: A): boolean\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamEmit.ts#L89"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "Left",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Left: HaltStrategy",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L54"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "Right",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Right: HaltStrategy",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L60"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "Both",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Both: HaltStrategy",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L66"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "Either",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Either: HaltStrategy",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L72"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "fromInput",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromInput: (input: HaltStrategyInput) => HaltStrategy",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L78"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "isLeft",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isLeft: (self: HaltStrategy) => self is Left",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L84"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "isRight",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isRight: (self: HaltStrategy) => self is Right",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L90"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "isBoth",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isBoth: (self: HaltStrategy) => self is Both",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L96"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "isEither",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isEither: (self: HaltStrategy) => self is Either",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L102"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Folds over the specified `HaltStrategy` using the provided case functions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const match: { <Z>(options: { readonly onLeft: () => Z; readonly onRight: () => Z; readonly onBoth: () => Z; readonly onEither: () => Z; }): (self: HaltStrategy) => Z; <Z>(self: HaltStrategy, options: { readonly onLeft: () => Z; readonly onRight: () => Z; readonly onBoth: () => Z; readonly onEither: () => Z; }): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L110"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "Left",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Left {\n  readonly _tag: \"Left\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L22"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "Right",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Right {\n  readonly _tag: \"Right\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L30"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "Both",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Both {\n  readonly _tag: \"Both\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L38"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "Either",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Either {\n  readonly _tag: \"Either\"\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L46"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "HaltStrategy",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type HaltStrategy = Left | Right | Both | Either",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L10"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "StreamHaltStrategy.ts",
      "path": "src/StreamHaltStrategy.ts"
    },
    "project": "effect",
    "name": "HaltStrategyInput",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type HaltStrategyInput = HaltStrategy | \"left\" | \"right\" | \"both\" | \"either\"",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/StreamHaltStrategy.ts#L16"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "isString",
    "description": "Tests if a value is a `string`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { String } from \"effect\"\n\nassert.deepStrictEqual(String.isString(\"a\"), true)\nassert.deepStrictEqual(String.isString(1), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isString: Refinement<unknown, string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L35"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "Equivalence",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Equivalence: equivalence.Equivalence<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L41"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "Order",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Order: order.Order<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L47"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "The empty string `\"\"`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const empty: \"\"",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L54"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "concat",
    "description": "Concatenates two strings at runtime.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const concat: { <B extends string>(that: B): <A extends string>(self: A) => Concat<A, B>; <A extends string, B extends string>(self: A, that: B): Concat<A, B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L68"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "split",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe('abc', String.split('')), ['a', 'b', 'c'])\nassert.deepStrictEqual(pipe('', String.split('')), [''])\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const split: { (separator: string | RegExp): (self: string) => NonEmptyArray<string>; (self: string, separator: string | RegExp): NonEmptyArray<string>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L264"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "charCodeAt",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"abc\", String.charCodeAt(1)), Option.some(98))\nassert.deepStrictEqual(pipe(\"abc\", String.charCodeAt(4)), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const charCodeAt: { (index: number): (self: string) => Option.Option<number>; (self: string, index: number): Option.Option<number>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L305"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "at",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"abc\", String.at(1)), Option.some(\"b\"))\nassert.deepStrictEqual(pipe(\"abc\", String.at(4)), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const at: { (index: number): (self: string) => Option.Option<string>; (self: string, index: number): Option.Option<string>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L340"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "charAt",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"abc\", String.charAt(1)), Option.some(\"b\"))\nassert.deepStrictEqual(pipe(\"abc\", String.charAt(4)), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const charAt: { (index: number): (self: string) => Option.Option<string>; (self: string, index: number): Option.Option<string>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L357"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "codePointAt",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"abc\", String.codePointAt(1)), Option.some(98))\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const codePointAt: { (index: number): (self: string) => Option.Option<number>; (self: string, index: number): Option.Option<number>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L376"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "search",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"ababb\", String.search(\"b\")), Option.some(1))\nassert.deepStrictEqual(pipe(\"ababb\", String.search(/abb/)), Option.some(2))\nassert.deepStrictEqual(pipe(\"ababb\", String.search(\"d\")), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const search: { (regexp: RegExp | string): (self: string) => Option.Option<number>; (self: string, regexp: RegExp | string): Option.Option<number>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L531"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "takeLeft",
    "description": "Keep the specified number of characters from the start of a string.\n\nIf `n` is larger than the available number of characters, the string will\nbe returned whole.\n\nIf `n` is not a positive number, an empty string will be returned.\n\nIf `n` is a float, it will be rounded down to the nearest integer.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { String } from \"effect\"\n\nassert.deepStrictEqual(String.takeLeft(\"Hello World\", 5), \"Hello\")\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const takeLeft: { (n: number): (self: string) => string; (self: string, n: number): string; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L590"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "takeRight",
    "description": "Keep the specified number of characters from the end of a string.\n\nIf `n` is larger than the available number of characters, the string will\nbe returned whole.\n\nIf `n` is not a positive number, an empty string will be returned.\n\nIf `n` is a float, it will be rounded down to the nearest integer.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { String } from \"effect\"\n\nassert.deepStrictEqual(String.takeRight(\"Hello World\", 5), \"World\")\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const takeRight: { (n: number): (self: string) => string; (self: string, n: number): string; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L615"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "stripMarginWith",
    "description": "For every line in this string, strip a leading prefix consisting of blanks\nor control characters followed by the character specified by `marginChar`\nfrom the line.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const stripMarginWith: { (marginChar: string): (self: string) => string; (self: string, marginChar: string): string; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L649"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "toUpperCase",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe('a', String.toUpperCase), 'A')\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const toUpperCase: <S extends string>(self: S) => Uppercase<S>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L84"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "toLowerCase",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe('A', String.toLowerCase), 'a')\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const toLowerCase: <T extends string>(self: T) => Lowercase<T>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L97"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "capitalize",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe('abc', String.capitalize), 'Abc')\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const capitalize: <T extends string>(self: T) => Capitalize<T>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L110"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "uncapitalize",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe('ABC', String.uncapitalize), 'aBC')\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const uncapitalize: <T extends string>(self: T) => Uncapitalize<T>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L127"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "replace",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe('abc', String.replace('b', 'd')), 'adc')\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const replace: (searchValue: string | RegExp, replaceValue: string) => (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L144"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "trim",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { String } from \"effect\"\n\nassert.deepStrictEqual(String.trim(' a '), 'a')\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const trim: <A extends string>(self: A) => Trim<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L163"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "trimStart",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { String } from \"effect\"\n\nassert.deepStrictEqual(String.trimStart(' a '), 'a ')\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const trimStart: <A extends string>(self: A) => TrimStart<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L181"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "trimEnd",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { String } from \"effect\"\n\nassert.deepStrictEqual(String.trimEnd(' a '), ' a')\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const trimEnd: <A extends string>(self: A) => TrimEnd<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L199"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "slice",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe('abcd', String.slice(1, 3)), 'bc')\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const slice: (start?: number, end?: number) => (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L212"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Test whether a `string` is empty.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { String } from \"effect\"\n\nassert.deepStrictEqual(String.isEmpty(''), true)\nassert.deepStrictEqual(String.isEmpty('a'), false)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const isEmpty: (self: string) => self is \"\"",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L228"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "isNonEmpty",
    "description": "Test whether a `string` is non empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const isNonEmpty: (self: string) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L235"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "length",
    "description": "Calculate the number of characters in a `string`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { String } from \"effect\"\n\nassert.deepStrictEqual(String.length('abc'), 3)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const length: (self: string) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L250"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "includes",
    "description": "Returns `true` if `searchString` appears as a substring of `self`, at one or more positions that are\ngreater than or equal to `position`; otherwise, returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const includes: (searchString: string, position?: number) => (self: string) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L278"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "startsWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const startsWith: (searchString: string, position?: number) => (self: string) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L284"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "endsWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const endsWith: (searchString: string, position?: number) => (self: string) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L290"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "substring",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"abcd\", String.substring(1)), \"bcd\")\nassert.deepStrictEqual(pipe(\"abcd\", String.substring(1, 3)), \"bc\")\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const substring: (start: number, end?: number) => (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L326"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "indexOf",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"abbbc\", String.indexOf(\"b\")), Option.some(1))\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const indexOf: (searchString: string) => (self: string) => Option.Option<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L392"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "lastIndexOf",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"abbbc\", String.lastIndexOf(\"b\")), Option.some(3))\nassert.deepStrictEqual(pipe(\"abbbc\", String.lastIndexOf(\"d\")), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const lastIndexOf: (searchString: string) => (self: string) => Option.Option<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L407"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "localeCompare",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"a\", String.localeCompare(\"b\")), -1)\nassert.deepStrictEqual(pipe(\"b\", String.localeCompare(\"a\")), 1)\nassert.deepStrictEqual(pipe(\"a\", String.localeCompare(\"a\")), 0)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const localeCompare: (that: string, locales?: Array<string>, options?: Intl.CollatorOptions) => (self: string) => Ordering.Ordering",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L423"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "It is the `pipe`-able version of the native `match` method.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const match: (regexp: RegExp | string) => (self: string) => Option.Option<RegExpMatchArray>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L432"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "matchAll",
    "description": "It is the `pipe`-able version of the native `matchAll` method.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const matchAll: (regexp: RegExp) => (self: string) => IterableIterator<RegExpMatchArray>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L440"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "normalize",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nconst str = \"\\u1E9B\\u0323\";\nassert.deepStrictEqual(pipe(str, String.normalize()), \"\\u1E9B\\u0323\")\nassert.deepStrictEqual(pipe(str, String.normalize(\"NFC\")), \"\\u1E9B\\u0323\")\nassert.deepStrictEqual(pipe(str, String.normalize(\"NFD\")), \"\\u017F\\u0323\\u0307\")\nassert.deepStrictEqual(pipe(str, String.normalize(\"NFKC\")), \"\\u1E69\")\nassert.deepStrictEqual(pipe(str, String.normalize(\"NFKD\")), \"\\u0073\\u0323\\u0307\")\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const normalize: (form?: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\") => (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L458"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "padEnd",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"a\", String.padEnd(5)), \"a    \")\nassert.deepStrictEqual(pipe(\"a\", String.padEnd(5, \"_\")), \"a____\")\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const padEnd: (maxLength: number, fillString?: string) => (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L472"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "padStart",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"a\", String.padStart(5)), \"    a\")\nassert.deepStrictEqual(pipe(\"a\", String.padStart(5, \"_\")), \"____a\")\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const padStart: (maxLength: number, fillString?: string) => (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L487"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "repeat",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"a\", String.repeat(5)), \"aaaaa\")\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const repeat: (count: number) => (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L501"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "replaceAll",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"ababb\", String.replaceAll(\"b\", \"c\")), \"acacc\")\nassert.deepStrictEqual(pipe(\"ababb\", String.replaceAll(/ba/g, \"cc\")), \"accbb\")\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const replaceAll: (searchValue: string | RegExp, replaceValue: string) => (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L515"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "toLocaleLowerCase",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nconst str = \"\\u0130\"\nassert.deepStrictEqual(pipe(str, String.toLocaleLowerCase(\"tr\")), \"i\")\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const toLocaleLowerCase: (locale?: string | Array<string>) => (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L552"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "toLocaleUpperCase",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, String } from \"effect\"\n\nconst str = \"i\\u0307\"\nassert.deepStrictEqual(pipe(str, String.toLocaleUpperCase(\"lt-LT\")), \"I\")\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const toLocaleUpperCase: (locale?: string | Array<string>) => (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L567"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "linesIterator",
    "description": "Returns an `IterableIterator` which yields each line contained within the\nstring, trimming off the trailing newline character.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const linesIterator: (self: string) => LinesIterator",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L632"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "linesWithSeparators",
    "description": "Returns an `IterableIterator` which yields each line contained within the\nstring as well as the trailing newline character.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const linesWithSeparators: (s: string) => LinesIterator",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L640"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "stripMargin",
    "description": "For every line in this string, strip a leading prefix consisting of blanks\nor control characters followed by the `\"|\"` character from the line.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const stripMargin: (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L678"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "snakeToCamel",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const snakeToCamel: (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L683"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "snakeToPascal",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const snakeToPascal: (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L694"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "snakeToKebab",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const snakeToKebab: (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L705"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "camelToSnake",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const camelToSnake: (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L710"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "pascalToSnake",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const pascalToSnake: (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L715"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "kebabToSnake",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const kebabToSnake: (self: string) => string",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L721"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "Concat",
    "description": "Concatenates two strings at the type level.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type `${A}${B}` = `${A}${B}`",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L61"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "Trim",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Trim<A> = TrimEnd<TrimStart<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L150"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "TrimStart",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type TrimStart<A> = A extends `${\" \" | \"\\n\" | \"\\t\" | \"\\r\"}${infer B}` ? TrimStart<B> : A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L168"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "String.ts",
      "path": "src/String.ts"
    },
    "project": "effect",
    "name": "TrimEnd",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type TrimEnd<A> = A extends `${infer B}${\" \" | \"\\n\" | \"\\t\" | \"\\r\"}` ? TrimEnd<B> : A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/String.ts#L186"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Struct.ts",
      "path": "src/Struct.ts"
    },
    "project": "effect",
    "name": "pick",
    "description": "Create a new object by picking properties of an existing object.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, Struct } from \"effect\"\n\nassert.deepStrictEqual(pipe({ a: \"a\", b: 1, c: true }, Struct.pick(\"a\", \"b\")), { a: \"a\", b: 1 })\nassert.deepStrictEqual(Struct.pick({ a: \"a\", b: 1, c: true }, \"a\", \"b\"), { a: \"a\", b: 1 })\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const pick: { <Keys extends Array<PropertyKey>>(...keys: Keys): <S extends { [K in Keys[number]]?: any; }>(s: S) => MatchRecord<S, { [K in Keys[number]]?: S[K]; }, Simplify<Pick<S, Keys[number]>>>; <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys): MatchRecord<S, { [K in Keys[number]]?: S[K]; }, Simplify<Pick<S, Keys[number]>>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Struct.ts#L27"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Struct.ts",
      "path": "src/Struct.ts"
    },
    "project": "effect",
    "name": "omit",
    "description": "Create a new object by omitting properties of an existing object.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, Struct } from \"effect\"\n\nassert.deepStrictEqual(pipe({ a: \"a\", b: 1, c: true }, Struct.omit(\"c\")), { a: \"a\", b: 1 })\nassert.deepStrictEqual(Struct.omit({ a: \"a\", b: 1, c: true }, \"c\"), { a: \"a\", b: 1 })\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const omit: { <Keys extends Array<PropertyKey>>(...keys: Keys): <S extends { [K in Keys[number]]?: any; }>(s: S) => Simplify<Omit<S, Keys[number]>>; <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys): Simplify<Omit<S, Keys[number]>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Struct.ts#L64"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Struct.ts",
      "path": "src/Struct.ts"
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": "Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct\nby applying each `Equivalence` to the corresponding property of the struct.\n\nAlias of {@link Equivalence.struct}.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Struct, String, Number } from \"effect\"\n\nconst PersonEquivalence = Struct.getEquivalence({\n  name: String.Equivalence,\n  age: Number.Equivalence\n})\n\nassert.deepStrictEqual(\n  PersonEquivalence({ name: \"John\", age: 25 }, { name: \"John\", age: 25 }),\n  true\n)\nassert.deepStrictEqual(\n  PersonEquivalence({ name: \"John\", age: 25 }, { name: \"John\", age: 40 }),\n  false\n)\n```"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const getEquivalence: <R extends Record<string, Equivalence.Equivalence<any>>>(isEquivalents: R) => Equivalence.Equivalence<{ readonly [K in keyof R]: [R[K]] extends [Equivalence.Equivalence<infer A>] ? A : never; }>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Struct.ts#L112"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Struct.ts",
      "path": "src/Struct.ts"
    },
    "project": "effect",
    "name": "getOrder",
    "description": "This function creates and returns a new `Order` for a struct of values based on the given `Order`s\nfor each property in the struct.\n\nAlias of {@link order.struct}.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const getOrder: <R extends { readonly [x: string]: order.Order<any>; }>(fields: R) => order.Order<{ [K in keyof R]: [R[K]] extends [order.Order<infer A>] ? A : never; }>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Struct.ts#L127"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Struct.ts",
      "path": "src/Struct.ts"
    },
    "project": "effect",
    "name": "evolve",
    "description": "Transforms the values of a Struct provided a transformation function for each key.\nIf no transformation function is provided for a key, it will return the origional value for that key.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, Struct } from \"effect\"\n\nassert.deepStrictEqual(\n  pipe(\n    { a: 'a', b: 1, c: 3 },\n    Struct.evolve({\n      a: (a) => a.length,\n      b: (b) => b * 2\n    })\n  ),\n  { a: 1, b: 2, c: 3 }\n)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const evolve: { <O, T>(t: PartialTransform<O, T>): (obj: O) => Transformed<O, T>; <O, T>(obj: O, t: PartialTransform<O, T>): Transformed<O, T>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Struct.ts#L162"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Struct.ts",
      "path": "src/Struct.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves the value associated with the specified key from a struct.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, Struct } from \"effect\"\n\nconst value = pipe({ a: 1, b: 2 }, Struct.get(\"a\"))\n\nassert.deepStrictEqual(value, 1)\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const get: <K extends PropertyKey>(key: K) => <S extends { [P in K]?: any; }>(s: S) => MatchRecord<S, S[K] | undefined, S[K]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Struct.ts#L194"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Struct.ts",
      "path": "src/Struct.ts"
    },
    "project": "effect",
    "name": "keys",
    "description": "Retrieves the object keys that are strings in a typed manner",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Struct } from \"effect\"\n\nconst symbol: unique symbol = Symbol()\n\nconst value = {\n  a: 1,\n  b: 2,\n  [symbol]: 3\n}\n\nconst keys: Array<\"a\" | \"b\"> = Struct.keys(value)\n\nassert.deepStrictEqual(keys, [\"a\", \"b\"])\n```"
    ],
    "since": "3.6.0",
    "category": null,
    "signature": "declare const keys: <T extends {}>(o: T) => Array<(keyof T) & string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Struct.ts#L221"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Subscribable.ts",
      "path": "src/Subscribable.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "declare const TypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Subscribable.ts#L16"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Subscribable.ts",
      "path": "src/Subscribable.ts"
    },
    "project": "effect",
    "name": "map",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const map: { <A, B>(f: (a: NoInfer<A>) => B): <E, R>(fa: Subscribable<A, E, R>) => Subscribable<B, E, R>; <A, E, R, B>(self: Subscribable<A, E, R>, f: (a: NoInfer<A>) => B): Subscribable<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Subscribable.ts#L60"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Subscribable.ts",
      "path": "src/Subscribable.ts"
    },
    "project": "effect",
    "name": "mapEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const mapEffect: { <A, B, E2, R2>(f: (a: NoInfer<A>) => Effect.Effect<B, E2, R2>): <E, R>(fa: Subscribable<A, E, R>) => Subscribable<B, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Subscribable<A, E, R>, f: (a: NoInfer<A>) => Effect.Effect<B, E2, R2>): Subscribable<B, E | E2, R | R2>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Subscribable.ts#L73"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Subscribable.ts",
      "path": "src/Subscribable.ts"
    },
    "project": "effect",
    "name": "isSubscribable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isSubscribable: (u: unknown) => u is Subscribable<unknown, unknown, unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Subscribable.ts#L37"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Subscribable.ts",
      "path": "src/Subscribable.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A, E, R>(options: { readonly get: Effect.Effect<A, E, R>; readonly changes: Stream.Stream<A, E, R>; }) => Subscribable<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Subscribable.ts#L51"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Subscribable.ts",
      "path": "src/Subscribable.ts"
    },
    "project": "effect",
    "name": "unwrap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unwrap: <A, E, R, E1, R1>(effect: Effect.Effect<Subscribable<A, E, R>, E1, R1>) => Subscribable<A, E | E1, R | R1>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Subscribable.ts#L94"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Subscribable.ts",
      "path": "src/Subscribable.ts"
    },
    "project": "effect",
    "name": "Subscribable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Subscribable<A, E = never, R = never> extends Readable.Readable<A, E, R> {\n  readonly [TypeId]: TypeId\n  readonly changes: Stream.Stream<A, E, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Subscribable.ts#L28"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Subscribable.ts",
      "path": "src/Subscribable.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Subscribable.ts#L22"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "SubscriptionRefTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const SubscriptionRefTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L19"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "get",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const get: <A>(self: SubscriptionRef<A>) => Effect.Effect<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L90"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "getAndSet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndSet: { <A>(value: A): (self: SubscriptionRef<A>) => Effect.Effect<A>; <A>(self: SubscriptionRef<A>, value: A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L96"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdate",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndUpdate: { <A>(f: (a: A) => A): (self: SubscriptionRef<A>) => Effect.Effect<A>; <A>(self: SubscriptionRef<A>, f: (a: A) => A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L105"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdateEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndUpdateEffect: { <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SubscriptionRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L114"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdateSome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndUpdateSome: { <A>(pf: (a: A) => Option.Option<A>): (self: SubscriptionRef<A>) => Effect.Effect<A>; <A>(self: SubscriptionRef<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L123"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdateSomeEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndUpdateSomeEffect: { <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SubscriptionRef<A>, pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L132"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new `SubscriptionRef` with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A>(value: A) => Effect.Effect<SubscriptionRef<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L148"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "modify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const modify: { <A, B>(f: (a: A) => readonly [B, A]): (self: SubscriptionRef<A>) => Effect.Effect<B>; <A, B>(self: SubscriptionRef<A>, f: (a: A) => readonly [B, A]): Effect.Effect<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L154"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "modifyEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const modifyEffect: { <B, A, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): (self: SubscriptionRef<A>) => Effect.Effect<B, E, R>; <A, B, E, R>(self: SubscriptionRef<A>, f: (a: A) => Effect.Effect<readonly [B, A], E, R>): Effect.Effect<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L163"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "modifySome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const modifySome: { <B, A>(fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): (self: SubscriptionRef<A>) => Effect.Effect<B>; <A, B>(self: SubscriptionRef<A>, fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): Effect.Effect<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L172"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "modifySomeEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const modifySomeEffect: { <A, B, R, E>(fallback: B, pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>): (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<B, E, R>; <A, B, R, E>(self: Synchronized.SynchronizedRef<A>, fallback: B, pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>): Effect.Effect<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L188"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "set",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const set: { <A>(value: A): (self: SubscriptionRef<A>) => Effect.Effect<void>; <A>(self: SubscriptionRef<A>, value: A): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L204"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "setAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const setAndGet: { <A>(value: A): (self: SubscriptionRef<A>) => Effect.Effect<A>; <A>(self: SubscriptionRef<A>, value: A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L213"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "update",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const update: { <A>(f: (a: A) => A): (self: SubscriptionRef<A>) => Effect.Effect<void>; <A>(self: SubscriptionRef<A>, f: (a: A) => A): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L222"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "updateEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateEffect: { <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<void, E, R>; <A, R, E>(self: Synchronized.SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L231"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "updateAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateAndGet: { <A>(f: (a: A) => A): (self: SubscriptionRef<A>) => Effect.Effect<A>; <A>(self: SubscriptionRef<A>, f: (a: A) => A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L240"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "updateAndGetEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateAndGetEffect: { <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SubscriptionRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L249"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "updateSome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateSome: { <A>(f: (a: A) => Option.Option<A>): (self: SubscriptionRef<A>) => Effect.Effect<void>; <A>(self: SubscriptionRef<A>, f: (a: A) => Option.Option<A>): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L258"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "updateSomeEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateSomeEffect: { <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<void, E, R>; <A, R, E>(self: Synchronized.SynchronizedRef<A>, pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): Effect.Effect<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L267"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "updateSomeAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateSomeAndGet: { <A>(pf: (a: A) => Option.Option<A>): (self: SubscriptionRef<A>) => Effect.Effect<A>; <A>(self: SubscriptionRef<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L281"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "updateSomeAndGetEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateSomeAndGetEffect: { <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SubscriptionRef<A>, pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L290"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "SubscriptionRef",
    "description": "A `SubscriptionRef<A>` is a `Ref` that can be subscribed to in order to\nreceive the current value as well as all changes to the value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SubscriptionRef<in out A>\n  extends SubscriptionRef.Variance<A>, Synchronized.SynchronizedRef<A>, Subscribable<A>\n{\n  /** @internal */\n  readonly ref: Ref.Ref<A>\n  /** @internal */\n  readonly pubsub: PubSub.PubSub<A>\n  /** @internal */\n  readonly semaphore: Effect.Semaphore\n  /**\n   * A stream containing the current value of the `Ref` as well as all changes\n   * to that value.\n   */\n  readonly changes: Stream.Stream<A>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: SubscriptionRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: SubscriptionRefUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L34"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "SubscriptionRefUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface SubscriptionRefUnify<A extends { [Unify.typeSymbol]?: any }>\n  extends Synchronized.SynchronizedRefUnify<A>\n{\n  SubscriptionRef?: () => Extract<A[Unify.typeSymbol], SubscriptionRef<any>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L57"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "SubscriptionRefUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface SubscriptionRefUnifyIgnore extends Synchronized.SynchronizedRefUnifyIgnore {\n  SynchronizedRef?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L67"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "SubscriptionRefTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type SubscriptionRefTypeId = typeof SubscriptionRefTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L25"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SubscriptionRef.ts",
      "path": "src/SubscriptionRef.ts"
    },
    "project": "effect",
    "name": "SubscriptionRef.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out A> {\n    readonly [SubscriptionRefTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SubscriptionRef.ts#L79"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Supervisor.ts",
      "path": "src/Supervisor.ts"
    },
    "project": "effect",
    "name": "AbstractSupervisor",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare class AbstractSupervisor<T>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L155"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Supervisor.ts",
      "path": "src/Supervisor.ts"
    },
    "project": "effect",
    "name": "SupervisorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const SupervisorTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L24"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Supervisor.ts",
      "path": "src/Supervisor.ts"
    },
    "project": "effect",
    "name": "addSupervisor",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const addSupervisor: <A>(supervisor: Supervisor<A>) => Layer.Layer<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L107"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Supervisor.ts",
      "path": "src/Supervisor.ts"
    },
    "project": "effect",
    "name": "fibersIn",
    "description": "Creates a new supervisor that tracks children in a set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fibersIn: (ref: MutableRef.MutableRef<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>) => Effect.Effect<Supervisor<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L115"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Supervisor.ts",
      "path": "src/Supervisor.ts"
    },
    "project": "effect",
    "name": "fromEffect",
    "description": "Creates a new supervisor that constantly yields effect when polled",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromEffect: <A>(effect: Effect.Effect<A>) => Supervisor<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L125"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Supervisor.ts",
      "path": "src/Supervisor.ts"
    },
    "project": "effect",
    "name": "none",
    "description": "A supervisor that doesn't do anything in response to supervision events.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const none: Supervisor<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L133"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Supervisor.ts",
      "path": "src/Supervisor.ts"
    },
    "project": "effect",
    "name": "track",
    "description": "Creates a new supervisor that tracks children in a set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const track: Effect.Effect<Supervisor<Array<Fiber.RuntimeFiber<any, any>>>, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L141"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Supervisor.ts",
      "path": "src/Supervisor.ts"
    },
    "project": "effect",
    "name": "unsafeTrack",
    "description": "Unsafely creates a new supervisor that tracks children in a set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeTrack: () => Supervisor<Array<Fiber.RuntimeFiber<any, any>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L149"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Supervisor.ts",
      "path": "src/Supervisor.ts"
    },
    "project": "effect",
    "name": "Supervisor",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Supervisor<out T> extends Supervisor.Variance<T> {\n  /**\n   * Returns an `Effect` that succeeds with the value produced by this\n   * supervisor. This value may change over time, reflecting what the supervisor\n   * produces as it supervises fibers.\n   */\n  readonly value: Effect.Effect<T>\n\n  /**\n   * Supervises the start of a `Fiber`.\n   */\n  onStart<A, E, R>(\n    context: Context.Context<R>,\n    effect: Effect.Effect<A, E, R>,\n    parent: Option.Option<Fiber.RuntimeFiber<any, any>>,\n    fiber: Fiber.RuntimeFiber<A, E>\n  ): void\n\n  /**\n   * Supervises the end of a `Fiber`.\n   */\n  onEnd<A, E>(value: Exit.Exit<A, E>, fiber: Fiber.RuntimeFiber<A, E>): void\n\n  /**\n   * Supervises the execution of an `Effect` by a `Fiber`.\n   */\n  onEffect<A, E>(fiber: Fiber.RuntimeFiber<A, E>, effect: Effect.Effect<any, any, any>): void\n\n  /**\n   * Supervises the suspension of a computation running within a `Fiber`.\n   */\n  onSuspend<A, E>(fiber: Fiber.RuntimeFiber<A, E>): void\n\n  /**\n   * Supervises the resumption of a computation running within a `Fiber`.\n   */\n  onResume<A, E>(fiber: Fiber.RuntimeFiber<A, E>): void\n\n  /**\n   * Maps this supervisor to another one, which has the same effect, but whose\n   * value has been transformed by the specified function.\n   */\n  map<B>(f: (a: T) => B): Supervisor<B>\n\n  /**\n   * Returns a new supervisor that performs the function of this supervisor, and\n   * the function of the specified supervisor, producing a tuple of the outputs\n   * produced by both supervisors.\n   */\n  zip<A>(right: Supervisor<A>): Supervisor<[T, A]>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L36"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Supervisor.ts",
      "path": "src/Supervisor.ts"
    },
    "project": "effect",
    "name": "SupervisorTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type SupervisorTypeId = typeof SupervisorTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L30"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Supervisor.ts",
      "path": "src/Supervisor.ts"
    },
    "project": "effect",
    "name": "Supervisor.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out T> {\n    readonly [SupervisorTypeId]: {\n      readonly _T: Types.Covariant<T>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Supervisor.ts#L96"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Symbol.ts",
      "path": "src/Symbol.ts"
    },
    "project": "effect",
    "name": "isSymbol",
    "description": "Tests if a value is a `symbol`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Predicate } from \"effect\"\n\nassert.deepStrictEqual(Predicate.isSymbol(Symbol.for(\"a\")), true)\nassert.deepStrictEqual(Predicate.isSymbol(\"a\"), false)\n```"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "declare const isSymbol: (u: unknown) => u is symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Symbol.ts#L23"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Symbol.ts",
      "path": "src/Symbol.ts"
    },
    "project": "effect",
    "name": "Equivalence",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "declare const Equivalence: equivalence.Equivalence<symbol>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Symbol.ts#L29"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "SynchronizedRefTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const SynchronizedRefTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L17"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A>(value: A) => Effect.Effect<SynchronizedRef<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L71"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "get",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const get: <A>(self: SynchronizedRef<A>) => Effect.Effect<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L77"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "getAndSet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndSet: { <A>(value: A): (self: Ref.Ref<A>) => Effect.Effect<A>; <A>(self: Ref.Ref<A>, value: A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L83"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdate",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndUpdate: { <A>(f: (a: A) => A): (self: Ref.Ref<A>) => Effect.Effect<A>; <A>(self: Ref.Ref<A>, f: (a: A) => A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L92"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdateEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndUpdateEffect: { <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L101"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdateSome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndUpdateSome: { <A>(pf: (a: A) => Option.Option<A>): (self: Ref.Ref<A>) => Effect.Effect<A>; <A>(self: Ref.Ref<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L110"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdateSomeEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const getAndUpdateSomeEffect: { <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SynchronizedRef<A>, pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L119"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "modify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const modify: { <A, B>(f: (a: A) => readonly [B, A]): (self: SynchronizedRef<A>) => Effect.Effect<B>; <A, B>(self: SynchronizedRef<A>, f: (a: A) => readonly [B, A]): Effect.Effect<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L128"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "modifyEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const modifyEffect: { <A, B, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): (self: SynchronizedRef<A>) => Effect.Effect<B, E, R>; <A, B, E, R>(self: SynchronizedRef<A>, f: (a: A) => Effect.Effect<readonly [B, A], E, R>): Effect.Effect<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L137"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "modifySome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const modifySome: { <B, A>(fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): (self: Ref.Ref<A>) => Effect.Effect<B>; <A, B>(self: Ref.Ref<A>, fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): Effect.Effect<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L146"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "modifySomeEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const modifySomeEffect: { <A, B, R, E>(fallback: B, pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>): (self: SynchronizedRef<A>) => Effect.Effect<B, E, R>; <A, B, R, E>(self: SynchronizedRef<A>, fallback: B, pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>): Effect.Effect<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L162"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "set",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const set: { <A>(value: A): (self: Ref.Ref<A>) => Effect.Effect<void>; <A>(self: Ref.Ref<A>, value: A): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L178"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "setAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const setAndGet: { <A>(value: A): (self: Ref.Ref<A>) => Effect.Effect<A>; <A>(self: Ref.Ref<A>, value: A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L187"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "update",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const update: { <A>(f: (a: A) => A): (self: Ref.Ref<A>) => Effect.Effect<void>; <A>(self: Ref.Ref<A>, f: (a: A) => A): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L196"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "updateEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateEffect: { <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SynchronizedRef<A>) => Effect.Effect<void, E, R>; <A, R, E>(self: SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L205"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "updateAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateAndGet: { <A>(f: (a: A) => A): (self: Ref.Ref<A>) => Effect.Effect<A>; <A>(self: Ref.Ref<A>, f: (a: A) => A): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L214"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "updateAndGetEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateAndGetEffect: { <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L223"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "updateSome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateSome: { <A>(f: (a: A) => Option.Option<A>): (self: Ref.Ref<A>) => Effect.Effect<void>; <A>(self: Ref.Ref<A>, f: (a: A) => Option.Option<A>): Effect.Effect<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L232"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "updateSomeEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateSomeEffect: { <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SynchronizedRef<A>) => Effect.Effect<void, E, R>; <A, R, E>(self: SynchronizedRef<A>, pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): Effect.Effect<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L241"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "updateSomeAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateSomeAndGet: { <A>(pf: (a: A) => Option.Option<A>): (self: Ref.Ref<A>) => Effect.Effect<A>; <A>(self: Ref.Ref<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L252"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "updateSomeAndGetEffect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const updateSomeAndGetEffect: { <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SynchronizedRef<A>, pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L261"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "unsafeMake",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeMake: <A>(value: A) => SynchronizedRef<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L270"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "SynchronizedRef",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SynchronizedRef<in out A> extends SynchronizedRef.Variance<A>, Ref.Ref<A> {\n  modifyEffect<B, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): Effect.Effect<B, E, R>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: SynchronizedRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: SynchronizedRefUnifyIgnore\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L29"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "SynchronizedRefUnify",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface SynchronizedRefUnify<A extends { [Unify.typeSymbol]?: any }> extends Ref.RefUnify<A> {\n  SynchronizedRef?: () => Extract<A[Unify.typeSymbol], SynchronizedRef<any>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L40"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "SynchronizedRefUnifyIgnore",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface SynchronizedRefUnifyIgnore extends Ref.RefUnifyIgnore {\n  Ref?: true\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L48"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "SynchronizedRefTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type SynchronizedRefTypeId = typeof SynchronizedRefTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L23"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SynchronizedRef.ts",
      "path": "src/SynchronizedRef.ts"
    },
    "project": "effect",
    "name": "SynchronizedRef.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out A> {\n    readonly [SynchronizedRefTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/SynchronizedRef.ts#L60"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "TakeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TakeTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L17"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "chunk",
    "description": "Creates a `Take` with the specified chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const chunk: <A>(chunk: Chunk.Chunk<A>) => Take<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L60"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "die",
    "description": "Creates a failing `Take` with the specified defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const die: (defect: unknown) => Take<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L68"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "dieMessage",
    "description": "Creates a failing `Take` with the specified error message.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dieMessage: (message: string) => Take<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L76"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "done",
    "description": "Transforms a `Take<A, E>` to an `Effect<A, E>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const done: <A, E>(self: Take<A, E>) => Effect.Effect<Chunk.Chunk<A>, Option.Option<E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L84"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "end",
    "description": "Represents the end-of-stream marker.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const end: Take<never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L92"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "fail",
    "description": "Creates a failing `Take` with the specified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fail: <E>(error: E) => Take<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L100"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "failCause",
    "description": "Creates a failing `Take` with the specified cause.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const failCause: <E>(cause: Cause.Cause<E>) => Take<never, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L108"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "fromEffect",
    "description": "Creates an effect from `Effect<A, E, R>` that does not fail, but succeeds with\nthe `Take<A, E>`. Error from stream when pulling is converted to\n`Take.failCause`. Creates a single value chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<Take<A, E>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L118"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "fromExit",
    "description": "Creates a `Take` from an `Exit`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromExit: <A, E>(exit: Exit.Exit<A, E>) => Take<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L127"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "fromPull",
    "description": "Creates effect from `Effect<Chunk<A>, Option<E>, R>` that does not fail, but\nsucceeds with the `Take<A, E>`. Errors from stream when pulling are converted\nto `Take.failCause`, and the end-of-stream is converted to `Take.end`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromPull: <A, E, R>(pull: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>) => Effect.Effect<Take<A, E>, never, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L137"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "isDone",
    "description": "Checks if this `take` is done (`Take.end`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isDone: <A, E>(self: Take<A, E>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L147"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "isFailure",
    "description": "Checks if this `take` is a failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isFailure: <A, E>(self: Take<A, E>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L155"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "isSuccess",
    "description": "Checks if this `take` is a success.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isSuccess: <A, E>(self: Take<A, E>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L163"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a `Take`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A, E>(exit: Exit.Exit<Chunk.Chunk<A>, Option.Option<E>>) => Take<A, E>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L171"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms `Take<A, E>` to `Take<B, A>` by applying function `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const map: { <A, B>(f: (a: A) => B): <E>(self: Take<A, E>) => Take<B, E>; <A, E, B>(self: Take<A, E>, f: (a: A) => B): Take<B, E>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L179"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Folds over the failure cause, success value and end-of-stream marker to\nyield a value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const match: { <Z, E, Z2, A, Z3>(options: { readonly onEnd: () => Z; readonly onFailure: (cause: Cause.Cause<E>) => Z2; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Z3; }): (self: Take<A, E>) => Z | Z2 | Z3; <A, E, Z, Z2, Z3>(self: Take<A, E>, options: { readonly onEnd: () => Z; readonly onFailure: (cause: Cause.Cause<E>) => Z2; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Z3; }): Z | Z2 | Z3; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L191"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "matchEffect",
    "description": "Effectful version of `Take.fold`.\n\nFolds over the failure cause, success value and end-of-stream marker to\nyield an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const matchEffect: { <Z, E2, R, E, Z2, R2, A, Z3, E3, R3>(options: { readonly onEnd: Effect.Effect<Z, E2, R>; readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<Z2, E2, R2>; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Effect.Effect<Z3, E3, R3>; }): (self: Take<A, E>) => Effect.Effect<Z | Z2 | Z3, E2 | E | E3, R | R2 | R3>; <A, E, Z, E2, R, Z2, R2, Z3, E3, R3>(self: Take<A, E>, options: { readonly onEnd: Effect.Effect<Z, E2, R>; readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<Z2, E2, R2>; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Effect.Effect<Z3, E3, R3>; }): Effect.Effect<Z | Z2 | Z3, E | E2 | E3, R | R2 | R3>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L218"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "of",
    "description": "Creates a `Take` with a single value chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const of: <A>(value: A) => Take<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L242"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "tap",
    "description": "Returns an effect that effectfully \"peeks\" at the success of this take.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "declare const tap: { <A, X, E2, R>(f: (chunk: Chunk.Chunk<A>) => Effect.Effect<X, E2, R>): <E>(self: Take<A, E>) => Effect.Effect<void, E2 | E, R>; <A, E, X, E2, R>(self: Take<A, E>, f: (chunk: Chunk.Chunk<A>) => Effect.Effect<X, E2, R>): Effect.Effect<void, E | E2, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L250"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "Take",
    "description": "A `Take<A, E>` represents a single `take` from a queue modeling a stream of\nvalues. A `Take` may be a failure cause `Cause<E>`, a chunk value `Chunk<A>`,\nor an end-of-stream marker.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Take<out A, out E = never> extends Take.Variance<A, E>, Pipeable {\n  /** @internal */\n  readonly exit: Exit.Exit<Chunk.Chunk<A>, Option.Option<E>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L33"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "TakeTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type TakeTypeId = typeof TakeTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L23"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Take.ts",
      "path": "src/Take.ts"
    },
    "project": "effect",
    "name": "Take.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out A, out E> {\n    readonly [TakeTypeId]: {\n      readonly _A: Types.Covariant<A>\n      readonly _E: Types.Covariant<E>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Take.ts#L46"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "TArrayTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TArrayTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L16"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "collectFirst",
    "description": "Finds the result of applying a partial function to the first value in its\ndomain.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const collectFirst: { <A, B>(pf: (a: A) => Option.Option<B>): (self: TArray<A>) => STM.STM<Option.Option<B>>; <A, B>(self: TArray<A>, pf: (a: A) => Option.Option<B>): STM.STM<Option.Option<B>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L60"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "collectFirstSTM",
    "description": "Finds the result of applying an transactional partial function to the first\nvalue in its domain.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const collectFirstSTM: { <A, B, E, R>(pf: (a: A) => Option.Option<STM.STM<B, E, R>>): (self: TArray<A>) => STM.STM<Option.Option<B>, E, R>; <A, B, E, R>(self: TArray<A>, pf: (a: A) => Option.Option<STM.STM<B, E, R>>): STM.STM<Option.Option<B>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L72"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "contains",
    "description": "Determine if the array contains a specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const contains: { <A>(value: A): (self: TArray<A>) => STM.STM<boolean>; <A>(self: TArray<A>, value: A): STM.STM<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L84"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "count",
    "description": "Count the values in the array matching a predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const count: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<number>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<number>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L96"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "countSTM",
    "description": "Count the values in the array matching a transactional predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const countSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<number, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<number, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L108"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Makes an empty `TArray`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <A>() => STM.STM<TArray<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L119"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "every",
    "description": "Atomically evaluate the conjunction of a predicate across the members of\nthe array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const every: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<boolean>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L128"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "everySTM",
    "description": "Atomically evaluate the conjunction of a transactional predicate across the\nmembers of the array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const everySTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<boolean, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<boolean, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L140"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Find the first element in the array matching the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirst: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L151"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "findFirstIndex",
    "description": "Get the first index of a specific value in the array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirstIndex: { <A>(value: A): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A): STM.STM<Option.Option<number>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L162"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "findFirstIndexFrom",
    "description": "Get the first index of a specific value in the array starting from the\nspecified index.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirstIndexFrom: { <A>(value: A, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A, from: number): STM.STM<Option.Option<number>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L174"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "findFirstIndexWhere",
    "description": "Get the index of the first entry in the array matching a predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirstIndexWhere: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<number>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L185"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "findFirstIndexWhereFrom",
    "description": "Get the index of the first entry in the array starting from the specified\nindex, matching a predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirstIndexWhereFrom: { <A>(predicate: Predicate<A>, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, predicate: Predicate<A>, from: number): STM.STM<Option.Option<number>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L197"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "findFirstIndexWhereSTM",
    "description": "Get the index of the next entry that matches a transactional predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirstIndexWhereSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<number>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<number>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L208"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "findFirstIndexWhereFromSTM",
    "description": "Starting at specified index, get the index of the next entry that matches a\ntransactional predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirstIndexWhereFromSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>, from: number): STM.STM<Option.Option<number>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L220"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "findFirstSTM",
    "description": "Find the first element in the array matching a transactional predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findFirstSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L238"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "findLast",
    "description": "Find the last element in the array matching a predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findLast: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L249"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "findLastIndex",
    "description": "Get the last index of a specific value in the array bounded above by a\nspecific index.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findLastIndex: { <A>(value: A): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A): STM.STM<Option.Option<number>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L261"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "findLastIndexFrom",
    "description": "Get the last index of a specific value in the array bounded above by a\nspecific index.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findLastIndexFrom: { <A>(value: A, end: number): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A, end: number): STM.STM<Option.Option<number>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L273"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "findLastSTM",
    "description": "Find the last element in the array matching a transactional predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findLastSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L284"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "Atomically performs transactional effect for each item in array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const forEach: { <A, R, E>(f: (value: A) => STM.STM<void, E, R>): (self: TArray<A>) => STM.STM<void, E, R>; <A, R, E>(self: TArray<A>, f: (value: A) => STM.STM<void, E, R>): STM.STM<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L295"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `TArray` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: <A>(iterable: Iterable<A>) => STM.STM<TArray<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L306"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Extracts value from ref in array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const get: { (index: number): <A>(self: TArray<A>) => STM.STM<A>; <A>(self: TArray<A>, index: number): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L314"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "headOption",
    "description": "The first entry of the array, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const headOption: <A>(self: TArray<A>) => STM.STM<Option.Option<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L325"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "lastOption",
    "description": "The last entry in the array, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const lastOption: <A>(self: TArray<A>) => STM.STM<Option.Option<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L333"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Makes a new `TArray` that is initialized with specified values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Elements extends [any, ...Array<any>]>(...elements: Elements) => STM.STM<TArray<Elements[number]>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L341"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "maxOption",
    "description": "Atomically compute the greatest element in the array, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const maxOption: { <A>(order: Order.Order<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, order: Order.Order<A>): STM.STM<Option.Option<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L351"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "minOption",
    "description": "Atomically compute the least element in the array, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const minOption: { <A>(order: Order.Order<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, order: Order.Order<A>): STM.STM<Option.Option<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L362"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "reduce",
    "description": "Atomically folds using a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduce: { <Z, A>(zero: Z, f: (accumulator: Z, current: A) => Z): (self: TArray<A>) => STM.STM<Z>; <Z, A>(self: TArray<A>, zero: Z, f: (accumulator: Z, current: A) => Z): STM.STM<Z>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L373"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "reduceOption",
    "description": "Atomically reduce the array, if non-empty, by a binary operator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const reduceOption: { <A>(f: (x: A, y: A) => A): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, f: (x: A, y: A) => A): STM.STM<Option.Option<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L384"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "reduceOptionSTM",
    "description": "Atomically reduce the non-empty array using a transactional binary\noperator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const reduceOptionSTM: { <A, R, E>(f: (x: A, y: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>; <A, R, E>(self: TArray<A>, f: (x: A, y: A) => STM.STM<A, E, R>): STM.STM<Option.Option<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L396"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "reduceSTM",
    "description": "Atomically folds using a transactional function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduceSTM: { <Z, A, R, E>(zero: Z, f: (accumulator: Z, current: A) => STM.STM<Z, E, R>): (self: TArray<A>) => STM.STM<Z, E, R>; <Z, A, R, E>(self: TArray<A>, zero: Z, f: (accumulator: Z, current: A) => STM.STM<Z, E, R>): STM.STM<Z, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L408"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the size of the `TArray`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <A>(self: TArray<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L419"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "some",
    "description": "Determine if the array contains a value satisfying a predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const some: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<boolean>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L427"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "someSTM",
    "description": "Determine if the array contains a value satisfying a transactional\npredicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const someSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<boolean, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<boolean, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L439"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "toArray",
    "description": "Collects all elements into a chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toArray: <A>(self: TArray<A>) => STM.STM<Array<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L451"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "transform",
    "description": "Atomically updates all elements using a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const transform: { <A>(f: (value: A) => A): (self: TArray<A>) => STM.STM<void>; <A>(self: TArray<A>, f: (value: A) => A): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L459"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "transformSTM",
    "description": "Atomically updates all elements using a transactional effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const transformSTM: { <A, R, E>(f: (value: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<void, E, R>; <A, R, E>(self: TArray<A>, f: (value: A) => STM.STM<A, E, R>): STM.STM<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L470"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "update",
    "description": "Updates element in the array with given function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const update: { <A>(index: number, f: (value: A) => A): (self: TArray<A>) => STM.STM<void>; <A>(self: TArray<A>, index: number, f: (value: A) => A): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L481"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "updateSTM",
    "description": "Atomically updates element in the array with given transactional effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const updateSTM: { <A, R, E>(index: number, f: (value: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<void, E, R>; <A, R, E>(self: TArray<A>, index: number, f: (value: A) => STM.STM<A, E, R>): STM.STM<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L492"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "TArray",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TArray<in out A> extends TArray.Variance<A> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L28"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "TArrayTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type TArrayTypeId = typeof TArrayTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L22"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TArray.ts",
      "path": "src/TArray.ts"
    },
    "project": "effect",
    "name": "TArray.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out A> {\n    readonly [TArrayTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TArray.ts#L46"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TDeferred.ts",
      "path": "src/TDeferred.ts"
    },
    "project": "effect",
    "name": "TDeferredTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TDeferredTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TDeferred.ts#L15"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TDeferred.ts",
      "path": "src/TDeferred.ts"
    },
    "project": "effect",
    "name": "done",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const done: { <A, E>(either: Either.Either<A, E>): (self: TDeferred<A, E>) => STM.STM<boolean>; <A, E>(self: TDeferred<A, E>, either: Either.Either<A, E>): STM.STM<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TDeferred.ts#L67"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TDeferred.ts",
      "path": "src/TDeferred.ts"
    },
    "project": "effect",
    "name": "fail",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const fail: { <E>(error: E): <A>(self: TDeferred<A, E>) => STM.STM<boolean>; <A, E>(self: TDeferred<A, E>, error: E): STM.STM<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TDeferred.ts#L76"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TDeferred.ts",
      "path": "src/TDeferred.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A, E = never>() => STM.STM<TDeferred<A, E>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TDeferred.ts#L85"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TDeferred.ts",
      "path": "src/TDeferred.ts"
    },
    "project": "effect",
    "name": "poll",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const poll: <A, E>(self: TDeferred<A, E>) => STM.STM<Option.Option<Either.Either<A, E>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TDeferred.ts#L91"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TDeferred.ts",
      "path": "src/TDeferred.ts"
    },
    "project": "effect",
    "name": "succeed",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const succeed: { <A>(value: A): <E>(self: TDeferred<A, E>) => STM.STM<boolean>; <A, E>(self: TDeferred<A, E>, value: A): STM.STM<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TDeferred.ts#L97"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TDeferred.ts",
      "path": "src/TDeferred.ts"
    },
    "project": "effect",
    "name": "TDeferred",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TDeferred<in out A, in out E = never> extends TDeferred.Variance<A, E> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TDeferred.ts#L27"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TDeferred.ts",
      "path": "src/TDeferred.ts"
    },
    "project": "effect",
    "name": "TDeferredTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type TDeferredTypeId = typeof TDeferredTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TDeferred.ts#L21"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TDeferred.ts",
      "path": "src/TDeferred.ts"
    },
    "project": "effect",
    "name": "TDeferred.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out A, in out E> {\n    readonly [TDeferredTypeId]: {\n      readonly _A: Types.Invariant<A>\n      readonly _E: Types.Invariant<E>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TDeferred.ts#L45"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotation.ts",
      "path": "src/TestAnnotation.ts"
    },
    "project": "effect",
    "name": "TestAnnotationTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TestAnnotationTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L23"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotation.ts",
      "path": "src/TestAnnotation.ts"
    },
    "project": "effect",
    "name": "fibers",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const fibers: TestAnnotation<Either.Either<Chunk.Chunk<MutableRef.MutableRef<SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>>>, number>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L106"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotation.ts",
      "path": "src/TestAnnotation.ts"
    },
    "project": "effect",
    "name": "ignored",
    "description": "An annotation which counts ignored tests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const ignored: TestAnnotation<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L121"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotation.ts",
      "path": "src/TestAnnotation.ts"
    },
    "project": "effect",
    "name": "repeated",
    "description": "An annotation which counts repeated tests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const repeated: TestAnnotation<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L132"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotation.ts",
      "path": "src/TestAnnotation.ts"
    },
    "project": "effect",
    "name": "retried",
    "description": "An annotation which counts retried tests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const retried: TestAnnotation<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L143"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotation.ts",
      "path": "src/TestAnnotation.ts"
    },
    "project": "effect",
    "name": "tagged",
    "description": "An annotation which tags tests with strings.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const tagged: TestAnnotation<HashSet.HashSet<string>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L154"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotation.ts",
      "path": "src/TestAnnotation.ts"
    },
    "project": "effect",
    "name": "isTestAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const isTestAnnotation: (u: unknown) => u is TestAnnotation<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L68"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotation.ts",
      "path": "src/TestAnnotation.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const make: <A>(identifier: string, initial: A, combine: (a: A, b: A) => A) => TestAnnotation<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L73"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotation.ts",
      "path": "src/TestAnnotation.ts"
    },
    "project": "effect",
    "name": "compose",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const compose: <A>(left: Either.Either<Chunk.Chunk<A>, number>, right: Either.Either<Chunk.Chunk<A>, number>) => Either.Either<Chunk.Chunk<A>, number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L84"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestAnnotation.ts",
      "path": "src/TestAnnotation.ts"
    },
    "project": "effect",
    "name": "TestAnnotation",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TestAnnotation<in out A> extends Equal.Equal {\n  readonly [TestAnnotationTypeId]: {\n    readonly _A: Types.Invariant<A>\n  }\n  readonly identifier: string\n  readonly initial: A\n  combine(a: A, b: A): A\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L33"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TestAnnotation.ts",
      "path": "src/TestAnnotation.ts"
    },
    "project": "effect",
    "name": "TestAnnotationTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type TestAnnotationTypeId = typeof TestAnnotationTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotation.ts#L28"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotationMap.ts",
      "path": "src/TestAnnotationMap.ts"
    },
    "project": "effect",
    "name": "TestAnnotationMapTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TestAnnotationMapTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotationMap.ts#L12"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotationMap.ts",
      "path": "src/TestAnnotationMap.ts"
    },
    "project": "effect",
    "name": "overwrite",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const overwrite: (<A>(key: TestAnnotation.TestAnnotation<A>, value: A) => (self: TestAnnotationMap) => TestAnnotationMap) & (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>, value: A) => TestAnnotationMap)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotationMap.ts#L57"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotationMap.ts",
      "path": "src/TestAnnotationMap.ts"
    },
    "project": "effect",
    "name": "update",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const update: (<A>(key: TestAnnotation.TestAnnotation<A>, f: (value: A) => A) => (self: TestAnnotationMap) => TestAnnotationMap) & (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>, f: (value: A) => A) => TestAnnotationMap)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotationMap.ts#L65"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotationMap.ts",
      "path": "src/TestAnnotationMap.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves the annotation of the specified type, or its default value if\nthere is none.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const get: (<A>(key: TestAnnotation.TestAnnotation<A>) => (self: TestAnnotationMap) => A) & (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>) => A)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotationMap.ts#L82"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotationMap.ts",
      "path": "src/TestAnnotationMap.ts"
    },
    "project": "effect",
    "name": "annotate",
    "description": "Appends the specified annotation to the annotation map.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const annotate: (<A>(key: TestAnnotation.TestAnnotation<A>, value: A) => (self: TestAnnotationMap) => TestAnnotationMap) & (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>, value: A) => TestAnnotationMap)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotationMap.ts#L97"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotationMap.ts",
      "path": "src/TestAnnotationMap.ts"
    },
    "project": "effect",
    "name": "combine",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const combine: ((that: TestAnnotationMap) => (self: TestAnnotationMap) => TestAnnotationMap) & ((self: TestAnnotationMap, that: TestAnnotationMap) => TestAnnotationMap)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotationMap.ts#L105"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotationMap.ts",
      "path": "src/TestAnnotationMap.ts"
    },
    "project": "effect",
    "name": "isTestAnnotationMap",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const isTestAnnotationMap: (u: unknown) => u is TestAnnotationMap",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotationMap.ts#L40"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotationMap.ts",
      "path": "src/TestAnnotationMap.ts"
    },
    "project": "effect",
    "name": "empty",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const empty: (_: void) => TestAnnotationMap",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotationMap.ts#L45"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotationMap.ts",
      "path": "src/TestAnnotationMap.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const make: (map: HashMap.HashMap<TestAnnotation.TestAnnotation<any>, any>) => TestAnnotationMap",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotationMap.ts#L50"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestAnnotationMap.ts",
      "path": "src/TestAnnotationMap.ts"
    },
    "project": "effect",
    "name": "TestAnnotationMap",
    "description": "An annotation map keeps track of annotations of different types.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TestAnnotationMap {\n  readonly [TestAnnotationMapTypeId]: TestAnnotationMapTypeId\n  /** @internal */\n  readonly map: HashMap.HashMap<TestAnnotation.TestAnnotation<any>, any>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotationMap.ts#L24"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TestAnnotationMap.ts",
      "path": "src/TestAnnotationMap.ts"
    },
    "project": "effect",
    "name": "TestAnnotationMapTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type TestAnnotationMapTypeId = typeof TestAnnotationMapTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotationMap.ts#L17"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotations.ts",
      "path": "src/TestAnnotations.ts"
    },
    "project": "effect",
    "name": "TestAnnotationsTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TestAnnotationsTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotations.ts#L23"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotations.ts",
      "path": "src/TestAnnotations.ts"
    },
    "project": "effect",
    "name": "TestAnnotations",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TestAnnotations: Context.Tag<TestAnnotations, TestAnnotations>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotations.ts#L103"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotations.ts",
      "path": "src/TestAnnotations.ts"
    },
    "project": "effect",
    "name": "isTestAnnotations",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const isTestAnnotations: (u: unknown) => u is TestAnnotations",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotations.ts#L110"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotations.ts",
      "path": "src/TestAnnotations.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const make: (ref: Ref.Ref<TestAnnotationMap.TestAnnotationMap>) => TestAnnotations",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotations.ts#L115"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestAnnotations.ts",
      "path": "src/TestAnnotations.ts"
    },
    "project": "effect",
    "name": "TestAnnotations",
    "description": "The `Annotations` trait provides access to an annotation map that tests can\nadd arbitrary annotations to. Each annotation consists of a string\nidentifier, an initial value, and a function for combining two values.\nAnnotations form monoids and you can think of `Annotations` as a more\nstructured logging service or as a super polymorphic version of the writer\nmonad effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TestAnnotations {\n  readonly [TestAnnotationsTypeId]: TestAnnotationsTypeId\n\n  /**\n   * A ref containing the bacnking map for all annotations\n   */\n  readonly ref: Ref.Ref<TestAnnotationMap.TestAnnotationMap>\n\n  /**\n   * Accesses an `Annotations` instance in the context and retrieves the\n   * annotation of the specified type, or its default value if there is none.\n   */\n  get<A>(key: TestAnnotation.TestAnnotation<A>): Effect.Effect<A>\n\n  /**\n   * Accesses an `Annotations` instance in the context and appends the\n   * specified annotation to the annotation map.\n   */\n  annotate<A>(key: TestAnnotation.TestAnnotation<A>, value: A): Effect.Effect<void>\n\n  /**\n   * Returns the set of all fibers in this test.\n   */\n  readonly supervisedFibers: Effect.Effect<\n    SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>\n  >\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotations.ts#L40"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TestAnnotations.ts",
      "path": "src/TestAnnotations.ts"
    },
    "project": "effect",
    "name": "TestAnnotationsTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type TestAnnotationsTypeId = typeof TestAnnotationsTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestAnnotations.ts#L28"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "TestClock",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TestClock: Context.Tag<TestClock, TestClock>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L108"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "defaultTestClock",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const defaultTestClock: Layer.Layer<TestClock, never, Annotations.TestAnnotations | Live.TestLive>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L459"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "adjustWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const adjustWith: ((duration: Duration.DurationInput) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, duration: Duration.DurationInput) => Effect.Effect<A, E, R>)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L478"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "currentTimeMillis",
    "description": "Accesses the current time of a `TestClock` instance in the context in\nmilliseconds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const currentTimeMillis: Effect.Effect<number, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L556"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "makeData",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const makeData: (instant: number, sleeps: Chunk.Chunk<readonly [number, Deferred.Deferred<void>]>) => Data",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L97"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "live",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const live: (data: Data) => Layer.Layer<TestClock, never, Annotations.TestAnnotations | Live.TestLive>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L438"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "adjust",
    "description": "Accesses a `TestClock` instance in the context and increments the time\nby the specified duration, running any actions scheduled for on or before\nthe new time in order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const adjust: (durationInput: Duration.DurationInput) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L470"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "save",
    "description": "Accesses a `TestClock` instance in the context and saves the clock\nstate in an effect which, when run, will restore the `TestClock` to the\nsaved state.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const save: () => Effect.Effect<Effect.Effect<void>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L493"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "setTime",
    "description": "Accesses a `TestClock` instance in the context and sets the clock time\nto the specified `Instant` or `Date`, running any actions scheduled for on or before\nthe new time in order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const setTime: (input: DateTime.DateTime.Input) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L502"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "sleep",
    "description": "Semantically blocks the current fiber until the clock time is equal to or\ngreater than the specified duration. Once the clock time is adjusted to\non or after the duration, the fiber will automatically be resumed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const sleep: (durationInput: Duration.DurationInput) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L518"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "sleeps",
    "description": "Accesses a `TestClock` instance in the context and returns a list of\ntimes that effects are scheduled to run.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const sleeps: () => Effect.Effect<Chunk.Chunk<number>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L529"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "testClock",
    "description": "Retrieves the `TestClock` service for this test.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const testClock: () => Effect.Effect<TestClock>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L536"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "testClockWith",
    "description": "Retrieves the `TestClock` service for this test and uses it to run the\nspecified workflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const testClockWith: <A, E, R>(f: (testClock: TestClock) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L544"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "TestClock",
    "description": "A `TestClock` makes it easy to deterministically and efficiently test effects\ninvolving the passage of time.\n\nInstead of waiting for actual time to pass, `sleep` and methods implemented\nin terms of it schedule effects to take place at a given clock time. Users\ncan adjust the clock time using the `adjust` and `setTime` methods, and all\neffects scheduled to take place on or before that time will automatically be\nrun in order.\n\nFor example, here is how we can test `Effect.timeout` using `TestClock`:\n\n```ts\nimport * as assert from \"node:assert\"\nimport { Duration, Effect, Fiber, TestClock, Option, pipe } from \"effect\"\n\nEffect.gen(function*() {\n  const fiber = yield* pipe(\n    Effect.sleep(Duration.minutes(5)),\n    Effect.timeout(Duration.minutes(1)),\n    Effect.fork\n  )\n  yield* TestClock.adjust(Duration.minutes(1))\n  const result = yield* Fiber.join(fiber)\n  assert.deepStrictEqual(result, Option.none())\n})\n```\n\nNote how we forked the fiber that `sleep` was invoked on. Calls to `sleep`\nand methods derived from it will semantically block until the time is set to\non or after the time they are scheduled to run. If we didn't fork the fiber\non which we called sleep we would never get to set the time on the line\nbelow. Thus, a useful pattern when using `TestClock` is to fork the effect\nbeing tested, then adjust the clock time, and finally verify that the\nexpected effects have been performed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TestClock extends Clock.Clock {\n  adjust(duration: Duration.DurationInput): Effect.Effect<void>\n  adjustWith(duration: Duration.DurationInput): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  readonly save: Effect.Effect<Effect.Effect<void>>\n  setTime(time: number): Effect.Effect<void>\n  readonly sleeps: Effect.Effect<Chunk.Chunk<number>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L76"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestClock.ts",
      "path": "src/TestClock.ts"
    },
    "project": "effect",
    "name": "Data",
    "description": "`Data` represents the state of the `TestClock`, including the clock time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.1",
    "category": null,
    "signature": "export interface Data {\n  readonly instant: number\n  readonly sleeps: Chunk.Chunk<readonly [number, Deferred.Deferred<void>]>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestClock.ts#L89"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestConfig.ts",
      "path": "src/TestConfig.ts"
    },
    "project": "effect",
    "name": "TestConfig",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TestConfig: Context.Tag<TestConfig, TestConfig>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestConfig.ts#L37"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestConfig.ts",
      "path": "src/TestConfig.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const make: (params: { readonly repeats: number; readonly retries: number; readonly samples: number; readonly shrinks: number; }) => TestConfig",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestConfig.ts#L42"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestConfig.ts",
      "path": "src/TestConfig.ts"
    },
    "project": "effect",
    "name": "TestConfig",
    "description": "The `TestConfig` service provides access to default configuration settings\nused by tests, including the number of times to repeat tests to ensure\nthey are stable, the number of times to retry flaky tests, the sufficient\nnumber of samples to check from a random variable, and the maximum number of\nshrinkings to minimize large failures.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TestConfig {\n  /**\n   * The number of times to repeat tests to ensure they are stable.\n   */\n  readonly repeats: number\n  /**\n   * The number of times to retry flaky tests.\n   */\n  readonly retries: number\n  /**\n   * The number of sufficient samples to check for a random variable.\n   */\n  readonly samples: number\n  /**\n   * The maximum number of shrinkings to minimize large failures\n   */\n  readonly shrinks: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestConfig.ts#L15"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestContext.ts",
      "path": "src/TestContext.ts"
    },
    "project": "effect",
    "name": "LiveContext",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const LiveContext: Layer.Layer<DefaultServices.DefaultServices, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestContext.ts#L29"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestContext.ts",
      "path": "src/TestContext.ts"
    },
    "project": "effect",
    "name": "TestContext",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TestContext: Layer.Layer<TestServices.TestServices, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestContext.ts#L36"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestLive.ts",
      "path": "src/TestLive.ts"
    },
    "project": "effect",
    "name": "TestLiveTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TestLiveTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestLive.ts#L13"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestLive.ts",
      "path": "src/TestLive.ts"
    },
    "project": "effect",
    "name": "TestLive",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TestLive: Context.Tag<TestLive, TestLive>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestLive.ts#L36"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestLive.ts",
      "path": "src/TestLive.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const make: (services: Context.Context<DefaultServices.DefaultServices>) => TestLive",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestLive.ts#L53"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestLive.ts",
      "path": "src/TestLive.ts"
    },
    "project": "effect",
    "name": "TestLive",
    "description": "The `Live` trait provides access to the \"live\" default Effect services from\nwithin tests for workflows such as printing test results to the console or\ntiming out tests where it is necessary to access the real implementations of\nthese services.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TestLive {\n  readonly [TestLiveTypeId]: TestLiveTypeId\n  provide<A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestLive.ts#L28"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TestLive.ts",
      "path": "src/TestLive.ts"
    },
    "project": "effect",
    "name": "TestLiveTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type TestLiveTypeId = typeof TestLiveTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestLive.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "liveServices",
    "description": "The default Effect test services.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const liveServices: Context.Context<TestServices>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L39"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "currentServices",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const currentServices: FiberRef.FiberRef<Context.Context<TestServices>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L49"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "withAnnotations",
    "description": "Executes the specified workflow with the specified implementation of the\nannotations service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const withAnnotations: ((annotations: Annotations.TestAnnotations) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, annotations: Annotations.TestAnnotations) => Effect.Effect<A, E, R>)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L80"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "live",
    "description": "Retrieves the `Live` service for this test.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const live: Effect.Effect<Live.TestLive, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L159"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "withLive",
    "description": "Executes the specified workflow with the specified implementation of the\nlive service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const withLive: ((live: Live.TestLive) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, live: Live.TestLive) => Effect.Effect<A, E, R>)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L167"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "provideWithLive",
    "description": "Runs a transformation function with the live default Effect services while\nensuring that the workflow itself is run with the test services.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const provideWithLive: (<A, E, R, A2, E2, R2>(f: (effect: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>) => (self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E | E2, R | R2>) & (<A, E, R, A2, E2, R2>(self: Effect.Effect<A, E, R>, f: (effect: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>) => Effect.Effect<A2, E | E2, R | R2>)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L214"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "sized",
    "description": "Retrieves the `Sized` service for this test.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const sized: Effect.Effect<Sized.TestSized, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L245"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "withSized",
    "description": "Executes the specified workflow with the specified implementation of the\nsized service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const withSized: ((sized: Sized.TestSized) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, sized: Sized.TestSized) => Effect.Effect<A, E, R>)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L253"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "size",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const size: Effect.Effect<number, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L287"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "withSize",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const withSize: ((size: number) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, size: number) => Effect.Effect<A, E, R>)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L292"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "testConfig",
    "description": "Retrieves the `TestConfig` service for this test.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const testConfig: Effect.Effect<TestConfig.TestConfig, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L316"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "withTestConfig",
    "description": "Executes the specified workflow with the specified implementation of the\nconfig service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const withTestConfig: ((config: TestConfig.TestConfig) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, config: TestConfig.TestConfig) => Effect.Effect<A, E, R>)",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L324"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "repeats",
    "description": "The number of times to repeat tests to ensure they are stable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const repeats: Effect.Effect<number, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L369"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "retries",
    "description": "The number of times to retry flaky tests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const retries: Effect.Effect<number, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L376"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "samples",
    "description": "The number of sufficient samples to check for a random variable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const samples: Effect.Effect<number, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L383"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "shrinks",
    "description": "The maximum number of shrinkings to minimize large failures.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const shrinks: Effect.Effect<number, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L390"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "annotations",
    "description": "Retrieves the `Annotations` service for this test.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const annotations: () => Effect.Effect<Annotations.TestAnnotations>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L58"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "annotationsWith",
    "description": "Retrieves the `Annotations` service for this test and uses it to run the\nspecified workflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const annotationsWith: <A, E, R>(f: (annotations: Annotations.TestAnnotations) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L66"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "withAnnotationsScoped",
    "description": "Sets the implementation of the annotations service to the specified value\nand restores it to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const withAnnotationsScoped: (annotations: Annotations.TestAnnotations) => Effect.Effect<void, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L95"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "annotationsLayer",
    "description": "Constructs a new `Annotations` service wrapped in a layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const annotationsLayer: () => Layer.Layer<Annotations.TestAnnotations>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L108"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Accesses an `Annotations` instance in the context and retrieves the\nannotation of the specified type, or its default value if there is none.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const get: <A>(key: TestAnnotation.TestAnnotation<A>) => Effect.Effect<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L124"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "annotate",
    "description": "Accesses an `Annotations` instance in the context and appends the\nspecified annotation to the annotation map.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const annotate: <A>(key: TestAnnotation.TestAnnotation<A>, value: A) => Effect.Effect<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L133"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "supervisedFibers",
    "description": "Returns the set of all fibers in this test.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const supervisedFibers: () => Effect.Effect<SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L141"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "liveWith",
    "description": "Retrieves the `Live` service for this test and uses it to run the specified\nworkflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const liveWith: <A, E, R>(f: (live: Live.TestLive) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L151"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "withLiveScoped",
    "description": "Sets the implementation of the live service to the specified value and\nrestores it to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const withLiveScoped: (live: Live.TestLive) => Effect.Effect<void, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L182"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "liveLayer",
    "description": "Constructs a new `Live` service wrapped in a layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const liveLayer: () => Layer.Layer<Live.TestLive, never, DefaultServices.DefaultServices>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L190"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "provideLive",
    "description": "Provides a workflow with the \"live\" default Effect services.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const provideLive: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L205"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "sizedWith",
    "description": "Retrieves the `Sized` service for this test and uses it to run the\nspecified workflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const sizedWith: <A, E, R>(f: (sized: Sized.TestSized) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L234"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "withSizedScoped",
    "description": "Sets the implementation of the sized service to the specified value and\nrestores it to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const withSizedScoped: (sized: Sized.TestSized) => Effect.Effect<void, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L268"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "sizedLayer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const sizedLayer: (size: number) => Layer.Layer<Sized.TestSized>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L274"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "testConfigWith",
    "description": "Retrieves the `TestConfig` service for this test and uses it to run the\nspecified workflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const testConfigWith: <A, E, R>(f: (config: TestConfig.TestConfig) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L303"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "withTestConfigScoped",
    "description": "Sets the implementation of the config service to the specified value and\nrestores it to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const withTestConfigScoped: (config: TestConfig.TestConfig) => Effect.Effect<void, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L339"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "testConfigLayer",
    "description": "Constructs a new `TestConfig` service with the specified settings.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const testConfigLayer: (params: { readonly repeats: number; readonly retries: number; readonly samples: number; readonly shrinks: number; }) => Layer.Layer<TestConfig.TestConfig>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L347"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TestServices.ts",
      "path": "src/TestServices.ts"
    },
    "project": "effect",
    "name": "TestServices",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type TestServices = | Annotations.TestAnnotations\n  | Live.TestLive\n  | Sized.TestSized\n  | TestConfig.TestConfig",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestServices.ts#L28"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestSized.ts",
      "path": "src/TestSized.ts"
    },
    "project": "effect",
    "name": "TestSizedTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TestSizedTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestSized.ts#L12"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestSized.ts",
      "path": "src/TestSized.ts"
    },
    "project": "effect",
    "name": "TestSized",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TestSized: Context.Tag<TestSized, TestSized>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestSized.ts#L32"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestSized.ts",
      "path": "src/TestSized.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const make: (size: number) => TestSized",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestSized.ts#L50"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestSized.ts",
      "path": "src/TestSized.ts"
    },
    "project": "effect",
    "name": "fromFiberRef",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const fromFiberRef: (fiberRef: FiberRef.FiberRef<number>) => TestSized",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestSized.ts#L55"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestSized.ts",
      "path": "src/TestSized.ts"
    },
    "project": "effect",
    "name": "TestSized",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TestSized {\n  readonly [TestSizedTypeId]: TestSizedTypeId\n  readonly fiberRef: FiberRef.FiberRef<number>\n  readonly size: Effect.Effect<number>\n  withSize(size: number): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestSized.ts#L22"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TestSized.ts",
      "path": "src/TestSized.ts"
    },
    "project": "effect",
    "name": "TestSizedTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type TestSizedTypeId = typeof TestSizedTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TestSized.ts#L17"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "TMapTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TMapTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Makes an empty `TMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <K, V>() => STM.STM<TMap<K, V>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L67"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "find",
    "description": "Finds the key/value pair matching the specified predicate, and uses the\nprovided function to extract a value out of it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const find: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<Option.Option<A>>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<Option.Option<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L76"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "findSTM",
    "description": "Finds the key/value pair matching the specified predicate, and uses the\nprovided effectful function to extract a value out of it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findSTM: { <K, V, A, E, R>(f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<Option.Option<A>, E, R>; <K, V, A, E, R>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<Option.Option<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L88"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "findAll",
    "description": "Finds all the key/value pairs matching the specified predicate, and uses\nthe provided function to extract values out them.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findAll: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<Array<A>>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<Array<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L105"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "findAllSTM",
    "description": "Finds all the key/value pairs matching the specified predicate, and uses\nthe provided effectful function to extract values out of them..",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const findAllSTM: { <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<Array<A>, E, R>; <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<Array<A>, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L117"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "Atomically performs transactional-effect for each binding present in map.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const forEach: { <K, V, X, E, R>(f: (key: K, value: V) => STM.STM<X, E, R>): (self: TMap<K, V>) => STM.STM<void, E, R>; <K, V, X, E, R>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<X, E, R>): STM.STM<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L130"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `TMap` from an iterable collection of key/value pairs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: <K, V>(iterable: Iterable<readonly [K, V]>) => STM.STM<TMap<K, V>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L141"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves value associated with given key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const get: { <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<Option.Option<V>>; <K, V>(self: TMap<K, V>, key: K): STM.STM<Option.Option<V>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L151"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "getOrElse",
    "description": "Retrieves value associated with given key or default value, in case the key\nisn't present.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const getOrElse: { <K, V>(key: K, fallback: LazyArg<V>): (self: TMap<K, V>) => STM.STM<V>; <K, V>(self: TMap<K, V>, key: K, fallback: LazyArg<V>): STM.STM<V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L163"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "has",
    "description": "Tests whether or not map contains a key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const has: { <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<boolean>; <K, V>(self: TMap<K, V>, key: K): STM.STM<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L174"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Tests if the map is empty or not.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isEmpty: <K, V>(self: TMap<K, V>) => STM.STM<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L185"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "keys",
    "description": "Collects all keys stored in map.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const keys: <K, V>(self: TMap<K, V>) => STM.STM<Array<K>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L193"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Makes a new `TMap` that is initialized with specified values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <K, V>(...entries: Array<readonly [K, V]>) => STM.STM<TMap<K, V>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L201"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "merge",
    "description": "If the key is not already associated with a value, stores the provided value,\notherwise merge the existing value with the new one using function `f` and\nstore the result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const merge: { <K, V>(key: K, value: V, f: (x: V, y: V) => V): (self: TMap<K, V>) => STM.STM<V>; <K, V>(self: TMap<K, V>, key: K, value: V, f: (x: V, y: V) => V): STM.STM<V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L211"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "reduce",
    "description": "Atomically folds using a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduce: { <Z, K, V>(zero: Z, f: (acc: Z, value: V, key: K) => Z): (self: TMap<K, V>) => STM.STM<Z>; <K, V, Z>(self: TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => Z): STM.STM<Z>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L222"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "reduceSTM",
    "description": "Atomically folds using a transactional function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduceSTM: { <Z, V, K, R, E>(zero: Z, f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>): (self: TMap<K, V>) => STM.STM<Z, E, R>; <Z, V, K, R, E>(self: TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>): STM.STM<Z, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L233"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "remove",
    "description": "Removes binding for given key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const remove: { <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L244"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "removeAll",
    "description": "Deletes all entries associated with the specified keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const removeAll: { <K>(keys: Iterable<K>): <V>(self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, keys: Iterable<K>): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L255"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "removeIf",
    "description": "Removes entries from a `TMap` that satisfy the specified predicate and returns the removed entries\n(or `void` if `discard = true`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const removeIf: { <K, V>(predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): (self: TMap<K, V>) => STM.STM<void>; <K, V>(predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): (self: TMap<K, V>) => STM.STM<Array<[K, V]>>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): STM.STM<void>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): STM.STM<Array<[K, V]>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L267"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "retainIf",
    "description": "Retains entries in a `TMap` that satisfy the specified predicate and returns the removed entries\n(or `void` if `discard = true`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const retainIf: { <K, V>(predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): (self: TMap<K, V>) => STM.STM<void>; <K, V>(predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): (self: TMap<K, V>) => STM.STM<Array<[K, V]>>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): STM.STM<void>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): STM.STM<Array<[K, V]>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L303"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "set",
    "description": "Stores new binding into the map.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const set: { <K, V>(key: K, value: V): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K, value: V): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L338"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "setIfAbsent",
    "description": "Stores new binding in the map if it does not already exist.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const setIfAbsent: { <K, V>(key: K, value: V): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K, value: V): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L349"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the number of bindings.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <K, V>(self: TMap<K, V>) => STM.STM<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L360"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "takeFirst",
    "description": "Takes the first matching value, or retries until there is one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeFirst: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<A>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L368"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "takeFirstSTM",
    "description": "Takes the first matching value, or retries until there is one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeFirstSTM: { <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<A, E, R>; <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L379"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "takeSome",
    "description": "Takes all matching values, or retries until there is at least one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeSome: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<[A, ...Array<A>]>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<[A, ...Array<A>]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L390"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "takeSomeSTM",
    "description": "Takes all matching values, or retries until there is at least one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeSomeSTM: { <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<[A, ...Array<A>], E, R>; <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<[A, ...Array<A>], E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L401"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "toChunk",
    "description": "Collects all bindings into a `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toChunk: <K, V>(self: TMap<K, V>) => STM.STM<Chunk.Chunk<[K, V]>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L417"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "toHashMap",
    "description": "Collects all bindings into a `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toHashMap: <K, V>(self: TMap<K, V>) => STM.STM<HashMap.HashMap<K, V>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L425"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "toArray",
    "description": "Collects all bindings into an `Array`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toArray: <K, V>(self: TMap<K, V>) => STM.STM<Array<[K, V]>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L433"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "toMap",
    "description": "Collects all bindings into a `Map`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toMap: <K, V>(self: TMap<K, V>) => STM.STM<ReadonlyMap<K, V>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L441"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "transform",
    "description": "Atomically updates all bindings using a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const transform: { <K, V>(f: (key: K, value: V) => readonly [K, V]): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, f: (key: K, value: V) => readonly [K, V]): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L449"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "transformSTM",
    "description": "Atomically updates all bindings using a transactional function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const transformSTM: { <K, V, R, E>(f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>): (self: TMap<K, V>) => STM.STM<void, E, R>; <K, V, R, E>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>): STM.STM<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L460"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "transformValues",
    "description": "Atomically updates all values using a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const transformValues: { <V>(f: (value: V) => V): <K>(self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, f: (value: V) => V): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L471"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "transformValuesSTM",
    "description": "Atomically updates all values using a transactional function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const transformValuesSTM: { <V, R, E>(f: (value: V) => STM.STM<V, E, R>): <K>(self: TMap<K, V>) => STM.STM<void, E, R>; <K, V, R, E>(self: TMap<K, V>, f: (value: V) => STM.STM<V, E, R>): STM.STM<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L482"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "updateWith",
    "description": "Updates the mapping for the specified key with the specified function,\nwhich takes the current value of the key as an input, if it exists, and\neither returns `Some` with a new value to indicate to update the value in\nthe map or `None` to remove the value from the map. Returns `Some` with the\nupdated value or `None` if the value was removed from the map.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const updateWith: { <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>): (self: TMap<K, V>) => STM.STM<Option.Option<V>>; <K, V>(self: TMap<K, V>, key: K, f: (value: Option.Option<V>) => Option.Option<V>): STM.STM<Option.Option<V>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L497"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "values",
    "description": "Collects all values stored in map.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const values: <K, V>(self: TMap<K, V>) => STM.STM<Array<V>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L515"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "TMap",
    "description": "Transactional map implemented on top of `TRef` and `TArray`. Resolves\nconflicts via chaining.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TMap<in out K, in out V> extends TMap.Variance<K, V> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L33"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "TMapTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type TMapTypeId = typeof TMapTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L24"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TMap.ts",
      "path": "src/TMap.ts"
    },
    "project": "effect",
    "name": "TMap.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out K, in out V> {\n    readonly [TMapTypeId]: {\n      readonly _K: Types.Invariant<K>\n      readonly _V: Types.Invariant<V>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TMap.ts#L53"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "TPriorityQueueTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TPriorityQueueTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Constructs a new empty `TPriorityQueue` with the specified `Order`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <A>(order: Order.Order<A>) => STM.STM<TPriorityQueue<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L67"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `TPriorityQueue` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: <A>(order: Order.Order<A>) => (iterable: Iterable<A>) => STM.STM<TPriorityQueue<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L75"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Checks whether the queue is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isEmpty: <A>(self: TPriorityQueue<A>) => STM.STM<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L85"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "isNonEmpty",
    "description": "Checks whether the queue is not empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isNonEmpty: <A>(self: TPriorityQueue<A>) => STM.STM<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L93"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Makes a new `TPriorityQueue` that is initialized with specified values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A>(order: Order.Order<A>) => (...elements: Array<A>) => STM.STM<TPriorityQueue<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L101"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "offer",
    "description": "Offers the specified value to the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const offer: { <A>(value: A): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, value: A): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L109"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "offerAll",
    "description": "Offers all of the elements in the specified collection to the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const offerAll: { <A>(values: Iterable<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, values: Iterable<A>): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L120"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "peek",
    "description": "Peeks at the first value in the queue without removing it, retrying until a\nvalue is in the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const peek: <A>(self: TPriorityQueue<A>) => STM.STM<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L132"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "peekOption",
    "description": "Peeks at the first value in the queue without removing it, returning `None`\nif there is not a value in the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const peekOption: <A>(self: TPriorityQueue<A>) => STM.STM<Option.Option<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L141"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "removeIf",
    "description": "Removes all elements from the queue matching the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const removeIf: { <A>(predicate: Predicate<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, predicate: Predicate<A>): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L149"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "retainIf",
    "description": "Retains only elements from the queue matching the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const retainIf: { <A>(predicate: Predicate<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, predicate: Predicate<A>): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L160"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the size of the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <A>(self: TPriorityQueue<A>) => STM.STM<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L171"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "take",
    "description": "Takes a value from the queue, retrying until a value is in the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const take: <A>(self: TPriorityQueue<A>) => STM.STM<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L179"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "takeAll",
    "description": "Takes all values from the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeAll: <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L187"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "takeOption",
    "description": "Takes a value from the queue, returning `None` if there is not a value in\nthe queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeOption: <A>(self: TPriorityQueue<A>) => STM.STM<Option.Option<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L196"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "takeUpTo",
    "description": "Takes up to the specified maximum number of elements from the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeUpTo: { (n: number): <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>; <A>(self: TPriorityQueue<A>, n: number): STM.STM<Array<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L204"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "toChunk",
    "description": "Collects all values into a `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toChunk: <A>(self: TPriorityQueue<A>) => STM.STM<Chunk.Chunk<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L215"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "toArray",
    "description": "Collects all values into an array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toArray: <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L223"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "TPriorityQueue",
    "description": "A `TPriorityQueue` contains values of type `A` that an `Order` is defined\non. Unlike a `TQueue`, `take` returns the highest priority value (the value\nthat is first in the specified ordering) as opposed to the first value\noffered to the queue. The ordering that elements with the same priority will\nbe taken from the queue is not guaranteed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TPriorityQueue<in out A> extends TPriorityQueue.Variance<A> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L36"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "TPriorityQueueTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type TPriorityQueueTypeId = typeof TPriorityQueueTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L24"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TPriorityQueue.ts",
      "path": "src/TPriorityQueue.ts"
    },
    "project": "effect",
    "name": "TPriorityQueue.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out A> {\n    readonly [TPriorityQueueTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPriorityQueue.ts#L54"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "TPubSubTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TPubSubTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "awaitShutdown",
    "description": "Waits until the `TPubSub` is shutdown. The `STM` returned by this method will\nnot resume until the queue has been shutdown. If the `TPubSub` is already\nshutdown, the `STM` will resume right away.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const awaitShutdown: <A>(self: TPubSub<A>) => STM.STM<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L64"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "bounded",
    "description": "Creates a bounded `TPubSub` with the back pressure strategy. The `TPubSub` will retain\nmessages until they have been taken by all subscribers, applying back\npressure to publishers if the `TPubSub` is at capacity.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const bounded: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L74"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "capacity",
    "description": "Returns the number of elements the `TPubSub` can hold.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const capacity: <A>(self: TPubSub<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L82"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "dropping",
    "description": "Creates a bounded `TPubSub` with the dropping strategy. The `TPubSub` will drop new\nmessages if the `TPubSub` is at capacity.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dropping: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L91"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the `TPubSub` contains zero elements, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isEmpty: <A>(self: TPubSub<A>) => STM.STM<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L99"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "isFull",
    "description": "Returns `true` if the `TPubSub` contains at least one element, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isFull: <A>(self: TPubSub<A>) => STM.STM<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L108"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "shutdown",
    "description": "Interrupts any fibers that are suspended on `offer` or `take`. Future calls\nto `offer*` and `take*` will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "declare const shutdown: <A>(self: TPubSub<A>) => STM.STM<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L117"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "isShutdown",
    "description": "Returns `true` if `shutdown` has been called, otherwise returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isShutdown: <A>(self: TPubSub<A>) => STM.STM<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L125"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "publish",
    "description": "Publishes a message to the `TPubSub`, returning whether the message was published\nto the `TPubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const publish: { <A>(value: A): (self: TPubSub<A>) => STM.STM<boolean>; <A>(self: TPubSub<A>, value: A): STM.STM<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L134"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "publishAll",
    "description": "Publishes all of the specified messages to the `TPubSub`, returning whether they\nwere published to the `TPubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const publishAll: { <A>(iterable: Iterable<A>): (self: TPubSub<A>) => STM.STM<boolean>; <A>(self: TPubSub<A>, iterable: Iterable<A>): STM.STM<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L146"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Retrieves the size of the `TPubSub`, which is equal to the number of elements\nin the `TPubSub`. This may be negative if fibers are suspended waiting for\nelements to be added to the `TPubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <A>(self: TPubSub<A>) => STM.STM<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L159"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "sliding",
    "description": "Creates a bounded `TPubSub` with the sliding strategy. The `TPubSub` will add new\nmessages and drop old messages if the `TPubSub` is at capacity.\n\nFor best performance use capacities that are powers of two.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sliding: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L170"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "subscribe",
    "description": "Subscribes to receive messages from the `TPubSub`. The resulting subscription can\nbe evaluated multiple times to take a message from the `TPubSub` each time. The\ncaller is responsible for unsubscribing from the `TPubSub` by shutting down the\nqueue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const subscribe: <A>(self: TPubSub<A>) => STM.STM<TQueue.TDequeue<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L181"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "subscribeScoped",
    "description": "Subscribes to receive messages from the `TPubSub`. The resulting subscription can\nbe evaluated multiple times within the scope to take a message from the `TPubSub`\neach time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const subscribeScoped: <A>(self: TPubSub<A>) => Effect.Effect<TQueue.TDequeue<A>, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L191"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "unbounded",
    "description": "Creates an unbounded `TPubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unbounded: <A>() => STM.STM<TPubSub<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L200"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "TPubSub",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TPubSub<in out A> extends TQueue.TEnqueue<A> {\n  readonly [TPubSubTypeId]: {\n    readonly _A: Types.Invariant<A>\n  }\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L30"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TPubSub.ts",
      "path": "src/TPubSub.ts"
    },
    "project": "effect",
    "name": "TPubSubTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type TPubSubTypeId = typeof TPubSubTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TPubSub.ts#L24"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "TDequeueTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TDequeueTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L14"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "TEnqueueTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TEnqueueTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L26"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "isTQueue",
    "description": "Returns `true` if the specified value is a `TQueue`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isTQueue: (u: unknown) => u is TQueue<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L183"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "isTDequeue",
    "description": "Returns `true` if the specified value is a `TDequeue`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isTDequeue: (u: unknown) => u is TDequeue<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L191"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "isTEnqueue",
    "description": "Returns `true` if the specified value is a `TEnqueue`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isTEnqueue: (u: unknown) => u is TEnqueue<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L199"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "awaitShutdown",
    "description": "Waits until the queue is shutdown. The `STM` returned by this method will\nnot resume until the queue has been shutdown. If the queue is already\nshutdown, the `STM` will resume right away.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const awaitShutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L209"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "bounded",
    "description": "Creates a bounded queue with the back pressure strategy. The queue will\nretain values until they have been taken, applying back pressure to\nofferors if the queue is at capacity.\n\nFor best performance use capacities that are powers of two.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const bounded: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L221"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "capacity",
    "description": "Returns the number of elements the queue can hold.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const capacity: <A>(self: TDequeue<A> | TEnqueue<A>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L229"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "dropping",
    "description": "Creates a bounded queue with the dropping strategy. The queue will drop new\nvalues if the queue is at capacity.\n\nFor best performance use capacities that are powers of two.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const dropping: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L240"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the `TQueue` contains zero elements, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isEmpty: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L248"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "isFull",
    "description": "Returns `true` if the `TQueue` contains at least one element, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isFull: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L257"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "isShutdown",
    "description": "Returns `true` if `shutdown` has been called, otherwise returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isShutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L265"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "offer",
    "description": "Places one value in the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const offer: { <A>(value: A): (self: TEnqueue<A>) => STM.STM<void>; <A>(self: TEnqueue<A>, value: A): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L273"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "offerAll",
    "description": "For Bounded TQueue: uses the `BackPressure` Strategy, places the values in\nthe queue and always returns true. If the queue has reached capacity, then\nthe fiber performing the `offerAll` will be suspended until there is room\nin the queue.\n\nFor Unbounded TQueue: Places all values in the queue and returns true.\n\nFor Sliding TQueue: uses `Sliding` Strategy If there is room in the queue,\nit places the values otherwise it removes the old elements and enqueues the\nnew ones. Always returns true.\n\nFor Dropping TQueue: uses `Dropping` Strategy, It places the values in the\nqueue but if there is no room it will not enqueue them and return false.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const offerAll: { <A>(iterable: Iterable<A>): (self: TEnqueue<A>) => STM.STM<boolean>; <A>(self: TEnqueue<A>, iterable: Iterable<A>): STM.STM<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L296"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "peek",
    "description": "Views the next element in the queue without removing it, retrying if the\nqueue is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const peek: <A>(self: TDequeue<A>) => STM.STM<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L308"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "peekOption",
    "description": "Views the next element in the queue without removing it, returning `None`\nif the queue is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const peekOption: <A>(self: TDequeue<A>) => STM.STM<Option.Option<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L317"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "poll",
    "description": "Takes a single element from the queue, returning `None` if the queue is\nempty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const poll: <A>(self: TDequeue<A>) => STM.STM<Option.Option<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L326"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "seek",
    "description": "Drops elements from the queue while they do not satisfy the predicate,\ntaking and returning the first element that does satisfy the predicate.\nRetries if no elements satisfy the predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const seek: { <A>(predicate: Predicate<A>): (self: TDequeue<A>) => STM.STM<A>; <A>(self: TDequeue<A>, predicate: Predicate<A>): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L336"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "shutdown",
    "description": "Interrupts any fibers that are suspended on `offer` or `take`. Future calls\nto `offer*` and `take*` will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const shutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L348"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Retrieves the size of the queue, which is equal to the number of elements\nin the queue. This may be negative if fibers are suspended waiting for\nelements to be added to the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L358"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "sliding",
    "description": "Creates a bounded queue with the sliding strategy. The queue will add new\nvalues and drop old values if the queue is at capacity.\n\nFor best performance use capacities that are powers of two.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const sliding: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L369"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "take",
    "description": "Takes the oldest value in the queue. If the queue is empty, this will return\na computation that resumes when an item has been added to the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const take: <A>(self: TDequeue<A>) => STM.STM<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L378"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "takeAll",
    "description": "Takes all the values in the queue and returns the values. If the queue is\nempty returns an empty collection.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeAll: <A>(self: TDequeue<A>) => STM.STM<Array<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L387"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "takeBetween",
    "description": "Takes a number of elements from the queue between the specified minimum and\nmaximum. If there are fewer than the minimum number of elements available,\nretries until at least the minimum number of elements have been collected.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeBetween: { (min: number, max: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, min: number, max: number): STM.STM<Array<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L397"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "takeN",
    "description": "Takes the specified number of elements from the queue. If there are fewer\nthan the specified number of elements available, it retries until they\nbecome available.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeN: { (n: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, n: number): STM.STM<Array<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L410"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "takeUpTo",
    "description": "Takes up to max number of values from the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeUpTo: { (max: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, max: number): STM.STM<Array<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L421"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "unbounded",
    "description": "Creates an unbounded queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const unbounded: <A>() => STM.STM<TQueue<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L432"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "TQueue",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TQueue<in out A> extends TEnqueue<A>, TDequeue<A> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L38"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "TEnqueue",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TEnqueue<in A> extends TQueue.TEnqueueVariance<A>, BaseTQueue {\n  /**\n   * Places one value in the queue.\n   */\n  offer(value: A): STM.STM<boolean>\n\n  /**\n   * For Bounded TQueue: uses the `BackPressure` Strategy, places the values in\n   * the queue and always returns true. If the queue has reached capacity, then\n   * the fiber performing the `offerAll` will be suspended until there is room\n   * in the queue.\n   *\n   * For Unbounded TQueue: Places all values in the queue and returns true.\n   *\n   * For Sliding TQueue: uses `Sliding` Strategy If there is room in the queue,\n   * it places the values otherwise it removes the old elements and enqueues the\n   * new ones. Always returns true.\n   *\n   * For Dropping TQueue: uses `Dropping` Strategy, It places the values in the\n   * queue but if there is no room it will not enqueue them and return false.\n   */\n  offerAll(iterable: Iterable<A>): STM.STM<boolean>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L44"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "TDequeue",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TDequeue<out A> extends TQueue.TDequeueVariance<A>, BaseTQueue {\n  /**\n   * Views the next element in the queue without removing it, retrying if the\n   * queue is empty.\n   */\n  readonly peek: STM.STM<A>\n\n  /**\n   * Views the next element in the queue without removing it, returning `None`\n   * if the queue is empty.\n   */\n  readonly peekOption: STM.STM<Option.Option<A>>\n\n  /**\n   * Takes the oldest value in the queue. If the queue is empty, this will return\n   * a computation that resumes when an item has been added to the queue.\n   */\n  readonly take: STM.STM<A>\n\n  /**\n   * Takes all the values in the queue and returns the values. If the queue is\n   * empty returns an empty collection.\n   */\n  readonly takeAll: STM.STM<Array<A>>\n\n  /**\n   * Takes up to max number of values from the queue.\n   */\n  takeUpTo(max: number): STM.STM<Array<A>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L72"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "BaseTQueue",
    "description": "The base interface that all `TQueue`s must implement.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BaseTQueue {\n  /**\n   * Returns the number of elements the queue can hold.\n   */\n  capacity(): number\n\n  /**\n   * Retrieves the size of the queue, which is equal to the number of elements\n   * in the queue. This may be negative if fibers are suspended waiting for\n   * elements to be added to the queue.\n   */\n  readonly size: STM.STM<number>\n\n  /**\n   * Returns `true` if the `TQueue` contains at least one element, `false`\n   * otherwise.\n   */\n  readonly isFull: STM.STM<boolean>\n\n  /**\n   * Returns `true` if the `TQueue` contains zero elements, `false` otherwise.\n   */\n  readonly isEmpty: STM.STM<boolean>\n\n  /**\n   * Interrupts any fibers that are suspended on `offer` or `take`. Future calls\n   * to `offer*` and `take*` will be interrupted immediately.\n   */\n  readonly shutdown: STM.STM<void>\n\n  /**\n   * Returns `true` if `shutdown` has been called, otherwise returns `false`.\n   */\n  readonly isShutdown: STM.STM<boolean>\n\n  /**\n   * Waits until the queue is shutdown. The `STM` returned by this method will\n   * not resume until the queue has been shutdown. If the queue is already\n   * shutdown, the `STM` will resume right away.\n   */\n  readonly awaitShutdown: STM.STM<void>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L109"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "TDequeueTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type TDequeueTypeId = typeof TDequeueTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L20"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "TEnqueueTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type TEnqueueTypeId = typeof TEnqueueTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L32"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "TQueue.TEnqueueVariance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TEnqueueVariance<in A> {\n    readonly [TEnqueueTypeId]: {\n      readonly _In: Types.Contravariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L160"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TQueue.ts",
      "path": "src/TQueue.ts"
    },
    "project": "effect",
    "name": "TQueue.TDequeueVariance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TDequeueVariance<out A> {\n    readonly [TDequeueTypeId]: {\n      readonly _Out: Types.Covariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TQueue.ts#L170"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "TracerTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const TracerTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L16"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "ParentSpan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tags",
    "signature": "declare const ParentSpan: Context.Tag<ParentSpan, AnySpan>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L71"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "Tracer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tags",
    "signature": "declare const Tracer: Context.Tag<Tracer, Tracer>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L141"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (options: Omit<Tracer, typeof TracerTypeId>) => Tracer",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L147"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "externalSpan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const externalSpan: (options: { readonly spanId: string; readonly traceId: string; readonly sampled?: boolean | undefined; readonly context?: Context.Context<never> | undefined; }) => ExternalSpan",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L153"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "tracerWith",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const tracerWith: <A, E, R>(f: (tracer: Tracer) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L166"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "DisablePropagation",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "annotations",
    "signature": "declare const DisablePropagation: Context.Reference<DisablePropagation, boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L181"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "Tracer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface Tracer {\n  readonly [TracerTypeId]: TracerTypeId\n  span(\n    name: string,\n    parent: Option.Option<AnySpan>,\n    context: Context.Context<never>,\n    links: ReadonlyArray<SpanLink>,\n    startTime: bigint,\n    kind: SpanKind\n  ): Span\n  context<X>(f: () => X, fiber: Fiber.RuntimeFiber<any, any>): X\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L26"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "ParentSpan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tags",
    "signature": "export interface ParentSpan {\n  readonly _: unique symbol\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L63"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "ExternalSpan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ExternalSpan {\n  readonly _tag: \"ExternalSpan\"\n  readonly spanId: string\n  readonly traceId: string\n  readonly sampled: boolean\n  readonly context: Context.Context<never>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L77"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "SpanOptions",
    "deprecated": false,
    "examples": [],
    "since": "3.1.0",
    "category": "models",
    "signature": "export interface SpanOptions {\n  readonly attributes?: Record<string, unknown> | undefined\n  readonly links?: ReadonlyArray<SpanLink> | undefined\n  readonly parent?: AnySpan | undefined\n  readonly root?: boolean | undefined\n  readonly context?: Context.Context<never> | undefined\n  readonly kind?: SpanKind | undefined\n  readonly captureStackTrace?: boolean | LazyArg<string | undefined> | undefined\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L89"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "Span",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Span {\n  readonly _tag: \"Span\"\n  readonly name: string\n  readonly spanId: string\n  readonly traceId: string\n  readonly parent: Option.Option<AnySpan>\n  readonly context: Context.Context<never>\n  readonly status: SpanStatus\n  readonly attributes: ReadonlyMap<string, unknown>\n  readonly links: ReadonlyArray<SpanLink>\n  readonly sampled: boolean\n  readonly kind: SpanKind\n  end(endTime: bigint, exit: Exit.Exit<unknown, unknown>): void\n  attribute(key: string, value: unknown): void\n  event(name: string, startTime: bigint, attributes?: Record<string, unknown>): void\n  addLinks(links: ReadonlyArray<SpanLink>): void\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L109"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "SpanLink",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SpanLink {\n  readonly _tag: \"SpanLink\"\n  readonly span: AnySpan\n  readonly attributes: Readonly<Record<string, unknown>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L131"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "DisablePropagation",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "annotations",
    "signature": "export interface DisablePropagation {\n  readonly _: unique symbol\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L173"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "TracerTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type TracerTypeId = typeof TracerTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L21"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "SpanStatus",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type SpanStatus = {\n  _tag: \"Started\"\n  startTime: bigint\n} | {\n  _tag: \"Ended\"\n  startTime: bigint\n  endTime: bigint\n  exit: Exit.Exit<unknown, unknown>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L43"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "AnySpan",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type AnySpan = Span | ExternalSpan",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L57"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Tracer.ts",
      "path": "src/Tracer.ts"
    },
    "project": "effect",
    "name": "SpanKind",
    "deprecated": false,
    "examples": [],
    "since": "3.1.0",
    "category": "models",
    "signature": "type SpanKind = \"internal\" | \"server\" | \"client\" | \"producer\" | \"consumer\"",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tracer.ts#L103"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom.ts",
      "path": "src/TRandom.ts"
    },
    "project": "effect",
    "name": "TRandomTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TRandomTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L15"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom.ts",
      "path": "src/TRandom.ts"
    },
    "project": "effect",
    "name": "Tag",
    "description": "The service tag used to access `TRandom` in the environment of an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const Tag: Context.Tag<TRandom, TRandom>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L71"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom.ts",
      "path": "src/TRandom.ts"
    },
    "project": "effect",
    "name": "live",
    "description": "The \"live\" `TRandom` service wrapped into a `Layer`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "declare const live: Layer.Layer<TRandom, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L79"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom.ts",
      "path": "src/TRandom.ts"
    },
    "project": "effect",
    "name": "next",
    "description": "Returns the next number from the pseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "random",
    "signature": "declare const next: STM.STM<number, never, TRandom>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L87"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom.ts",
      "path": "src/TRandom.ts"
    },
    "project": "effect",
    "name": "nextBoolean",
    "description": "Returns the next boolean value from the pseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "random",
    "signature": "declare const nextBoolean: STM.STM<boolean, never, TRandom>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L95"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom.ts",
      "path": "src/TRandom.ts"
    },
    "project": "effect",
    "name": "nextInt",
    "description": "Returns the next integer from the pseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "random",
    "signature": "declare const nextInt: STM.STM<number, never, TRandom>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L103"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom.ts",
      "path": "src/TRandom.ts"
    },
    "project": "effect",
    "name": "nextIntBetween",
    "description": "Returns the next integer in the specified range from the pseudo-random number\ngenerator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "random",
    "signature": "declare const nextIntBetween: (low: number, high: number) => STM.STM<number, never, TRandom>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L112"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom.ts",
      "path": "src/TRandom.ts"
    },
    "project": "effect",
    "name": "nextRange",
    "description": "Returns the next number in the specified range from the pseudo-random number\ngenerator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "random",
    "signature": "declare const nextRange: (min: number, max: number) => STM.STM<number, never, TRandom>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L121"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom.ts",
      "path": "src/TRandom.ts"
    },
    "project": "effect",
    "name": "shuffle",
    "description": "Uses the pseudo-random number generator to shuffle the specified iterable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "random",
    "signature": "declare const shuffle: <A>(elements: Iterable<A>) => STM.STM<Array<A>, never, TRandom>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L129"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TRandom.ts",
      "path": "src/TRandom.ts"
    },
    "project": "effect",
    "name": "TRandom",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TRandom {\n  readonly [TRandomTypeId]: TRandomTypeId\n  /**\n   * Returns the next numeric value from the pseudo-random number generator.\n   */\n  readonly next: STM.STM<number>\n  /**\n   * Returns the next boolean value from the pseudo-random number generator.\n   */\n  readonly nextBoolean: STM.STM<boolean>\n  /**\n   * Returns the next integer value from the pseudo-random number generator.\n   */\n  readonly nextInt: STM.STM<number>\n  /**\n   * Returns the next numeric value in the specified range from the\n   * pseudo-random number generator.\n   */\n  nextRange(min: number, max: number): STM.STM<number>\n  /**\n   * Returns the next integer value in the specified range from the\n   * pseudo-random number generator.\n   */\n  nextIntBetween(min: number, max: number): STM.STM<number>\n  /**\n   * Uses the pseudo-random number generator to shuffle the specified iterable.\n   */\n  shuffle<A>(elements: Iterable<A>): STM.STM<Array<A>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L27"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TRandom.ts",
      "path": "src/TRandom.ts"
    },
    "project": "effect",
    "name": "TRandomTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type TRandomTypeId = typeof TRandomTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRandom.ts#L21"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "TReentrantLockTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TReentrantLockTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L14"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "acquireRead",
    "description": "Acquires a read lock. The transaction will suspend until no other fiber is\nholding a write lock. Succeeds with the number of read locks held by this\nfiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const acquireRead: (self: TReentrantLock) => STM.STM<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L72"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "acquireWrite",
    "description": "Acquires a write lock. The transaction will suspend until no other fibers\nare holding read or write locks. Succeeds with the number of write locks\nheld by this fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const acquireWrite: (self: TReentrantLock) => STM.STM<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L82"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "fiberReadLocks",
    "description": "Retrieves the number of acquired read locks for this fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const fiberReadLocks: (self: TReentrantLock) => STM.STM<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L90"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "fiberWriteLocks",
    "description": "Retrieves the number of acquired write locks for this fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const fiberWriteLocks: (self: TReentrantLock) => STM.STM<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L98"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "lock",
    "description": "Just a convenience method for applications that only need reentrant locks,\nwithout needing a distinction between readers / writers.\n\nSee `TReentrantLock.writeLock`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const lock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L109"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "locked",
    "description": "Determines if any fiber has a read or write lock.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const locked: (self: TReentrantLock) => STM.STM<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L117"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Makes a new reentrant read/write lock.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: STM.STM<TReentrantLock, never, never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L125"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "readLock",
    "description": "Obtains a read lock in a scoped context.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const readLock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L133"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "readLocks",
    "description": "Retrieves the total number of acquired read locks.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const readLocks: (self: TReentrantLock) => STM.STM<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L141"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "readLocked",
    "description": "Determines if any fiber has a read lock.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const readLocked: (self: TReentrantLock) => STM.STM<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L149"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "releaseRead",
    "description": "Releases a read lock held by this fiber. Succeeds with the outstanding\nnumber of read locks held by this fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const releaseRead: (self: TReentrantLock) => STM.STM<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L158"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "releaseWrite",
    "description": "Releases a write lock held by this fiber. Succeeds with the outstanding\nnumber of write locks held by this fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const releaseWrite: (self: TReentrantLock) => STM.STM<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L167"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "withLock",
    "description": "Runs the specified workflow with a lock.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const withLock: { (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L175"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "withReadLock",
    "description": "Runs the specified workflow with a read lock.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const withReadLock: { (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L186"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "withWriteLock",
    "description": "Runs the specified workflow with a write lock.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const withWriteLock: { (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L197"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "writeLock",
    "description": "Obtains a write lock in a scoped context.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const writeLock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L208"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "writeLocked",
    "description": "Determines if a write lock is held by some fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const writeLocked: (self: TReentrantLock) => STM.STM<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L216"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "writeLocks",
    "description": "Computes the number of write locks held by fibers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const writeLocks: (self: TReentrantLock) => STM.STM<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L224"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "TReentrantLock",
    "description": "A `TReentrantLock` is a reentrant read/write lock. Multiple readers may all\nconcurrently acquire read locks. Only one writer is allowed to acquire a\nwrite lock at any given time. Read locks may be upgraded into write locks. A\nfiber that has a write lock may acquire other write locks or read locks.\n\nThe two primary methods of this structure are `readLock`, which acquires a\nread lock in a scoped context, and `writeLock`, which acquires a write lock\nin a scoped context.\n\nAlthough located in the STM package, there is no need for locks within STM\ntransactions. However, this lock can be quite useful in effectful code, to\nprovide consistent read/write access to mutable state; and being in STM\nallows this structure to be composed into more complicated concurrent\nstructures that are consumed from effectful code.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TReentrantLock extends TReentrantLock.Proto {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L41"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "TReentrantLockTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type TReentrantLockTypeId = typeof TReentrantLockTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L20"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TReentrantLock.ts",
      "path": "src/TReentrantLock.ts"
    },
    "project": "effect",
    "name": "TReentrantLock.Proto",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Proto {\n    readonly [TReentrantLockTypeId]: TReentrantLockTypeId\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TReentrantLock.ts#L59"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "TRefTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TRefTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L18"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "get",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const get: <A>(self: TRef<A>) => STM.STM<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L73"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "getAndSet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const getAndSet: { <A>(value: A): (self: TRef<A>) => STM.STM<A>; <A>(self: TRef<A>, value: A): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L79"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdate",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const getAndUpdate: { <A>(f: (a: A) => A): (self: TRef<A>) => STM.STM<A>; <A>(self: TRef<A>, f: (a: A) => A): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L88"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdateSome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const getAndUpdateSome: { <A>(f: (a: A) => Option.Option<A>): (self: TRef<A>) => STM.STM<A>; <A>(self: TRef<A>, f: (a: A) => Option.Option<A>): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L97"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A>(value: A) => STM.STM<TRef<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L106"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "modify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const modify: { <A, B>(f: (a: A) => readonly [B, A]): (self: TRef<A>) => STM.STM<B>; <A, B>(self: TRef<A>, f: (a: A) => readonly [B, A]): STM.STM<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L112"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "modifySome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const modifySome: { <A, B>(fallback: B, f: (a: A) => Option.Option<readonly [B, A]>): (self: TRef<A>) => STM.STM<B>; <A, B>(self: TRef<A>, fallback: B, f: (a: A) => Option.Option<readonly [B, A]>): STM.STM<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L121"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "set",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const set: { <A>(value: A): (self: TRef<A>) => STM.STM<void>; <A>(self: TRef<A>, value: A): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L130"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "setAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const setAndGet: { <A>(value: A): (self: TRef<A>) => STM.STM<A>; <A>(self: TRef<A>, value: A): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L139"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "update",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const update: { <A>(f: (a: A) => A): (self: TRef<A>) => STM.STM<void>; <A>(self: TRef<A>, f: (a: A) => A): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L148"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "updateAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const updateAndGet: { <A>(f: (a: A) => A): (self: TRef<A>) => STM.STM<A>; <A>(self: TRef<A>, f: (a: A) => A): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L157"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "updateSome",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const updateSome: { <A>(f: (a: A) => Option.Option<A>): (self: TRef<A>) => STM.STM<void>; <A>(self: TRef<A>, f: (a: A) => Option.Option<A>): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L166"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "updateSomeAndGet",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const updateSomeAndGet: { <A>(f: (a: A) => Option.Option<A>): (self: TRef<A>) => STM.STM<A>; <A>(self: TRef<A>, f: (a: A) => Option.Option<A>): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L175"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "TRef",
    "description": "A `TRef<A>` is a purely functional description of a mutable reference that can\nbe modified as part of a transactional effect. The fundamental operations of\na `TRef` are `set` and `get`. `set` transactionally sets the reference to a\nnew value. `get` gets the current value of the reference.\n\nNOTE: While `TRef<A>` provides the transactional equivalent of a mutable\nreference, the value inside the `TRef` should be immutable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TRef<in out A> extends TRef.Variance<A>, Pipeable {\n  /**\n   * Note: the method is unbound, exposed only for potential extensions.\n   */\n  modify<B>(f: (a: A) => readonly [B, A]): STM.STM<B>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L38"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "TRefTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type TRefTypeId = typeof TRefTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L24"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TRef.ts",
      "path": "src/TRef.ts"
    },
    "project": "effect",
    "name": "TRef.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface Variance<in out A> {\n    readonly [TRefTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TRef.ts#L62"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates an empty `Trie`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<string>()\n\nassert.equal(Trie.size(trie), 0)\nassert.deepStrictEqual(Array.from(trie), [])\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <V = never>() => Trie<V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L60"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `Trie` from an iterable collection of key/value pairs (e.g. `Array<[string, V]>`).",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie, Equal } from \"effect\"\n\nconst iterable: Array<readonly [string, number]> = [[\"call\", 0], [\"me\", 1], [\"mind\", 2], [\"mid\", 3]]\nconst trie = Trie.fromIterable(iterable)\n\n// The entries in the `Trie` are extracted in alphabetical order, regardless of the insertion order\nassert.deepStrictEqual(Array.from(trie), [[\"call\", 0], [\"me\", 1], [\"mid\", 3], [\"mind\", 2]])\nassert.equal(Equal.equals(Trie.make([\"call\", 0], [\"me\", 1], [\"mind\", 2], [\"mid\", 3]), trie), true)\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: <V>(entries: Iterable<readonly [string, V]>) => Trie<V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L81"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new `Trie` from the specified entries (`[string, V]`).",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie, Equal } from \"effect\"\n\nconst trie = Trie.make([\"ca\", 0], [\"me\", 1])\n\nassert.deepStrictEqual(Array.from(trie), [[\"ca\", 0], [\"me\", 1]])\nassert.equal(Equal.equals(Trie.fromIterable([[\"ca\", 0], [\"me\", 1]]), trie), true)\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Entries extends Array<readonly [string, any]>>(...entries: Entries) => Trie<Entries[number] extends readonly [any, infer V] ? V : never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L100"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "insert",
    "description": "Insert a new entry in the `Trie`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie1 = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0)\n)\nconst trie2 = trie1.pipe(Trie.insert(\"me\", 1))\nconst trie3 = trie2.pipe(Trie.insert(\"mind\", 2))\nconst trie4 = trie3.pipe(Trie.insert(\"mid\", 3))\n\nassert.deepStrictEqual(Array.from(trie1), [[\"call\", 0]])\nassert.deepStrictEqual(Array.from(trie2), [[\"call\", 0], [\"me\", 1]])\nassert.deepStrictEqual(Array.from(trie3), [[\"call\", 0], [\"me\", 1], [\"mind\", 2]])\nassert.deepStrictEqual(Array.from(trie4), [[\"call\", 0], [\"me\", 1], [\"mid\", 3], [\"mind\", 2]])\n```"
    ],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const insert: { <V1>(key: string, value: V1): <V>(self: Trie<V>) => Trie<V | V1>; <V1, V>(self: Trie<V>, key: string, value: V1): Trie<V | V1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L128"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "keys",
    "description": "Returns an `IterableIterator` of the keys within the `Trie`.\n\nThe keys are returned in alphabetical order, regardless of insertion order.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"cab\", 0),\n  Trie.insert(\"abc\", 1),\n  Trie.insert(\"bca\", 2)\n)\n\nconst result = Array.from(Trie.keys(trie))\nassert.deepStrictEqual(result, [\"abc\", \"bca\", \"cab\"])\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const keys: <V>(self: Trie<V>) => IterableIterator<string>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L156"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "values",
    "description": "Returns an `IterableIterator` of the values within the `Trie`.\n\nValues are ordered based on their key in alphabetical order, regardless of insertion order.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1),\n  Trie.insert(\"and\", 2)\n)\n\nconst result = Array.from(Trie.values(trie))\nassert.deepStrictEqual(result, [2, 0, 1])\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const values: <V>(self: Trie<V>) => IterableIterator<V>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L181"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "entries",
    "description": "Returns an `IterableIterator` of the entries within the `Trie`.\n\nThe entries are returned by keys in alphabetical order, regardless of insertion order.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1)\n)\n\nconst result = Array.from(Trie.entries(trie))\nassert.deepStrictEqual(result, [[\"call\", 0], [\"me\", 1]])\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const entries: <V>(self: Trie<V>) => IterableIterator<[string, V]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L205"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "keysWithPrefix",
    "description": "Returns an `IterableIterator` of the keys within the `Trie`\nthat have `prefix` as prefix (`prefix` included if it exists).",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 0),\n  Trie.insert(\"shells\", 1),\n  Trie.insert(\"sea\", 2),\n  Trie.insert(\"shore\", 3)\n)\n\nconst result = Array.from(Trie.keysWithPrefix(trie, \"she\"))\nassert.deepStrictEqual(result, [\"she\", \"shells\"])\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const keysWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<string>; <V>(self: Trie<V>, prefix: string): IterableIterator<string>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L254"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "valuesWithPrefix",
    "description": "Returns an `IterableIterator` of the values within the `Trie`\nthat have `prefix` as prefix (`prefix` included if it exists).",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 0),\n  Trie.insert(\"shells\", 1),\n  Trie.insert(\"sea\", 2),\n  Trie.insert(\"shore\", 3)\n)\n\nconst result = Array.from(Trie.valuesWithPrefix(trie, \"she\"))\n\n// 0: \"she\", 1: \"shells\"\nassert.deepStrictEqual(result, [0, 1])\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const valuesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<V>; <V>(self: Trie<V>, prefix: string): IterableIterator<V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L284"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "entriesWithPrefix",
    "description": "Returns an `IterableIterator` of the entries within the `Trie`\nthat have `prefix` as prefix (`prefix` included if it exists).",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 0),\n  Trie.insert(\"shells\", 1),\n  Trie.insert(\"sea\", 2),\n  Trie.insert(\"shore\", 3)\n)\n\nconst result = Array.from(Trie.entriesWithPrefix(trie, \"she\"))\nassert.deepStrictEqual(result, [[\"she\", 0], [\"shells\", 1]])\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const entriesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<[string, V]>; <V>(self: Trie<V>, prefix: string): IterableIterator<[string, V]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L312"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "toEntriesWithPrefix",
    "description": "Returns `Array<[K, V]>` of the entries within the `Trie`\nthat have `prefix` as prefix (`prefix` included if it exists).",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"sea\", 2),\n  Trie.insert(\"she\", 3)\n)\n\nconst result = Trie.toEntriesWithPrefix(trie, \"she\")\nassert.deepStrictEqual(result, [[\"she\", 3], [\"shells\", 0]])\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const toEntriesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => Array<[string, V]>; <V>(self: Trie<V>, prefix: string): Array<[string, V]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L340"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "longestPrefixOf",
    "description": "Returns the longest key/value in the `Trie`\nthat is a prefix of that `key` if it exists, `None` otherwise.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nassert.deepStrictEqual(Trie.longestPrefixOf(trie, \"sell\"), Option.none())\nassert.deepStrictEqual(Trie.longestPrefixOf(trie, \"sells\"), Option.some([\"sells\", 1]))\nassert.deepStrictEqual(Trie.longestPrefixOf(trie, \"shell\"), Option.some([\"she\", 2]))\nassert.deepStrictEqual(Trie.longestPrefixOf(trie, \"shellsort\"), Option.some([\"shells\", 0]))\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const longestPrefixOf: { (key: string): <V>(self: Trie<V>) => Option<[string, V]>; <V>(self: Trie<V>, key: string): Option<[string, V]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L369"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the size of the `Trie` (number of entries in the `Trie`).",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"a\", 0),\n  Trie.insert(\"b\", 1)\n)\n\nassert.equal(Trie.size(trie), 2)\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <V>(self: Trie<V>) => number",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L393"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "get",
    "description": "Safely lookup the value for the specified key in the `Trie`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1),\n  Trie.insert(\"mind\", 2),\n  Trie.insert(\"mid\", 3)\n)\n\nassert.deepStrictEqual(Trie.get(trie, \"call\"), Option.some(0))\nassert.deepStrictEqual(Trie.get(trie, \"me\"), Option.some(1))\nassert.deepStrictEqual(Trie.get(trie, \"mind\"), Option.some(2))\nassert.deepStrictEqual(Trie.get(trie, \"mid\"), Option.some(3))\nassert.deepStrictEqual(Trie.get(trie, \"cale\"), Option.none())\nassert.deepStrictEqual(Trie.get(trie, \"ma\"), Option.none())\nassert.deepStrictEqual(Trie.get(trie, \"midn\"), Option.none())\nassert.deepStrictEqual(Trie.get(trie, \"mea\"), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const get: { (key: string): <V>(self: Trie<V>) => Option<V>; <V>(self: Trie<V>, key: string): Option<V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L423"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "has",
    "description": "Check if the given key exists in the `Trie`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1),\n  Trie.insert(\"mind\", 2),\n  Trie.insert(\"mid\", 3)\n)\n\nassert.equal(Trie.has(trie, \"call\"), true)\nassert.equal(Trie.has(trie, \"me\"), true)\nassert.equal(Trie.has(trie, \"mind\"), true)\nassert.equal(Trie.has(trie, \"mid\"), true)\nassert.equal(Trie.has(trie, \"cale\"), false)\nassert.equal(Trie.has(trie, \"ma\"), false)\nassert.equal(Trie.has(trie, \"midn\"), false)\nassert.equal(Trie.has(trie, \"mea\"), false)\n```"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const has: { (key: string): <V>(self: Trie<V>) => boolean; <V>(self: Trie<V>, key: string): boolean; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L456"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Checks if the `Trie` contains any entries.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>()\nconst trie1 = trie.pipe(Trie.insert(\"ma\", 0))\n\nassert.equal(Trie.isEmpty(trie), true)\nassert.equal(Trie.isEmpty(trie1), false)\n```"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const isEmpty: <V>(self: Trie<V>) => boolean",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L479"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "unsafeGet",
    "description": "Unsafely lookup the value for the specified key in the `Trie`.\n\n`unsafeGet` will throw if the key is not found. Use `get` instead to safely\nget a value from the `Trie`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1)\n)\n\nassert.throws(() => Trie.unsafeGet(trie, \"mae\"))\n```"
    ],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeGet: { (key: string): <V>(self: Trie<V>) => V; <V>(self: Trie<V>, key: string): V; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L503"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "remove",
    "description": "Remove the entry for the specified key in the `Trie`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1),\n  Trie.insert(\"mind\", 2),\n  Trie.insert(\"mid\", 3)\n)\n\nconst trie1 = trie.pipe(Trie.remove(\"call\"))\nconst trie2 = trie1.pipe(Trie.remove(\"mea\"))\n\nassert.deepStrictEqual(Trie.get(trie, \"call\"), Option.some(0))\nassert.deepStrictEqual(Trie.get(trie1, \"call\"), Option.none())\nassert.deepStrictEqual(Trie.get(trie2, \"call\"), Option.none())\n```"
    ],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const remove: { (key: string): <V>(self: Trie<V>) => Trie<V>; <V>(self: Trie<V>, key: string): Trie<V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L534"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "reduce",
    "description": "Reduce a state over the entries of the `Trie`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nassert.equal(\n  trie.pipe(\n    Trie.reduce(0, (acc, n) => acc + n)\n  ),\n  3\n)\nassert.equal(\n  trie.pipe(\n    Trie.reduce(10, (acc, n) => acc + n)\n  ),\n  13\n)\nassert.equal(\n  trie.pipe(\n    Trie.reduce(\"\", (acc, _, key) => acc + key)\n  ),\n  \"sellssheshells\"\n)\n```"
    ],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduce: { <Z, V>(zero: Z, f: (accumulator: Z, value: V, key: string) => Z): (self: Trie<V>) => Z; <Z, V>(self: Trie<V>, zero: Z, f: (accumulator: Z, value: V, key: string) => Z): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L576"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Maps over the entries of the `Trie` using the specified function.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapV = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 1),\n  Trie.insert(\"sells\", 2),\n  Trie.insert(\"she\", 3)\n)\n\nconst trieMapK = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 6),\n  Trie.insert(\"sells\", 5),\n  Trie.insert(\"she\", 3)\n)\n\nassert.equal(Equal.equals(Trie.map(trie, (v) => v + 1), trieMapV), true)\nassert.equal(Equal.equals(Trie.map(trie, (_, k) => k.length), trieMapK), true)\n```"
    ],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const map: { <A, V>(f: (value: V, key: string) => A): (self: Trie<V>) => Trie<A>; <V, A>(self: Trie<V>, f: (value: V, key: string) => A): Trie<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L614"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters entries out of a `Trie` using the specified predicate.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapV = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapK = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1)\n)\n\nassert.equal(Equal.equals(Trie.filter(trie, (v) => v > 1), trieMapV), true)\nassert.equal(Equal.equals(Trie.filter(trie, (_, k) => k.length > 3), trieMapK), true)\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filter: { <A, B extends A>(f: (a: NoInfer<A>, k: string) => a is B): (self: Trie<A>) => Trie<B>; <A>(f: (a: NoInfer<A>, k: string) => boolean): (self: Trie<A>) => Trie<A>; <A, B extends A>(self: Trie<A>, f: (a: A, k: string) => a is B): Trie<B>; <A>(self: Trie<A>, f: (a: A, k: string) => boolean): Trie<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L649"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Maps over the entries of the `Trie` using the specified partial function\nand filters out `None` values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie, Equal, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapV = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapK = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1)\n)\n\nassert.equal(Equal.equals(Trie.filterMap(trie, (v) => v > 1 ? Option.some(v) : Option.none()), trieMapV), true)\nassert.equal(\n  Equal.equals(Trie.filterMap(trie, (v, k) => k.length > 3 ? Option.some(v) : Option.none()), trieMapK),\n  true\n)\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const filterMap: { <A, B>(f: (value: A, key: string) => Option<B>): (self: Trie<A>) => Trie<B>; <A, B>(self: Trie<A>, f: (value: A, key: string) => Option<B>): Trie<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L690"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "compact",
    "description": "Filters out `None` values from a `Trie` of `Options`s.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie, Equal, Option } from \"effect\"\n\nconst trie = Trie.empty<Option.Option<number>>().pipe(\n  Trie.insert(\"shells\", Option.some(0)),\n  Trie.insert(\"sells\", Option.none()),\n  Trie.insert(\"she\", Option.some(2))\n)\n\nconst trieMapV = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"she\", 2)\n)\n\nassert.equal(Equal.equals(Trie.compact(trie), trieMapV), true)\n```"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "declare const compact: <A>(self: Trie<Option<A>>) => Trie<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L720"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "Applies the specified function to the entries of the `Trie`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nlet value = 0\n\nTrie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2),\n  Trie.forEach((n, key) => {\n    value += n + key.length\n  })\n)\n\nassert.equal(value, 17)\n```"
    ],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "declare const forEach: { <V>(f: (value: V, key: string) => void): (self: Trie<V>) => void; <V>(self: Trie<V>, f: (value: V, key: string) => void): void; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L747"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "modify",
    "description": "Updates the value of the specified key within the `Trie` if it exists.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie, Equal, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nassert.deepStrictEqual(trie.pipe(Trie.modify(\"she\", (v) => v + 10), Trie.get(\"she\")), Option.some(12))\n\nassert.equal(Equal.equals(trie.pipe(Trie.modify(\"me\", (v) => v)), trie), true)\n```"
    ],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const modify: { <V1, V>(key: string, f: (v: V) => V1): (self: Trie<V>) => Trie<V1 | V>; <V1, V>(self: Trie<V>, key: string, f: (v: V) => V1): Trie<V | V1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L774"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "removeMany",
    "description": "Removes all entries in the `Trie` which have the specified keys.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nassert.equal(\n  Equal.equals(trie.pipe(Trie.removeMany([\"she\", \"sells\"])), Trie.empty<number>().pipe(Trie.insert(\"shells\", 0))),\n  true\n)\n```"
    ],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const removeMany: { (keys: Iterable<string>): <V>(self: Trie<V>) => Trie<V>; <V>(self: Trie<V>, keys: Iterable<string>): Trie<V>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L802"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "insertMany",
    "description": "Insert multiple entries in the `Trie` at once.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nconst trieInsert = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insertMany(\n    [[\"sells\", 1], [\"she\", 2]]\n  )\n)\n\nassert.equal(\n  Equal.equals(trie, trieInsert),\n  true\n)\n```"
    ],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const insertMany: { <V1>(iter: Iterable<[string, V1]>): <V>(self: Trie<V>) => Trie<V | V1>; <V1, V>(self: Trie<V>, iter: Iterable<[string, V1]>): Trie<V | V1>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L837"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "toEntries",
    "description": "Returns an `Array<[K, V]>` of the entries within the `Trie`.\n\nEquivalent to `Array.from(Trie.entries(trie))`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1)\n)\nconst result = Trie.toEntries(trie)\n\nassert.deepStrictEqual(result, [[\"call\", 0], [\"me\", 1]])\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const toEntries: <V>(self: Trie<V>) => Array<[string, V]>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L229"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "Trie",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Trie<out Value> extends Iterable<[string, Value]>, Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _Value: Covariant<Value>\n  }\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L37"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Trie.ts",
      "path": "src/Trie.ts"
    },
    "project": "effect",
    "name": "TypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "type TypeId = typeof TypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Trie.ts#L31"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "TSemaphoreTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TSemaphoreTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L15"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "acquire",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const acquire: (self: TSemaphore) => STM.STM<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L54"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "acquireN",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const acquireN: { (n: number): (self: TSemaphore) => STM.STM<void>; (self: TSemaphore, n: number): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L60"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "available",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const available: (self: TSemaphore) => STM.STM<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L69"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: (permits: number) => STM.STM<TSemaphore>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L75"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "release",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const release: (self: TSemaphore) => STM.STM<void>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L81"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "releaseN",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const releaseN: { (n: number): (self: TSemaphore) => STM.STM<void>; (self: TSemaphore, n: number): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L87"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "withPermit",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const withPermit: { (semaphore: TSemaphore): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(self: Effect.Effect<A, E, R>, semaphore: TSemaphore): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L96"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "withPermits",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const withPermits: { (semaphore: TSemaphore, permits: number): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(self: Effect.Effect<A, E, R>, semaphore: TSemaphore, permits: number): Effect.Effect<A, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L105"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "withPermitScoped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const withPermitScoped: (self: TSemaphore) => Effect.Effect<void, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L114"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "withPermitsScoped",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const withPermitsScoped: { (permits: number): (self: TSemaphore) => Effect.Effect<void, never, Scope.Scope>; (self: TSemaphore, permits: number): Effect.Effect<void, never, Scope.Scope>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L120"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "unsafeMake",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "declare const unsafeMake: (permits: number) => TSemaphore",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L129"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "TSemaphore",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TSemaphore extends TSemaphore.Proto {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L27"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "TSemaphoreTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type TSemaphoreTypeId = typeof TSemaphoreTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L21"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TSemaphore.ts",
      "path": "src/TSemaphore.ts"
    },
    "project": "effect",
    "name": "TSemaphore.Proto",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Proto {\n    readonly [TSemaphoreTypeId]: TSemaphoreTypeId\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSemaphore.ts#L45"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "TSetTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const TSetTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L17"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "add",
    "description": "Stores new element in the set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const add: { <A>(value: A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, value: A): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L62"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "difference",
    "description": "Atomically transforms the set into the difference of itself and the\nprovided set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const difference: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L74"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "empty",
    "description": "Makes an empty `TSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const empty: <A>() => STM.STM<TSet<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L85"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "forEach",
    "description": "Atomically performs transactional-effect for each element in set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const forEach: { <A, R, E>(f: (value: A) => STM.STM<void, E, R>): (self: TSet<A>) => STM.STM<void, E, R>; <A, R, E>(self: TSet<A>, f: (value: A) => STM.STM<void, E, R>): STM.STM<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L93"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `TSet` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const fromIterable: <A>(iterable: Iterable<A>) => STM.STM<TSet<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L104"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "has",
    "description": "Tests whether or not set contains an element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "declare const has: { <A>(value: A): (self: TSet<A>) => STM.STM<boolean>; <A>(self: TSet<A>, value: A): STM.STM<boolean>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L112"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "intersection",
    "description": "Atomically transforms the set into the intersection of itself and the\nprovided set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const intersection: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L124"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Tests if the set is empty or not",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const isEmpty: <A>(self: TSet<A>) => STM.STM<boolean>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L135"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Makes a new `TSet` that is initialized with specified values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <Elements extends Array<any>>(...elements: Elements) => STM.STM<TSet<Elements[number]>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L143"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "reduce",
    "description": "Atomically folds using a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduce: { <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: TSet<A>) => STM.STM<Z>; <Z, A>(self: TSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): STM.STM<Z>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L153"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "reduceSTM",
    "description": "Atomically folds using a transactional function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const reduceSTM: { <Z, A, R, E>(zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>): (self: TSet<A>) => STM.STM<Z, E, R>; <Z, A, R, E>(self: TSet<A>, zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>): STM.STM<Z, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L164"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "remove",
    "description": "Removes a single element from the set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const remove: { <A>(value: A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, value: A): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L175"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "removeAll",
    "description": "Removes elements from the set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const removeAll: { <A>(iterable: Iterable<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, iterable: Iterable<A>): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L186"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "removeIf",
    "description": "Removes entries from a `TSet` that satisfy the specified predicate and returns the removed entries\n(or `void` if `discard = true`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const removeIf: { <A>(predicate: Predicate<A>, options: { readonly discard: true; }): (self: TSet<A>) => STM.STM<void>; <A>(predicate: Predicate<A>, options?: { readonly discard: false; }): (self: TSet<A>) => STM.STM<Array<A>>; <A>(self: TSet<A>, predicate: Predicate<A>, options: { readonly discard: true; }): STM.STM<void>; <A>(self: TSet<A>, predicate: Predicate<A>, options?: { readonly discard: false; }): STM.STM<Array<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L198"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "retainIf",
    "description": "Retains entries in a `TSet` that satisfy the specified predicate and returns the removed entries\n(or `void` if `discard = true`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const retainIf: { <A>(predicate: Predicate<A>, options: { readonly discard: true; }): (self: TSet<A>) => STM.STM<void>; <A>(predicate: Predicate<A>, options?: { readonly discard: false; }): (self: TSet<A>) => STM.STM<Array<A>>; <A>(self: TSet<A>, predicate: Predicate<A>, options: { readonly discard: true; }): STM.STM<void>; <A>(self: TSet<A>, predicate: Predicate<A>, options?: { readonly discard: false; }): STM.STM<Array<A>>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L227"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the set's cardinality.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const size: <A>(self: TSet<A>) => STM.STM<number>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L255"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "takeFirst",
    "description": "Takes the first matching value, or retries until there is one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeFirst: { <A, B>(pf: (a: A) => Option.Option<B>): (self: TSet<A>) => STM.STM<B>; <A, B>(self: TSet<A>, pf: (a: A) => Option.Option<B>): STM.STM<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L263"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "takeFirstSTM",
    "description": "Takes the first matching value, or retries until there is one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeFirstSTM: { <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>): (self: TSet<A>) => STM.STM<B, E, R>; <A, B, E, R>(self: TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>): STM.STM<B, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L274"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "takeSome",
    "description": "Takes all matching values, or retries until there is at least one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeSome: { <A, B>(pf: (a: A) => Option.Option<B>): (self: TSet<A>) => STM.STM<[B, ...Array<B>]>; <A, B>(self: TSet<A>, pf: (a: A) => Option.Option<B>): STM.STM<[B, ...Array<B>]>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L285"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "takeSomeSTM",
    "description": "Takes all matching values, or retries until there is at least one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const takeSomeSTM: { <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>): (self: TSet<A>) => STM.STM<[B, ...Array<B>], E, R>; <A, B, E, R>(self: TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>): STM.STM<[B, ...Array<B>], E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L296"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "toChunk",
    "description": "Collects all elements into a `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toChunk: <A>(self: TSet<A>) => STM.STM<Chunk.Chunk<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L307"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "toHashSet",
    "description": "Collects all elements into a `HashSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toHashSet: <A>(self: TSet<A>) => STM.STM<HashSet.HashSet<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L315"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "toArray",
    "description": "Collects all elements into a `Array`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toArray: <A>(self: TSet<A>) => STM.STM<Array<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L323"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "toReadonlySet",
    "description": "Collects all elements into a `ReadonlySet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "declare const toReadonlySet: <A>(self: TSet<A>) => STM.STM<ReadonlySet<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L331"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "transform",
    "description": "Atomically updates all elements using a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const transform: { <A>(f: (a: A) => A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, f: (a: A) => A): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L339"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "transformSTM",
    "description": "Atomically updates all elements using a transactional function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const transformSTM: { <A, R, E>(f: (a: A) => STM.STM<A, E, R>): (self: TSet<A>) => STM.STM<void, E, R>; <A, R, E>(self: TSet<A>, f: (a: A) => STM.STM<A, E, R>): STM.STM<void, E, R>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L350"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "union",
    "description": "Atomically transforms the set into the union of itself and the provided\nset.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "declare const union: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L362"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "TSet",
    "description": "Transactional set implemented on top of `TMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TSet<in out A> extends TSet.Variance<A> {}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L31"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "TSetTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type TSetTypeId = typeof TSetTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L23"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TSet.ts",
      "path": "src/TSet.ts"
    },
    "project": "effect",
    "name": "TSet.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out A> {\n    readonly [TSetTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSet.ts#L49"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "TSubscriptionRefTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbols",
    "signature": "declare const TSubscriptionRefTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L19"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "get",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const get: <A>(self: TSubscriptionRef<A>) => STM.STM<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L68"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "getAndSet",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const getAndSet: { <A>(value: A): (self: TSubscriptionRef<A>) => STM.STM<A>; <A>(self: TSubscriptionRef<A>, value: A): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L74"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdate",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const getAndUpdate: { <A>(f: (a: A) => A): (self: TSubscriptionRef<A>) => STM.STM<A>; <A>(self: TSubscriptionRef<A>, f: (a: A) => A): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L83"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "getAndUpdateSome",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const getAndUpdateSome: { <A>(f: (a: A) => Option.Option<A>): (self: TSubscriptionRef<A>) => STM.STM<A>; <A>(self: TSubscriptionRef<A>, f: (a: A) => Option.Option<A>): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L92"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "make",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "declare const make: <A>(value: A) => STM.STM<TSubscriptionRef<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L101"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "modify",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const modify: { <A, B>(f: (a: A) => readonly [B, A]): (self: TSubscriptionRef<A>) => STM.STM<B>; <A, B>(self: TSubscriptionRef<A>, f: (a: A) => readonly [B, A]): STM.STM<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L107"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "modifySome",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const modifySome: { <A, B>(fallback: B, f: (a: A) => Option.Option<readonly [B, A]>): (self: TSubscriptionRef<A>) => STM.STM<B>; <A, B>(self: TSubscriptionRef<A>, fallback: B, f: (a: A) => Option.Option<readonly [B, A]>): STM.STM<B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L116"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "set",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const set: { <A>(value: A): (self: TSubscriptionRef<A>) => STM.STM<void>; <A>(self: TSubscriptionRef<A>, value: A): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L125"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "setAndGet",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const setAndGet: { <A>(value: A): (self: TSubscriptionRef<A>) => STM.STM<A>; <A>(self: TSubscriptionRef<A>, value: A): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L134"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "update",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const update: { <A>(f: (a: A) => A): (self: TSubscriptionRef<A>) => STM.STM<void>; <A>(self: TSubscriptionRef<A>, f: (a: A) => A): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L143"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "updateAndGet",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const updateAndGet: { <A>(f: (a: A) => A): (self: TSubscriptionRef<A>) => STM.STM<A>; <A>(self: TSubscriptionRef<A>, f: (a: A) => A): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L152"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "updateSome",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const updateSome: { <A>(f: (a: A) => Option.Option<A>): (self: TSubscriptionRef<A>) => STM.STM<void>; <A>(self: TSubscriptionRef<A>, f: (a: A) => Option.Option<A>): STM.STM<void>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L161"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "updateSomeAndGet",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const updateSomeAndGet: { <A>(f: (a: A) => Option.Option<A>): (self: TSubscriptionRef<A>) => STM.STM<A>; <A>(self: TSubscriptionRef<A>, f: (a: A) => Option.Option<A>): STM.STM<A>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L170"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "changesScoped",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const changesScoped: <A>(self: TSubscriptionRef<A>) => Effect.Effect<TQueue.TDequeue<A>, never, Scope.Scope>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L179"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "changesStream",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const changesStream: <A>(self: TSubscriptionRef<A>) => Stream.Stream<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L186"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "changes",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "declare const changes: <A>(self: TSubscriptionRef<A>) => STM.STM<TQueue.TDequeue<A>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L192"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "TSubscriptionRef",
    "description": "A `TSubscriptionRef<A>` is a `TRef` that can be subscribed to in order to\nreceive a `TDequeue<A>` of the current value and all committed changes to the value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "models",
    "signature": "export interface TSubscriptionRef<in out A> extends TSubscriptionRef.Variance<A>, TRef.TRef<A> {\n  /** @internal */\n  readonly ref: TRef.TRef<A>\n  /** @internal */\n  readonly pubsub: TPubSub.TPubSub<A>\n  /** @internal */\n  modify<B>(f: (a: A) => readonly [B, A]): STM.STM<B>\n\n  /**\n   * A TDequeue containing the current value of the `Ref` as well as all changes\n   * to that value.\n   */\n  readonly changes: STM.STM<TQueue.TDequeue<A>>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L34"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "TSubscriptionRefTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbols",
    "signature": "type TSubscriptionRefTypeId = typeof TSubscriptionRefTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L25"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TSubscriptionRef.ts",
      "path": "src/TSubscriptionRef.ts"
    },
    "project": "effect",
    "name": "TSubscriptionRef.Variance",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "models",
    "signature": "export interface Variance<in out A> {\n    readonly [TSubscriptionRefTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/TSubscriptionRef.ts#L57"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple.ts",
      "path": "src/Tuple.ts"
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms each element of tuple using the given function, treating tuple homomorphically",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { pipe, Tuple } from \"effect\"\n\nconst result = pipe(\n  [\"a\", 1, false] as const,\n  Tuple.map((el) => el.toString().toUpperCase())\n)\nassert.deepStrictEqual(result, ['A', '1', 'FALSE'])\n```"
    ],
    "since": "3.9.0",
    "category": "mapping",
    "signature": "declare const map: { <T extends ReadonlyArray<any> | [], B>(fn: (element: T[number]) => B): (self: T) => TupleOf<T[\"length\"], B>; <B, T extends ReadonlyArray<any> | []>(self: T, fn: (element: T[number]) => B): TupleOf<T[\"length\"], B>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L86"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple.ts",
      "path": "src/Tuple.ts"
    },
    "project": "effect",
    "name": "mapBoth",
    "description": "Transforms both elements of a tuple using the given functions.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { mapBoth } from \"effect/Tuple\"\n\nassert.deepStrictEqual(\n  mapBoth([\"hello\", 42], { onFirst: s => s.toUpperCase(), onSecond: n => n.toString() }),\n  [\"HELLO\", \"42\"]\n)\n```"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapBoth: { <L1, L2, R1, R2>(options: { readonly onFirst: (e: L1) => L2; readonly onSecond: (a: R1) => R2; }): (self: readonly [L1, R1]) => [L2, R2]; <L1, R1, L2, R2>(self: readonly [L1, R1], options: { readonly onFirst: (e: L1) => L2; readonly onSecond: (a: R1) => R2; }): [L2, R2]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L119"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple.ts",
      "path": "src/Tuple.ts"
    },
    "project": "effect",
    "name": "mapFirst",
    "description": "Transforms the first component of a tuple using a given function.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { mapFirst } from \"effect/Tuple\"\n\nassert.deepStrictEqual(\n  mapFirst([\"hello\", 42], s => s.toUpperCase()),\n  [\"HELLO\", 42]\n)\n```"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapFirst: { <L1, L2>(f: (left: L1) => L2): <R>(self: readonly [L1, R]) => [L2, R]; <L1, R, L2>(self: readonly [L1, R], f: (left: L1) => L2): [L2, R]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L156"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple.ts",
      "path": "src/Tuple.ts"
    },
    "project": "effect",
    "name": "mapSecond",
    "description": "Transforms the second component of a tuple using a given function.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { mapSecond } from \"effect/Tuple\"\n\nassert.deepStrictEqual(\n  mapSecond([\"hello\", 42], n => n.toString()),\n  [\"hello\", \"42\"]\n)\n```"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "declare const mapSecond: { <R1, R2>(f: (right: R1) => R2): <L>(self: readonly [L, R1]) => [L, R2]; <L, R1, R2>(self: readonly [L, R1], f: (right: R1) => R2): [L, R2]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L178"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple.ts",
      "path": "src/Tuple.ts"
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": "Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\nby applying each `Equivalence` to the corresponding element of the tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const getEquivalence: <T extends ReadonlyArray<Equivalence.Equivalence<any>>>(...isEquivalents: T) => Equivalence.Equivalence<Readonly<{ [I in keyof T]: [T[I]] extends [Equivalence.Equivalence<infer A>] ? A : never; }>>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L205"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple.ts",
      "path": "src/Tuple.ts"
    },
    "project": "effect",
    "name": "getOrder",
    "description": "This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\nThe returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\nIt is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\nof the tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "declare const getOrder: <T extends ReadonlyArray<order.Order<any>>>(...elements: T) => order.Order<{ [I in keyof T]: [T[I]] extends [order.Order<infer A>] ? A : never; }>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L220"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple.ts",
      "path": "src/Tuple.ts"
    },
    "project": "effect",
    "name": "appendElement",
    "description": "Appends an element to the end of a tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "declare const appendElement: { <B>(that: B): <A extends ReadonlyArray<unknown>>(self: A) => [...A, B]; <A extends ReadonlyArray<unknown>, B>(self: A, that: B): [...A, B]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L230"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple.ts",
      "path": "src/Tuple.ts"
    },
    "project": "effect",
    "name": "at",
    "description": "Retrieves the element at a specified index from a tuple.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { Tuple } from \"effect\"\n\nassert.deepStrictEqual(Tuple.at([1, 'hello', true], 1), 'hello')\n```"
    ],
    "since": "3.4.0",
    "category": "getters",
    "signature": "declare const at: { <N extends number>(index: N): <A extends ReadonlyArray<unknown>>(self: A) => A[N]; <A extends ReadonlyArray<unknown>, N extends number>(self: A, index: N): A[N]; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L249"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Tuple.ts",
      "path": "src/Tuple.ts"
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new tuple from the provided values.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { make } from \"effect/Tuple\"\n\nassert.deepStrictEqual(make(1, 'hello', true), [1, 'hello', true])\n```"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const make: <A extends ReadonlyArray<any>>(...elements: A) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L34"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Tuple.ts",
      "path": "src/Tuple.ts"
    },
    "project": "effect",
    "name": "getFirst",
    "description": "Return the first element of a tuple.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { getFirst } from \"effect/Tuple\"\n\nassert.deepStrictEqual(getFirst([\"hello\", 42]), \"hello\")\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const getFirst: <L, R>(self: readonly [L, R]) => L",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L50"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Tuple.ts",
      "path": "src/Tuple.ts"
    },
    "project": "effect",
    "name": "getSecond",
    "description": "Return the second element of a tuple.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { getSecond } from \"effect/Tuple\"\n\nassert.deepStrictEqual(getSecond([\"hello\", 42]), 42)\n```"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "declare const getSecond: <L, R>(self: readonly [L, R]) => R",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L66"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Tuple.ts",
      "path": "src/Tuple.ts"
    },
    "project": "effect",
    "name": "swap",
    "description": "Swaps the two elements of a tuple.",
    "deprecated": false,
    "examples": [
      "```ts\nimport * as assert from \"node:assert\"\nimport { swap } from \"effect/Tuple\"\n\nassert.deepStrictEqual(swap([\"hello\", 42]), [42, \"hello\"])\n```"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const swap: <L, R>(self: readonly [L, R]) => [R, L]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L196"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tuple.ts",
      "path": "src/Tuple.ts"
    },
    "project": "effect",
    "name": "TupleTypeLambda",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface TupleTypeLambda extends TypeLambda {\n  readonly type: [this[\"Out1\"], this[\"Target\"]]\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Tuple.ts#L16"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "TupleOf",
    "description": "Represents a tuple with a fixed number of elements of type `T`.\n\nThis type constructs a tuple that has exactly `N` elements of type `T`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { TupleOf } from \"effect/Types\"\n\n// A tuple with exactly 3 numbers\nconst example1: TupleOf<3, number> = [1, 2, 3]; // valid\n// @ts-expect-error\nconst example2: TupleOf<3, number> = [1, 2]; // invalid\n// @ts-expect-error\nconst example3: TupleOf<3, number> = [1, 2, 3, 4]; // invalid\n```"
    ],
    "since": "3.3.0",
    "category": "tuples",
    "signature": "type TupleOf<N, T> = N extends N ? number extends N ? Array<T> : _TupleOf<T, N, []> : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L32"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "TupleOfAtLeast",
    "description": "Represents a tuple with at least `N` elements of type `T`.\n\nThis type constructs a tuple that has a fixed number of elements `N` of type `T` at the start,\nfollowed by any number (including zero) of additional elements of the same type `T`.",
    "deprecated": false,
    "examples": [
      "```ts\nimport { TupleOfAtLeast } from \"effect/Types\"\n\n// A tuple with at least 3 numbers\nconst example1: TupleOfAtLeast<3, number> = [1, 2, 3]; // valid\nconst example2: TupleOfAtLeast<3, number> = [1, 2, 3, 4, 5]; // valid\n// @ts-expect-error\nconst example3: TupleOfAtLeast<3, number> = [1, 2]; // invalid\n```"
    ],
    "since": "3.3.0",
    "category": "tuples",
    "signature": "type [...TupleOf<N, T>, ...T[]] = [...TupleOf<N, T>, ...Array<T>]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L57"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "Tags",
    "description": "Returns the tags in a type.",
    "deprecated": false,
    "examples": [
      "```ts\nimport type { Types } from \"effect\"\n\ntype Res = Types.Tags<string | { _tag: \"a\" } | { _tag: \"b\" } > // \"a\" | \"b\"\n```"
    ],
    "since": "2.0.0",
    "category": "types",
    "signature": "type Tags<E> = E extends { _tag: string } ? E[\"_tag\"] : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L71"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "ExcludeTag",
    "description": "Excludes the tagged object from the type.",
    "deprecated": false,
    "examples": [
      "```ts\nimport type { Types } from \"effect\"\n\ntype Res = Types.ExcludeTag<string | { _tag: \"a\" } | { _tag: \"b\" }, \"a\"> // string | { _tag: \"b\" }\n```"
    ],
    "since": "2.0.0",
    "category": "types",
    "signature": "type ExcludeTag<E, K> = Exclude<E, { _tag: K }>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L85"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "ExtractTag",
    "description": "Extracts the type of the given tag.",
    "deprecated": false,
    "examples": [
      "```ts\nimport type { Types } from \"effect\"\n\ntype Res = Types.ExtractTag<{ _tag: \"a\", a: number } | { _tag: \"b\", b: number }, \"b\"> // { _tag: \"b\", b: number }\n```"
    ],
    "since": "2.0.0",
    "category": "types",
    "signature": "type ExtractTag<E, K> = Extract<E, { _tag: K }>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L100"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "UnionToIntersection",
    "description": "A utility type that transforms a union type `T` into an intersection type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "types",
    "signature": "type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R\n  : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L108"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "Simplify",
    "description": "Simplifies the type signature of a type.",
    "deprecated": false,
    "examples": [
      "```ts\nimport type { Types } from \"effect\"\n\ntype Res = Types.Simplify<{ a: number } & { b: number }> // { a: number; b: number; }\n```"
    ],
    "since": "2.0.0",
    "category": "types",
    "signature": "type Simplify<A> = {\n  [K in keyof A]: A[K]\n} extends infer B ? B : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L124"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "Equals",
    "description": "Determines if two types are equal.",
    "deprecated": false,
    "examples": [
      "```ts\nimport type { Types } from \"effect\"\n\ntype Res1 = Types.Equals<{ a: number }, { a: number }> // true\ntype Res2 = Types.Equals<{ a: number }, { b: number }> // false\n```"
    ],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends <\n  T\n>() => T extends Y ? 1 : 2 ? true\n  : false",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L142"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "Has",
    "description": "Determines if a record contains any of the given keys.",
    "deprecated": false,
    "examples": [
      "```ts\nimport type { Types } from \"effect\"\n\ntype Res1 = Types.Has<{ a: number }, \"a\" | \"b\"> // true\ntype Res2 = Types.Has<{ c: number }, \"a\" | \"b\"> // false\n```"
    ],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Has<A, Key> = (Key extends infer K ? K extends keyof A ? true : never : never) extends never\n  ? false\n  : true",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L161"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "MergeLeft",
    "description": "Merges two object where the keys of the left object take precedence in the case of a conflict.",
    "deprecated": false,
    "examples": [
      "```ts\nimport type { Types } from \"effect\"\ntype MergeLeft = Types.MergeLeft<{ a: number, b: number; }, { a: string }> // { a: number; b: number; }\n```"
    ],
    "since": "2.0.0",
    "category": "models",
    "signature": "type MergeLeft<Source, Target> = MergeRight<Target, Source>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L177"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "MergeRight",
    "description": "Merges two object where the keys of the right object take precedence in the case of a conflict.",
    "deprecated": false,
    "examples": [
      "```ts\nimport type { Types } from \"effect\"\ntype MergeRight = Types.MergeRight<{ a: number, b: number; }, { a: string }> // { a: string; b: number; }\n```"
    ],
    "since": "2.0.0",
    "category": "models",
    "signature": "type MergeRight<Target, Source> = Simplify<\n  & Source\n  & {\n    [Key in keyof Target as Key extends keyof Source ? never : Key]: Target[Key]\n  }\n>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L191"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "MergeRecord",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type MergeRecord<Source, Target> = MergeLeft<Source, Target>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L202"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "Concurrency",
    "description": "Describes the concurrency to use when executing multiple Effect's.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Concurrency = number | \"unbounded\" | \"inherit\"",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L210"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "Mutable",
    "description": "Make all properties in `T` mutable. Supports arrays, tuples, and records as well.",
    "deprecated": false,
    "examples": [
      "```ts\nimport type { Types } from \"effect\"\n\ntype MutableStruct = Types.Mutable<{ readonly a: string; readonly b: number }> // { a: string; b: number; }\n\ntype MutableArray = Types.Mutable<ReadonlyArray<string>> // string[]\n\ntype MutableTuple = Types.Mutable<readonly [string, number]> // [string, number]\n\ntype MutableRecord = Types.Mutable<{ readonly [_: string]: number }> // { [x: string]: number; }\n```"
    ],
    "since": "2.0.0",
    "category": "types",
    "signature": "type Mutable<T> = {\n  -readonly [P in keyof T]: T[P]\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L231"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "DeepMutable",
    "description": "Like `Types.Mutable`, but works recursively.",
    "deprecated": false,
    "examples": [
      "```ts\nimport type { Types } from \"effect\"\n\ntype DeepMutableStruct = Types.DeepMutable<{\n  readonly a: string;\n  readonly b: readonly string[]\n}>\n// { a: string; b: string[] }\n```"
    ],
    "since": "3.1.0",
    "category": "types",
    "signature": "type DeepMutable<T> = T extends ReadonlyMap<infer K, infer V> ? Map<DeepMutable<K>, DeepMutable<V>>\n  : T extends ReadonlySet<infer V> ? Set<DeepMutable<V>>\n  : T extends string | number | boolean | bigint | symbol ? T\n  : { -readonly [K in keyof T]: DeepMutable<T[K]> }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L252"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "NoInfer",
    "description": "Avoid inference on a specific parameter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type NoInfer<A> = [A][A extends any ? 0 : never]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L263"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "Invariant",
    "description": "Invariant helper.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Invariant<A> = (_: A) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L271"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "Covariant",
    "description": "Covariant helper.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Covariant<A> = (_: never) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L291"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "Contravariant",
    "description": "Contravariant helper.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type Contravariant<A> = (_: A) => void",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L311"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "MatchRecord",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type MatchRecord<S, onTrue, onFalse> = {} extends S ? onTrue : onFalse",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L328"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "NotFunction",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type NotFunction<T> = T extends Function ? never : T",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L333"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "NoExcessProperties",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": null,
    "signature": "type NoExcessProperties<T, U> = T & { readonly [K in Exclude<keyof U, keyof T>]: never }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L338"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "Invariant.Type",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "type Type<A> = A extends Invariant<infer U> ? U : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L282"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "Covariant.Type",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "type Type<A> = A extends Covariant<infer U> ? U : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L302"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types.ts",
      "path": "src/Types.ts"
    },
    "project": "effect",
    "name": "Contravariant.Type",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "type Type<A> = A extends Contravariant<infer U> ? U : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Types.ts#L322"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Unify.ts",
      "path": "src/Unify.ts"
    },
    "project": "effect",
    "name": "unify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "declare const unify: { <Args extends Array<any>, Args2 extends Array<any>, Args3 extends Array<any>, Args4 extends Array<any>, Args5 extends Array<any>, T>(x: (...args: Args) => (...args: Args2) => (...args: Args3) => (...args: Args4) => (...args: Args5) => T): (...args: Args) => (...args: Args2) => (...args: Args3) => (...args: Args4) => (...args: Args5) => Unify<T>; <Args extends Array<any>, Args2 extends Array<any>, Args3 extends Array<any>, Args4 extends Array<any>, T>(x: (...args: Args) => (...args: Args2) => (...args: Args3) => (...args: Args4) => T): (...args: Args) => (...args: Args2) => (...args: Args3) => (...args: Args4) => Unify<T>; <Args extends Array<any>, Args2 extends Array<any>, Args3 extends Array<any>, T>(x: (...args: Args) => (...args: Args2) => (...args: Args3) => T): (...args: Args) => (...args: Args2) => (...args: Args3) => Unify<T>; <Args extends Array<any>, Args2 extends Array<any>, T>(x: (...args: Args) => (...args: Args2) => T): (...args: Args) => (...args: Args2) => Unify<T>; <Args extends Array<any>, T>(x: (...args: Args) => T): (...args: Args) => Unify<T>; <T>(x: T): Unify<T>; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Unify.ts#L73"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Unify.ts",
      "path": "src/Unify.ts"
    },
    "project": "effect",
    "name": "unifySymbol",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type unifySymbol = typeof unifySymbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Unify.ts#L15"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Unify.ts",
      "path": "src/Unify.ts"
    },
    "project": "effect",
    "name": "typeSymbol",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type typeSymbol = typeof typeSymbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Unify.ts#L25"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Unify.ts",
      "path": "src/Unify.ts"
    },
    "project": "effect",
    "name": "ignoreSymbol",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type ignoreSymbol = typeof ignoreSymbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Unify.ts#L35"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Unify.ts",
      "path": "src/Unify.ts"
    },
    "project": "effect",
    "name": "Unify",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "type Unify<A> = Values<\n  ExtractTypes<\n    (\n      & FilterIn<A>\n      & { [typeSymbol]: A }\n    )\n  >\n> extends infer Z ? Z | Exclude<A, Z> | FilterOut<A> : never",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Unify.ts#L61"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullRequest.ts",
      "path": "src/UpstreamPullRequest.ts"
    },
    "project": "effect",
    "name": "UpstreamPullRequestTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const UpstreamPullRequestTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L11"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullRequest.ts",
      "path": "src/UpstreamPullRequest.ts"
    },
    "project": "effect",
    "name": "Pulled",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const Pulled: <A>(value: A) => UpstreamPullRequest<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L62"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullRequest.ts",
      "path": "src/UpstreamPullRequest.ts"
    },
    "project": "effect",
    "name": "NoUpstream",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const NoUpstream: (activeDownstreamCount: number) => UpstreamPullRequest<never>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L68"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullRequest.ts",
      "path": "src/UpstreamPullRequest.ts"
    },
    "project": "effect",
    "name": "isUpstreamPullRequest",
    "description": "Returns `true` if the specified value is an `UpstreamPullRequest`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isUpstreamPullRequest: (u: unknown) => u is UpstreamPullRequest<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L77"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullRequest.ts",
      "path": "src/UpstreamPullRequest.ts"
    },
    "project": "effect",
    "name": "isPulled",
    "description": "Returns `true` if the specified `UpstreamPullRequest` is a `Pulled`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isPulled: <A>(self: UpstreamPullRequest<A>) => self is Pulled<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L86"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullRequest.ts",
      "path": "src/UpstreamPullRequest.ts"
    },
    "project": "effect",
    "name": "isNoUpstream",
    "description": "Returns `true` if the specified `UpstreamPullRequest` is a `NoUpstream`,\n`false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isNoUpstream: <A>(self: UpstreamPullRequest<A>) => self is NoUpstream",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L95"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullRequest.ts",
      "path": "src/UpstreamPullRequest.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Folds an `UpstreamPullRequest<A>` into a value of type `Z`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const match: { <A, Z>(options: { readonly onPulled: (value: A) => Z; readonly onNoUpstream: (activeDownstreamCount: number) => Z; }): (self: UpstreamPullRequest<A>) => Z; <A, Z>(self: UpstreamPullRequest<A>, options: { readonly onPulled: (value: A) => Z; readonly onNoUpstream: (activeDownstreamCount: number) => Z; }): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L103"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "UpstreamPullRequest.ts",
      "path": "src/UpstreamPullRequest.ts"
    },
    "project": "effect",
    "name": "Pulled",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Pulled<out A> extends UpstreamPullRequest.Variance<A> {\n  readonly _tag: \"Pulled\"\n  readonly value: A\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L44"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "UpstreamPullRequest.ts",
      "path": "src/UpstreamPullRequest.ts"
    },
    "project": "effect",
    "name": "NoUpstream",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface NoUpstream extends UpstreamPullRequest.Variance<never> {\n  readonly _tag: \"NoUpstream\"\n  readonly activeDownstreamCount: number\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L53"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "UpstreamPullRequest.ts",
      "path": "src/UpstreamPullRequest.ts"
    },
    "project": "effect",
    "name": "UpstreamPullRequestTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type UpstreamPullRequestTypeId = typeof UpstreamPullRequestTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L17"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "UpstreamPullRequest.ts",
      "path": "src/UpstreamPullRequest.ts"
    },
    "project": "effect",
    "name": "UpstreamPullRequest",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type UpstreamPullRequest<A> = Pulled<A> | NoUpstream",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L23"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "UpstreamPullRequest.ts",
      "path": "src/UpstreamPullRequest.ts"
    },
    "project": "effect",
    "name": "UpstreamPullRequest.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out A> {\n    readonly [UpstreamPullRequestTypeId]: {\n      readonly _A: Types.Covariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullRequest.ts#L33"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullStrategy.ts",
      "path": "src/UpstreamPullStrategy.ts"
    },
    "project": "effect",
    "name": "UpstreamPullStrategyTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const UpstreamPullStrategyTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L12"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullStrategy.ts",
      "path": "src/UpstreamPullStrategy.ts"
    },
    "project": "effect",
    "name": "PullAfterNext",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const PullAfterNext: <A>(emitSeparator: Option.Option<A>) => UpstreamPullStrategy<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L63"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullStrategy.ts",
      "path": "src/UpstreamPullStrategy.ts"
    },
    "project": "effect",
    "name": "PullAfterAllEnqueued",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const PullAfterAllEnqueued: <A>(emitSeparator: Option.Option<A>) => UpstreamPullStrategy<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L69"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullStrategy.ts",
      "path": "src/UpstreamPullStrategy.ts"
    },
    "project": "effect",
    "name": "isUpstreamPullStrategy",
    "description": "Returns `true` if the specified value is an `UpstreamPullStrategy`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isUpstreamPullStrategy: (u: unknown) => u is UpstreamPullStrategy<unknown>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L79"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullStrategy.ts",
      "path": "src/UpstreamPullStrategy.ts"
    },
    "project": "effect",
    "name": "isPullAfterNext",
    "description": "Returns `true` if the specified `UpstreamPullStrategy` is a `PullAfterNext`,\n`false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isPullAfterNext: <A>(self: UpstreamPullStrategy<A>) => self is PullAfterNext<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L89"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullStrategy.ts",
      "path": "src/UpstreamPullStrategy.ts"
    },
    "project": "effect",
    "name": "isPullAfterAllEnqueued",
    "description": "Returns `true` if the specified `UpstreamPullStrategy` is a\n`PullAfterAllEnqueued`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "declare const isPullAfterAllEnqueued: <A>(self: UpstreamPullStrategy<A>) => self is PullAfterAllEnqueued<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L98"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullStrategy.ts",
      "path": "src/UpstreamPullStrategy.ts"
    },
    "project": "effect",
    "name": "match",
    "description": "Folds an `UpstreamPullStrategy<A>` into a value of type `Z`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "declare const match: { <A, Z>(options: { readonly onNext: (emitSeparator: Option.Option<A>) => Z; readonly onAllEnqueued: (emitSeparator: Option.Option<A>) => Z; }): (self: UpstreamPullStrategy<A>) => Z; <A, Z>(self: UpstreamPullStrategy<A>, options: { readonly onNext: (emitSeparator: Option.Option<A>) => Z; readonly onAllEnqueued: (emitSeparator: Option.Option<A>) => Z; }): Z; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L107"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "UpstreamPullStrategy.ts",
      "path": "src/UpstreamPullStrategy.ts"
    },
    "project": "effect",
    "name": "PullAfterNext",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface PullAfterNext<out A> extends UpstreamPullStrategy.Variance<A> {\n  readonly _tag: \"PullAfterNext\"\n  readonly emitSeparator: Option.Option<A>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L45"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "UpstreamPullStrategy.ts",
      "path": "src/UpstreamPullStrategy.ts"
    },
    "project": "effect",
    "name": "PullAfterAllEnqueued",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface PullAfterAllEnqueued<out A> extends UpstreamPullStrategy.Variance<A> {\n  readonly _tag: \"PullAfterAllEnqueued\"\n  readonly emitSeparator: Option.Option<A>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L54"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "UpstreamPullStrategy.ts",
      "path": "src/UpstreamPullStrategy.ts"
    },
    "project": "effect",
    "name": "UpstreamPullStrategyTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type UpstreamPullStrategyTypeId = typeof UpstreamPullStrategyTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L18"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "UpstreamPullStrategy.ts",
      "path": "src/UpstreamPullStrategy.ts"
    },
    "project": "effect",
    "name": "UpstreamPullStrategy",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "type UpstreamPullStrategy<A> = PullAfterNext<A> | PullAfterAllEnqueued<A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L24"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "UpstreamPullStrategy.ts",
      "path": "src/UpstreamPullStrategy.ts"
    },
    "project": "effect",
    "name": "UpstreamPullStrategy.Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<out A> {\n    readonly [UpstreamPullStrategyTypeId]: {\n      readonly _A: Types.Covariant<A>\n    }\n  }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/UpstreamPullStrategy.ts#L34"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "GenKindImpl",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare class GenKindImpl<F, R, O, E, A> { constructor(\n    /**\n     * @since 2.0.0\n     */\n    readonly value: Kind<F, R, O, E, A>\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L56"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "SingleShotGen",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare class SingleShotGen<T, A> { constructor(readonly self: T) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L109"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "PCGRandom",
    "description": "PCG is a family of simple fast space-efficient statistically good algorithms\nfor random number generation. Unlike many general-purpose RNGs, they are also\nhard to predict.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "declare class PCGRandom { constructor(\n    seedHi?: OptionalNumber,\n    seedLo?: OptionalNumber,\n    incHi?: OptionalNumber,\n    incLo?: OptionalNumber\n  ) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L516"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "YieldWrap",
    "deprecated": false,
    "examples": [],
    "since": "3.0.6",
    "category": null,
    "signature": "declare class YieldWrap<T> { constructor(value: T) }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L714"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "GenKindTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "declare const GenKindTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L28"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "YieldWrapTypeId",
    "deprecated": false,
    "examples": [],
    "since": "3.0.6",
    "category": null,
    "signature": "declare const YieldWrapTypeId: unique symbol",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L709"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "structuralRegionState",
    "description": "Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code",
    "deprecated": false,
    "examples": [],
    "since": "3.1.1",
    "category": "modifiers",
    "signature": "declare const structuralRegionState: { enabled: boolean; tester: ((a: unknown, b: unknown) => boolean) | undefined; }",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L747"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "internalCall",
    "deprecated": false,
    "examples": [],
    "since": "3.2.2",
    "category": "tracing",
    "signature": "declare const internalCall: <A>(fn: () => A) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L793"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "yieldWrapGet",
    "deprecated": false,
    "examples": [],
    "since": "3.0.6",
    "category": null,
    "signature": "declare const yieldWrapGet: <T>(self: YieldWrap<T>) => T",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L733"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "isGenKind",
    "deprecated": false,
    "examples": [],
    "since": "3.0.6",
    "category": "predicates",
    "signature": "declare const isGenKind: (u: unknown) => u is GenKind<any, any, any, any, any>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L50"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "makeGenKind",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "declare const makeGenKind: <F extends TypeLambda, R, O, E, A>(kind: Kind<F, R, O, E, A>) => GenKind<F, R, O, E, A>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L159"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "adapter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "adapters",
    "signature": "declare const adapter: <F extends TypeLambda>() => Adapter<F>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L481"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "structuralRegion",
    "description": "Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code",
    "deprecated": false,
    "examples": [],
    "since": "3.1.1",
    "category": "modifiers",
    "signature": "declare const structuralRegion: <A>(body: () => A, tester?: (a: unknown, b: unknown) => boolean) => A",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L762"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "isGeneratorFunction",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": null,
    "signature": "declare const isGeneratorFunction: (u: unknown) => u is (...args: Array<any>) => Generator<any, any, any>",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L800"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "GenKind",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface GenKind<F extends TypeLambda, R, O, E, A> extends Variance<F, R, O, E> {\n  readonly value: Kind<F, R, O, E, A>\n\n  [Symbol.iterator](): IterableIterator<GenKind<F, R, O, E, A>, A>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L40"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "Variance",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out F extends TypeLambda, in R, out O, out E> {\n  readonly [GenKindTypeId]: GenKindTypeId\n  readonly _F: Types.Invariant<F>\n  readonly _R: Types.Contravariant<R>\n  readonly _O: Types.Covariant<O>\n  readonly _E: Types.Covariant<E>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L167"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "Gen",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Gen<F extends TypeLambda, Z> {\n  <Self, K extends Variance<F, any, any, any> | YieldWrap<Kind<F, any, any, any, any>>, A>(\n    ...args:\n      | [\n        self: Self,\n        body: (this: Self, resume: Z) => Generator<K, A, never>\n      ]\n      | [\n        body: (resume: Z) => Generator<K, A, never>\n      ]\n  ): Kind<\n    F,\n    [K] extends [Variance<F, infer R, any, any>] ? R\n      : [K] extends [YieldWrap<Kind<F, infer R, any, any, any>>] ? R\n      : never,\n    [K] extends [Variance<F, any, infer O, any>] ? O\n      : [K] extends [YieldWrap<Kind<F, any, infer O, any, any>>] ? O\n      : never,\n    [K] extends [Variance<F, any, any, infer E>] ? E\n      : [K] extends [YieldWrap<Kind<F, any, any, infer E, any>>] ? E\n      : never,\n    A\n  >\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L179"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "Adapter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Adapter<Z extends TypeLambda> {\n  <_R, _O, _E, _A>(\n    self: Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, _R, _O, _E, _A>(a: A, ab: (a: A) => Kind<Z, _R, _O, _E, _A>): GenKind<Z, _R, _O, _E, _A>\n  <A, B, _R, _O, _E, _A>(a: A, ab: (a: A) => B, bc: (b: B) => Kind<Z, _R, _O, _E, _A>): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: F) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (g: H) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => T,\n    tu: (s: T) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n}",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L208"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "GenKindTypeId",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "type GenKindTypeId = typeof GenKindTypeId",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L34"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "PCGRandomState",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "type PCGRandomState = [number, number, number, number]",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L500"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Utils.ts",
      "path": "src/Utils.ts"
    },
    "project": "effect",
    "name": "OptionalNumber",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "type OptionalNumber = number | null | undefined",
    "sourceUrl": "https://github.com/Effect-TS/effect/tree/main/packages/effect/src/Utils.ts#L506"
  }
]