[
  {
    "_tag": "Function",
    "module": {
      "name": "Arbitrary",
      "path": [
        "src",
        "Arbitrary.ts"
      ]
    },
    "project": "effect",
    "name": "makeLazy",
    "description": "Returns a LazyArbitrary for the `A` type of the provided schema.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "arbitrary",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Arbitrary",
      "path": [
        "src",
        "Arbitrary.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Returns a fast-check Arbitrary for the `A` type of the provided schema.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "arbitrary",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Arbitrary",
      "path": [
        "src",
        "Arbitrary.ts"
      ]
    },
    "project": "effect",
    "name": "ArbitraryGenerationContext",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export interface ArbitraryGenerationContext {\n  readonly maxDepth: number\n  readonly depthIdentifier?: string\n  readonly constraints?: StringConstraints | NumberConstraints | BigIntConstraints | DateConstraints | ArrayConstraints\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Arbitrary",
      "path": [
        "src",
        "Arbitrary.ts"
      ]
    },
    "project": "effect",
    "name": "LazyArbitrary",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface LazyArbitrary<A> {\n  (fc: typeof FastCheck): FastCheck.Arbitrary<A>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Arbitrary",
      "path": [
        "src",
        "Arbitrary.ts"
      ]
    },
    "project": "effect",
    "name": "ArbitraryAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type ArbitraryAnnotation<A, TypeParameters extends ReadonlyArray<any> = readonly []> = (\n  ...arbitraries: [\n    ...{ readonly [K in keyof TypeParameters]: LazyArbitrary<TypeParameters[K]> },\n    ctx: ArbitraryGenerationContext\n  ]\n) => LazyArbitrary<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "makeBy",
    "description": "Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n\n**Note**. `n` is normalized to an integer >= 1.",
    "deprecated": false,
    "examples": [
      "import { makeBy } from \"effect/Array\"\n\nassert.deepStrictEqual(makeBy(5, n => n * 2), [0, 2, 4, 6, 8])"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeBy: { <A>(f: (i: number) => A): (n: number) => NonEmptyArray<A>; <A>(n: number, f: (i: number) => A): NonEmptyArray<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "replicate",
    "description": "Return a `NonEmptyArray` containing a value repeated the specified number of times.\n\n**Note**. `n` is normalized to an integer >= 1.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nassert.deepStrictEqual(Array.replicate(\"a\", 3), [\"a\", \"a\", \"a\"])"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const replicate: { (n: number): <A>(a: A) => NonEmptyArray<A>; <A>(a: A, n: number): NonEmptyArray<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "fromRecord",
    "description": "Takes a record and returns an array of tuples containing its keys and values.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst x = { a: 1, b: 2, c: 3 }\nassert.deepStrictEqual(Array.fromRecord(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "export declare const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Array<[K, A]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "fromOption",
    "description": "Converts an `Option` to an array.",
    "deprecated": false,
    "examples": [
      "import { Array, Option } from \"effect\"\n\nassert.deepStrictEqual(Array.fromOption(Option.some(1)), [1])\nassert.deepStrictEqual(Array.fromOption(Option.none()), [])"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "export declare const fromOption: <A>(self: Option<A>) => Array<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Matches the elements of an array, applying functions to cases of empty and non-empty arrays.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst match = Array.match({\n  onEmpty: () => \"empty\",\n  onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`\n})\nassert.deepStrictEqual(match([]), \"empty\")\nassert.deepStrictEqual(match([1, 2, 3]), \"head: 1, tail: 2\")"
    ],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "export declare const match: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C; }): B | C; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "matchLeft",
    "description": "Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst matchLeft = Array.matchLeft({\n  onEmpty: () => \"empty\",\n  onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`\n})\nassert.deepStrictEqual(matchLeft([]), \"empty\")\nassert.deepStrictEqual(matchLeft([1, 2, 3]), \"head: 1, tail: 2\")"
    ],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "export declare const matchLeft: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (head: A, tail: Array<A>) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (head: A, tail: Array<A>) => C; }): B | C; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "matchRight",
    "description": "Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst matchRight = Array.matchRight({\n  onEmpty: () => \"empty\",\n  onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`\n})\nassert.deepStrictEqual(matchRight([]), \"empty\")\nassert.deepStrictEqual(matchRight([1, 2, 3]), \"init: 2, last: 3\")"
    ],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "export declare const matchRight: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (init: Array<A>, last: A) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (init: Array<A>, last: A) => C; }): B | C; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "prepend",
    "description": "Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst original = [2, 3, 4];\nconst result = Array.prepend(original, 1);\nassert.deepStrictEqual(result, [1, 2, 3, 4]);"
    ],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const prepend: { <B>(head: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, head: B): NonEmptyArray<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "prependAll",
    "description": "Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\nIf either array is non-empty, the result is also a non-empty array.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst prefix = [0, 1];\nconst array = [2, 3];\nconst result = Array.prependAll(array, prefix);\nassert.deepStrictEqual(result, [0, 1, 2, 3]);"
    ],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const prependAll: { <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "append",
    "description": "Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst original = [1, 2, 3];\nconst result = Array.append(original, 4);\nassert.deepStrictEqual(result, [1, 2, 3, 4]);"
    ],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const append: { <B>(last: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, last: B): NonEmptyArray<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "appendAll",
    "description": "Concatenates two arrays (or iterables), combining their elements.\nIf either array is non-empty, the result is also a non-empty array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const appendAll: { <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "scan",
    "description": "Accumulates values from an `Iterable` starting from the left, storing\neach intermediate result in an array. Useful for tracking the progression of\na value through a series of transformations.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\";\n\nconst numbers = [1, 2, 3, 4]\nconst result = Array.scan(numbers, 0, (acc, value) => acc + value)\nassert.deepStrictEqual(result, [0, 1, 3, 6, 10])\n\n// Explanation:\n// This function starts with the initial value (0 in this case)\n// and adds each element of the array to this accumulator one by one,\n// keeping track of the cumulative sum after each addition.\n// Each of these sums is captured in the resulting array."
    ],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const scan: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "scanRight",
    "description": "Accumulates values from an `Iterable` starting from the right, storing\neach intermediate result in an array. Useful for tracking the progression of\na value through a series of transformations.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\";\n\nconst numbers = [1, 2, 3, 4]\nconst result = Array.scanRight(numbers, 0, (acc, value) => acc + value)\nassert.deepStrictEqual(result, [10, 9, 7, 4, 0])"
    ],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const scanRight: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "isArray",
    "description": "Determine if `unknown` is an Array.",
    "deprecated": false,
    "examples": [
      "import { isArray } from \"effect/Array\"\n\nassert.deepStrictEqual(isArray(null), false);\nassert.deepStrictEqual(isArray([1, 2, 3]), true);"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isArray: { (self: unknown): self is Array<unknown>; <T>(self: T): self is Extract<T, ReadonlyArray<any>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "isEmptyReadonlyArray",
    "description": "Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.",
    "deprecated": false,
    "examples": [
      "import { isEmptyReadonlyArray } from \"effect/Array\"\n\nassert.deepStrictEqual(isEmptyReadonlyArray([]), true);\nassert.deepStrictEqual(isEmptyReadonlyArray([1, 2, 3]), false);"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is readonly []"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "isNonEmptyArray",
    "description": "Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.\n\nAn `Array` is considered to be a `NonEmptyArray` if it contains at least one element.",
    "deprecated": false,
    "examples": [
      "import { isNonEmptyArray } from \"effect/Array\"\n\nassert.deepStrictEqual(isNonEmptyArray([]), false);\nassert.deepStrictEqual(isNonEmptyArray([1, 2, 3]), true);"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isNonEmptyArray: <A>(self: Array<A>) => self is NonEmptyArray<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "isNonEmptyReadonlyArray",
    "description": "Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.\n\nA `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.",
    "deprecated": false,
    "examples": [
      "import { isNonEmptyReadonlyArray } from \"effect/Array\"\n\nassert.deepStrictEqual(isNonEmptyReadonlyArray([]), false);\nassert.deepStrictEqual(isNonEmptyReadonlyArray([1, 2, 3]), true);"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isNonEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const get: { (index: number): <A>(self: ReadonlyArray<A>) => Option<A>; <A>(self: ReadonlyArray<A>, index: number): Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeGet",
    "description": "Gets an element unsafely, will throw on out of bounds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeGet: { (index: number): <A>(self: ReadonlyArray<A>) => A; <A>(self: ReadonlyArray<A>, index: number): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "head",
    "description": "Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const head: <A>(self: ReadonlyArray<A>) => Option<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "headNonEmpty",
    "description": "Get the first element of a non empty array.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst result = Array.headNonEmpty([1, 2, 3, 4])\nassert.deepStrictEqual(result, 1)"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const headNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => A"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "take",
    "description": "Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n\n**Note**. `n` is normalized to a non negative integer.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst result = Array.take(numbers, 3)\nassert.deepStrictEqual(result, [1, 2, 3])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const take: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "takeRight",
    "description": "Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n\n**Note**. `n` is normalized to a non negative integer.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst result = Array.takeRight(numbers, 3)\nassert.deepStrictEqual(result, [3, 4, 5])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const takeRight: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "takeWhile",
    "description": "Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 3, 2, 4, 1, 2]\nconst result = Array.takeWhile(numbers, x => x < 4)\nassert.deepStrictEqual(result, [1, 3, 2])\n\n// Explanation:\n// - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n// - The next element (`3`) is also less than `4`, so it adds `3`.\n// - The next element (`2`) is again less than `4`, so it adds `2`.\n// - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result."
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const takeWhile: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Array<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Array<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "span",
    "description": "Split an `Iterable` into two parts:\n\n1. the longest initial subarray for which all elements satisfy the specified predicate\n2. the remaining elements",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "export declare const span: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => [init: Array<B>, rest: Array<Exclude<A, B>>]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [init: Array<A>, rest: Array<A>]; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [init: Array<B>, rest: Array<Exclude<A, B>>]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [init: Array<A>, rest: Array<A>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "drop",
    "description": "Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n\n**Note**. `n` is normalized to a non negative integer.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst result = Array.drop(numbers, 2)\nassert.deepStrictEqual(result, [3, 4, 5])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const drop: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "dropRight",
    "description": "Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n\n**Note**. `n` is normalized to a non negative integer.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst result = Array.dropRight(numbers, 2)\nassert.deepStrictEqual(result, [1, 2, 3])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const dropRight: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "dropWhile",
    "description": "Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst result = Array.dropWhile(numbers, x => x < 4)\nassert.deepStrictEqual(result, [4, 5])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const dropWhile: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "findFirstIndex",
    "description": "Return the first index for which a predicate holds.",
    "deprecated": false,
    "examples": [
      "import { Array, Option } from \"effect\"\n\nconst numbers = [5, 3, 8, 9]\nconst result = Array.findFirstIndex(numbers, x => x > 5)\nassert.deepStrictEqual(result, Option.some(2))"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirstIndex: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<number>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<number>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "findLastIndex",
    "description": "Return the last index for which a predicate holds.",
    "deprecated": false,
    "examples": [
      "import { Array, Option } from \"effect\"\n\nconst numbers = [1, 3, 8, 9]\nconst result = Array.findLastIndex(numbers, x => x < 5)\nassert.deepStrictEqual(result, Option.some(1))"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findLastIndex: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<number>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<number>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
    "deprecated": false,
    "examples": [
      "import { Array, Option } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst result = Array.findFirst(numbers, x => x > 3)\nassert.deepStrictEqual(result, Option.some(4))"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirst: { <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "findLast",
    "description": "Finds the last element in an iterable collection that satisfies the given predicate or refinement.\nReturns an `Option` containing the found element, or `Option.none` if no element matches.",
    "deprecated": false,
    "examples": [
      "import { Array, Option } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst result = Array.findLast(numbers, n => n % 2 === 0)\nassert.deepStrictEqual(result, Option.some(4))"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findLast: { <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "insertAt",
    "description": "Insert an element at the specified index, creating a new `NonEmptyArray`,\nor return `None` if the index is out of bounds.",
    "deprecated": false,
    "examples": [
      "import { Array, Option } from \"effect\"\n\nconst letters = ['a', 'b', 'c', 'e']\nconst result = Array.insertAt(letters, 3, 'd')\nassert.deepStrictEqual(result, Option.some(['a', 'b', 'c', 'd', 'e']))"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const insertAt: { <B>(i: number, b: B): <A>(self: Iterable<A>) => Option<NonEmptyArray<A | B>>; <A, B>(self: Iterable<A>, i: number, b: B): Option<NonEmptyArray<A | B>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "replace",
    "description": "Change the element at the specified index, creating a new `Array`,\nor return a copy of the input if the index is out of bounds.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst letters = ['a', 'b', 'c', 'd']\nconst result = Array.replace(letters, 1, 'z')\nassert.deepStrictEqual(result, ['a', 'z', 'c', 'd'])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const replace: { <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "replaceOption",
    "description": "Replaces an element in an array with the given value, returning an option of the updated array.",
    "deprecated": false,
    "examples": [
      "import { Array, Option } from \"effect\"\n\nconst numbers = [1, 2, 3]\nconst result = Array.replaceOption(numbers, 1, 4)\nassert.deepStrictEqual(result, Option.some([1, 4, 3]))"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const replaceOption: { <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(self: S) => Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "modify",
    "description": "Apply a function to the element at the specified index, creating a new `Array`,\nor return a copy of the input if the index is out of bounds.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4]\nconst result = Array.modify(numbers, 2, (n) => n * 2)\nassert.deepStrictEqual(result, [1, 2, 6, 4])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const modify: { <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "modifyOption",
    "description": "Apply a function to the element at the specified index, creating a new `Array`,\nor return `None` if the index is out of bounds.",
    "deprecated": false,
    "examples": [
      "import { Array, Option } from \"effect\"\n\nconst numbers = [1, 2, 3, 4]\nconst result = Array.modifyOption(numbers, 2, (n) => n * 2)\nassert.deepStrictEqual(result, Option.some([1, 2, 6, 4]))\n\nconst outOfBoundsResult = Array.modifyOption(numbers, 5, (n) => n * 2)\nassert.deepStrictEqual(outOfBoundsResult, Option.none())"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const modifyOption: { <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "remove",
    "description": "Delete the element at the specified index, creating a new `Array`,\nor return a copy of the input if the index is out of bounds.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4]\nconst result = Array.remove(numbers, 2)\nassert.deepStrictEqual(result, [1, 2, 4])\n\nconst outOfBoundsResult = Array.remove(numbers, 5)\nassert.deepStrictEqual(outOfBoundsResult, [1, 2, 3, 4])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const remove: { (i: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, i: number): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "sort",
    "description": "Create a new array with elements sorted in increasing order based on the specified comparator.\nIf the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sorting",
    "signature": "export declare const sort: { <B>(O: Order.Order<B>): <A extends B, S extends Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A extends B, B>(self: NonEmptyReadonlyArray<A>, O: Order.Order<B>): NonEmptyArray<A>; <A extends B, B>(self: Iterable<A>, O: Order.Order<B>): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "sortWith",
    "description": "Sorts an array based on a provided mapping function and order. The mapping\nfunction transforms the elements into a value that can be compared, and the\norder defines how those values should be sorted.",
    "deprecated": false,
    "examples": [
      "import { Array, Order } from \"effect\"\n\nconst strings = [\"aaa\", \"b\", \"cc\"]\nconst result = Array.sortWith(strings, (s) => s.length, Order.number)\nassert.deepStrictEqual(result, [\"b\", \"cc\", \"aaa\"])\n\n// Explanation:\n// The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n// converts each string into its length, and the `Order.number` specifies that the lengths should\n// be sorted in ascending order."
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const sortWith: { <S extends Iterable<any>, B>(f: (a: ReadonlyArray.Infer<S>) => B, order: Order.Order<B>): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B, O: Order.Order<B>): NonEmptyArray<A>; <A, B>(self: Iterable<A>, f: (a: A) => B, order: Order.Order<B>): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Takes two `Iterable`s and returns an `Array` of corresponding pairs.\nIf one input `Iterable` is short, excess elements of the\nlonger `Iterable` are discarded.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst array1 = [1, 2, 3]\nconst array2 = ['a', 'b']\nconst result = Array.zip(array1, array2)\nassert.deepStrictEqual(result, [[1, 'a'], [2, 'b']])"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zip: { <B>(that: NonEmptyReadonlyArray<B>): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<[A, B]>; <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<[A, B]>; <A, B>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<[A, B]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\ninput `Iterable` is short, excess elements of the longer `Iterable` are discarded.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst array1 = [1, 2, 3]\nconst array2 = [4, 5, 6]\nconst result = Array.zipWith(array1, array2, (a, b) => a + b)\nassert.deepStrictEqual(result, [5, 7, 9])"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWith: { <B, A, C>(that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<C>; <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Array<C>; <A, B, C>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): NonEmptyArray<C>; <B, A, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Array<C>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "unzip",
    "description": "This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst result = Array.unzip([[1, \"a\"], [2, \"b\"], [3, \"c\"]])\nassert.deepStrictEqual(result, [[1, 2, 3], ['a', 'b', 'c']])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const unzip: <S extends Iterable<readonly [any, any]>>(self: S) => S extends NonEmptyReadonlyArray<readonly [infer A, infer B]> ? [NonEmptyArray<A>, NonEmptyArray<B>] : S extends Iterable<readonly [infer A, infer B]> ? [Array<A>, Array<B>] : never"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "intersperse",
    "description": "Places an element in between members of an `Iterable`.\nIf the input is a non-empty array, the result is also a non-empty array.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3]\nconst result = Array.intersperse(numbers, 0)\nassert.deepStrictEqual(result, [1, 0, 2, 0, 3])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const intersperse: { <B>(middle: B): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B>(self: NonEmptyReadonlyArray<A>, middle: B): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, middle: B): Array<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "modifyNonEmptyHead",
    "description": "Apply a function to the head, creating a new `NonEmptyReadonlyArray`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)\nassert.deepStrictEqual(result, [10, 2, 3])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const modifyNonEmptyHead: { <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "setNonEmptyHead",
    "description": "Change the head, creating a new `NonEmptyReadonlyArray`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst result = Array.setNonEmptyHead([1, 2, 3], 10)\nassert.deepStrictEqual(result, [10, 2, 3])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const setNonEmptyHead: { <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "modifyNonEmptyLast",
    "description": "Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)\nassert.deepStrictEqual(result, [1, 2, 6])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const modifyNonEmptyLast: { <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "setNonEmptyLast",
    "description": "Change the last element, creating a new `NonEmptyReadonlyArray`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst result = Array.setNonEmptyLast([1, 2, 3], 4)\nassert.deepStrictEqual(result, [1, 2, 4])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const setNonEmptyLast: { <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "rotate",
    "description": "Rotate an `Iterable` by `n` steps.\nIf the input is a non-empty array, the result is also a non-empty array.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst letters = ['a', 'b', 'c', 'd']\nconst result = Array.rotate(letters, 2)\nassert.deepStrictEqual(result, ['c', 'd', 'a', 'b'])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const rotate: { (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<A>; <A>(self: Iterable<A>, n: number): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "contains",
    "description": "Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst letters = ['a', 'b', 'c', 'd']\nconst result = Array.contains('c')(letters)\nassert.deepStrictEqual(result, true)"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const contains: { <A>(a: A): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, a: A): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "chop",
    "description": "A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n`Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\nvalue and the rest of the `Array`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst result = Array.chop(numbers, (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\nassert.deepStrictEqual(result, [2, 4, 6, 8, 10])\n\n// Explanation:\n// The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n// The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n// resulting in a new array `[2, 4, 6, 8, 10]`."
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const chop: { <S extends Iterable<any>, B>(f: (as: NonEmptyReadonlyArray<ReadonlyArray.Infer<S>>) => readonly [B, ReadonlyArray<ReadonlyArray.Infer<S>>]): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]): NonEmptyArray<B>; <A, B>(self: Iterable<A>, f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]): Array<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "splitAt",
    "description": "Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.\nThe value of `n` can be `0`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst result = Array.splitAt(numbers, 3)\nassert.deepStrictEqual(result, [[1, 2, 3], [4, 5]])"
    ],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "export declare const splitAt: { (n: number): <A>(self: Iterable<A>) => [beforeIndex: Array<A>, fromIndex: Array<A>]; <A>(self: Iterable<A>, n: number): [beforeIndex: Array<A>, fromIndex: Array<A>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "splitNonEmptyAt",
    "description": "Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.\nThe value of `n` must be `>= 1`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst result = Array.splitNonEmptyAt([\"a\", \"b\", \"c\", \"d\", \"e\"], 3)\nassert.deepStrictEqual(result, [[\"a\", \"b\", \"c\"], [\"d\", \"e\"]])"
    ],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "export declare const splitNonEmptyAt: { (n: number): <A>(self: NonEmptyReadonlyArray<A>) => [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]; <A>(self: NonEmptyReadonlyArray<A>, n: number): [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "split",
    "description": "Splits this iterable into `n` equally sized arrays.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8]\nconst result = Array.split(numbers, 3)\nassert.deepStrictEqual(result, [[1, 2, 3], [4, 5, 6], [7, 8]])"
    ],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "export declare const split: { (n: number): <A>(self: Iterable<A>) => Array<Array<A>>; <A>(self: Iterable<A>, n: number): Array<Array<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "splitWhere",
    "description": "Splits this iterable on the first element that matches this predicate.\nReturns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst result = Array.splitWhere(numbers, n => n > 3)\nassert.deepStrictEqual(result, [[1, 2, 3], [4, 5]])"
    ],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "export declare const splitWhere: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [beforeMatch: Array<A>, fromMatch: Array<A>]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [beforeMatch: Array<A>, fromMatch: Array<A>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "copy",
    "description": "Copies an array.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3]\nconst copy = Array.copy(numbers)\nassert.deepStrictEqual(copy, [1, 2, 3])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const copy: { <A>(self: NonEmptyReadonlyArray<A>): NonEmptyArray<A>; <A>(self: ReadonlyArray<A>): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "pad",
    "description": "Pads an array.\nReturns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.\nIf `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.\nIf `n` is less than or equal to 0, the returned array will be an empty array.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst arr = [1, 2, 3]\nconst result = Array.pad(arr, 6, 0)\nassert.deepStrictEqual(result, [1, 2, 3, 0, 0, 0])"
    ],
    "since": "3.8.4",
    "category": null,
    "signature": "export declare const pad: { <A, T>(n: number, fill: T): (self: Array<A>) => Array<A | T>; <A, T>(self: Array<A>, n: number, fill: T): Array<A | T>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "chunksOf",
    "description": "Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\nthe `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\ndefinition of `chunksOf`; it satisfies the property that\n\n```ts\nchunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n```\n\nwhenever `n` evenly divides the length of `self`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst result = Array.chunksOf(numbers, 2)\nassert.deepStrictEqual(result, [[1, 2], [3, 4], [5]])\n\n// Explanation:\n// The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n// It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n// the last chunk contains the remaining elements.\n// The result is `[[1, 2], [3, 4], [5]]`."
    ],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "export declare const chunksOf: { (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, NonEmptyArray<ReadonlyArray.Infer<S>>>; <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<NonEmptyArray<A>>; <A>(self: Iterable<A>, n: number): Array<NonEmptyArray<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "groupWith",
    "description": "Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst result = Array.groupWith([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"a\"], (x, y) => x === y)\nassert.deepStrictEqual(result, [[\"a\", \"a\"], [\"b\", \"b\", \"b\"], [\"c\"], [\"a\"]])"
    ],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "export declare const groupWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>; <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<NonEmptyArray<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "group",
    "description": "Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst result = Array.group([1, 1, 2, 2, 2, 3, 1])\nassert.deepStrictEqual(result, [[1, 1], [2, 2, 2], [3], [1]])"
    ],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "export declare const group: <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "groupBy",
    "description": "Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\nfunction on each element, and grouping the results according to values returned",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst people = [\n  { name: \"Alice\", group: \"A\" },\n  { name: \"Bob\", group: \"B\" },\n  { name: \"Charlie\", group: \"A\" }\n]\nconst result = Array.groupBy(people, person => person.group)\nassert.deepStrictEqual(result, {\n  A: [{ name: \"Alice\", group: \"A\" }, { name: \"Charlie\", group: \"A\" }],\n  B: [{ name: \"Bob\", group: \"B\" }]\n})"
    ],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "export declare const groupBy: { <A, K extends string | symbol>(f: (a: A) => K): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; <A, K extends string | symbol>(self: Iterable<A>, f: (a: A) => K): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "unionWith",
    "description": "Calculates the union of two arrays using the provided equivalence relation.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst array1 = [1, 2]\nconst array2 = [2, 3]\nconst union = Array.unionWith(array1, array2, (a, b) => a === b)\nassert.deepStrictEqual(union, [1, 2, 3])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const unionWith: { <S extends Iterable<any>, T extends Iterable<any>>(that: T, isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<T>) => boolean): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>, isEquivalent: (self: A, that: B) => boolean): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>, isEquivalent: (self: A, that: B) => boolean): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>, isEquivalent: (self: A, that: B) => boolean): Array<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "union",
    "description": "Creates a union of two arrays, removing duplicates.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst array1 = [1, 2]\nconst array2 = [2, 3]\nconst result = Array.union(array1, array2)\nassert.deepStrictEqual(result, [1, 2, 3])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const union: { <T extends Iterable<any>>(that: T): <S extends Iterable<any>>(self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, that: ReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: ReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "intersection",
    "description": "Creates an `Array` of unique values that are included in all given `Iterable`s.\nThe order and references of result values are determined by the first `Iterable`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst array1 = [1, 2, 3]\nconst array2 = [3, 4, 1]\nconst result = Array.intersection(array1, array2)\nassert.deepStrictEqual(result, [1, 3])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const intersection: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<A & B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A & B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "difference",
    "description": "Creates a `Array` of values not included in the other given `Iterable`.\nThe order and references of result values are determined by the first `Iterable`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst array1 = [1, 2, 3]\nconst array2 = [2, 3, 4]\nconst difference = Array.difference(array1, array2)\nassert.deepStrictEqual(difference, [1])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const difference: { <A>(that: Iterable<A>): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, that: Iterable<A>): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <S extends ReadonlyArray<any>, B>(f: (a: ReadonlyArray.Infer<S>, i: number) => B): (self: S) => ReadonlyArray.With<S, B>; <S extends ReadonlyArray<any>, B>(self: S, f: (a: ReadonlyArray.Infer<S>, i: number) => B): ReadonlyArray.With<S, B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMap: { <S extends ReadonlyArray<any>, T extends ReadonlyArray<any>>(f: (a: ReadonlyArray.Infer<S>, i: number) => T): (self: S) => ReadonlyArray.AndNonEmpty<S, T, ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A, i: number) => NonEmptyReadonlyArray<B>): NonEmptyArray<B>; <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => ReadonlyArray<B>): Array<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "flatten",
    "description": "Combines multiple arrays into a single array by concatenating all elements\nfrom each nested array. This function ensures that the structure of nested\narrays is collapsed into a single, flat array.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\";\n\nconst nestedArrays = [[1, 2], [], [3, 4], [], [5, 6]]\nconst result = Array.flatten(nestedArrays)\n\nassert.deepStrictEqual(result, [1, 2, 3, 4, 5, 6]);"
    ],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatten: <S extends ReadonlyArray<ReadonlyArray<any>>>(self: S) => ReadonlyArray.Flatten<S>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.\nThis method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.",
    "deprecated": false,
    "examples": [
      "import { Array, Option } from \"effect\";\n\nconst data = [1, 2, 3, 4, 5];\nconst evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none();\nconst result = Array.filterMap(data, evenSquares);\n\nassert.deepStrictEqual(result, [4, 16]);"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterMap: { <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Array<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Array<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "filterMapWhile",
    "description": "Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.\nThis method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.\nThis is useful when you need to transform an array but only up to the point where a certain condition holds true.",
    "deprecated": false,
    "examples": [
      "import { Array, Option } from \"effect\";\n\nconst data = [2, 4, 5];\nconst toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none();\nconst result = Array.filterMapWhile(data, toSquareTillOdd);\n\nassert.deepStrictEqual(result, [4, 16]);"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterMapWhile: { <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Array<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Array<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "partitionMap",
    "description": "Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.\nThis function is particularly useful for operations where each element can result in two possible types,\nand you want to separate these types into different collections. For instance, separating validation results\ninto successes and failures.",
    "deprecated": false,
    "examples": [
      "import { Array, Either } from \"effect\";\n\nconst data = [1, 2, 3, 4, 5]\nconst isEven = (x: number) => x % 2 === 0\nconst partitioned = Array.partitionMap(data, x =>\n  isEven(x) ? Either.right(x) : Either.left(x)\n)\n\nassert.deepStrictEqual(partitioned, [\n  [1, 3, 5],\n  [2, 4]\n])"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const partitionMap: { <A, B, C>(f: (a: A, i: number) => Either<C, B>): (self: Iterable<A>) => [left: Array<B>, right: Array<C>]; <A, B, C>(self: Iterable<A>, f: (a: A, i: number) => Either<C, B>): [left: Array<B>, right: Array<C>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "getSomes",
    "description": "Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.",
    "deprecated": false,
    "examples": [
      "import { Array, Option } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.getSomes([Option.some(1), Option.none(), Option.some(2)]),\n  [1, 2]\n)"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const getSomes: <T extends Iterable<Option<X>>, X = any>(self: T) => Array<Option.Value<ReadonlyArray.Infer<T>>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filter: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Array<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Array<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "partition",
    "description": "Separate elements based on a predicate that also exposes the index of the element.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4]\n\nconst result = Array.partition(numbers, n => n % 2 === 0)\n\nassert.deepStrictEqual(result, [[1, 3], [2, 4]])"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const partition: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [excluded: Array<A>, satisfying: Array<A>]; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [excluded: Array<A>, satisfying: Array<A>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "separate",
    "description": "Separates an `Iterable` into two arrays based on a predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const separate: <T extends Iterable<Either<any, any>>>(self: T) => [Array<Either.Left<ReadonlyArray.Infer<T>>>, Array<Either.Right<ReadonlyArray.Infer<T>>>]"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": "Reduces an array from the left.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3]\nconst result = Array.reduce(numbers, 0, (acc, n) => acc + n)\nassert.deepStrictEqual(result, 6)"
    ],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduce: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "reduceRight",
    "description": "Reduces an array from the right.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3]\nconst result = Array.reduceRight(numbers, 0, (acc, n) => acc + n)\nassert.deepStrictEqual(result, 6)"
    ],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduceRight: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "flatMapNullable",
    "description": "Maps over an array and flattens the result, removing null and undefined values.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3]\nconst result = Array.flatMapNullable(numbers, n => (n % 2 === 0 ? null : n))\nassert.deepStrictEqual(result, [1, 3])\n\n// Explanation:\n// The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers\n// and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened\n// to remove null values, resulting in [1, 3]."
    ],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMapNullable: { <A, B>(f: (a: A) => B | null | undefined): (self: ReadonlyArray<A>) => Array<NonNullable<B>>; <A, B>(self: ReadonlyArray<A>, f: (a: A) => B | null | undefined): Array<NonNullable<B>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "every",
    "description": "Check if a predicate holds true for every `ReadonlyArray` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const every: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: ReadonlyArray<A>) => self is ReadonlyArray<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => boolean; <A, B extends A>(self: ReadonlyArray<A>, refinement: (a: A, i: number) => a is B): self is ReadonlyArray<B>; <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": "Check if a predicate holds true for some `ReadonlyArray` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const some: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>; <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): self is NonEmptyReadonlyArray<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "extend",
    "description": "Extends an array with a function that maps each subarray to a value.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3]\nconst result = Array.extend(numbers, as => as.length)\nassert.deepStrictEqual(result, [3, 2, 1])\n\n// Explanation:\n// The function maps each subarray starting from each element to its length.\n// The subarrays are: [1, 2, 3], [2, 3], [3].\n// The lengths are: 3, 2, 1.\n// Therefore, the result is [3, 2, 1]."
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const extend: { <A, B>(f: (as: ReadonlyArray<A>) => B): (self: ReadonlyArray<A>) => Array<B>; <A, B>(self: ReadonlyArray<A>, f: (as: ReadonlyArray<A>) => B): Array<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "min",
    "description": "Finds the minimum element in an array based on a comparator.",
    "deprecated": false,
    "examples": [
      "import { Array, Order } from \"effect\"\n\nconst min = Array.min([3, 1, 2], Order.number)\nassert.deepStrictEqual(min, 1)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const min: { <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A; <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "max",
    "description": "Finds the maximum element in an array based on a comparator.",
    "deprecated": false,
    "examples": [
      "import { Array, Order } from \"effect\"\n\nconst max = Array.max([3, 1, 2], Order.number)\nassert.deepStrictEqual(max, 3)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const max: { <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A; <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "getOrder",
    "description": "This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\nThe returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\nIf all elements are equal, the arrays are then compared based on their length.\nIt is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const getOrder: <A>(O: Order.Order<A>) => Order.Order<ReadonlyArray<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": "Creates an equivalence relation for arrays.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers1 = [1, 2, 3]\nconst numbers2 = [1, 2, 3]\nconst eq = Array.getEquivalence<number>((a, b) => a === b)\nassert.deepStrictEqual(eq(numbers1, numbers2), true)"
    ],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<ReadonlyArray<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "Performs a side-effect for each element of the `Iterable`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3]\nArray.forEach(numbers, n => console.log(n)) // 1, 2, 3"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const forEach: { <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void; <A>(self: Iterable<A>, f: (a: A, i: number) => void): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "dedupeWith",
    "description": "Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\npreserving the order of the first occurrence of each element.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 2, 3, 3, 3]\nconst unique = Array.dedupeWith(numbers, (a, b) => a === b)\nassert.deepStrictEqual(unique, [1, 2, 3])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const dedupeWith: { <S extends Iterable<any>>(isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<S>) => boolean): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<A>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "dedupeAdjacentWith",
    "description": "Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 1, 2, 2, 3, 3]\nconst unique = Array.dedupeAdjacentWith(numbers, (a, b) => a === b)\nassert.deepStrictEqual(unique, [1, 2, 3])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const dedupeAdjacentWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "dedupeAdjacent",
    "description": "Deduplicates adjacent elements that are identical.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 1, 2, 2, 3, 3]\nconst unique = Array.dedupeAdjacent(numbers)\nassert.deepStrictEqual(unique, [1, 2, 3])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const dedupeAdjacent: <A>(self: Iterable<A>) => Array<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "join",
    "description": "Joins the elements together with \"sep\" in the middle.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst strings = [\"a\", \"b\", \"c\"]\nconst joined = Array.join(strings, \"-\")\nassert.deepStrictEqual(joined, \"a-b-c\")"
    ],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const join: { (sep: string): (self: Iterable<string>) => string; (self: Iterable<string>, sep: string): string; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "mapAccum",
    "description": "Statefully maps over the chunk, producing new elements of type `B`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3]\nconst result = Array.mapAccum(numbers, 0, (acc, n) => [acc + n, acc + n])\nassert.deepStrictEqual(result, [6, [1, 3, 6]])"
    ],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const mapAccum: { <S, A, B, I extends Iterable<A> = Iterable<A>>(s: S, f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]): (self: I) => [state: S, mappedArray: ReadonlyArray.With<I, B>]; <S, A, B, I extends Iterable<A> = Iterable<A>>(self: I, s: S, f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]): [state: S, mappedArray: ReadonlyArray.With<I, B>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "cartesianWith",
    "description": "Zips this chunk crosswise with the specified chunk using the specified combiner.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst array1 = [1, 2]\nconst array2 = [\"a\", \"b\"]\nconst product = Array.cartesianWith(array1, array2, (a, b) => `${a}-${b}`)\nassert.deepStrictEqual(product, [\"1-a\", \"1-b\", \"2-a\", \"2-b\"])"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const cartesianWith: { <A, B, C>(that: ReadonlyArray<B>, f: (a: A, b: B) => C): (self: ReadonlyArray<A>) => Array<C>; <A, B, C>(self: ReadonlyArray<A>, that: ReadonlyArray<B>, f: (a: A, b: B) => C): Array<C>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "cartesian",
    "description": "Zips this chunk crosswise with the specified chunk.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst array1 = [1, 2]\nconst array2 = [\"a\", \"b\"]\nconst product = Array.cartesian(array1, array2)\nassert.deepStrictEqual(product, [[1, \"a\"], [1, \"b\"], [2, \"a\"], [2, \"b\"]])"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const cartesian: { <B>(that: ReadonlyArray<B>): <A>(self: ReadonlyArray<A>) => Array<[A, B]>; <A, B>(self: ReadonlyArray<A>, that: ReadonlyArray<B>): Array<[A, B]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "Do",
    "description": "The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n\nIt can be used to simulate \"array comprehension\".\nIt's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope",
    "deprecated": false,
    "examples": [
      "import { Array as Arr, pipe } from \"effect\"\nconst doResult = pipe(\n  Arr.Do,\n  Arr.bind(\"x\", () => [1, 3, 5]),\n  Arr.bind(\"y\", () => [2, 4, 6]),\n  Arr.filter(({ x, y }) => x < y), // condition\n  Arr.map(({ x, y }) => [x, y] as const) // transformation\n)\nassert.deepStrictEqual(doResult, [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]])\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}"
    ],
    "since": "3.2.0",
    "category": "do notation",
    "signature": "export declare const Do: readonly {}[]"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "bind",
    "description": "The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n\nIt can be used to simulate \"array comprehension\".\nIt's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope",
    "deprecated": false,
    "examples": [
      "import { Array as Arr, pipe } from \"effect\"\nconst doResult = pipe(\n  Arr.Do,\n  Arr.bind(\"x\", () => [1, 3, 5]),\n  Arr.bind(\"y\", () => [2, 4, 6]),\n  Arr.filter(({ x, y }) => x < y), // condition\n  Arr.map(({ x, y }) => [x, y] as const) // transformation\n)\nassert.deepStrictEqual(doResult, [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]])\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}"
    ],
    "since": "3.2.0",
    "category": "do notation",
    "signature": "export declare const bind: { <A extends object, N extends string, B>(tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => ReadonlyArray<B>): (self: ReadonlyArray<A>) => Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <A extends object, N extends string, B>(self: ReadonlyArray<A>, tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => ReadonlyArray<B>): Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "bindTo",
    "description": "The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n\nIt can be used to simulate \"array comprehension\".\nIt's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope",
    "deprecated": false,
    "examples": [
      "import { Array as Arr, pipe } from \"effect\"\nconst doResult = pipe(\n  Arr.Do,\n  Arr.bind(\"x\", () => [1, 3, 5]),\n  Arr.bind(\"y\", () => [2, 4, 6]),\n  Arr.filter(({ x, y }) => x < y), // condition\n  Arr.map(({ x, y }) => [x, y] as const) // transformation\n)\nassert.deepStrictEqual(doResult, [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]])\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}"
    ],
    "since": "3.2.0",
    "category": "do notation",
    "signature": "export declare const bindTo: { <N extends string>(tag: N): <A>(self: ReadonlyArray<A>) => Array<{ [K in N]: A; }>; <A, N extends string>(self: ReadonlyArray<A>, tag: N): Array<{ [K in N]: A; }>; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "let",
    "description": "The \"do simulation\" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n\nIt can be used to simulate \"array comprehension\".\nIt's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope",
    "deprecated": false,
    "examples": [
      "import { Array as Arr, pipe } from \"effect\"\nconst doResult = pipe(\n  Arr.Do,\n  Arr.bind(\"x\", () => [1, 3, 5]),\n  Arr.bind(\"y\", () => [2, 4, 6]),\n  Arr.filter(({ x, y }) => x < y), // condition\n  Arr.map(({ x, y }) => [x, y] as const) // transformation\n)\nassert.deepStrictEqual(doResult, [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]])\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}\n"
    ],
    "since": "3.2.0",
    "category": "do notation",
    "signature": "export declare const let: { <N extends string, B, A extends object>(tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): (self: ReadonlyArray<A>) => Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <N extends string, A extends object, B>(self: ReadonlyArray<A>, tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Builds a `NonEmptyArray` from an non-empty collection of elements.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst result = Array.make(1, 2, 3)\nassert.deepStrictEqual(result, [1, 2, 3])"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "allocate",
    "description": "Creates a new `Array` of the specified length.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst result = Array.allocate<number>(3)\nassert.deepStrictEqual(result.length, 3)"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "range",
    "description": "Return a `NonEmptyArray` containing a range of integers, including both endpoints.",
    "deprecated": false,
    "examples": [
      "import { range } from \"effect/Array\"\n\nassert.deepStrictEqual(range(1, 3), [1, 2, 3])"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `Array` from an iterable collection of values.\nIf the input is already an array, it returns the input as-is.\nOtherwise, it converts the iterable collection to an array.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst set = new Set([1, 2, 3])\nconst result = Array.fromIterable(set)\nassert.deepStrictEqual(result, [1, 2, 3])"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "ensure",
    "description": "Creates a new `Array` from a value that might not be an iterable.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nassert.deepStrictEqual(Array.ensure(\"a\"), [\"a\"])\nassert.deepStrictEqual(Array.ensure([\"a\"]), [\"a\"])\nassert.deepStrictEqual(Array.ensure([\"a\", \"b\", \"c\"]), [\"a\", \"b\", \"c\"])"
    ],
    "since": "3.3.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "isEmptyArray",
    "description": "Determine if an `Array` is empty narrowing down the type to `[]`.",
    "deprecated": false,
    "examples": [
      "import { isEmptyArray } from \"effect/Array\"\n\nassert.deepStrictEqual(isEmptyArray([]), true);\nassert.deepStrictEqual(isEmptyArray([1, 2, 3]), false);"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "length",
    "description": "Return the number of elements in a `ReadonlyArray`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "unprepend",
    "description": "Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\";\n\nconst result = Array.unprepend([1, 2, 3, 4])\nassert.deepStrictEqual(result, [1, [2, 3, 4]])"
    ],
    "since": "2.0.0",
    "category": "splitting",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "unappend",
    "description": "Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\";\n\nconst result = Array.unappend([1, 2, 3, 4])\nassert.deepStrictEqual(result, [[1, 2, 3], 4])"
    ],
    "since": "2.0.0",
    "category": "splitting",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "last",
    "description": "Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "lastNonEmpty",
    "description": "Get the last element of a non empty array.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst result = Array.lastNonEmpty([1, 2, 3, 4])\nassert.deepStrictEqual(result, 4)"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "tail",
    "description": "Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "tailNonEmpty",
    "description": "Get all but the first element of a `NonEmptyReadonlyArray`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst result = Array.tailNonEmpty([1, 2, 3, 4])\nassert.deepStrictEqual(result, [2, 3, 4])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "init",
    "description": "Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "initNonEmpty",
    "description": "Get all but the last element of a non empty array, creating a new array.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst result = Array.initNonEmpty([1, 2, 3, 4])\nassert.deepStrictEqual(result, [1, 2, 3])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "reverse",
    "description": "Reverse an `Iterable`, creating a new `Array`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4]\nconst result = Array.reverse(numbers)\nassert.deepStrictEqual(result, [4, 3, 2, 1])"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "sortBy",
    "description": "Sorts the elements of an `Iterable` in increasing order based on the provided\norders. The elements are compared using the first order in `orders`, then the\nsecond order if the first comparison is equal, and so on.",
    "deprecated": false,
    "examples": [
      "import { Array, Order } from \"effect\"\n\nconst users = [\n  { name: \"Alice\", age: 30 },\n  { name: \"Bob\", age: 25 },\n  { name: \"Charlie\", age: 30 }\n]\n\nconst result = Array.sortBy(\n  Order.mapInput(Order.number, (user: (typeof users)[number]) => user.age),\n  Order.mapInput(Order.string, (user: (typeof users)[number]) => user.name)\n)(users)\n\nassert.deepStrictEqual(result, [\n  { name: \"Bob\", age: 25 },\n  { name: \"Alice\", age: 30 },\n  { name: \"Charlie\", age: 30 }\n])\n\n// Explanation:\n// The array of users is sorted first by age in ascending order. When ages are equal,\n// the users are further sorted by name in ascending order."
    ],
    "since": "2.0.0",
    "category": "sorting",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "containsWith",
    "description": "Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst numbers = [1, 2, 3, 4]\nconst isEquivalent = (a: number, b: number) => a === b\nconst containsNumber = Array.containsWith(isEquivalent)\nconst result = containsNumber(3)(numbers)\nassert.deepStrictEqual(result, true)"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "intersectionWith",
    "description": "Creates an `Array` of unique values that are included in all given `Iterable`s using the provided `isEquivalent` function.\nThe order and references of result values are determined by the first `Iterable`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]\nconst array2 = [{ id: 3 }, { id: 4 }, { id: 1 }]\nconst isEquivalent = (a: { id: number }, b: { id: number }) => a.id === b.id\nconst result = Array.intersectionWith(isEquivalent)(array2)(array1)\nassert.deepStrictEqual(result, [{ id: 1 }, { id: 3 }])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "differenceWith",
    "description": "Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.\nThe order and references of result values are determined by the first `Iterable`.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst array1 = [1, 2, 3]\nconst array2 = [2, 3, 4]\nconst difference = Array.differenceWith<number>((a, b) => a === b)(array1, array2)\nassert.deepStrictEqual(difference, [1])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "of",
    "description": "Constructs a new `NonEmptyArray<A>` from the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "getLefts",
    "description": "Retrieves the `Left` values from an `Iterable` of `Either`s, collecting them into an array.",
    "deprecated": false,
    "examples": [
      "import { Array, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.getLefts([Either.right(1), Either.left(\"err\"), Either.right(2)]),\n  [\"err\"]\n)"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "getRights",
    "description": "Retrieves the `Right` values from an `Iterable` of `Either`s, collecting them into an array.",
    "deprecated": false,
    "examples": [
      "import { Array, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.getRights([Either.right(1), Either.left(\"err\"), Either.right(2)]),\n  [1, 2]\n)"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "liftPredicate",
    "description": "Lifts a predicate into an array.",
    "deprecated": false,
    "examples": [
      "import { Array } from \"effect\"\n\nconst isEven = (n: number) => n % 2 === 0\nconst to = Array.liftPredicate(isEven)\nassert.deepStrictEqual(to(1), [])\nassert.deepStrictEqual(to(2), [2])"
    ],
    "since": "2.0.0",
    "category": "lifting",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "liftOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "lifting",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "fromNullable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "liftNullable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "lifting",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "liftEither",
    "description": "Lifts a function that returns an `Either` into a function that returns an array.\nIf the `Either` is a left, it returns an empty array.\nIf the `Either` is a right, it returns an array with the right value.",
    "deprecated": false,
    "examples": [
      "import { Array, Either } from \"effect\"\n\nconst parseNumber = (s: string): Either.Either<number, Error> =>\n  isNaN(Number(s)) ? Either.left(new Error(\"Not a number\")) : Either.right(Number(s))\n\nconst liftedParseNumber = Array.liftEither(parseNumber)\n\nconst result1 = liftedParseNumber(\"42\")\nassert.deepStrictEqual(result1, [42])\n\nconst result2 = liftedParseNumber(\"not a number\")\nassert.deepStrictEqual(result2, [])\n\n// Explanation:\n// The function parseNumber is lifted to return an array.\n// When parsing \"42\", it returns an Either.left with the number 42, resulting in [42].\n// When parsing \"not a number\", it returns an Either.right with an error, resulting in an empty array []."
    ],
    "since": "2.0.0",
    "category": "lifting",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "unfold",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "dedupe",
    "description": "Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.\nThe equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlyArrayTypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface ReadonlyArrayTypeLambda extends TypeLambda {\n  readonly type: ReadonlyArray<this[\"Target\"]>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "NonEmptyArray",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type NonEmptyArray<A> = [A, ...Array<A>]"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Array",
      "path": [
        "src",
        "Array.ts"
      ]
    },
    "project": "effect",
    "name": "NonEmptyReadonlyArray",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type NonEmptyReadonlyArray<A> = readonly [A, ...Array<A>]"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "scale",
    "description": "Scales a given `BigDecimal` to the specified scale.\n\nIf the given scale is smaller than the current scale, the value will be rounded down to\nthe nearest integer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "scaling",
    "signature": "export declare const scale: { (scale: number): (self: BigDecimal) => BigDecimal; (self: BigDecimal, scale: number): BigDecimal; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "sum",
    "description": "Provides an addition operation on `BigDecimal`s.",
    "deprecated": false,
    "examples": [
      "import { sum, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(sum(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"5\"))"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const sum: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "multiply",
    "description": "Provides a multiplication operation on `BigDecimal`s.",
    "deprecated": false,
    "examples": [
      "import { multiply, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(multiply(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"6\"))"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const multiply: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "subtract",
    "description": "Provides a subtraction operation on `BigDecimal`s.",
    "deprecated": false,
    "examples": [
      "import { subtract, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(subtract(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"-1\"))"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const subtract: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "divide",
    "description": "Provides a division operation on `BigDecimal`s.\n\nIf the dividend is not a multiple of the divisor the result will be a `BigDecimal` value\nwhich represents the integer division rounded down to the nearest integer.\n\nIf the divisor is `0`, the result will be `None`.",
    "deprecated": false,
    "examples": [
      "import { BigDecimal, Option } from \"effect\"\n\nassert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString(\"6\"), BigDecimal.unsafeFromString(\"3\")), Option.some(BigDecimal.unsafeFromString(\"2\")))\nassert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString(\"6\"), BigDecimal.unsafeFromString(\"4\")), Option.some(BigDecimal.unsafeFromString(\"1.5\")))\nassert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString(\"6\"), BigDecimal.unsafeFromString(\"0\")), Option.none())"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const divide: { (that: BigDecimal): (self: BigDecimal) => Option.Option<BigDecimal>; (self: BigDecimal, that: BigDecimal): Option.Option<BigDecimal>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeDivide",
    "description": "Provides an unsafe division operation on `BigDecimal`s.\n\nIf the dividend is not a multiple of the divisor the result will be a `BigDecimal` value\nwhich represents the integer division rounded down to the nearest integer.\n\nThrows a `RangeError` if the divisor is `0`.",
    "deprecated": false,
    "examples": [
      "import { unsafeDivide, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeDivide(unsafeFromString(\"6\"), unsafeFromString(\"3\")), unsafeFromString(\"2\"))\nassert.deepStrictEqual(unsafeDivide(unsafeFromString(\"6\"), unsafeFromString(\"4\")), unsafeFromString(\"1.5\"))"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const unsafeDivide: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "Order",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Order: order.Order<BigDecimal>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "lessThan",
    "description": "Returns `true` if the first argument is less than the second, otherwise `false`.",
    "deprecated": false,
    "examples": [
      "import { lessThan, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(lessThan(unsafeFromString(\"2\"), unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(lessThan(unsafeFromString(\"3\"), unsafeFromString(\"3\")), false)\nassert.deepStrictEqual(lessThan(unsafeFromString(\"4\"), unsafeFromString(\"3\")), false)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const lessThan: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanOrEqualTo",
    "description": "Checks if a given `BigDecimal` is less than or equal to the provided one.",
    "deprecated": false,
    "examples": [
      "import { lessThanOrEqualTo, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString(\"2\"), unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString(\"3\"), unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString(\"4\"), unsafeFromString(\"3\")), false)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const lessThanOrEqualTo: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThan",
    "description": "Returns `true` if the first argument is greater than the second, otherwise `false`.",
    "deprecated": false,
    "examples": [
      "import { greaterThan, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(greaterThan(unsafeFromString(\"2\"), unsafeFromString(\"3\")), false)\nassert.deepStrictEqual(greaterThan(unsafeFromString(\"3\"), unsafeFromString(\"3\")), false)\nassert.deepStrictEqual(greaterThan(unsafeFromString(\"4\"), unsafeFromString(\"3\")), true)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const greaterThan: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanOrEqualTo",
    "description": "Checks if a given `BigDecimal` is greater than or equal to the provided one.",
    "deprecated": false,
    "examples": [
      "import { greaterThanOrEqualTo, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString(\"2\"), unsafeFromString(\"3\")), false)\nassert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString(\"3\"), unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString(\"4\"), unsafeFromString(\"3\")), true)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const greaterThanOrEqualTo: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "between",
    "description": "Checks if a `BigDecimal` is between a `minimum` and `maximum` value (inclusive).",
    "deprecated": false,
    "examples": [
      "import { BigDecimal } from \"effect\"\n\nconst between = BigDecimal.between({\n  minimum: BigDecimal.unsafeFromString(\"1\"),\n  maximum: BigDecimal.unsafeFromString(\"5\") }\n)\n\nassert.deepStrictEqual(between(BigDecimal.unsafeFromString(\"3\")), true)\nassert.deepStrictEqual(between(BigDecimal.unsafeFromString(\"0\")), false)\nassert.deepStrictEqual(between(BigDecimal.unsafeFromString(\"6\")), false)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const between: { (options: { minimum: BigDecimal; maximum: BigDecimal; }): (self: BigDecimal) => boolean; (self: BigDecimal, options: { minimum: BigDecimal; maximum: BigDecimal; }): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "clamp",
    "description": "Restricts the given `BigDecimal` to be within the range specified by the `minimum` and `maximum` values.\n\n- If the `BigDecimal` is less than the `minimum` value, the function returns the `minimum` value.\n- If the `BigDecimal` is greater than the `maximum` value, the function returns the `maximum` value.\n- Otherwise, it returns the original `BigDecimal`.",
    "deprecated": false,
    "examples": [
      "import { BigDecimal } from \"effect\"\n\nconst clamp = BigDecimal.clamp({\n  minimum: BigDecimal.unsafeFromString(\"1\"),\n  maximum: BigDecimal.unsafeFromString(\"5\") }\n)\n\nassert.deepStrictEqual(clamp(BigDecimal.unsafeFromString(\"3\")), BigDecimal.unsafeFromString(\"3\"))\nassert.deepStrictEqual(clamp(BigDecimal.unsafeFromString(\"0\")), BigDecimal.unsafeFromString(\"1\"))\nassert.deepStrictEqual(clamp(BigDecimal.unsafeFromString(\"6\")), BigDecimal.unsafeFromString(\"5\"))"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const clamp: { (options: { minimum: BigDecimal; maximum: BigDecimal; }): (self: BigDecimal) => BigDecimal; (self: BigDecimal, options: { minimum: BigDecimal; maximum: BigDecimal; }): BigDecimal; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "min",
    "description": "Returns the minimum between two `BigDecimal`s.",
    "deprecated": false,
    "examples": [
      "import { min, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(min(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"2\"))"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const min: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "max",
    "description": "Returns the maximum between two `BigDecimal`s.",
    "deprecated": false,
    "examples": [
      "import { max, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(max(unsafeFromString(\"2\"), unsafeFromString(\"3\")), unsafeFromString(\"3\"))"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const max: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "remainder",
    "description": "Returns the remainder left over when one operand is divided by a second operand.\n\nIf the divisor is `0`, the result will be `None`.",
    "deprecated": false,
    "examples": [
      "import { BigDecimal, Option } from \"effect\"\n\nassert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString(\"2\"), BigDecimal.unsafeFromString(\"2\")), Option.some(BigDecimal.unsafeFromString(\"0\")))\nassert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString(\"3\"), BigDecimal.unsafeFromString(\"2\")), Option.some(BigDecimal.unsafeFromString(\"1\")))\nassert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString(\"-4\"), BigDecimal.unsafeFromString(\"2\")), Option.some(BigDecimal.unsafeFromString(\"0\")))"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const remainder: { (divisor: BigDecimal): (self: BigDecimal) => Option.Option<BigDecimal>; (self: BigDecimal, divisor: BigDecimal): Option.Option<BigDecimal>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeRemainder",
    "description": "Returns the remainder left over when one operand is divided by a second operand.\n\nThrows a `RangeError` if the divisor is `0`.",
    "deprecated": false,
    "examples": [
      "import { unsafeRemainder, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeRemainder(unsafeFromString(\"2\"), unsafeFromString(\"2\")), unsafeFromString(\"0\"))\nassert.deepStrictEqual(unsafeRemainder(unsafeFromString(\"3\"), unsafeFromString(\"2\")), unsafeFromString(\"1\"))\nassert.deepStrictEqual(unsafeRemainder(unsafeFromString(\"-4\"), unsafeFromString(\"2\")), unsafeFromString(\"0\"))"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const unsafeRemainder: { (divisor: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, divisor: BigDecimal): BigDecimal; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "Equivalence",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Equivalence: equivalence.Equivalence<BigDecimal>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "equals",
    "description": "Checks if two `BigDecimal`s are equal.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const equals: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "fromNumber",
    "description": "Creates a `BigDecimal` from a `number` value.\n\nIt is not recommended to convert a floating point number to a decimal directly,\nas the floating point representation may be unexpected.\n\nThrows a `RangeError` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromNumber: (n: number) => BigDecimal"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "isBigDecimal",
    "description": "Checks if a given value is a `BigDecimal`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a `BigDecimal` from a `bigint` value and a scale.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "normalize",
    "description": "Normalizes a given `BigDecimal` by removing trailing zeros.",
    "deprecated": false,
    "examples": [
      "import { normalize, make, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(normalize(unsafeFromString(\"123.00000\")), normalize(make(123n, 0)))\nassert.deepStrictEqual(normalize(unsafeFromString(\"12300000\")), normalize(make(123n, -5)))"
    ],
    "since": "2.0.0",
    "category": "scaling",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "sign",
    "description": "Determines the sign of a given `BigDecimal`.",
    "deprecated": false,
    "examples": [
      "import { sign, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(sign(unsafeFromString(\"-5\")), -1)\nassert.deepStrictEqual(sign(unsafeFromString(\"0\")), 0)\nassert.deepStrictEqual(sign(unsafeFromString(\"5\")), 1)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "abs",
    "description": "Determines the absolute value of a given `BigDecimal`.",
    "deprecated": false,
    "examples": [
      "import { abs, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(abs(unsafeFromString(\"-5\")), unsafeFromString(\"5\"))\nassert.deepStrictEqual(abs(unsafeFromString(\"0\")), unsafeFromString(\"0\"))\nassert.deepStrictEqual(abs(unsafeFromString(\"5\")), unsafeFromString(\"5\"))"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "negate",
    "description": "Provides a negate operation on `BigDecimal`s.",
    "deprecated": false,
    "examples": [
      "import { negate, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(negate(unsafeFromString(\"3\")), unsafeFromString(\"-3\"))\nassert.deepStrictEqual(negate(unsafeFromString(\"-6\")), unsafeFromString(\"6\"))"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "fromBigInt",
    "description": "Creates a `BigDecimal` from a `bigint` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeFromNumber",
    "description": "Creates a `BigDecimal` from a `number` value.\n\nIt is not recommended to convert a floating point number to a decimal directly,\nas the floating point representation may be unexpected.\n\nThrows a `RangeError` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).",
    "deprecated": false,
    "examples": [
      "import { unsafeFromNumber, make } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeFromNumber(123), make(123n, 0))\nassert.deepStrictEqual(unsafeFromNumber(123.456), make(123456n, 3))"
    ],
    "since": "3.11.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "safeFromNumber",
    "description": "Creates a `BigDecimal` from a `number` value.\n\nIt is not recommended to convert a floating point number to a decimal directly,\nas the floating point representation may be unexpected.\n\nReturns `None` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).",
    "deprecated": false,
    "examples": [
      "import { BigDecimal, Option } from \"effect\"\n\nassert.deepStrictEqual(BigDecimal.safeFromNumber(123), Option.some(BigDecimal.make(123n, 0)))\nassert.deepStrictEqual(BigDecimal.safeFromNumber(123.456), Option.some(BigDecimal.make(123456n, 3)))\nassert.deepStrictEqual(BigDecimal.safeFromNumber(Infinity), Option.none())"
    ],
    "since": "3.11.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "fromString",
    "description": "Parses a numerical `string` into a `BigDecimal`.",
    "deprecated": false,
    "examples": [
      "import { BigDecimal, Option } from \"effect\"\n\nassert.deepStrictEqual(BigDecimal.fromString(\"123\"), Option.some(BigDecimal.make(123n, 0)))\nassert.deepStrictEqual(BigDecimal.fromString(\"123.456\"), Option.some(BigDecimal.make(123456n, 3)))\nassert.deepStrictEqual(BigDecimal.fromString(\"123.abc\"), Option.none())"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeFromString",
    "description": "Parses a numerical `string` into a `BigDecimal`.",
    "deprecated": false,
    "examples": [
      "import { unsafeFromString, make } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeFromString(\"123\"), make(123n, 0))\nassert.deepStrictEqual(unsafeFromString(\"123.456\"), make(123456n, 3))\nassert.throws(() => unsafeFromString(\"123.abc\"))"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "format",
    "description": "Formats a given `BigDecimal` as a `string`.\n\nIf the scale of the `BigDecimal` is greater than or equal to 16, the `BigDecimal` will\nbe formatted in scientific notation.",
    "deprecated": false,
    "examples": [
      "import { format, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(format(unsafeFromString(\"-5\")), \"-5\")\nassert.deepStrictEqual(format(unsafeFromString(\"123.456\")), \"123.456\")\nassert.deepStrictEqual(format(unsafeFromString(\"-0.00000123\")), \"-0.00000123\")"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "toExponential",
    "description": "Formats a given `BigDecimal` as a `string` in scientific notation.",
    "deprecated": false,
    "examples": [
      "import { toExponential, make } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(toExponential(make(123456n, -5)), \"1.23456e+10\")"
    ],
    "since": "3.11.0",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeToNumber",
    "description": "Converts a `BigDecimal` to a `number`.\n\nThis function will produce incorrect results if the `BigDecimal` exceeds the 64-bit range of a `number`.",
    "deprecated": false,
    "examples": [
      "import { unsafeToNumber, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(unsafeToNumber(unsafeFromString(\"123.456\")), 123.456)"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "isInteger",
    "description": "Checks if a given `BigDecimal` is an integer.",
    "deprecated": false,
    "examples": [
      "import { isInteger, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(isInteger(unsafeFromString(\"0\")), true)\nassert.deepStrictEqual(isInteger(unsafeFromString(\"1\")), true)\nassert.deepStrictEqual(isInteger(unsafeFromString(\"1.1\")), false)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "isZero",
    "description": "Checks if a given `BigDecimal` is `0`.",
    "deprecated": false,
    "examples": [
      "import { isZero, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(isZero(unsafeFromString(\"0\")), true)\nassert.deepStrictEqual(isZero(unsafeFromString(\"1\")), false)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "isNegative",
    "description": "Checks if a given `BigDecimal` is negative.",
    "deprecated": false,
    "examples": [
      "import { isNegative, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(isNegative(unsafeFromString(\"-1\")), true)\nassert.deepStrictEqual(isNegative(unsafeFromString(\"0\")), false)\nassert.deepStrictEqual(isNegative(unsafeFromString(\"1\")), false)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "isPositive",
    "description": "Checks if a given `BigDecimal` is positive.",
    "deprecated": false,
    "examples": [
      "import { isPositive, unsafeFromString } from \"effect/BigDecimal\"\n\nassert.deepStrictEqual(isPositive(unsafeFromString(\"-1\")), false)\nassert.deepStrictEqual(isPositive(unsafeFromString(\"0\")), false)\nassert.deepStrictEqual(isPositive(unsafeFromString(\"1\")), true)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "BigDecimal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BigDecimal extends Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly value: bigint\n  readonly scale: number\n  /** @internal */\n  normalized?: BigDecimal\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "BigDecimal",
      "path": [
        "src",
        "BigDecimal.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "isBigInt",
    "description": "Tests if a value is a `bigint`.",
    "deprecated": false,
    "examples": [
      "import { isBigInt } from \"effect/BigInt\"\n\nassert.deepStrictEqual(isBigInt(1n), true)\nassert.deepStrictEqual(isBigInt(1), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isBigInt: (u: unknown) => u is bigint"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "sum",
    "description": "Provides an addition operation on `bigint`s.",
    "deprecated": false,
    "examples": [
      "import { sum } from \"effect/BigInt\"\n\nassert.deepStrictEqual(sum(2n, 3n), 5n)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const sum: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "multiply",
    "description": "Provides a multiplication operation on `bigint`s.",
    "deprecated": false,
    "examples": [
      "import { multiply } from \"effect/BigInt\"\n\nassert.deepStrictEqual(multiply(2n, 3n), 6n)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const multiply: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "subtract",
    "description": "Provides a subtraction operation on `bigint`s.",
    "deprecated": false,
    "examples": [
      "import { subtract } from \"effect/BigInt\"\n\nassert.deepStrictEqual(subtract(2n, 3n), -1n)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const subtract: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "divide",
    "description": "Provides a division operation on `bigint`s.\n\nIf the dividend is not a multiple of the divisor the result will be a `bigint` value\nwhich represents the integer division rounded down to the nearest integer.\n\nReturns `None` if the divisor is `0n`.",
    "deprecated": false,
    "examples": [
      "import { BigInt, Option } from \"effect\"\n\nassert.deepStrictEqual(BigInt.divide(6n, 3n), Option.some(2n))\nassert.deepStrictEqual(BigInt.divide(6n, 0n), Option.none())"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const divide: { (that: bigint): (self: bigint) => Option.Option<bigint>; (self: bigint, that: bigint): Option.Option<bigint>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeDivide",
    "description": "Provides a division operation on `bigint`s.\n\nIf the dividend is not a multiple of the divisor the result will be a `bigint` value\nwhich represents the integer division rounded down to the nearest integer.\n\nThrows a `RangeError` if the divisor is `0n`.",
    "deprecated": false,
    "examples": [
      "import { unsafeDivide } from \"effect/BigInt\"\n\nassert.deepStrictEqual(unsafeDivide(6n, 3n), 2n)\nassert.deepStrictEqual(unsafeDivide(6n, 4n), 1n)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const unsafeDivide: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "Equivalence",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Equivalence: equivalence.Equivalence<bigint>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "Order",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Order: order.Order<bigint>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "lessThan",
    "description": "Returns `true` if the first argument is less than the second, otherwise `false`.",
    "deprecated": false,
    "examples": [
      "import { lessThan } from \"effect/BigInt\"\n\nassert.deepStrictEqual(lessThan(2n, 3n), true)\nassert.deepStrictEqual(lessThan(3n, 3n), false)\nassert.deepStrictEqual(lessThan(4n, 3n), false)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const lessThan: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanOrEqualTo",
    "description": "Returns a function that checks if a given `bigint` is less than or equal to the provided one.",
    "deprecated": false,
    "examples": [
      "import { lessThanOrEqualTo } from \"effect/BigInt\"\n\nassert.deepStrictEqual(lessThanOrEqualTo(2n, 3n), true)\nassert.deepStrictEqual(lessThanOrEqualTo(3n, 3n), true)\nassert.deepStrictEqual(lessThanOrEqualTo(4n, 3n), false)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const lessThanOrEqualTo: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThan",
    "description": "Returns `true` if the first argument is greater than the second, otherwise `false`.",
    "deprecated": false,
    "examples": [
      "import { greaterThan } from \"effect/BigInt\"\n\nassert.deepStrictEqual(greaterThan(2n, 3n), false)\nassert.deepStrictEqual(greaterThan(3n, 3n), false)\nassert.deepStrictEqual(greaterThan(4n, 3n), true)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const greaterThan: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanOrEqualTo",
    "description": "Returns a function that checks if a given `bigint` is greater than or equal to the provided one.",
    "deprecated": false,
    "examples": [
      "import { greaterThanOrEqualTo } from \"effect/BigInt\"\n\nassert.deepStrictEqual(greaterThanOrEqualTo(2n, 3n), false)\nassert.deepStrictEqual(greaterThanOrEqualTo(3n, 3n), true)\nassert.deepStrictEqual(greaterThanOrEqualTo(4n, 3n), true)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const greaterThanOrEqualTo: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "between",
    "description": "Checks if a `bigint` is between a `minimum` and `maximum` value (inclusive).",
    "deprecated": false,
    "examples": [
      "import { BigInt } from \"effect\"\n\nconst between = BigInt.between({ minimum: 0n, maximum: 5n })\n\nassert.deepStrictEqual(between(3n), true)\nassert.deepStrictEqual(between(-1n), false)\nassert.deepStrictEqual(between(6n), false)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const between: { (options: { minimum: bigint; maximum: bigint; }): (self: bigint) => boolean; (self: bigint, options: { minimum: bigint; maximum: bigint; }): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "clamp",
    "description": "Restricts the given `bigint` to be within the range specified by the `minimum` and `maximum` values.\n\n- If the `bigint` is less than the `minimum` value, the function returns the `minimum` value.\n- If the `bigint` is greater than the `maximum` value, the function returns the `maximum` value.\n- Otherwise, it returns the original `bigint`.",
    "deprecated": false,
    "examples": [
      "import { BigInt } from \"effect\"\n\nconst clamp = BigInt.clamp({ minimum: 1n, maximum: 5n })\n\nassert.equal(clamp(3n), 3n)\nassert.equal(clamp(0n), 1n)\nassert.equal(clamp(6n), 5n)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const clamp: { (options: { minimum: bigint; maximum: bigint; }): (self: bigint) => bigint; (self: bigint, options: { minimum: bigint; maximum: bigint; }): bigint; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "min",
    "description": "Returns the minimum between two `bigint`s.",
    "deprecated": false,
    "examples": [
      "import { min } from \"effect/BigInt\"\n\nassert.deepStrictEqual(min(2n, 3n), 2n)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const min: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "max",
    "description": "Returns the maximum between two `bigint`s.",
    "deprecated": false,
    "examples": [
      "import { max } from \"effect/BigInt\"\n\nassert.deepStrictEqual(max(2n, 3n), 3n)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const max: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "gcd",
    "description": "Determines the greatest common divisor of two `bigint`s.",
    "deprecated": false,
    "examples": [
      "import { gcd } from \"effect/BigInt\"\n\nassert.deepStrictEqual(gcd(2n, 3n), 1n)\nassert.deepStrictEqual(gcd(2n, 4n), 2n)\nassert.deepStrictEqual(gcd(16n, 24n), 8n)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const gcd: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "lcm",
    "description": "Determines the least common multiple of two `bigint`s.",
    "deprecated": false,
    "examples": [
      "import { lcm } from \"effect/BigInt\"\n\nassert.deepStrictEqual(lcm(2n, 3n), 6n)\nassert.deepStrictEqual(lcm(2n, 4n), 4n)\nassert.deepStrictEqual(lcm(16n, 24n), 48n)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const lcm: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "increment",
    "description": "Returns the result of adding `1n` to a given number.",
    "deprecated": false,
    "examples": [
      "import { increment } from \"effect/BigInt\"\n\nassert.deepStrictEqual(increment(2n), 3n)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "decrement",
    "description": "Decrements a number by `1n`.",
    "deprecated": false,
    "examples": [
      "import { decrement } from \"effect/BigInt\"\n\nassert.deepStrictEqual(decrement(3n), 2n)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "sign",
    "description": "Determines the sign of a given `bigint`.",
    "deprecated": false,
    "examples": [
      "import { sign } from \"effect/BigInt\"\n\nassert.deepStrictEqual(sign(-5n), -1)\nassert.deepStrictEqual(sign(0n), 0)\nassert.deepStrictEqual(sign(5n), 1)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "abs",
    "description": "Determines the absolute value of a given `bigint`.",
    "deprecated": false,
    "examples": [
      "import { abs } from \"effect/BigInt\"\n\nassert.deepStrictEqual(abs(-5n), 5n)\nassert.deepStrictEqual(abs(0n), 0n)\nassert.deepStrictEqual(abs(5n), 5n)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeSqrt",
    "description": "Determines the square root of a given `bigint` unsafely. Throws if the given `bigint` is negative.",
    "deprecated": false,
    "examples": [
      "import { unsafeSqrt } from \"effect/BigInt\"\n\nassert.deepStrictEqual(unsafeSqrt(4n), 2n)\nassert.deepStrictEqual(unsafeSqrt(9n), 3n)\nassert.deepStrictEqual(unsafeSqrt(16n), 4n)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "sqrt",
    "description": "Determines the square root of a given `bigint` safely. Returns `none` if the given `bigint` is negative.",
    "deprecated": false,
    "examples": [
      "import { BigInt, Option } from \"effect\"\n\nassert.deepStrictEqual(BigInt.sqrt(4n), Option.some(2n))\nassert.deepStrictEqual(BigInt.sqrt(9n), Option.some(3n))\nassert.deepStrictEqual(BigInt.sqrt(16n), Option.some(4n))\nassert.deepStrictEqual(BigInt.sqrt(-1n), Option.none())"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "sumAll",
    "description": "Takes an `Iterable` of `bigint`s and returns their sum as a single `bigint",
    "deprecated": false,
    "examples": [
      "import { sumAll } from \"effect/BigInt\"\n\nassert.deepStrictEqual(sumAll([2n, 3n, 4n]), 9n)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "multiplyAll",
    "description": "Takes an `Iterable` of `bigint`s and returns their multiplication as a single `number`.",
    "deprecated": false,
    "examples": [
      "import { multiplyAll } from \"effect/BigInt\"\n\nassert.deepStrictEqual(multiplyAll([2n, 3n, 4n]), 24n)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "toNumber",
    "description": "Takes a `bigint` and returns an `Option` of `number`.\n\nIf the `bigint` is outside the safe integer range for JavaScript (`Number.MAX_SAFE_INTEGER`\nand `Number.MIN_SAFE_INTEGER`), it returns `Option.none()`. Otherwise, it converts the `bigint`\nto a number and returns `Option.some(number)`.",
    "deprecated": false,
    "examples": [
      "import { BigInt as BI, Option } from \"effect\"\n\nassert.deepStrictEqual(BI.toNumber(BigInt(42)), Option.some(42))\nassert.deepStrictEqual(BI.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)), Option.none())\nassert.deepStrictEqual(BI.toNumber(BigInt(Number.MIN_SAFE_INTEGER) - BigInt(1)), Option.none())"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "fromString",
    "description": "Takes a string and returns an `Option` of `bigint`.\n\nIf the string is empty or contains characters that cannot be converted into a `bigint`,\nit returns `Option.none()`, otherwise, it returns `Option.some(bigint)`.",
    "deprecated": false,
    "examples": [
      "import { BigInt as BI, Option } from \"effect\"\n\nassert.deepStrictEqual(BI.fromString(\"42\"), Option.some(BigInt(42)))\nassert.deepStrictEqual(BI.fromString(\" \"), Option.none())\nassert.deepStrictEqual(BI.fromString(\"a\"), Option.none())"
    ],
    "since": "2.4.12",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "BigInt",
      "path": [
        "src",
        "BigInt.ts"
      ]
    },
    "project": "effect",
    "name": "fromNumber",
    "description": "Takes a number and returns an `Option` of `bigint`.\n\nIf the number is outside the safe integer range for JavaScript (`Number.MAX_SAFE_INTEGER`\nand `Number.MIN_SAFE_INTEGER`), it returns `Option.none()`. Otherwise, it attempts to\nconvert the number to a `bigint` and returns `Option.some(bigint)`.",
    "deprecated": false,
    "examples": [
      "import { BigInt as BI, Option } from \"effect\"\n\nassert.deepStrictEqual(BI.fromNumber(42), Option.some(BigInt(42)))\nassert.deepStrictEqual(BI.fromNumber(Number.MAX_SAFE_INTEGER + 1), Option.none())\nassert.deepStrictEqual(BI.fromNumber(Number.MIN_SAFE_INTEGER - 1), Option.none())"
    ],
    "since": "2.4.12",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean",
      "path": [
        "src",
        "Boolean.ts"
      ]
    },
    "project": "effect",
    "name": "isBoolean",
    "description": "Tests if a value is a `boolean`.",
    "deprecated": false,
    "examples": [
      "import { isBoolean } from \"effect/Boolean\"\n\nassert.deepStrictEqual(isBoolean(true), true)\nassert.deepStrictEqual(isBoolean(\"true\"), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isBoolean: (input: unknown) => input is boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean",
      "path": [
        "src",
        "Boolean.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "This function returns the result of either of the given functions depending on the value of the boolean parameter.\nIt is useful when you have to run one of two functions depending on the boolean value.",
    "deprecated": false,
    "examples": [
      "import { Boolean } from \"effect\"\n\nassert.deepStrictEqual(Boolean.match(true, { onFalse: () => \"It's false!\", onTrue: () => \"It's true!\" }), \"It's true!\")"
    ],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "export declare const match: { <A, B = A>(options: { readonly onFalse: LazyArg<A>; readonly onTrue: LazyArg<B>; }): (value: boolean) => A | B; <A, B>(value: boolean, options: { readonly onFalse: LazyArg<A>; readonly onTrue: LazyArg<B>; }): A | B; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean",
      "path": [
        "src",
        "Boolean.ts"
      ]
    },
    "project": "effect",
    "name": "Equivalence",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Equivalence: equivalence.Equivalence<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean",
      "path": [
        "src",
        "Boolean.ts"
      ]
    },
    "project": "effect",
    "name": "Order",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Order: order.Order<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean",
      "path": [
        "src",
        "Boolean.ts"
      ]
    },
    "project": "effect",
    "name": "and",
    "description": "Combines two boolean using AND: `self && that`.",
    "deprecated": false,
    "examples": [
      "import { and } from \"effect/Boolean\"\n\nassert.deepStrictEqual(and(true, true), true)\nassert.deepStrictEqual(and(true, false), false)\nassert.deepStrictEqual(and(false, true), false)\nassert.deepStrictEqual(and(false, false), false)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const and: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean",
      "path": [
        "src",
        "Boolean.ts"
      ]
    },
    "project": "effect",
    "name": "nand",
    "description": "Combines two boolean using NAND: `!(self && that)`.",
    "deprecated": false,
    "examples": [
      "import { nand } from \"effect/Boolean\"\n\nassert.deepStrictEqual(nand(true, true), false)\nassert.deepStrictEqual(nand(true, false), true)\nassert.deepStrictEqual(nand(false, true), true)\nassert.deepStrictEqual(nand(false, false), true)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const nand: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean",
      "path": [
        "src",
        "Boolean.ts"
      ]
    },
    "project": "effect",
    "name": "or",
    "description": "Combines two boolean using OR: `self || that`.",
    "deprecated": false,
    "examples": [
      "import { or } from \"effect/Boolean\"\n\nassert.deepStrictEqual(or(true, true), true)\nassert.deepStrictEqual(or(true, false), true)\nassert.deepStrictEqual(or(false, true), true)\nassert.deepStrictEqual(or(false, false), false)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const or: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean",
      "path": [
        "src",
        "Boolean.ts"
      ]
    },
    "project": "effect",
    "name": "nor",
    "description": "Combines two booleans using NOR: `!(self || that)`.",
    "deprecated": false,
    "examples": [
      "import { nor } from \"effect/Boolean\"\n\nassert.deepStrictEqual(nor(true, true), false)\nassert.deepStrictEqual(nor(true, false), false)\nassert.deepStrictEqual(nor(false, true), false)\nassert.deepStrictEqual(nor(false, false), true)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const nor: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean",
      "path": [
        "src",
        "Boolean.ts"
      ]
    },
    "project": "effect",
    "name": "xor",
    "description": "Combines two booleans using XOR: `(!self && that) || (self && !that)`.",
    "deprecated": false,
    "examples": [
      "import { xor } from \"effect/Boolean\"\n\nassert.deepStrictEqual(xor(true, true), false)\nassert.deepStrictEqual(xor(true, false), true)\nassert.deepStrictEqual(xor(false, true), true)\nassert.deepStrictEqual(xor(false, false), false)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const xor: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean",
      "path": [
        "src",
        "Boolean.ts"
      ]
    },
    "project": "effect",
    "name": "eqv",
    "description": "Combines two booleans using EQV (aka XNOR): `!xor(self, that)`.",
    "deprecated": false,
    "examples": [
      "import { eqv } from \"effect/Boolean\"\n\nassert.deepStrictEqual(eqv(true, true), true)\nassert.deepStrictEqual(eqv(true, false), false)\nassert.deepStrictEqual(eqv(false, true), false)\nassert.deepStrictEqual(eqv(false, false), true)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const eqv: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Boolean",
      "path": [
        "src",
        "Boolean.ts"
      ]
    },
    "project": "effect",
    "name": "implies",
    "description": "Combines two booleans using an implication: `(!self || that)`.",
    "deprecated": false,
    "examples": [
      "import { implies } from \"effect/Boolean\"\n\nassert.deepStrictEqual(implies(true, true), true)\nassert.deepStrictEqual(implies(true, false), false)\nassert.deepStrictEqual(implies(false, true), true)\nassert.deepStrictEqual(implies(false, false), true)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const implies: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Boolean",
      "path": [
        "src",
        "Boolean.ts"
      ]
    },
    "project": "effect",
    "name": "not",
    "description": "Negates the given boolean: `!self`",
    "deprecated": false,
    "examples": [
      "import { not } from \"effect/Boolean\"\n\nassert.deepStrictEqual(not(true), false)\nassert.deepStrictEqual(not(false), true)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Boolean",
      "path": [
        "src",
        "Boolean.ts"
      ]
    },
    "project": "effect",
    "name": "every",
    "description": "This utility function is used to check if all the elements in a collection of boolean values are `true`.",
    "deprecated": false,
    "examples": [
      "import { every } from \"effect/Boolean\"\n\nassert.deepStrictEqual(every([true, true, true]), true)\nassert.deepStrictEqual(every([true, false, true]), false)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Boolean",
      "path": [
        "src",
        "Boolean.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": "This utility function is used to check if at least one of the elements in a collection of boolean values is `true`.",
    "deprecated": false,
    "examples": [
      "import { some } from \"effect/Boolean\"\n\nassert.deepStrictEqual(some([true, false, true]), true)\nassert.deepStrictEqual(some([false, false, false]), false)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Brand",
      "path": [
        "src",
        "Brand.ts"
      ]
    },
    "project": "effect",
    "name": "BrandTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const BrandTypeId: typeof BrandTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Brand",
      "path": [
        "src",
        "Brand.ts"
      ]
    },
    "project": "effect",
    "name": "RefinedConstructorsTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const RefinedConstructorsTypeId: typeof RefinedConstructorsTypeId"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Brand",
      "path": [
        "src",
        "Brand.ts"
      ]
    },
    "project": "effect",
    "name": "refined",
    "description": "Returns a `Brand.Constructor` that can construct a branded type from an unbranded value using the provided `refinement`\npredicate as validation of the input data.\n\nIf you don't want to perform any validation but only distinguish between two values of the same type but with different meanings,\nsee {@link nominal}.",
    "deprecated": false,
    "examples": [
      "import { Brand } from \"effect\"\n\ntype Int = number & Brand.Brand<\"Int\">\n\nconst Int = Brand.refined<Int>(\n  (n) => Number.isInteger(n),\n  (n) => Brand.error(`Expected ${n} to be an integer`)\n)\n\nassert.strictEqual(Int(1), 1)\nassert.throws(() => Int(1.1))"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Brand",
      "path": [
        "src",
        "Brand.ts"
      ]
    },
    "project": "effect",
    "name": "error",
    "description": "Returns a `BrandErrors` that contains a single `RefinementError`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Brand",
      "path": [
        "src",
        "Brand.ts"
      ]
    },
    "project": "effect",
    "name": "errors",
    "description": "Takes a variable number of `BrandErrors` and returns a single `BrandErrors` that contains all refinement errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Brand",
      "path": [
        "src",
        "Brand.ts"
      ]
    },
    "project": "effect",
    "name": "nominal",
    "description": "This function returns a `Brand.Constructor` that **does not apply any runtime checks**, it just returns the provided value.\nIt can be used to create nominal types that allow distinguishing between two values of the same type but with different meanings.\n\nIf you also want to perform some validation, see {@link refined}.",
    "deprecated": false,
    "examples": [
      "import { Brand } from \"effect\"\n\ntype UserId = number & Brand.Brand<\"UserId\">\n\nconst UserId = Brand.nominal<UserId>()\n\nassert.strictEqual(UserId(1), 1)"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Brand",
      "path": [
        "src",
        "Brand.ts"
      ]
    },
    "project": "effect",
    "name": "all",
    "description": "Combines two or more brands together to form a single branded type.\nThis API is useful when you want to validate that the input data passes multiple brand validators.",
    "deprecated": false,
    "examples": [
      "import { Brand } from \"effect\"\n\ntype Int = number & Brand.Brand<\"Int\">\nconst Int = Brand.refined<Int>(\n  (n) => Number.isInteger(n),\n  (n) => Brand.error(`Expected ${n} to be an integer`)\n)\ntype Positive = number & Brand.Brand<\"Positive\">\nconst Positive = Brand.refined<Positive>(\n  (n) => n > 0,\n  (n) => Brand.error(`Expected ${n} to be positive`)\n)\n\nconst PositiveInt = Brand.all(Int, Positive)\n\nassert.strictEqual(PositiveInt(1), 1)\nassert.throws(() => PositiveInt(1.1))"
    ],
    "since": "2.0.0",
    "category": "combining",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Brand",
      "path": [
        "src",
        "Brand.ts"
      ]
    },
    "project": "effect",
    "name": "Brand",
    "description": "A generic interface that defines a branded type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Brand<in out K extends string | symbol> {\n  readonly [BrandTypeId]: {\n    readonly [k in K]: K\n  }\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Brand",
      "path": [
        "src",
        "Brand.ts"
      ]
    },
    "project": "effect",
    "name": "BrandTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type BrandTypeId = typeof BrandTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Brand",
      "path": [
        "src",
        "Brand.ts"
      ]
    },
    "project": "effect",
    "name": "Branded",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "alias",
    "signature": "export type Branded<A, K extends string | symbol> = A & Brand<K>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Brand",
      "path": [
        "src",
        "Brand.ts"
      ]
    },
    "project": "effect",
    "name": "RefinedConstructorsTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type RefinedConstructorsTypeId = typeof RefinedConstructorsTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cache",
      "path": [
        "src",
        "Cache.ts"
      ]
    },
    "project": "effect",
    "name": "CacheTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const CacheTypeId: typeof CacheTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cache",
      "path": [
        "src",
        "Cache.ts"
      ]
    },
    "project": "effect",
    "name": "ConsumerCacheTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.4",
    "category": "symbols",
    "signature": "export declare const ConsumerCacheTypeId: typeof ConsumerCacheTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cache",
      "path": [
        "src",
        "Cache.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new cache with the specified capacity, time to live, and\nlookup function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly timeToLive: Duration.DurationInput; readonly lookup: Lookup<Key, Value, Error, Environment>; }) => Effect.Effect<Cache<Key, Value, Error>, never, Environment>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cache",
      "path": [
        "src",
        "Cache.ts"
      ]
    },
    "project": "effect",
    "name": "makeWith",
    "description": "Constructs a new cache with the specified capacity, time to live, and\nlookup function, where the time to live can depend on the `Exit` value\nreturned by the lookup function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeWith: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly lookup: Lookup<Key, Value, Error, Environment>; readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput; }) => Effect.Effect<Cache<Key, Value, Error>, never, Environment>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cache",
      "path": [
        "src",
        "Cache.ts"
      ]
    },
    "project": "effect",
    "name": "makeCacheStats",
    "description": "Constructs a new `CacheStats` from the specified values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeCacheStats: (options: { readonly hits: number; readonly misses: number; readonly size: number; }) => CacheStats"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cache",
      "path": [
        "src",
        "Cache.ts"
      ]
    },
    "project": "effect",
    "name": "makeEntryStats",
    "description": "Constructs a new `EntryStats` from the specified values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeEntryStats: (loadedMillis: number) => EntryStats"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cache",
      "path": [
        "src",
        "Cache.ts"
      ]
    },
    "project": "effect",
    "name": "Cache",
    "description": "A `Cache` is defined in terms of a lookup function that, given a key of\ntype `Key`, can either fail with an error of type `Error` or succeed with a\nvalue of type `Value`. Getting a value from the cache will either return\nthe previous result of the lookup function if it is available or else\ncompute a new result with the lookup function, put it in the cache, and\nreturn it.\n\nA cache also has a specified capacity and time to live. When the cache is\nat capacity the least recently accessed values in the cache will be\nremoved to make room for new values. Getting a value with a life older than\nthe specified time to live will result in a new value being computed with\nthe lookup function and returned when available.\n\nThe cache is safe for concurrent access. If multiple fibers attempt to get\nthe same key the lookup function will only be computed once and the result\nwill be returned to all fibers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Cache<in out Key, in out Value, out Error = never>\n  extends ConsumerCache<Key, Value, Error>, Cache.Variance<Key, Value, Error>\n{\n  /**\n   * Retrieves the value associated with the specified key if it exists.\n   * Otherwise computes the value with the lookup function, puts it in the\n   * cache, and returns it.\n   */\n  get(key: Key): Effect.Effect<Value, Error>\n\n  /**\n   * Retrieves the value associated with the specified key if it exists as a left.\n   * Otherwise computes the value with the lookup function, puts it in the\n   * cache, and returns it as a right.\n   */\n  getEither(key: Key): Effect.Effect<Either<Value, Value>, Error>\n\n  /**\n   * Computes the value associated with the specified key, with the lookup\n   * function, and puts it in the cache. The difference between this and\n   * `get` method is that `refresh` triggers (re)computation of the value\n   * without invalidating it in the cache, so any request to the associated\n   * key can still be served while the value is being re-computed/retrieved\n   * by the lookup function. Additionally, `refresh` always triggers the\n   * lookup function, disregarding the last `Error`.\n   */\n  refresh(key: Key): Effect.Effect<void, Error>\n\n  /**\n   * Associates the specified value with the specified key in the cache.\n   */\n  set(key: Key, value: Value): Effect.Effect<void>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cache",
      "path": [
        "src",
        "Cache.ts"
      ]
    },
    "project": "effect",
    "name": "CacheStats",
    "description": "`CacheStats` represents a snapshot of statistics for the cache as of a\npoint in time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface CacheStats {\n  readonly hits: number\n  readonly misses: number\n  readonly size: number\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cache",
      "path": [
        "src",
        "Cache.ts"
      ]
    },
    "project": "effect",
    "name": "ConsumerCache",
    "description": "A ConsumerCache models a portion of a cache which is safe to share without allowing to create new values or access existing ones.\n\nIt can be used safely to give over control for request management without leaking writer side details.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ConsumerCache<in out Key, out Value, out Error = never>\n  extends Cache.ConsumerVariance<Key, Value, Error>\n{\n  /**\n   * Retrieves the value associated with the specified key if it exists.\n   * Otherwise returns `Option.none`.\n   */\n  getOption(key: Key): Effect.Effect<Option.Option<Value>, Error>\n\n  /**\n   * Retrieves the value associated with the specified key if it exists and the\n   * lookup function has completed. Otherwise returns `Option.none`.\n   */\n  getOptionComplete(key: Key): Effect.Effect<Option.Option<Value>>\n\n  /**\n   * Returns statistics for this cache.\n   */\n  readonly cacheStats: Effect.Effect<CacheStats>\n\n  /**\n   * Returns whether a value associated with the specified key exists in the\n   * cache.\n   */\n  contains(key: Key): Effect.Effect<boolean>\n\n  /**\n   * Returns statistics for the specified entry.\n   */\n  entryStats(key: Key): Effect.Effect<Option.Option<EntryStats>>\n\n  /**\n   * Invalidates the value associated with the specified key.\n   */\n  invalidate(key: Key): Effect.Effect<void>\n\n  /**\n   * Invalidates the value associated with the specified key if the predicate holds.\n   */\n  invalidateWhen(key: Key, predicate: Predicate.Predicate<Value>): Effect.Effect<void>\n\n  /**\n   * Invalidates all values in the cache.\n   */\n  readonly invalidateAll: Effect.Effect<void>\n\n  /**\n   * Returns the approximate number of values in the cache.\n   */\n  readonly size: Effect.Effect<number>\n\n  /**\n   * Returns an approximation of the values in the cache.\n   */\n  readonly keys: Effect.Effect<Array<Key>>\n\n  /**\n   * Returns an approximation of the values in the cache.\n   */\n  readonly values: Effect.Effect<Array<Value>>\n\n  /**\n   * Returns an approximation of the values in the cache.\n   */\n  readonly entries: Effect.Effect<Array<[Key, Value]>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cache",
      "path": [
        "src",
        "Cache.ts"
      ]
    },
    "project": "effect",
    "name": "EntryStats",
    "description": "Represents a snapshot of statistics for an entry in the cache.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface EntryStats {\n  readonly loadedMillis: number\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cache",
      "path": [
        "src",
        "Cache.ts"
      ]
    },
    "project": "effect",
    "name": "CacheTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type CacheTypeId = typeof CacheTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cache",
      "path": [
        "src",
        "Cache.ts"
      ]
    },
    "project": "effect",
    "name": "ConsumerCacheTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.4",
    "category": "symbols",
    "signature": "export type ConsumerCacheTypeId = typeof ConsumerCacheTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cache",
      "path": [
        "src",
        "Cache.ts"
      ]
    },
    "project": "effect",
    "name": "Lookup",
    "description": "A `Lookup` represents a lookup function that, given a key of type `Key`, can\nreturn an effect that will either produce a value of type `Value` or fail\nwith an error of type `Error` using an environment of type `Environment`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type Lookup<Key, Value, Error = never, Environment = never> = (\n  key: Key\n) => Effect.Effect<Value, Error, Environment>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "CauseTypeId",
    "description": "A unique symbol identifying the `Cause` type.\n\n**Details**\n\nThis provides a symbol that helps identify instances of the `Cause` data\ntype. This can be used for advanced operations such as refining types or\nbuilding internal utilities that check whether an unknown value is a `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export declare const CauseTypeId: typeof CauseTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "RuntimeExceptionTypeId",
    "description": "A unique symbol identifying the `RuntimeException` type.\n\n**Details**\n\nThis provides a symbol that identifies a `RuntimeException`. This is\ntypically used internally by the library to recognize checked exceptions that\noccur during runtime.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export declare const RuntimeExceptionTypeId: typeof RuntimeExceptionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "InterruptedExceptionTypeId",
    "description": "A unique symbol identifying the `InterruptedException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `InterruptedException`. This is\ntypically used internally to recognize when a fiber has been interrupted,\nhelping the framework handle interruption logic correctly.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export declare const InterruptedExceptionTypeId: typeof InterruptedExceptionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "IllegalArgumentExceptionTypeId",
    "description": "A unique symbol identifying the `IllegalArgumentException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `IllegalArgumentException`. This is\noften used in scenarios where invalid arguments are supplied to methods that\nexpect specific input.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export declare const IllegalArgumentExceptionTypeId: typeof IllegalArgumentExceptionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "NoSuchElementExceptionTypeId",
    "description": "A unique symbol identifying the `NoSuchElementException` type.\n\n**Details**\n\nThis provides a symbol that identifies a `NoSuchElementException`. It helps\ndifferentiate cases where a required element is missing within a data\nstructure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export declare const NoSuchElementExceptionTypeId: typeof NoSuchElementExceptionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "InvalidPubSubCapacityExceptionTypeId",
    "description": "A unique symbol identifying the `InvalidPubSubCapacityException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `InvalidPubSubCapacityException`.\nIt indicates an error related to an invalid capacity passed to a `PubSub`\nstructure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export declare const InvalidPubSubCapacityExceptionTypeId: typeof InvalidPubSubCapacityExceptionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "ExceededCapacityExceptionTypeId",
    "description": "A unique symbol identifying the `ExceededCapacityException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `ExceededCapacityException`. It\ndenotes situations where a resource has exceeded its configured capacity\nlimit.",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "Symbols",
    "signature": "export declare const ExceededCapacityExceptionTypeId: typeof ExceededCapacityExceptionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "TimeoutExceptionTypeId",
    "description": "A unique symbol identifying the `TimeoutException` type.\n\n**Details**\n\nThis provides a symbol that identifies a `TimeoutException`. It helps the\nframework recognize errors related to operations that fail to complete within\na given timeframe.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export declare const TimeoutExceptionTypeId: typeof TimeoutExceptionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "UnknownExceptionTypeId",
    "description": "A unique symbol identifying the `UnknownException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `UnknownException`. It is typically\nused for generic or unexpected errors that do not fit other specific\nexception categories.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export declare const UnknownExceptionTypeId: typeof UnknownExceptionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "YieldableError",
    "description": "Creates an error that occurs at runtime, extendable for other exception\ntypes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "export declare const YieldableError: new (message?: string | undefined) => YieldableError"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates an `Empty` cause.\n\n**Details**\n\nThis function returns a cause that signifies \"no error.\" It's commonly used\nto represent an absence of failure conditions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const empty: Cause<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": "Creates a `Fail` cause from an expected error.\n\n**Details**\n\nThis function constructs a `Cause` carrying an error of type `E`. It's used\nwhen you want to represent a known or anticipated failure in your effectful\ncomputations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const fail: <E>(error: E) => Cause<E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "die",
    "description": "Creates a `Die` cause from an unexpected error.\n\n**Details**\n\nThis function wraps an unhandled or unknown defect (like a runtime crash)\ninto a `Cause`. It's useful for capturing unforeseen issues in a structured\nway.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const die: (defect: unknown) => Cause<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "interrupt",
    "description": "Creates an `Interrupt` cause from a `FiberId`.\n\n**Details**\n\nThis function represents a fiber that has been interrupted. It stores the\nidentifier of the interrupted fiber, enabling precise tracking of concurrent\ncancellations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const interrupt: (fiberId: FiberId.FiberId) => Cause<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "parallel",
    "description": "Combines two `Cause`s in parallel.\n\n**Details**\n\nThis function merges two errors that occurred simultaneously. Instead of\ndiscarding one error, both are retained, allowing for richer error reporting\nand debugging.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const parallel: <E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "sequential",
    "description": "Combines two `Cause`s sequentially.\n\n**Details**\n\nThis function merges two errors that occurred in sequence, such as a main\nerror followed by a finalization error. It preserves both errors for complete\nfailure information.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const sequential: <E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isCause",
    "description": "Checks if a value is a `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isCause: (u: unknown) => u is Cause<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isEmptyType",
    "description": "Checks if a `Cause` is an `Empty` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isEmptyType: <E>(self: Cause<E>) => self is Empty"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isFailType",
    "description": "Checks if a `Cause` is a `Fail` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isFailType: <E>(self: Cause<E>) => self is Fail<E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isDieType",
    "description": "Checks if a `Cause` is a `Die` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isDieType: <E>(self: Cause<E>) => self is Die"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isInterruptType",
    "description": "Checks if a `Cause` is an `Interrupt` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isInterruptType: <E>(self: Cause<E>) => self is Interrupt"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isSequentialType",
    "description": "Checks if a `Cause` is a `Sequential` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isSequentialType: <E>(self: Cause<E>) => self is Sequential<E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isParallelType",
    "description": "Checks if a `Cause` is a `Parallel` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isParallelType: <E>(self: Cause<E>) => self is Parallel<E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Calculates the size of a `Cause`.\n\n**Details**\n\nThis function returns the total number of `Cause` nodes in the semiring\nstructure, reflecting how many individual error elements are recorded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const size: <E>(self: Cause<E>) => number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Checks if a `Cause` is entirely empty.\n\n**Details**\n\nThis function returns `true` if the `Cause` contains no errors, defects, or\ninterruptions. It's helpful for verifying if a computation truly had no\nfailures.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const isEmpty: <E>(self: Cause<E>) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isFailure",
    "description": "Checks if a `Cause` contains a failure.\n\n**Details**\n\nThis function returns `true` if the `Cause` includes any `Fail` error. It's\ncommonly used to confirm whether a workflow encountered an anticipated error\nversus just defects or interruptions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const isFailure: <E>(self: Cause<E>) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isDie",
    "description": "Checks if a `Cause` contains a defect.\n\n**Details**\n\nThis function returns `true` if the `Cause` includes any unexpected or\nunhandled errors (`Die`). It's useful for differentiating known failures from\nunexpected ones.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const isDie: <E>(self: Cause<E>) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isInterrupted",
    "description": "Checks if a `Cause` contains an interruption.\n\n**Details**\n\nThis function returns `true` if the `Cause` includes any fiber interruptions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const isInterrupted: <E>(self: Cause<E>) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isInterruptedOnly",
    "description": "Checks if a `Cause` contains only interruptions.\n\n**Details**\n\nThis function returns `true` if the `Cause` has been interrupted but does not\ncontain any other failures, such as `Fail` or `Die`. It's helpful for\nverifying purely \"cancellation\" scenarios.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const isInterruptedOnly: <E>(self: Cause<E>) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "failures",
    "description": "Extracts all recoverable errors of type `E` from a `Cause`.\n\n**Details**\n\nThis function returns a chunk of errors, providing a list of all `Fail`\nvalues found in the cause. It's useful for collecting all known failures for\nlogging or combined error handling.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const failures: <E>(self: Cause<E>) => Chunk.Chunk<E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "defects",
    "description": "Extracts all unrecoverable defects from a `Cause`.\n\n**Details**\n\nThis function returns a chunk of values representing unexpected errors\n(`Die`). It's handy for capturing or logging unanticipated failures that\nmight need special handling, such as bug reports.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const defects: <E>(self: Cause<E>) => Chunk.Chunk<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "interruptors",
    "description": "Collects all `FiberId`s responsible for interrupting a fiber.\n\n**Details**\n\nThis function returns a set of IDs indicating which fibers caused\ninterruptions within this `Cause`. It's useful for debugging concurrency\nissues or tracing cancellations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const interruptors: <E>(self: Cause<E>) => HashSet.HashSet<FiberId.FiberId>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "failureOption",
    "description": "Retrieves the first `Fail` error in a `Cause`, if present.\n\n**Details**\n\nThis function returns an `Option` containing the first recoverable error\n(`E`) from the cause. It's often used to quickly check if there's a primary\nerror to handle or display.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const failureOption: <E>(self: Cause<E>) => Option.Option<E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "failureOrCause",
    "description": "Splits a `Cause` into either its first `Fail` error or the rest of the cause\n(which might only contain `Die` or `Interrupt`).\n\n**Details**\n\nThis function either returns the checked error (`E`) or the remaining\n`Cause<never>` with defects/interruptions. It helps you decide if there's a\nrecoverable path or if only unhandled issues remain.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const failureOrCause: <E>(self: Cause<E>) => Either.Either<Cause<never>, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "flipCauseOption",
    "description": "Strips out failures with an error of `None` from a `Cause<Option<E>>`.\n\n**Details**\n\nThis function turns a `Cause<Option<E>>` into an `Option<Cause<E>>`. If the\ncause only contains failures of `None`, it becomes `None`; otherwise, it\nreturns a `Cause` of the remaining errors. It's helpful when working with\noptional errors and filtering out certain error paths.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const flipCauseOption: <E>(self: Cause<Option.Option<E>>) => Option.Option<Cause<E>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "dieOption",
    "description": "Retrieves the first `Die` defect in a `Cause`, if present.\n\n**Details**\n\nThis function returns an `Option` containing the first unexpected failure\n(`Die`) discovered. It's helpful for diagnosing the primary defect in a chain\nof errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const dieOption: <E>(self: Cause<E>) => Option.Option<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "interruptOption",
    "description": "Retrieves the first `Interrupt` in a `Cause`, if present.\n\n**Details**\n\nThis function returns an `Option` with the first fiber interruption\ndiscovered. This is particularly useful for concurrency analysis or debugging\ncancellations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const interruptOption: <E>(self: Cause<E>) => Option.Option<FiberId.FiberId>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "keepDefects",
    "description": "Removes all `Fail` and `Interrupt` nodes, keeping only defects (`Die`) in a\n`Cause`.\n\n**Details**\n\nThis function strips a cause of recoverable errors and interruptions, leaving\nonly unexpected failures. If no defects remain, it returns `None`. It's\nvaluable for focusing only on unanticipated problems when both known errors\nand defects could occur.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const keepDefects: <E>(self: Cause<E>) => Option.Option<Cause<never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "linearize",
    "description": "Linearizes a `Cause` into a set of parallel causes, each containing a\nsequential chain of failures.\n\n**Details**\n\nThis function reorganizes the cause structure so that you can analyze each\nparallel branch separately, even if they have multiple sequential errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const linearize: <E>(self: Cause<E>) => HashSet.HashSet<Cause<E>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "stripFailures",
    "description": "Removes `Fail` and `Interrupt` nodes from a `Cause`, keeping only defects\n(`Die`).\n\n**Details**\n\nThis function is similar to `keepDefects` but returns a `Cause<never>`\ndirectly, which can still store `Die` or finalizer-related defects. It's\nhelpful for analyzing only the irrecoverable portion of the error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const stripFailures: <E>(self: Cause<E>) => Cause<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "stripSomeDefects",
    "description": "Removes matching defects from a `Cause` using a partial function, returning\nthe remainder.\n\n**Details**\n\nThis function applies a user-defined extraction function to each defect\n(`Die`). If the function matches the defect, that defect is removed. If all\ndefects match, the result is `None`. Otherwise, you get a `Cause` with the\nunmatched defects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const stripSomeDefects: { (pf: (defect: unknown) => Option.Option<unknown>): <E>(self: Cause<E>) => Option.Option<Cause<E>>; <E>(self: Cause<E>, pf: (defect: unknown) => Option.Option<unknown>): Option.Option<Cause<E>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "as",
    "description": "Replaces any errors in a `Cause` with a provided constant error.\n\n**Details**\n\nThis function transforms all `Fail` errors into the specified error value,\npreserving the structure of the `Cause`. It's useful when you no longer need\nthe original error details but still want to keep the cause shape.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const as: { <E2>(error: E2): <E>(self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, error: E2): Cause<E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms the errors in a `Cause` using a user-provided function.\n\n**Details**\n\nThis function applies `f` to each `Fail` error while leaving defects (`Die`)\nand interruptions untouched. It's useful for changing or simplifying error\ntypes in your effectful workflows.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const map: { <E, E2>(f: (e: E) => E2): (self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => E2): Cause<E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Transforms errors in a `Cause` into new causes.\n\n**Details**\n\nThis function applies a function `f` to each `Fail` error, converting it into\na new `Cause`. This is especially powerful for merging or restructuring error\ntypes while preserving or combining cause information.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const flatMap: { <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "andThen",
    "description": "Sequences two `Cause`s. The second `Cause` can be dependent on the result of\nthe first `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const andThen: { <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>; <E2>(f: Cause<E2>): <E>(self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>; <E, E2>(self: Cause<E>, f: Cause<E2>): Cause<E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens a nested `Cause` structure.\n\n**Details**\n\nThis function takes a `Cause<Cause<E>>` and merges the layers into a single\n`Cause<E>`. It's useful for eliminating additional nesting created by\nrepeated transformations or compositions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const flatten: <E>(self: Cause<Cause<E>>) => Cause<E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "contains",
    "description": "Checks if the current `Cause` contains or is equal to another `Cause`.\n\n**Details**\n\nThis function returns `true` if `that` cause is part of or the same as\nthe current `Cause`. It's useful when you need to check for specific\nerror patterns or deduplicate repeated failures.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Elements",
    "signature": "export declare const contains: { <E2>(that: Cause<E2>): <E>(self: Cause<E>) => boolean; <E, E2>(self: Cause<E>, that: Cause<E2>): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "squash",
    "description": "Extracts the most \"important\" defect from a `Cause`.\n\n**Details**\n\nThis function reduces a `Cause` to a single, prioritized defect. It evaluates\nthe `Cause` in the following order of priority:\n\n1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it returns\n   the raw error value.\n2. If there is no failure, it looks for the first defect (e.g., from\n   `Effect.die`).\n3. If neither of the above is present, and the `Cause` stems from an\n   interruption, it creates and returns an `InterruptedException`.\n\nThis function ensures you can always extract a meaningful representation of\nthe primary issue from a potentially complex `Cause` structure.\n\n**When to Use**\n\nUse this function when you need to extract the most relevant error or defect\nfrom a `Cause`, especially in scenarios where multiple errors or defects may\nbe present. It's particularly useful for simplifying error reporting or\nlogging.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Destructors",
    "signature": "export declare const squash: <E>(self: Cause<E>) => unknown"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "squashWith",
    "description": "Extracts the most \"important\" defect from a `Cause`, transforming failures\ninto defects using a provided function.\n\n**Details**\n\nThis function reduces a `Cause` to a single, prioritized defect, while\nallowing you to transform recoverable failures into defects through a custom\nfunction. It processes the `Cause` in the following order:\n\n1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it applies\n   the provided function `f` to the error to transform it into a defect.\n2. If there is no failure, it looks for the first defect (e.g., from\n   `Effect.die`) and returns it.\n3. If neither is present and the `Cause` stems from an interruption, it\n   returns an `InterruptedException`.\n\nThis function is particularly useful when you need custom handling or\ntransformation of errors while processing a `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Destructors",
    "signature": "export declare const squashWith: { <E>(f: (error: E) => unknown): (self: Cause<E>) => unknown; <E>(self: Cause<E>, f: (error: E) => unknown): unknown; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "find",
    "description": "Searches a `Cause` using a partial function to extract information.\n\n**Details**\n\nThis function allows you to search through a `Cause` using a custom partial\nfunction. The partial function is applied to the `Cause`, and if it matches,\nthe result is returned wrapped in a `Some`. If no match is found, the result\nis `None`.\n\nThis is particularly useful when you are only interested in specific types of\nerrors, defects, or interruption causes within a potentially complex `Cause`\nstructure. By leveraging a partial function, you can focus on extracting only\nthe relevant information you care about.\n\nThe partial function should return an `Option` indicating whether it matched\nand the value it extracted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Elements",
    "signature": "export declare const find: { <E, Z>(pf: (cause: Cause<E>) => Option.Option<Z>): (self: Cause<E>) => Option.Option<Z>; <E, Z>(self: Cause<E>, pf: (cause: Cause<E>) => Option.Option<Z>): Option.Option<Z>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": "Preserves parts of a `Cause` that match a given predicate.\n\n**Details**\n\nThis function allows you to retain only the parts of a `Cause` structure that\nmatch a specified predicate or refinement. Any parts of the `Cause` that do\nnot match the provided condition are excluded from the result.\n\nYou can use this function in two ways:\n- With a `Predicate`: A function that evaluates whether a `Cause` should be\n  retained based on its value.\n- With a `Refinement`: A more specific predicate that can refine the type of\n  the `Cause`.\n\nThis is useful when you need to extract specific types of errors, defects, or\ninterruptions from a `Cause` while discarding unrelated parts.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "export declare const filter: { <E, EB extends E>(refinement: Refinement<Cause<NoInfer<E>>, Cause<EB>>): (self: Cause<E>) => Cause<EB>; <E>(predicate: Predicate<Cause<NoInfer<E>>>): (self: Cause<E>) => Cause<E>; <E, EB extends E>(self: Cause<E>, refinement: Refinement<Cause<E>, Cause<EB>>): Cause<EB>; <E>(self: Cause<E>, predicate: Predicate<Cause<E>>): Cause<E>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Transforms a `Cause` into a single value using custom handlers for each\npossible case.\n\n**Details**\n\nThis function processes a `Cause` by applying a set of custom handlers to\neach possible type of cause: `Empty`, `Fail`, `Die`, `Interrupt`,\n`Sequential`, and `Parallel`. The result of this function is a single value\nof type `Z`. This function allows you to define exactly how to handle each\npart of a `Cause`, whether it's a failure, defect, interruption, or a\ncombination of these.\n\nThe options parameter provides handlers for:\n- `onEmpty`: Handles the case where the cause is `Empty`, meaning no errors\n  occurred.\n- `onFail`: Processes a failure with an error of type `E`.\n- `onDie`: Processes a defect (unexpected error).\n- `onInterrupt`: Handles a fiber interruption, providing the `FiberId` of the\n  interruption.\n- `onSequential`: Combines two sequential causes into a single value of type\n  `Z`.\n- `onParallel`: Combines two parallel causes into a single value of type `Z`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Matching",
    "signature": "export declare const match: { <Z, E>(options: { readonly onEmpty: Z; readonly onFail: (error: E) => Z; readonly onDie: (defect: unknown) => Z; readonly onInterrupt: (fiberId: FiberId.FiberId) => Z; readonly onSequential: (left: Z, right: Z) => Z; readonly onParallel: (left: Z, right: Z) => Z; }): (self: Cause<E>) => Z; <Z, E>(self: Cause<E>, options: { readonly onEmpty: Z; readonly onFail: (error: E) => Z; readonly onDie: (defect: unknown) => Z; readonly onInterrupt: (fiberId: FiberId.FiberId) => Z; readonly onSequential: (left: Z, right: Z) => Z; readonly onParallel: (left: Z, right: Z) => Z; }): Z; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": "Combines all parts of a `Cause` into a single value by starting with an\ninitial value.\n\n**Details**\n\nThis function processes a `Cause` by starting with an initial value (`zero`)\nand applying a custom function (`pf`) to combine all elements of the `Cause`\ninto a single result of type `Z`. The custom function determines how each\npart of the `Cause` contributes to the final result. The function can return\nan `Option` to either continue combining values or skip specific parts of the\n`Cause`.\n\nThis function is useful for tasks such as:\n- Aggregating error messages from a `Cause` into a single string.\n- Summarizing the structure of a `Cause` into a simplified result.\n- Filtering or processing only specific parts of a `Cause`.\n\nThe reduction proceeds in a top-down manner, visiting all nodes in the\n`Cause` structure. This gives you complete control over how each part of the\n`Cause` contributes to the final result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Reducing",
    "signature": "export declare const reduce: { <Z, E>(zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option.Option<Z>): (self: Cause<E>) => Z; <Z, E>(self: Cause<E>, zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option.Option<Z>): Z; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "reduceWithContext",
    "description": "Combines all parts of a `Cause` into a single value using a custom reducer\nand a context.\n\n**Details**\n\nThis function allows you to reduce a `Cause` into a single value of type `Z`\nusing a custom `CauseReducer`. A `CauseReducer` provides methods to handle\nspecific parts of the `Cause`, such as failures, defects, or interruptions.\nAdditionally, this function provides access to a `context` value, which can\nbe used to carry information or maintain state during the reduction process.\n\nThis is particularly useful when the reduction process needs additional\ncontext or configuration, such as:\n- Aggregating error details with dynamic formatting.\n- Collecting logs or statistics about the `Cause`.\n- Performing stateful transformations based on the `context`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Reducing",
    "signature": "export declare const reduceWithContext: { <C, E, Z>(context: C, reducer: CauseReducer<C, E, Z>): (self: Cause<E>) => Z; <C, E, Z>(self: Cause<E>, context: C, reducer: CauseReducer<C, E, Z>): Z; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "InterruptedException",
    "description": "Creates an error that indicates a `Fiber` was interrupted.\n\n**Details**\n\nThis function constructs an `InterruptedException` recognized by the Effect\nruntime. It is usually thrown or returned when a fiber's execution is\ninterrupted by external events or by another fiber. This is particularly\nhelpful in concurrent programs where fibers may halt each other before\ncompletion.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "export declare const InterruptedException: new (message?: string | undefined) => InterruptedException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isInterruptedException",
    "description": "Checks if a given unknown value is an `InterruptedException`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isInterruptedException: (u: unknown) => u is InterruptedException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "IllegalArgumentException",
    "description": "Creates an error indicating an invalid method argument.\n\n**Details**\n\nThis function constructs an `IllegalArgumentException`. It is typically\nthrown or returned when an operation receives improper inputs, such as\nout-of-range values or invalid object states.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "export declare const IllegalArgumentException: new (message?: string | undefined) => IllegalArgumentException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isIllegalArgumentException",
    "description": "Checks if a given unknown value is an `IllegalArgumentException`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isIllegalArgumentException: (u: unknown) => u is IllegalArgumentException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "NoSuchElementException",
    "description": "Creates an error indicating a missing element.\n\n**Details**\n\nThis function constructs a `NoSuchElementException`. It helps you clearly\ncommunicate that a required element is unavailable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "export declare const NoSuchElementException: new (message?: string | undefined) => NoSuchElementException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isNoSuchElementException",
    "description": "Checks if a given unknown value is a `NoSuchElementException`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isNoSuchElementException: (u: unknown) => u is NoSuchElementException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "RuntimeException",
    "description": "Creates an error for general runtime errors.\n\n**Details**\n\nThis function constructs a `RuntimeException`, for errors that occur at\nruntime but are not specifically typed or categorized as interruptions,\nmissing elements, or invalid arguments. It helps unify a wide range of\nunexpected conditions under a single, recognizable error type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "export declare const RuntimeException: new (message?: string | undefined) => RuntimeException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isRuntimeException",
    "description": "Checks if a given unknown value is a `RuntimeException`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isRuntimeException: (u: unknown) => u is RuntimeException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "TimeoutException",
    "description": "Creates an error for operations that exceed their expected time.\n\n**Details**\n\nThis function constructs a `TimeoutException`. It is typically used to signal\nthat an operation or fiber did not complete within a designated time limit,\nallowing you to handle slow or hanging processes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "export declare const TimeoutException: new (message?: string | undefined) => TimeoutException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "UnknownException",
    "description": "Creates an instance of `UnknownException`, an error object used to handle\nunknown errors such as those from rejected promises.\n\n**Details**\n\nThis function constructs an `UnknownException` with flexible behavior for\nmanaging the error message and cause.\n\nThe required `error` argument is passed as the `cause` to the global `Error`\nconstructor, ensuring that the original cause is preserved in the error chain\nfor debugging purposes. This ensures that the origin stack trace is\npreserved.\n\nThe `error` argument is always stored in the `error` property of the\n`UnknownException` instance for reference, regardless of its type.\n\nAdditionally, if you provide a `message` argument, it is used as the error\nmessage. If no `message` is provided, the error message defaults to `\"An\nunknown error occurred\"`.\n\n**When to Use**\n\nUse this function when you need to handle unexpected or unknown errors in\nyour application, particularly when the source of the error might not provide\na clear message. This is useful for wrapping generic errors thrown from\npromises or external APIs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "export declare const UnknownException: new (error: unknown, message?: string | undefined) => UnknownException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isUnknownException",
    "description": "Checks if a given unknown value is an `UnknownException`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isUnknownException: (u: unknown) => u is UnknownException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "ExceededCapacityException",
    "description": "Creates an error indicating resource capacity has been exceeded.\n\n**Details**\n\nThis function constructs an `ExceededCapacityException`, signifying that an\noperation or resource usage surpassed established limits. This can be\nessential for concurrency or resource management situations, ensuring your\napplication doesn't go beyond acceptable thresholds.",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "Errors",
    "signature": "export declare const ExceededCapacityException: new (message?: string | undefined) => ExceededCapacityException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "isExceededCapacityException",
    "description": "Checks if a given unknown value is an `ExceededCapacityException`.",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "Guards",
    "signature": "export declare const isExceededCapacityException: (u: unknown) => u is ExceededCapacityException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "pretty",
    "description": "Converts a `Cause` into a human-readable string.\n\n**Details**\n\nThis function pretty-prints the entire `Cause`, including any failures,\ndefects, and interruptions. It can be especially helpful for logging,\ndebugging, or displaying structured errors to users.\n\nYou can optionally pass `options` to configure how the error cause is\nrendered. By default, it includes essential details of all errors in the\n`Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Formatting",
    "signature": "export declare const pretty: <E>(cause: Cause<E>, options?: { readonly renderErrorCause?: boolean | undefined; }) => string"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "prettyErrors",
    "description": "Returns a list of prettified errors (`PrettyError`) from a `Cause`.\n\n**Details**\n\nThis function inspects the entire `Cause` and produces an array of\n`PrettyError` objects. Each object may include additional metadata, such as a\n`Span`, to provide deeper insights into where and how the error occurred.",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": "Formatting",
    "signature": "export declare const prettyErrors: <E>(cause: Cause<E>) => Array<PrettyError>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "originalError",
    "description": "Retrieves the original, unproxied error instance from an error object.\n\n**Details**\n\nThis function returns the underlying error object without any\nlibrary-specific wrapping or proxying that might occur during error handling.\nThis can be essential if you need direct access to the error's native\nproperties, such as stack traces or custom data fields, for detailed\ndebugging or integration with external systems.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Errors",
    "signature": "export declare const originalError: <E>(obj: E) => E"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "CauseReducer",
    "description": "Describes methods for reducing a `Cause<E>` into a value of type `Z` with\naccess to contextual information.\n\n**Details**\n\nThis interface is meant for advanced transformations of `Cause`. By\nimplementing each method, you can define how different parts of the `Cause`\nstructure (like `Fail`, `Die`, or `Interrupt`) should be transformed into a\nfinal type `Z`. The `context` parameter carries additional data needed during\nthis reduction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface CauseReducer<in C, in E, in out Z> {\n  emptyCase(context: C): Z\n  failCase(context: C, error: E): Z\n  dieCase(context: C, defect: unknown): Z\n  interruptCase(context: C, fiberId: FiberId.FiberId): Z\n  sequentialCase(context: C, left: Z, right: Z): Z\n  parallelCase(context: C, left: Z, right: Z): Z\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "Die",
    "description": "Represents an unexpected defect within a `Cause`.\n\n**Details**\n\nThis interface models a `Cause` for errors that are typically unrecoverable or\nunanticipatedlike runtime exceptions or bugs. When code \"dies,\" it indicates a\nsevere failure that wasn't accounted for.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Die extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Die\"\n  readonly defect: unknown\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "Empty",
    "description": "Represents a lack of errors within a `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Empty extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Empty\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "ExceededCapacityException",
    "description": "An error that occurs when resource capacity is exceeded.",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "Models",
    "signature": "export interface ExceededCapacityException extends YieldableError {\n  readonly _tag: \"ExceededCapacityException\"\n  readonly [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "Fail",
    "description": "Represents an expected error within a `Cause`.\n\n**Details**\n\nThis interface models a `Cause` that carries an expected or known error of\ntype `E`. For example, if you validate user input and find it invalid, you\nmight store that error within a `Fail`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Fail<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Fail\"\n  readonly error: E\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "IllegalArgumentException",
    "description": "An error representing an invalid argument passed to a method.\n\n**Details**\n\nThis interface is used for signaling that a function or method received an\nargument that does not meet its preconditions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface IllegalArgumentException extends YieldableError {\n  readonly _tag: \"IllegalArgumentException\"\n  readonly [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "Interrupt",
    "description": "Represents fiber interruption within a `Cause`.\n\n**Details**\n\nThis interface models a scenario where an effect was halted by an external\nsignal, carrying a `FiberId` that identifies which fiber was interrupted.\nInterruption is a normal part of concurrency, used for cancellation or\nresource cleanup.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Interrupt extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Interrupt\"\n  readonly fiberId: FiberId.FiberId\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "InterruptedException",
    "description": "An error representing fiber interruption.\n\n**Details**\n\nThis interface represents errors that occur when a fiber is forcefully\ninterrupted. Interruption can happen for various reasons, including\ncancellations or system directives to halt operations. Code that deals with\nconcurrency might need to catch or handle these to ensure proper cleanup.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface InterruptedException extends YieldableError {\n  readonly _tag: \"InterruptedException\"\n  readonly [InterruptedExceptionTypeId]: InterruptedExceptionTypeId\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "InvalidPubSubCapacityException",
    "description": "An error indicating invalid capacity for a `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface InvalidPubSubCapacityException extends YieldableError {\n  readonly _tag: \"InvalidPubSubCapacityException\"\n  readonly [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "NoSuchElementException",
    "description": "An error that occurs when an expected element is missing.\n\n**Details**\n\nThis interface indicates scenarios like looking up an item in a collection\nor searching for data that should be present but isn't. It helps your code\nsignal a more specific issue rather than a general error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface NoSuchElementException extends YieldableError {\n  readonly _tag: \"NoSuchElementException\"\n  readonly [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "Parallel",
    "description": "Represents parallel composition of two `Cause`s.\n\n**Details**\n\nThis interface captures failures that happen simultaneously. In scenarios\nwith concurrency, more than one operation can fail in parallel. Instead of\nlosing information, this structure stores both errors together.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Parallel<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Parallel\"\n  readonly left: Cause<E>\n  readonly right: Cause<E>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "PrettyError",
    "description": "A shape for prettified errors, optionally including a source span.",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": "Models",
    "signature": "export interface PrettyError extends Error {\n  readonly span: Span | undefined\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "RuntimeException",
    "description": "An error representing a runtime error.\n\n**Details**\n\nThis interface is used for errors that occur at runtime but are still\nconsidered recoverable or typed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface RuntimeException extends YieldableError {\n  readonly _tag: \"RuntimeException\"\n  readonly [RuntimeExceptionTypeId]: RuntimeExceptionTypeId\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "Sequential",
    "description": "Represents sequential composition of two `Cause`s.\n\n**Details**\n\nThis interface models the scenario where one error follows another in\nsequence, such as when a main effect fails and then a finalizer also fails.\nIt ensures both errors are retained in the final `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Sequential<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Sequential\"\n  readonly left: Cause<E>\n  readonly right: Cause<E>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "TimeoutException",
    "description": "An error representing a computation that timed out.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface TimeoutException extends YieldableError {\n  readonly _tag: \"TimeoutException\"\n  readonly [TimeoutExceptionTypeId]: TimeoutExceptionTypeId\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "UnknownException",
    "description": "A checked exception for handling unknown or unexpected errors.\n\n**Details**\n\nThis interface captures errors that don't fall under known categories. It is\nespecially helpful for wrapping low-level or third-party library errors that\nmight provide little or no context, such as from a rejected promise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface UnknownException extends YieldableError {\n  readonly _tag: \"UnknownException\"\n  readonly [UnknownExceptionTypeId]: UnknownExceptionTypeId\n  readonly error: unknown\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "YieldableError",
    "description": "Represents an error object that can be yielded in `Effect.gen`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface YieldableError extends Pipeable, Inspectable, Readonly<Error> {\n  readonly [Effect.EffectTypeId]: Effect.Effect.VarianceStruct<never, this, never>\n  readonly [Stream.StreamTypeId]: Stream.Stream.VarianceStruct<never, this, never>\n  readonly [Sink.SinkTypeId]: Sink.Sink.VarianceStruct<never, unknown, never, this, never>\n  readonly [Channel.ChannelTypeId]: Channel.Channel.VarianceStruct<never, unknown, this, unknown, never, unknown, never>\n  [Symbol.iterator](): Effect.EffectGenerator<Effect.Effect<never, this, never>>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "Cause",
    "description": "Represents the full history of a failure within an `Effect`.\n\n**Details**\n\nThis type is a data structure that captures all information about why and how\nan effect has failed, including parallel errors, sequential errors, defects,\nand interruptions. It enables a \"lossless\" error model: no error-related\ninformation is discarded, which helps in debugging and understanding the root\ncause of failures.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export type Cause<E> =\n  | Empty\n  | Fail<E>\n  | Die\n  | Interrupt\n  | Sequential<E>\n  | Parallel<E>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "CauseTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export type CauseTypeId = typeof CauseTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "ExceededCapacityExceptionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "Symbols",
    "signature": "export type ExceededCapacityExceptionTypeId = typeof ExceededCapacityExceptionTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "IllegalArgumentExceptionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export type IllegalArgumentExceptionTypeId = typeof IllegalArgumentExceptionTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "InterruptedExceptionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export type InterruptedExceptionTypeId = typeof InterruptedExceptionTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "InvalidPubSubCapacityExceptionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export type InvalidPubSubCapacityExceptionTypeId = typeof InvalidPubSubCapacityExceptionTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "NoSuchElementExceptionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export type NoSuchElementExceptionTypeId = typeof NoSuchElementExceptionTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "RuntimeExceptionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export type RuntimeExceptionTypeId = typeof RuntimeExceptionTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "TimeoutExceptionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export type TimeoutExceptionTypeId = typeof TimeoutExceptionTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cause",
      "path": [
        "src",
        "Cause.ts"
      ]
    },
    "project": "effect",
    "name": "UnknownExceptionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export type UnknownExceptionTypeId = typeof UnknownExceptionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "ChannelTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const ChannelTypeId: typeof ChannelTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "ChannelExceptionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const ChannelExceptionTypeId: typeof ChannelExceptionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "isChannel",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.5.4",
    "category": "refinements",
    "signature": "export declare const isChannel: (u: unknown) => u is Channel<unknown, unknown, unknown, unknown, unknown, unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "acquireUseRelease",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const acquireUseRelease: <Acquired, OutErr, Env, OutElem1, InElem, InErr, OutDone, InDone>(acquire: Effect.Effect<Acquired, OutErr, Env>, use: (a: Acquired) => Channel<OutElem1, InElem, OutErr, InErr, OutDone, InDone, Env>, release: (a: Acquired, exit: Exit.Exit<OutDone, OutErr>) => Effect.Effect<any, never, Env>) => Channel<OutElem1, InElem, OutErr, InErr, OutDone, InDone, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "acquireReleaseOut",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const acquireReleaseOut: { <Z, R2>(release: (z: Z, e: Exit.Exit<unknown, unknown>) => Effect.Effect<unknown, never, R2>): <E, R>(self: Effect.Effect<Z, E, R>) => Channel<Z, unknown, E, unknown, void, unknown, R2 | R>; <Z, E, R, R2>(self: Effect.Effect<Z, E, R>, release: (z: Z, e: Exit.Exit<unknown, unknown>) => Effect.Effect<unknown, never, R2>): Channel<Z, unknown, E, unknown, void, unknown, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "as",
    "description": "Returns a new channel that is the same as this one, except the terminal\nvalue of the channel is the specified constant value.\n\nThis method produces the same result as mapping this channel to the\nspecified constant value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const as: { <OutDone2>(value: OutDone2): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, value: OutDone2): Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "asVoid",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const asVoid: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, void, InDone, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "buffer",
    "description": "Creates a channel backed by a buffer. When the buffer is empty, the channel\nwill simply passthrough its input as output. However, when the buffer is\nnon-empty, the value inside the buffer will be passed along as output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const buffer: <InElem, InErr, InDone>(options: { readonly empty: InElem; readonly isEmpty: Predicate<InElem>; readonly ref: Ref.Ref<InElem>; }) => Channel<InElem, InElem, InErr, InErr, InDone, InDone, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "bufferChunk",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const bufferChunk: <InElem, InErr, InDone>(ref: Ref.Ref<Chunk.Chunk<InElem>>) => Channel<Chunk.Chunk<InElem>, Chunk.Chunk<InElem>, InErr, InErr, InDone, InDone>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "catchAll",
    "description": "Returns a new channel that is the same as this one, except if this channel\nerrors for any typed error, then the returned channel will switch over to\nusing the fallback channel returned by the specified error handler.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const catchAll: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(f: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "catchAllCause",
    "description": "Returns a new channel that is the same as this one, except if this channel\nerrors for any typed error, then the returned channel will switch over to\nusing the fallback channel returned by the specified error handler.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const catchAllCause: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(f: (cause: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (cause: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "concatAll",
    "description": "Concat sequentially a channel of channels.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const concatAll: <OutElem, InElem, OutErr, InErr, InDone, Env>(channels: Channel<Channel<OutElem, InElem, OutErr, InErr, any, InDone, Env>, InElem, OutErr, InErr, any, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, any, InDone, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "concatAllWith",
    "description": "Concat sequentially a channel of channels.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const concatAllWith: <OutElem, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, InElem, OutErr, InErr, OutDone2, InDone, Env, OutDone3>(channels: Channel<Channel<OutElem, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutDone, o1: OutDone) => OutDone, g: (o: OutDone, o2: OutDone2) => OutDone3) => Channel<OutElem, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "concatMap",
    "description": "Returns a new channel whose outputs are fed to the specified factory\nfunction, which creates new channels in response. These new channels are\nsequentially concatenated together, and all their outputs appear as outputs\nof the newly returned channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const concatMap: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>): <Env, InErr, InElem, InDone, OutErr, OutDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, unknown, InDone & InDone2, Env2 | Env>; <Env, InErr, InElem, InDone, OutErr, OutDone, OutElem, OutElem2, Env2, InErr2, InElem2, InDone2, OutErr2, X>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, unknown, InDone & InDone2, Env | Env2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "concatMapWith",
    "description": "Returns a new channel whose outputs are fed to the specified factory\nfunction, which creates new channels in response. These new channels are\nsequentially concatenated together, and all their outputs appear as outputs\nof the newly returned channel. The provided merging function is used to\nmerge the terminal values of all channels into the single terminal value of\nthe returned channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const concatMapWith: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone2, OutDone3>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3): <Env, InErr, InElem, InDone, OutErr>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, OutDone3, InDone & InDone2, Env | Env2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "concatMapWithCustom",
    "description": "Returns a new channel whose outputs are fed to the specified factory\nfunction, which creates new channels in response. These new channels are\nsequentially concatenated together, and all their outputs appear as outputs\nof the newly returned channel. The provided merging function is used to\nmerge the terminal values of all channels into the single terminal value of\nthe returned channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const concatMapWithCustom: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone2, OutDone3>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3, onPull: (upstreamPullRequest: UpstreamPullRequest.UpstreamPullRequest<OutElem>) => UpstreamPullStrategy.UpstreamPullStrategy<OutElem2>, onEmit: (elem: OutElem2) => ChildExecutorDecision.ChildExecutorDecision): <Env, InErr, InElem, InDone, OutErr>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3, onPull: (upstreamPullRequest: UpstreamPullRequest.UpstreamPullRequest<OutElem>) => UpstreamPullStrategy.UpstreamPullStrategy<OutElem2>, onEmit: (elem: OutElem2) => ChildExecutorDecision.ChildExecutorDecision): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, OutDone3, InDone & InDone2, Env | Env2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "collect",
    "description": "Returns a new channel, which is the same as this one, except its outputs\nare filtered and transformed by the specified partial function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const collect: { <OutElem, OutElem2>(pf: (o: OutElem) => Option.Option<OutElem2>): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, unknown, never, unknown, void, unknown, never>) => Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, pf: (o: OutElem) => Option.Option<OutElem2>): Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "concatOut",
    "description": "Returns a new channel, which is the concatenation of all the channels that\nare written out by this channel. This method may only be called on channels\nthat output other channels.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const concatOut: <OutElem, InElem, OutErr, InErr, InDone, Env, OutDone>(self: Channel<Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mapInput",
    "description": "Returns a new channel which is the same as this one but applies the given\nfunction to the input channel's done value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mapInput: { <InDone0, InDone>(f: (a: InDone0) => InDone): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InDone0) => InDone): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputEffect",
    "description": "Returns a new channel which is the same as this one but applies the given\neffectual function to the input channel's done value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mapInputEffect: { <InDone0, InDone, InErr, Env1>(f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>): <OutElem, InElem, OutErr, OutDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputError",
    "description": "Returns a new channel which is the same as this one but applies the given\nfunction to the input channel's error value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mapInputError: { <InErr0, InErr>(f: (a: InErr0) => InErr): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InErr0) => InErr): Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputErrorEffect",
    "description": "Returns a new channel which is the same as this one but applies the given\neffectual function to the input channel's error value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mapInputErrorEffect: { <InErr0, InDone, InErr, Env1>(f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>): <OutElem, InElem, OutErr, OutDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>): Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputIn",
    "description": "Returns a new channel which is the same as this one but applies the given\nfunction to the input channel's output elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mapInputIn: { <InElem0, InElem>(f: (a: InElem0) => InElem): <OutElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InElem0) => InElem): Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputInEffect",
    "description": "Returns a new channel which is the same as this one but applies the given\neffectual function to the input channel's output elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mapInputInEffect: { <InElem0, InElem, InErr, Env1>(f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>): <OutElem, OutErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>): Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "doneCollect",
    "description": "Returns a new channel, which is the same as this one, except that all the\noutputs are collected and bundled into a tuple together with the terminal\nvalue of this channel.\n\nAs the channel returned from this channel collects all of this channel's\noutput into an in- memory chunk, it is not safe to call this method on\nchannels that output a large or unbounded number of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const doneCollect: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<never, InElem, OutErr, InErr, [Chunk.Chunk<OutElem>, OutDone], InDone, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "drain",
    "description": "Returns a new channel which reads all the elements from upstream's output\nchannel and ignores them, then terminates with the upstream result value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const drain: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<never, InElem, OutErr, InErr, OutDone, InDone, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "embedInput",
    "description": "Returns a new channel which connects the given `AsyncInputProducer` as\nthis channel's input.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const embedInput: { <InErr, InElem, InDone>(input: SingleProducerAsyncInput.AsyncInputProducer<InErr, InElem, InDone>): <OutElem, OutErr, OutDone, Env>(self: Channel<OutElem, unknown, OutErr, unknown, OutDone, unknown, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>; <OutElem, OutErr, OutDone, Env, InErr, InElem, InDone>(self: Channel<OutElem, unknown, OutErr, unknown, OutDone, unknown, Env>, input: SingleProducerAsyncInput.AsyncInputProducer<InErr, InElem, InDone>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "emitCollect",
    "description": "Returns a new channel that collects the output and terminal value of this\nchannel, which it then writes as output of the returned channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const emitCollect: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<[Chunk.Chunk<OutElem>, OutDone], InElem, OutErr, InErr, void, InDone, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "ensuring",
    "description": "Returns a new channel with an attached finalizer. The finalizer is\nguaranteed to be executed so long as the channel begins execution (and\nregardless of whether or not it completes).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const ensuring: { <Z, Env1>(finalizer: Effect.Effect<Z, never, Env1>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Z, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, finalizer: Effect.Effect<Z, never, Env1>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "ensuringWith",
    "description": "Returns a new channel with an attached finalizer. The finalizer is\nguaranteed to be executed so long as the channel begins execution (and\nregardless of whether or not it completes).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const ensuringWith: { <OutDone, OutErr, Env2>(finalizer: (e: Exit.Exit<OutDone, OutErr>) => Effect.Effect<unknown, never, Env2>): <OutElem, InElem, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, finalizer: (e: Exit.Exit<OutDone, OutErr>) => Effect.Effect<unknown, never, Env2>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "context",
    "description": "Accesses the whole context of the channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const context: <Env>() => Channel<never, unknown, never, unknown, Context.Context<Env>, unknown, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "contextWith",
    "description": "Accesses the context of the channel with the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const contextWith: <Env, OutDone>(f: (env: Context.Context<Env>) => OutDone) => Channel<never, unknown, never, unknown, OutDone, unknown, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "contextWithChannel",
    "description": "Accesses the context of the channel in the context of a channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const contextWithChannel: <Env, OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>(f: (env: Context.Context<Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "contextWithEffect",
    "description": "Accesses the context of the channel in the context of an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const contextWithEffect: <Env, OutDone, OutErr, Env1>(f: (env: Context.Context<Env>) => Effect.Effect<OutDone, OutErr, Env1>) => Channel<never, unknown, OutErr, unknown, OutDone, unknown, Env | Env1>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": "Constructs a channel that fails immediately with the specified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fail: <E>(error: E) => Channel<never, unknown, E, unknown, never, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "failSync",
    "description": "Constructs a channel that succeeds immediately with the specified lazily\nevaluated value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failSync: <E>(evaluate: LazyArg<E>) => Channel<never, unknown, E, unknown, never, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "failCause",
    "description": "Constructs a channel that fails immediately with the specified `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failCause: <E>(cause: Cause.Cause<E>) => Channel<never, unknown, E, unknown, never, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "failCauseSync",
    "description": "Constructs a channel that succeeds immediately with the specified lazily\nevaluated `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Channel<never, unknown, E, unknown, never, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Returns a new channel, which sequentially combines this channel, together\nwith the provided factory function, which creates a second channel based on\nthe terminal value of this channel. The result is a channel that will first\nperform the functions of this channel, before performing the functions of\nthe created channel (including yielding its terminal value).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMap: { <OutDone, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>(f: (d: OutDone) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>): <OutElem, InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone2, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (d: OutDone) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone2, InDone & InDone1, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "flatten",
    "description": "Returns a new channel, which flattens the terminal value of this channel.\nThis function may only be called if the terminal value of this channel is\nanother channel of compatible types.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatten: <OutElem, InElem, OutErr, InErr, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>, InDone, Env>) => Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone2, InDone & InDone1, Env1 | Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "foldChannel",
    "description": "Folds over the result of this channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const foldChannel: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutDone, OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>(options: { readonly onFailure: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSuccess: (done: OutDone) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem2 | OutElem, InElem & InElem1 & InElem2, OutErr1 | OutErr2, InErr & InErr1 & InErr2, OutDone1 | OutDone2, InDone & InDone1 & InDone2, Env1 | Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly onFailure: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSuccess: (done: OutDone) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>; }): Channel<OutElem | OutElem1 | OutElem2, InElem & InElem1 & InElem2, OutErr1 | OutErr2, InErr & InErr1 & InErr2, OutDone1 | OutDone2, InDone & InDone1 & InDone2, Env | Env1 | Env2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "foldCauseChannel",
    "description": "Folds over the result of this channel including any cause of termination.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const foldCauseChannel: { <OutErr, OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1, OutDone, OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>(options: { readonly onFailure: (c: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1>; readonly onSuccess: (o: OutDone) => Channel<OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem2 | OutElem, InElem & InElem1 & InElem2, OutErr2 | OutErr3, InErr & InErr1 & InErr2, OutDone2 | OutDone3, InDone & InDone1 & InDone2, Env1 | Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1, OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly onFailure: (c: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1>; readonly onSuccess: (o: OutDone) => Channel<OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>; }): Channel<OutElem | OutElem1 | OutElem2, InElem & InElem1 & InElem2, OutErr2 | OutErr3, InErr & InErr1 & InErr2, OutDone2 | OutDone3, InDone & InDone1 & InDone2, Env | Env1 | Env2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "fromEffect",
    "description": "Use an effect to end a channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Channel<never, unknown, E, unknown, A, unknown, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "fromEither",
    "description": "Constructs a channel from an `Either`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromEither: <R, L>(either: Either.Either<R, L>) => Channel<never, unknown, L, unknown, R, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "fromInput",
    "description": "Construct a `Channel` from an `AsyncInputConsumer`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromInput: <Err, Elem, Done>(input: SingleProducerAsyncInput.AsyncInputConsumer<Err, Elem, Done>) => Channel<Elem, unknown, Err, unknown, Done, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "fromPubSub",
    "description": "Construct a `Channel` from a `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromPubSub: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<Elem, unknown, Err, unknown, Done, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "fromPubSubScoped",
    "description": "Construct a `Channel` from a `PubSub` within a scoped effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromPubSubScoped: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Effect.Effect<Channel<Elem, unknown, Err, unknown, Done, unknown>, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "fromOption",
    "description": "Construct a `Channel` from an `Option`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromOption: <A>(option: Option.Option<A>) => Channel<never, unknown, Option.Option<never>, unknown, A, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "fromQueue",
    "description": "Construct a `Channel` from a `Queue`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromQueue: <Done, Err, Elem>(queue: Queue.Dequeue<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<Elem, unknown, Err, unknown, Done, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "identity",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const identity: <Elem, Err, Done>() => Channel<Elem, Elem, Err, Err, Done, Done>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "interruptWhen",
    "description": "Returns a new channel, which is the same as this one, except it will be\ninterrupted when the specified effect completes. If the effect completes\nsuccessfully before the underlying channel is done, then the returned\nchannel will yield the success value of the effect as its terminal value.\nOn the other hand, if the underlying channel finishes first, then the\nreturned channel will yield the success value of the underlying channel as\nits terminal value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const interruptWhen: { <OutDone1, OutErr1, Env1>(effect: Effect.Effect<OutDone1, OutErr1, Env1>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, effect: Effect.Effect<OutDone1, OutErr1, Env1>): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "interruptWhenDeferred",
    "description": "Returns a new channel, which is the same as this one, except it will be\ninterrupted when the specified deferred is completed. If the deferred is\ncompleted before the underlying channel is done, then the returned channel\nwill yield the value of the deferred. Otherwise, if the underlying channel\nfinishes first, then the returned channel will yield the value of the\nunderlying channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const interruptWhenDeferred: { <OutDone1, OutErr1>(deferred: Deferred.Deferred<OutDone1, OutErr1>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, deferred: Deferred.Deferred<OutDone1, OutErr1>): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Returns a new channel, which is the same as this one, except the terminal\nvalue of the returned channel is created by applying the specified function\nto the terminal value of this channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <OutDone, OutDone2>(f: (out: OutDone) => OutDone2): <OutElem, InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (out: OutDone) => OutDone2): Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mapEffect",
    "description": "Returns a new channel, which is the same as this one, except the terminal\nvalue of the returned channel is created by applying the specified\neffectful function to the terminal value of this channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapEffect: { <OutDone, OutDone1, OutErr1, Env1>(f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>): <OutElem, InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone1, InDone, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mapError",
    "description": "Returns a new channel, which is the same as this one, except the failure\nvalue of the returned channel is created by applying the specified function\nto the failure value of this channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapError: { <OutErr, OutErr2>(f: (err: OutErr) => OutErr2): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (err: OutErr) => OutErr2): Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mapErrorCause",
    "description": "A more powerful version of `mapError` which also surfaces the `Cause`\nof the channel failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapErrorCause: { <OutErr, OutErr2>(f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>): Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mapOut",
    "description": "Maps the output of this channel using the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapOut: { <OutElem, OutElem2>(f: (o: OutElem) => OutElem2): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => OutElem2): Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mapOutEffect",
    "description": "Creates a channel that is like this channel but the given effectful function\ngets applied to each emitted output element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapOutEffect: { <OutElem, OutElem1, OutErr1, Env1>(f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>): Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mapOutEffectPar",
    "description": "Creates a channel that is like this channel but the given ZIO function gets\napplied to each emitted output element, taking `n` elements at once and\nmapping them in parallel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapOutEffectPar: { <OutElem, OutElem1, OutErr1, Env1>(f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>, n: number): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>, n: number): Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mergeAll",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mergeAll: (options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined; }) => <OutElem, InElem1, OutErr1, InErr1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(channels: Channel<Channel<OutElem, InElem1, OutErr1, InErr1, unknown, InDone1, Env1>, InElem, OutErr, InErr, unknown, InDone, Env>) => Channel<OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mergeAllUnbounded",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mergeAllUnbounded: <OutElem, InElem1, OutErr1, InErr1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(channels: Channel<Channel<OutElem, InElem1, OutErr1, InErr1, unknown, InDone1, Env1>, InElem, OutErr, InErr, unknown, InDone, Env>) => Channel<OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mergeAllUnboundedWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mergeAllUnboundedWith: <OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(channels: Channel<Channel<OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1>, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o1: OutDone, o2: OutDone) => OutDone) => Channel<OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone, InDone & InDone1, Env1 | Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mergeAllWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mergeAllWith: ({ bufferSize, concurrency, mergeStrategy }: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined; }) => <OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(channels: Channel<Channel<OutElem, InElem1, OutErr1, InErr1, OutDone, InDone1, Env1>, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o1: OutDone, o2: OutDone) => OutDone) => Channel<OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone, InDone & InDone1, Env1 | Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mergeMap",
    "description": "Returns a new channel which creates a new channel for each emitted element\nand merges some of them together. Different merge strategies control what\nhappens if there are more than the given maximum number of channels gets\ncreated. See `Channel.mergeAll`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mergeMap: { <OutElem, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(f: (outElem: OutElem) => Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined; }): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (outElem: OutElem) => Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined; }): Channel<OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, unknown, InDone & InDone1, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mergeOut",
    "description": "Returns a new channel which merges a number of channels emitted by this\nchannel using the back pressuring merge strategy. See `Channel.mergeAll`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mergeOut: { (n: number): <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, InElem, OutErr, InErr, OutDone, InDone, Env>, n: number): Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mergeOutWith",
    "description": "Returns a new channel which merges a number of channels emitted by this\nchannel using the back pressuring merge strategy and uses a given function\nto merge each completed subchannel's result value. See\n`Channel.mergeAll`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mergeOutWith: { <OutDone1>(n: number, f: (o1: OutDone1, o2: OutDone1) => OutDone1): <OutElem1, InElem1, OutErr1, InErr1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, InElem, OutErr, InErr, OutDone1, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, InElem, OutErr, InErr, OutDone1, InDone, Env>, n: number, f: (o1: OutDone1, o2: OutDone1) => OutDone1): Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mergeWith",
    "description": "Returns a new channel, which is the merge of this channel and the specified\nchannel, where the behavior of the returned channel on left or right early\ntermination is decided by the specified `leftDone` and `rightDone` merge\ndecisions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mergeWith: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutDone, OutErr, OutErr2, OutDone2, OutErr3, OutDone3>(options: { readonly other: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSelfDone: (exit: Exit.Exit<OutDone, OutErr>) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>; readonly onOtherDone: (ex: Exit.Exit<OutDone1, OutErr1>) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr2 | OutErr3, InErr & InErr1, OutDone2 | OutDone3, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutErr2, OutDone2, OutErr3, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly other: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSelfDone: (exit: Exit.Exit<OutDone, OutErr>) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>; readonly onOtherDone: (ex: Exit.Exit<OutDone1, OutErr1>) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>; }): Channel<OutElem | OutElem1, InElem & InElem1, OutErr2 | OutErr3, InErr & InErr1, OutDone2 | OutDone3, InDone & InDone1, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "never",
    "description": "Returns a channel that never completes",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const never: Channel<never, unknown, never, unknown, never, unknown, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "orDie",
    "description": "Translates channel failure into death of the fiber, making all failures\nunchecked and not a part of the type of the channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orDie: { <E>(error: LazyArg<E>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, error: LazyArg<E>): Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "orDieWith",
    "description": "Keeps none of the errors, and terminates the fiber with them, using the\nspecified function to convert the `OutErr` into a defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orDieWith: { <OutErr>(f: (e: OutErr) => unknown): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (e: OutErr) => unknown): Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "orElse",
    "description": "Returns a new channel that will perform the operations of this one, until\nfailure, and then it will switch over to the operations of the specified\nfallback channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElse: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: LazyArg<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: LazyArg<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "pipeTo",
    "description": "Returns a new channel that pipes the output of this channel into the\nspecified channel. The returned channel has the input type of this channel,\nand the output type of the specified channel, terminating with the value of\nthe specified channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const pipeTo: { <OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>(that: Channel<OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>): <InElem, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>): Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env | Env2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "pipeToOrFail",
    "description": "Returns a new channel that pipes the output of this channel into the\nspecified channel and preserves this channel's failures without providing\nthem to the other channel for observation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const pipeToOrFail: { <OutElem2, OutElem, OutErr2, OutDone2, OutDone, Env2>(that: Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>): <InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem, OutErr2 | OutErr, InErr, OutDone2, InDone, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>): Channel<OutElem2, InElem, OutErr | OutErr2, InErr, OutDone2, InDone, Env | Env2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "provideContext",
    "description": "Provides the channel with its required context, which eliminates its\ndependency on `Env`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideContext: { <Env>(env: Context.Context<Env>): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, never>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, env: Context.Context<Env>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, never>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "provideLayer",
    "description": "Provides a layer to the channel, which translates it to another level.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideLayer: { <Env, OutErr2, Env0>(layer: Layer.Layer<Env, OutErr2, Env0>): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2, Env0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, layer: Layer.Layer<Env, OutErr2, Env0>): Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputContext",
    "description": "Transforms the context being provided to the channel with the specified\nfunction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const mapInputContext: { <Env0, Env>(f: (env: Context.Context<Env0>) => Context.Context<Env>): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (env: Context.Context<Env0>) => Context.Context<Env>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "provideSomeLayer",
    "description": "Splits the context into two parts, providing one part using the\nspecified layer and leaving the remainder `Env0`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideSomeLayer: { <R2, OutErr2, Env0>(layer: Layer.Layer<R2, OutErr2, Env0>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, R>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>) => Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, R, R2, OutErr2, Env0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>, layer: Layer.Layer<R2, OutErr2, Env0>): Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "provideService",
    "description": "Provides the effect with the single service it requires. If the effect\nrequires more than one service use `provideContext` instead.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: Types.NoInfer<S>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, I, S>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, tag: Context.Tag<I, S>, service: Types.NoInfer<S>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "read",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const read: <In>() => Channel<never, In, Option.Option<never>, unknown, In, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "readOrFail",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const readOrFail: <E, In = unknown>(error: E) => Channel<never, In, E, unknown, In, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "readWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const readWith: <InElem, OutElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2, OutElem3, OutErr3, OutDone3, Env3>(options: { readonly onInput: (input: InElem) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>; readonly onFailure: (error: InErr) => Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env2>; readonly onDone: (done: InDone) => Channel<OutElem3, InElem, OutErr3, InErr, OutDone3, InDone, Env3>; }) => Channel<OutElem | OutElem2 | OutElem3, InElem, OutErr | OutErr2 | OutErr3, InErr, OutDone | OutDone2 | OutDone3, InDone, Env | Env2 | Env3>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "readWithCause",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const readWithCause: <InElem, OutElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2, OutElem3, OutErr3, OutDone3, Env3>(options: { readonly onInput: (input: InElem) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>; readonly onFailure: (cause: Cause.Cause<InErr>) => Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env2>; readonly onDone: (done: InDone) => Channel<OutElem3, InElem, OutErr3, InErr, OutDone3, InDone, Env3>; }) => Channel<OutElem | OutElem2 | OutElem3, InElem, OutErr | OutErr2 | OutErr3, InErr, OutDone | OutDone2 | OutDone3, InDone, Env | Env2 | Env3>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "repeated",
    "description": "Creates a channel which repeatedly runs this channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const repeated: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "run",
    "description": "Runs a channel until the end is received.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const run: <OutErr, InErr, OutDone, InDone, Env>(self: Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "runCollect",
    "description": "Run the channel until it finishes with a done value or fails with an error\nand collects its emitted output elements.\n\nThe channel must not read any input.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runCollect: <OutElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<[Chunk.Chunk<OutElem>, OutDone], OutErr, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "runDrain",
    "description": "Runs a channel until the end is received.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runDrain: <OutElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "runScoped",
    "description": "Run the channel until it finishes with a done value or fails with an error.\nThe channel must not read any input or write any output.\n\nClosing the channel, which includes execution of all the finalizers\nattached to the channel will be added to the current scope as a finalizer.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "destructors",
    "signature": "export declare const runScoped: <OutErr, InErr, OutDone, InDone, Env>(self: Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env | Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "scoped",
    "description": "Use a scoped effect to emit an output element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const scoped: <A, E, R>(effect: Effect.Effect<A, E, R>) => Channel<A, unknown, E, unknown, unknown, unknown, Exclude<R, Scope.Scope>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "scopedWith",
    "description": "Use a function that receives a scope and returns an effect to emit an output\nelement. The output element will be the result of the returned effect, if\nsuccessful.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "export declare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect.Effect<A, E, R>) => Channel<A, unknown, E, unknown, unknown, unknown, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "splitLines",
    "description": "Splits strings on newlines. Handles both Windows newlines (`\\r\\n`) and UNIX\nnewlines (`\\n`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const splitLines: <Err, Done>() => Channel<Chunk.Chunk<string>, Chunk.Chunk<string>, Err, Err, Done, Done, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": "Constructs a channel that succeeds immediately with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const succeed: <A>(value: A) => Channel<never, unknown, never, unknown, A, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "suspend",
    "description": "Lazily constructs a channel from the given side effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const suspend: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(evaluate: LazyArg<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "sync",
    "description": "Constructs a channel that succeeds immediately with the specified lazy value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sync: <OutDone>(evaluate: LazyArg<OutDone>) => Channel<never, unknown, never, unknown, OutDone, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "toPubSub",
    "description": "Converts a `Channel` to a `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toPubSub: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<never, Elem, never, Err, unknown, Done>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "toPull",
    "description": "Returns a scoped `Effect` that can be used to repeatedly pull elements from\nthe constructed `Channel`. The pull effect fails with the channel's failure\nin case the channel fails, or returns either the channel's done value or an\nemitted element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toPull: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Scope.Scope | Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "toPullIn",
    "description": "Returns an `Effect` that can be used to repeatedly pull elements from the\nconstructed `Channel` within the provided `Scope`. The pull effect fails\nwith the channel's failure in case the channel fails, or returns either the\nchannel's done value or an emitted element.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "destructors",
    "signature": "export declare const toPullIn: { (scope: Scope.Scope): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, scope: Scope.Scope): Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "toQueue",
    "description": "Converts a `Channel` to a `Queue`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toQueue: <Done, Err, Elem>(queue: Queue.Enqueue<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<never, Elem, never, Err, unknown, Done>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "toSink",
    "description": "Converts this channel to a `Sink`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toSink: <OutElem, InElem, OutErr, InErr, OutDone, Env>(self: Channel<Chunk.Chunk<OutElem>, Chunk.Chunk<InElem>, OutErr, InErr, OutDone, unknown, Env>) => Sink.Sink<OutDone, InElem, OutElem, OutErr, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "toStream",
    "description": "Converts this channel to a `Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toStream: <OutElem, OutErr, OutDone, Env>(self: Channel<Chunk.Chunk<OutElem>, unknown, OutErr, unknown, OutDone, unknown, Env>) => Stream.Stream<OutElem, OutErr, Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "unwrap",
    "description": "Constructs a `Channel` from an effect that will result in a `Channel` if\nsuccessful.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unwrap: <OutElem, InElem, OutErr, InErr, OutDone, InDone, R2, E, R>(channel: Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R2>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | R2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "unwrapScoped",
    "description": "Constructs a `Channel` from a scoped effect that will result in a\n`Channel` if successful.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unwrapScoped: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(self: Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, Env | Exclude<R, Scope.Scope>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "unwrapScopedWith",
    "description": "Constructs a `Channel` from a function which receives a `Scope` and returns\nan effect that will result in a `Channel` if successful.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "export declare const unwrapScopedWith: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | Env>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "updateService",
    "description": "Updates a service in the context of this channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const updateService: { <I, S>(tag: Context.Tag<I, S>, f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>): <OutElem, OutErr, InErr, OutDone, InDone, R>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>) => Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, I | R>; <OutElem, OutErr, InErr, OutDone, InDone, R, I, S>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>, tag: Context.Tag<I, S>, f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>): Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, I | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "withSpan",
    "description": "Wraps the channel with a new span for tracing.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "export declare const withSpan: { (name: string, options?: Tracer.SpanOptions | undefined): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, name: string, options?: Tracer.SpanOptions | undefined): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "write",
    "description": "Writes a single value to the channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const write: <OutElem>(out: OutElem) => Channel<OutElem>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "writeAll",
    "description": "Writes a sequence of values to the channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const writeAll: <OutElems extends Array<any>>(...outs: OutElems) => Channel<OutElems[number]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "writeChunk",
    "description": "Writes a `Chunk` of values to the channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const writeChunk: <OutElem>(outs: Chunk.Chunk<OutElem>) => Channel<OutElem>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Returns a new channel that is the sequential composition of this channel\nand the specified channel. The returned channel terminates with a tuple of\nthe terminal values of both channels.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zip: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, readonly [OutDone, OutDone1], InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, readonly [OutDone, OutDone1], InDone & InDone1, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Returns a new channel that is the sequential composition of this channel\nand the specified channel. The returned channel terminates with the\nterminal value of this channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipLeft: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone, InDone & InDone1, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Returns a new channel that is the sequential composition of this channel\nand the specified channel. The returned channel terminates with the\nterminal value of that channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipRight: { <Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; }): <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; }): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone1, InDone & InDone1, Env | Env1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "ChannelException",
    "description": "Represents a generic checked exception which occurs when a `Channel` is\nexecuted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "errors",
    "signature": "export declare const ChannelException: <E>(error: E) => ChannelException<E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "isChannelException",
    "description": "Returns `true` if the specified value is an `ChannelException`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isChannelException: (u: unknown) => u is ChannelException<unknown>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "void",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const void: Channel<never, unknown, never, unknown, void, unknown, never>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "Channel",
    "description": "A `Channel` is a nexus of I/O operations, which supports both reading and\nwriting. A channel may read values of type `InElem` and write values of type\n`OutElem`. When the channel finishes, it yields a value of type `OutDone`. A\nchannel may fail with a value of type `OutErr`.\n\nChannels are the foundation of Streams: both streams and sinks are built on\nchannels. Most users shouldn't have to use channels directly, as streams and\nsinks are much more convenient and cover all common use cases. However, when\nadding new stream and sink operators, or doing something highly specialized,\nit may be useful to use channels directly.\n\nChannels compose in a variety of ways:\n\n - **Piping**: One channel can be piped to another channel, assuming the\n   input type of the second is the same as the output type of the first.\n - **Sequencing**: The terminal value of one channel can be used to create\n   another channel, and both the first channel and the function that makes\n   the second channel can be composed into a channel.\n - **Concatenating**: The output of one channel can be used to create other\n   channels, which are all concatenated together. The first channel and the\n   function that makes the other channels can be composed into a channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Channel<\n  out OutElem,\n  in InElem = unknown,\n  out OutErr = never,\n  in InErr = unknown,\n  out OutDone = void,\n  in InDone = unknown,\n  out Env = never\n> extends\n  Channel.Variance<\n    OutElem,\n    InElem,\n    OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    Env\n  >,\n  Pipeable\n{\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: ChannelUnify<this>\n  [Unify.ignoreSymbol]?: ChannelUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "ChannelException",
    "description": "Represents a generic checked exception which occurs when a `Channel` is\nexecuted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ChannelException<out E> {\n  readonly _tag: \"ChannelException\"\n  readonly [ChannelExceptionTypeId]: ChannelExceptionTypeId\n  readonly error: E\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "ChannelUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ChannelUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Channel?: () => A[Unify.typeSymbol] extends\n    | Channel<\n      infer OutElem,\n      infer InElem,\n      infer OutErr,\n      infer InErr,\n      infer OutDone,\n      infer InDone,\n      infer Env\n    >\n    | infer _ ? Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>\n    : never\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "ChannelUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ChannelUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Channel?: true\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "ChannelExceptionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type ChannelExceptionTypeId = typeof ChannelExceptionTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Channel",
      "path": [
        "src",
        "Channel.ts"
      ]
    },
    "project": "effect",
    "name": "ChannelTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type ChannelTypeId = typeof ChannelTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision",
      "path": [
        "src",
        "ChildExecutorDecision.ts"
      ]
    },
    "project": "effect",
    "name": "ChildExecutorDecisionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const ChildExecutorDecisionTypeId: typeof ChildExecutorDecisionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision",
      "path": [
        "src",
        "ChildExecutorDecision.ts"
      ]
    },
    "project": "effect",
    "name": "Continue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Continue: (_: void) => ChildExecutorDecision"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision",
      "path": [
        "src",
        "ChildExecutorDecision.ts"
      ]
    },
    "project": "effect",
    "name": "Close",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Close: (value: unknown) => ChildExecutorDecision"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision",
      "path": [
        "src",
        "ChildExecutorDecision.ts"
      ]
    },
    "project": "effect",
    "name": "Yield",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Yield: (_: void) => ChildExecutorDecision"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision",
      "path": [
        "src",
        "ChildExecutorDecision.ts"
      ]
    },
    "project": "effect",
    "name": "isChildExecutorDecision",
    "description": "Returns `true` if the specified value is a `ChildExecutorDecision`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isChildExecutorDecision: (u: unknown) => u is ChildExecutorDecision"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision",
      "path": [
        "src",
        "ChildExecutorDecision.ts"
      ]
    },
    "project": "effect",
    "name": "isContinue",
    "description": "Returns `true` if the specified `ChildExecutorDecision` is a `Continue`,\n`false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isContinue: (self: ChildExecutorDecision) => self is Continue"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision",
      "path": [
        "src",
        "ChildExecutorDecision.ts"
      ]
    },
    "project": "effect",
    "name": "isClose",
    "description": "Returns `true` if the specified `ChildExecutorDecision` is a `Close`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isClose: (self: ChildExecutorDecision) => self is Close"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision",
      "path": [
        "src",
        "ChildExecutorDecision.ts"
      ]
    },
    "project": "effect",
    "name": "isYield",
    "description": "Returns `true` if the specified `ChildExecutorDecision` is a `Yield`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isYield: (self: ChildExecutorDecision) => self is Yield"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ChildExecutorDecision",
      "path": [
        "src",
        "ChildExecutorDecision.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Folds over a `ChildExecutorDecision` to produce a value of type `A`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const match: { <A>(options: { readonly onContinue: () => A; readonly onClose: (value: unknown) => A; readonly onYield: () => A; }): (self: ChildExecutorDecision) => A; <A>(self: ChildExecutorDecision, options: { readonly onContinue: () => A; readonly onClose: (value: unknown) => A; readonly onYield: () => A; }): A; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ChildExecutorDecision",
      "path": [
        "src",
        "ChildExecutorDecision.ts"
      ]
    },
    "project": "effect",
    "name": "Close",
    "description": "Close the current substream with a given value and pass execution to the\nnext substream",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Close extends ChildExecutorDecision.Proto {\n  readonly _tag: \"Close\"\n  readonly value: unknown\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ChildExecutorDecision",
      "path": [
        "src",
        "ChildExecutorDecision.ts"
      ]
    },
    "project": "effect",
    "name": "Continue",
    "description": "Continue executing the current substream",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Continue extends ChildExecutorDecision.Proto {\n  readonly _tag: \"Continue\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ChildExecutorDecision",
      "path": [
        "src",
        "ChildExecutorDecision.ts"
      ]
    },
    "project": "effect",
    "name": "Yield",
    "description": "Pass execution to the next substream. This either pulls a new element\nfrom upstream, or yields to an already created active substream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Yield extends ChildExecutorDecision.Proto {\n  readonly _tag: \"Yield\"\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ChildExecutorDecision",
      "path": [
        "src",
        "ChildExecutorDecision.ts"
      ]
    },
    "project": "effect",
    "name": "ChildExecutorDecision",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type ChildExecutorDecision = Continue | Close | Yield"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ChildExecutorDecision",
      "path": [
        "src",
        "ChildExecutorDecision.ts"
      ]
    },
    "project": "effect",
    "name": "ChildExecutorDecisionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type ChildExecutorDecisionTypeId = typeof ChildExecutorDecisionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "toArray",
    "description": "Converts a `Chunk` into an `Array`. If the provided `Chunk` is non-empty\n(`NonEmptyChunk`), the function will return a `NonEmptyArray`, ensuring the\nnon-empty property is preserved.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "export declare const toArray: <S extends Chunk<any>>(self: S) => S extends NonEmptyChunk<any> ? RA.NonEmptyArray<Chunk.Infer<S>> : Array<Chunk.Infer<S>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "toReadonlyArray",
    "description": "Converts a `Chunk` into a `ReadonlyArray`. If the provided `Chunk` is\nnon-empty (`NonEmptyChunk`), the function will return a\n`NonEmptyReadonlyArray`, ensuring the non-empty property is preserved.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "export declare const toReadonlyArray: <S extends Chunk<any>>(self: S) => S extends NonEmptyChunk<any> ? RA.NonEmptyReadonlyArray<Chunk.Infer<S>> : ReadonlyArray<Chunk.Infer<S>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "reverse",
    "description": "Reverses the order of elements in a `Chunk`.\nImportantly, if the input chunk is a `NonEmptyChunk`, the reversed chunk will also be a `NonEmptyChunk`.",
    "deprecated": false,
    "examples": [
      "import { Chunk } from \"effect\"\n\nconst numbers = Chunk.make(1, 2, 3)\nconst reversedNumbers = Chunk.reverse(numbers)\nassert.deepStrictEqual(reversedNumbers, Chunk.make(3, 2, 1))"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const reverse: <S extends Chunk<any>>(self: S) => Chunk.With<S, Chunk.Infer<S>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "This function provides a safe way to read a value at a particular index from a `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const get: { (index: number): <A>(self: Chunk<A>) => Option<A>; <A>(self: Chunk<A>, index: number): Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeGet",
    "description": "Gets an element unsafely, will throw on out of bounds",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeGet: { (index: number): <A>(self: Chunk<A>) => A; <A>(self: Chunk<A>, index: number): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "append",
    "description": "Appends the specified element to the end of the `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const append: { <A2>(a: A2): <A>(self: Chunk<A>) => NonEmptyChunk<A2 | A>; <A, A2>(self: Chunk<A>, a: A2): NonEmptyChunk<A | A2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "prepend",
    "description": "Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const prepend: { <B>(elem: B): <A>(self: Chunk<A>) => NonEmptyChunk<B | A>; <A, B>(self: Chunk<A>, elem: B): NonEmptyChunk<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "take",
    "description": "Takes the first up to `n` elements from the chunk",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const take: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "drop",
    "description": "Drops the first up to `n` elements from the chunk",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const drop: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "dropRight",
    "description": "Drops the last `n` elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const dropRight: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "dropWhile",
    "description": "Drops all elements so long as the predicate returns true.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const dropWhile: { <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "prependAll",
    "description": "Prepends the specified prefix chunk to the beginning of the specified chunk.\nIf either chunk is non-empty, the result is also a non-empty chunk.",
    "deprecated": false,
    "examples": [
      "import { Chunk } from \"effect\"\n\nassert.deepStrictEqual(\n  Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray),\n  [\"a\", \"b\", 1, 2]\n)"
    ],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const prependAll: { <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>; <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>; <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "appendAll",
    "description": "Concatenates two chunks, combining their elements.\nIf either chunk is non-empty, the result is also a non-empty chunk.",
    "deprecated": false,
    "examples": [
      "import { Chunk } from \"effect\"\n\nassert.deepStrictEqual(\n  Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray),\n  [1, 2, \"a\", \"b\"]\n)"
    ],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const appendAll: { <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>; <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>; <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Returns a filtered and mapped subset of the elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterMap: { <A, B>(f: (a: A, i: number) => Option<B>): (self: Chunk<A>) => Chunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => Option<B>): Chunk<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": "Returns a filtered and mapped subset of the elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "filterMapWhile",
    "description": "Transforms all elements of the chunk for as long as the specified function returns some value",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterMapWhile: { <A, B>(f: (a: A) => Option<B>): (self: Chunk<A>) => Chunk<B>; <A, B>(self: Chunk<A>, f: (a: A) => Option<B>): Chunk<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMap: { <S extends Chunk<any>, T extends Chunk<any>>(f: (a: Chunk.Infer<S>, i: number) => T): (self: S) => Chunk.AndNonEmpty<S, T, Chunk.Infer<T>>; <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => NonEmptyChunk<B>): NonEmptyChunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => Chunk<B>): Chunk<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "Iterates over each element of a `Chunk` and applies a function to it.\n\n**Details**\n\nThis function processes every element of the given `Chunk`, calling the\nprovided function `f` on each element. It does not return a new value;\ninstead, it is primarily used for side effects, such as logging or\naccumulating data in an external variable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const forEach: { <A, B>(f: (a: A, index: number) => B): (self: Chunk<A>) => void; <A, B>(self: Chunk<A>, f: (a: A, index: number) => B): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens a chunk of chunks into a single chunk by concatenating all chunks.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatten: <S extends Chunk<Chunk<any>>>(self: S) => Chunk.Flatten<S>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "chunksOf",
    "description": "Groups elements in chunks of up to `n` elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const chunksOf: { (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>; <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "intersection",
    "description": "Creates a Chunk of unique values that are included in all given Chunks.\n\nThe order and references of result values are determined by the Chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const intersection: { <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A & B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A & B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "head",
    "description": "Returns the first element of this chunk if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const head: <A>(self: Chunk<A>) => Option<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "headNonEmpty",
    "description": "Returns the first element of this non empty chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const headNonEmpty: <A>(self: NonEmptyChunk<A>) => A"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "lastNonEmpty",
    "description": "Returns the last element of this non empty chunk.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "elements",
    "signature": "export declare const lastNonEmpty: <A>(self: NonEmptyChunk<A>) => A"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms the elements of a chunk using the specified mapping function.\nIf the input chunk is non-empty, the resulting chunk will also be non-empty.",
    "deprecated": false,
    "examples": [
      "import { Chunk } from \"effect\"\n\nassert.deepStrictEqual(\n  Chunk.map(Chunk.make(1, 2), (n) => n + 1),\n  Chunk.make(2, 3)\n)"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <S extends Chunk<any>, B>(f: (a: Chunk.Infer<S>, i: number) => B): (self: S) => Chunk.With<S, B>; <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => B): NonEmptyChunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => B): Chunk<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "mapAccum",
    "description": "Statefully maps over the chunk, producing new elements of type `B`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const mapAccum: { <S, A, B>(s: S, f: (s: S, a: A) => readonly [S, B]): (self: Chunk<A>) => [S, Chunk<B>]; <S, A, B>(self: Chunk<A>, s: S, f: (s: S, a: A) => readonly [S, B]): [S, Chunk<B>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "partition",
    "description": "Separate elements based on a predicate that also exposes the index of the element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const partition: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Chunk<A>) => [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Chunk<A>) => [excluded: Chunk<A>, satisfying: Chunk<A>]; <A, B extends A>(self: Chunk<A>, refinement: (a: A, i: number) => a is B): [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]; <A>(self: Chunk<A>, predicate: (a: A, i: number) => boolean): [excluded: Chunk<A>, satisfying: Chunk<A>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "partitionMap",
    "description": "Partitions the elements of this chunk into two chunks using f.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const partitionMap: { <A, B, C>(f: (a: A) => Either<C, B>): (self: Chunk<A>) => [left: Chunk<B>, right: Chunk<C>]; <A, B, C>(self: Chunk<A>, f: (a: A) => Either<C, B>): [left: Chunk<B>, right: Chunk<C>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "sort",
    "description": "Sort the elements of a Chunk in increasing order, creating a new Chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sorting",
    "signature": "export declare const sort: { <B>(O: Order.Order<B>): <A extends B>(self: Chunk<A>) => Chunk<A>; <A extends B, B>(self: Chunk<A>, O: Order.Order<B>): Chunk<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "sortWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sorting",
    "signature": "export declare const sortWith: { <A, B>(f: (a: A) => B, order: Order.Order<B>): (self: Chunk<A>) => Chunk<A>; <A, B>(self: Chunk<A>, f: (a: A) => B, order: Order.Order<B>): Chunk<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "splitAt",
    "description": "Returns two splits of this chunk at the specified index.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "export declare const splitAt: { (n: number): <A>(self: Chunk<A>) => [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]; <A>(self: Chunk<A>, n: number): [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "splitNonEmptyAt",
    "description": "Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.\nThe value of `n` must be `>= 1`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "export declare const splitNonEmptyAt: { (n: number): <A>(self: NonEmptyChunk<A>) => [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]; <A>(self: NonEmptyChunk<A>, n: number): [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "split",
    "description": "Splits this chunk into `n` equally sized chunks.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "export declare const split: { (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>; <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "splitWhere",
    "description": "Splits this chunk on the first element that matches this predicate.\nReturns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "export declare const splitWhere: { <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]; <A>(self: Chunk<A>, predicate: Predicate<A>): [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "takeRight",
    "description": "Takes the last `n` elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const takeRight: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "takeWhile",
    "description": "Takes all elements so long as the predicate returns true.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const takeWhile: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "union",
    "description": "Creates a Chunks of unique values, in order, from all given Chunks.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const union: { <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Zips this chunk pointwise with the specified chunk using the specified combiner.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWith: { <A, B, C>(that: Chunk<B>, f: (a: A, b: B) => C): (self: Chunk<A>) => Chunk<C>; <A, B, C>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => C): Chunk<C>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Zips this chunk pointwise with the specified chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zip: { <B>(that: Chunk<B>): <A>(self: Chunk<A>) => Chunk<[A, B]>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<[A, B]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "remove",
    "description": "Delete the element at the specified index, creating a new `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const remove: { (i: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, i: number): Chunk<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "modifyOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const modifyOption: { <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Option<Chunk<A | B>>; <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Option<Chunk<A | B>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "modify",
    "description": "Apply a function to the element at the specified index, creating a new `Chunk`,\nor returning the input if the index is out of bounds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const modify: { <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Chunk<A | B>; <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Chunk<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "replace",
    "description": "Change the element at the specified index, creating a new `Chunk`,\nor returning the input if the index is out of bounds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const replace: { <B>(i: number, b: B): <A>(self: Chunk<A>) => Chunk<B | A>; <A, B>(self: Chunk<A>, i: number, b: B): Chunk<B | A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "replaceOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const replaceOption: { <B>(i: number, b: B): <A>(self: Chunk<A>) => Option<Chunk<B | A>>; <A, B>(self: Chunk<A>, i: number, b: B): Option<Chunk<B | A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "makeBy",
    "description": "Return a Chunk of length n with element i initialized with f(i).\n\n**Note**. `n` is normalized to an integer >= 1.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeBy: { <A>(f: (i: number) => A): (n: number) => NonEmptyChunk<A>; <A>(n: number, f: (i: number) => A): NonEmptyChunk<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "contains",
    "description": "Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const contains: { <A>(a: A): (self: Chunk<A>) => boolean; <A>(self: Chunk<A>, a: A): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "containsWith",
    "description": "Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Chunk<A>) => boolean; (self: Chunk<A>, a: A): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirst: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "findFirstIndex",
    "description": "Return the first index for which a predicate holds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirstIndex: { <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "findLast",
    "description": "Find the last element for which a predicate holds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findLast: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "findLastIndex",
    "description": "Return the last index for which a predicate holds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findLastIndex: { <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "every",
    "description": "Check if a predicate holds true for every `Chunk` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const every: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => self is Chunk<B>; <A>(predicate: Predicate<A>): (self: Chunk<A>) => boolean; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): self is Chunk<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": "Check if a predicate holds true for some `Chunk` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const some: { <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => self is NonEmptyChunk<A>; <A>(self: Chunk<A>, predicate: Predicate<A>): self is NonEmptyChunk<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "join",
    "description": "Joins the elements together with \"sep\" in the middle.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const join: { (sep: string): (self: Chunk<string>) => string; (self: Chunk<string>, sep: string): string; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduce: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Chunk<A>) => B; <A, B>(self: Chunk<A>, b: B, f: (b: B, a: A, i: number) => B): B; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "reduceRight",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduceRight: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Chunk<A>) => B; <A, B>(self: Chunk<A>, b: B, f: (b: B, a: A, i: number) => B): B; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "difference",
    "description": "Creates a `Chunk` of values not included in the other given `Chunk`.\nThe order and references of result values are determined by the first `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": null,
    "signature": "export declare const difference: { <A>(that: Chunk<A>): (self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, that: Chunk<A>): Chunk<A>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": "Compares the two chunks of equal length using the specified function",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "equivalence",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "isChunk",
    "description": "Checks if `u` is a `Chunk<unknown>`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Builds a `NonEmptyChunk` from an non-empty collection of elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "of",
    "description": "Builds a `NonEmptyChunk` from a single element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `Chunk` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeFromArray",
    "description": "Wraps an array into a chunk without copying, unsafe on mutable arrays",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeFromNonEmptyArray",
    "description": "Wraps an array into a chunk without copying, unsafe on mutable arrays",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "compact",
    "description": "Filter out optional values",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Determines if the chunk is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "isNonEmpty",
    "description": "Determines if the chunk is not empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeHead",
    "description": "Returns the first element of this chunk.\n\nIt will throw an error if the chunk is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "last",
    "description": "Returns the last element of this chunk if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeLast",
    "description": "Returns the last element of this chunk.\n\nIt will throw an error if the chunk is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "separate",
    "description": "Partitions the elements of this chunk into two chunks.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Retireves the size of the chunk",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "tail",
    "description": "Returns every elements after the first.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "tailNonEmpty",
    "description": "Returns every elements after the first.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "dedupe",
    "description": "Remove duplicates from an array, keeping the first occurrence of an element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "dedupeAdjacent",
    "description": "Deduplicates adjacent elements that are identical.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "unzip",
    "description": "Takes a `Chunk` of pairs and return two corresponding `Chunk`s.\n\nNote: The function is reverse of `zip`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "range",
    "description": "Create a non empty `Chunk` containing a range of integers, including both endpoints.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "differenceWith",
    "description": "Creates a `Chunk` of values not included in the other given `Chunk` using the provided `isEquivalent` function.\nThe order and references of result values are determined by the first `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "Chunk",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Chunk<out A> extends Iterable<A>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _A: Covariant<A>\n  }\n  readonly length: number\n  /** @internal */\n  right: Chunk<A>\n  /** @internal */\n  left: Chunk<A>\n  /** @internal */\n  backing: Backing<A>\n  /** @internal */\n  depth: number\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "ChunkTypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface ChunkTypeLambda extends TypeLambda {\n  readonly type: Chunk<this[\"Target\"]>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "NonEmptyChunk",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface NonEmptyChunk<out A> extends Chunk<A>, NonEmptyIterable<A> {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Chunk",
      "path": [
        "src",
        "Chunk.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Clock",
      "path": [
        "src",
        "Clock.ts"
      ]
    },
    "project": "effect",
    "name": "ClockTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const ClockTypeId: typeof ClockTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Clock",
      "path": [
        "src",
        "Clock.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: (_: void) => Clock"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Clock",
      "path": [
        "src",
        "Clock.ts"
      ]
    },
    "project": "effect",
    "name": "sleep",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sleep: (duration: Duration.DurationInput) => Effect.Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Clock",
      "path": [
        "src",
        "Clock.ts"
      ]
    },
    "project": "effect",
    "name": "currentTimeMillis",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const currentTimeMillis: Effect.Effect<number, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Clock",
      "path": [
        "src",
        "Clock.ts"
      ]
    },
    "project": "effect",
    "name": "currentTimeNanos",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const currentTimeNanos: Effect.Effect<bigint, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Clock",
      "path": [
        "src",
        "Clock.ts"
      ]
    },
    "project": "effect",
    "name": "clockWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const clockWith: <A, E, R>(f: (clock: Clock) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Clock",
      "path": [
        "src",
        "Clock.ts"
      ]
    },
    "project": "effect",
    "name": "Clock",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const Clock: Context.Tag<Clock, Clock>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Clock",
      "path": [
        "src",
        "Clock.ts"
      ]
    },
    "project": "effect",
    "name": "Clock",
    "description": "Represents a time-based clock which provides functionality related to time\nand scheduling.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Clock {\n  readonly [ClockTypeId]: ClockTypeId\n  /**\n   * Unsafely returns the current time in milliseconds.\n   */\n  unsafeCurrentTimeMillis(): number\n  /**\n   * Returns the current time in milliseconds.\n   */\n  readonly currentTimeMillis: Effect.Effect<number>\n  /**\n   * Unsafely returns the current time in nanoseconds.\n   */\n  unsafeCurrentTimeNanos(): bigint\n  /**\n   * Returns the current time in nanoseconds.\n   */\n  readonly currentTimeNanos: Effect.Effect<bigint>\n  /**\n   * Asynchronously sleeps for the specified duration.\n   */\n  sleep(duration: Duration.Duration): Effect.Effect<void>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Clock",
      "path": [
        "src",
        "Clock.ts"
      ]
    },
    "project": "effect",
    "name": "ClockScheduler",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ClockScheduler {\n  /**\n   * Unsafely schedules the specified task for the specified duration.\n   */\n  unsafeSchedule(task: Task, duration: Duration.Duration): CancelToken\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Clock",
      "path": [
        "src",
        "Clock.ts"
      ]
    },
    "project": "effect",
    "name": "CancelToken",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type CancelToken = () => boolean"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Clock",
      "path": [
        "src",
        "Clock.ts"
      ]
    },
    "project": "effect",
    "name": "ClockTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type ClockTypeId = typeof ClockTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Clock",
      "path": [
        "src",
        "Clock.ts"
      ]
    },
    "project": "effect",
    "name": "Task",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type Task = () => void"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "ConfigTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const ConfigTypeId: typeof ConfigTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "all",
    "description": "Constructs a config from a tuple / struct / arguments of configs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const all: <const Arg extends Iterable<Config<any>> | Record<string, Config<any>>>(arg: Arg) => Config<[Arg] extends [ReadonlyArray<Config<any>>] ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Config<infer A>] ? A : never; } : [Arg] extends [Iterable<Config<infer A>>] ? Array<A> : [Arg] extends [Record<string, Config<any>>] ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Config<infer A>] ? A : never; } : never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "array",
    "description": "Constructs a config for an array of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const array: <A>(config: Config<A>, name?: string) => Config<Array<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "boolean",
    "description": "Constructs a config for a boolean value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const boolean: (name?: string) => Config<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "url",
    "description": "Constructs a config for a URL value.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "export declare const url: (name?: string) => Config<URL>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "chunk",
    "description": "Constructs a config for a sequence of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const chunk: <A>(config: Config<A>, name?: string) => Config<Chunk.Chunk<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "date",
    "description": "Constructs a config for a date value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const date: (name?: string) => Config<Date>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": "Constructs a config that fails with the specified message.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fail: (message: string) => Config<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "number",
    "description": "Constructs a config for a float value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const number: (name?: string) => Config<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "integer",
    "description": "Constructs a config for a integer value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const integer: (name?: string) => Config<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "literal",
    "description": "Constructs a config for a literal value.",
    "deprecated": false,
    "examples": [
      "import { Config } from \"effect\"\n\nconst config = Config.literal(\"http\", \"https\")(\"PROTOCOL\")"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const literal: <Literals extends ReadonlyArray<LiteralValue>>(...literals: Literals) => (name?: string) => Config<Literals[number]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "logLevel",
    "description": "Constructs a config for a `LogLevel` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const logLevel: (name?: string) => Config<LogLevel.LogLevel>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "duration",
    "description": "Constructs a config for a duration value.",
    "deprecated": false,
    "examples": [],
    "since": "2.5.0",
    "category": "constructors",
    "signature": "export declare const duration: (name?: string) => Config<Duration.Duration>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "isConfig",
    "description": "This function returns `true` if the specified value is an `Config` value,\n`false` otherwise.\n\nThis function can be useful for checking the type of a value before\nattempting to operate on it as an `Config` value. For example, you could\nuse `isConfig` to check the type of a value before using it as an\nargument to a function that expects an `Config` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isConfig: (u: unknown) => u is Config<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Returns a  config whose structure is the same as this one, but which produces\na different value, constructed using the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <A, B>(f: (a: A) => B): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => B): Config<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "mapAttempt",
    "description": "Returns a config whose structure is the same as this one, but which may\nproduce a different value, constructed using the specified function, which\nmay throw exceptions that will be translated into validation errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mapAttempt: { <A, B>(f: (a: A) => B): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => B): Config<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "mapOrFail",
    "description": "Returns a new config whose structure is the samea as this one, but which\nmay produce a different value, constructed using the specified fallible\nfunction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mapOrFail: { <A, B>(f: (a: A) => Either.Either<B, ConfigError.ConfigError>): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => Either.Either<B, ConfigError.ConfigError>): Config<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "nested",
    "description": "Returns a config that has this configuration nested as a property of the\nspecified name.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const nested: { (name: string): <A>(self: Config<A>) => Config<A>; <A>(self: Config<A>, name: string): Config<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "orElse",
    "description": "Returns a config whose structure is preferentially described by this\nconfig, but which falls back to the specified config if there is an issue\nreading from this config.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const orElse: { <A2>(that: LazyArg<Config<A2>>): <A>(self: Config<A>) => Config<A2 | A>; <A, A2>(self: Config<A>, that: LazyArg<Config<A2>>): Config<A | A2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "orElseIf",
    "description": "Returns configuration which reads from this configuration, but which falls\nback to the specified configuration if reading from this configuration\nfails with an error satisfying the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const orElseIf: { <A2>(options: { readonly if: Predicate<ConfigError.ConfigError>; readonly orElse: LazyArg<Config<A2>>; }): <A>(self: Config<A>) => Config<A>; <A, A2>(self: Config<A>, options: { readonly if: Predicate<ConfigError.ConfigError>; readonly orElse: LazyArg<Config<A2>>; }): Config<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "option",
    "description": "Returns an optional version of this config, which will be `None` if the\ndata is missing from configuration, and `Some` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const option: <A>(self: Config<A>) => Config<Option.Option<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "primitive",
    "description": "Constructs a new primitive config.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const primitive: <A>(description: string, parse: (text: string) => Either.Either<A, ConfigError.ConfigError>) => Config<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "repeat",
    "description": "Returns a config that describes a sequence of values, each of which has the\nstructure of this config.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const repeat: <A>(self: Config<A>) => Config<Array<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "secret",
    "description": "Constructs a config for a secret value.",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const secret: (name?: string) => Config<Secret.Secret>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "redacted",
    "description": "Constructs a config for a redacted value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const redacted: { (name?: string): Config<Redacted.Redacted>; <A>(config: Config<A>): Config<Redacted.Redacted<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "hashSet",
    "description": "Constructs a config for a sequence of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const hashSet: <A>(config: Config<A>, name?: string) => Config<HashSet.HashSet<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "string",
    "description": "Constructs a config for a string value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const string: (name?: string) => Config<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "nonEmptyString",
    "description": "Constructs a config for a non-empty string value.",
    "deprecated": false,
    "examples": [],
    "since": "3.7.0",
    "category": "constructors",
    "signature": "export declare const nonEmptyString: (name?: string) => Config<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": "Constructs a config which contains the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const succeed: <A>(value: A) => Config<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "suspend",
    "description": "Lazily constructs a config.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const suspend: <A>(config: LazyArg<Config<A>>) => Config<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "sync",
    "description": "Constructs a config which contains the specified lazy value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sync: <A>(value: LazyArg<A>) => Config<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "hashMap",
    "description": "Constructs a config for a sequence of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const hashMap: <A>(config: Config<A>, name?: string) => Config<HashMap.HashMap<string, A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "unwrap",
    "description": "Constructs a config from some configuration wrapped with the `Wrap<A>` utility type.\n\nFor example:\n\n```\nimport { Config, unwrap } from \"./Config\"\n\ninterface Options { key: string }\n\nconst makeConfig = (config: Config.Wrap<Options>): Config<Options> => unwrap(config)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unwrap: <A>(wrapped: Config.Wrap<A>) => Config<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "validate",
    "description": "Returns a config that describes the same structure as this one, but which\nperforms validation during loading.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const validate: { <A, B extends A>(options: { readonly message: string; readonly validation: Refinement<A, B>; }): (self: Config<A>) => Config<B>; <A>(options: { readonly message: string; readonly validation: Predicate<A>; }): (self: Config<A>) => Config<A>; <A, B extends A>(self: Config<A>, options: { readonly message: string; readonly validation: Refinement<A, B>; }): Config<B>; <A>(self: Config<A>, options: { readonly message: string; readonly validation: Predicate<A>; }): Config<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "withDefault",
    "description": "Returns a config that describes the same structure as this one, but has the\nspecified default value in case the information cannot be found.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const withDefault: { <const A2>(def: A2): <A>(self: Config<A>) => Config<A2 | A>; <A, const A2>(self: Config<A>, def: A2): Config<A | A2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "withDescription",
    "description": "Adds a description to this configuration, which is intended for humans.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const withDescription: { (description: string): <A>(self: Config<A>) => Config<A>; <A>(self: Config<A>, description: string): Config<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Returns a config that is the composition of this config and the specified\nconfig.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zip: { <B>(that: Config<B>): <A>(self: Config<A>) => Config<[A, B]>; <A, B>(self: Config<A>, that: Config<B>): Config<[A, B]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Returns a config that is the composes this config and the specified config\nusing the provided function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWith: { <B, A, C>(that: Config<B>, f: (a: A, b: B) => C): (self: Config<A>) => Config<C>; <A, B, C>(self: Config<A>, that: Config<B>, f: (a: A, b: B) => C): Config<C>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "Config",
    "description": "A `Config` describes the structure of some configuration data.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Config<out A> extends Config.Variance<A>, Effect.Effect<A, ConfigError.ConfigError> {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "ConfigTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type ConfigTypeId = typeof ConfigTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Config",
      "path": [
        "src",
        "Config.ts"
      ]
    },
    "project": "effect",
    "name": "LiteralValue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type LiteralValue = string | number | boolean | null | bigint"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "ConfigErrorTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const ConfigErrorTypeId: typeof ConfigErrorTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "And",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const And: (self: ConfigError, that: ConfigError) => ConfigError"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "Or",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Or: (self: ConfigError, that: ConfigError) => ConfigError"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "MissingData",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const MissingData: (path: Array<string>, message: string, options?: Options) => ConfigError"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "InvalidData",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const InvalidData: (path: Array<string>, message: string, options?: Options) => ConfigError"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "SourceUnavailable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const SourceUnavailable: (path: Array<string>, message: string, cause: Cause.Cause<unknown>, options?: Options) => ConfigError"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "Unsupported",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Unsupported: (path: Array<string>, message: string, options?: Options) => ConfigError"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "isConfigError",
    "description": "Returns `true` if the specified value is a `ConfigError`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isConfigError: (u: unknown) => u is ConfigError"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "isAnd",
    "description": "Returns `true` if the specified `ConfigError` is an `And`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isAnd: (self: ConfigError) => self is And"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "isOr",
    "description": "Returns `true` if the specified `ConfigError` is an `Or`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isOr: (self: ConfigError) => self is Or"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "isInvalidData",
    "description": "Returns `true` if the specified `ConfigError` is an `InvalidData`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isInvalidData: (self: ConfigError) => self is InvalidData"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "isMissingData",
    "description": "Returns `true` if the specified `ConfigError` is an `MissingData`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isMissingData: (self: ConfigError) => self is MissingData"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "isMissingDataOnly",
    "description": "Returns `true` if the specified `ConfigError` contains only `MissingData` errors, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const isMissingDataOnly: (self: ConfigError) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "isSourceUnavailable",
    "description": "Returns `true` if the specified `ConfigError` is a `SourceUnavailable`,\n`false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isSourceUnavailable: (self: ConfigError) => self is SourceUnavailable"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "isUnsupported",
    "description": "Returns `true` if the specified `ConfigError` is an `Unsupported`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isUnsupported: (self: ConfigError) => self is Unsupported"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "prefixed",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const prefixed: { (prefix: Array<string>): (self: ConfigError) => ConfigError; (self: ConfigError, prefix: Array<string>): ConfigError; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "reduceWithContext",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduceWithContext: { <C, Z>(context: C, reducer: ConfigErrorReducer<C, Z>): (self: ConfigError) => Z; <C, Z>(self: ConfigError, context: C, reducer: ConfigErrorReducer<C, Z>): Z; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "And",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface And extends ConfigError.Proto {\n  readonly _op: \"And\"\n  readonly left: ConfigError\n  readonly right: ConfigError\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "ConfigErrorReducer",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ConfigErrorReducer<in C, in out Z> {\n  andCase(context: C, left: Z, right: Z): Z\n  orCase(context: C, left: Z, right: Z): Z\n  invalidDataCase(context: C, path: Array<string>, message: string): Z\n  missingDataCase(context: C, path: Array<string>, message: string): Z\n  sourceUnavailableCase(\n    context: C,\n    path: Array<string>,\n    message: string,\n    cause: Cause.Cause<unknown>\n  ): Z\n  unsupportedCase(context: C, path: Array<string>, message: string): Z\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "InvalidData",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface InvalidData extends ConfigError.Proto {\n  readonly _op: \"InvalidData\"\n  readonly path: Array<string>\n  readonly message: string\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "MissingData",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MissingData extends ConfigError.Proto {\n  readonly _op: \"MissingData\"\n  readonly path: Array<string>\n  readonly message: string\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "Options",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Options {\n  readonly pathDelim: string\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "Or",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Or extends ConfigError.Proto {\n  readonly _op: \"Or\"\n  readonly left: ConfigError\n  readonly right: ConfigError\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "SourceUnavailable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SourceUnavailable extends ConfigError.Proto {\n  readonly _op: \"SourceUnavailable\"\n  readonly path: Array<string>\n  readonly message: string\n  readonly cause: Cause.Cause<unknown>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "Unsupported",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Unsupported extends ConfigError.Proto {\n  readonly _op: \"Unsupported\"\n  readonly path: Array<string>\n  readonly message: string\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "ConfigError",
    "description": "The possible ways that loading configuration data may fail.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type ConfigError =\n  | And\n  | Or\n  | InvalidData\n  | MissingData\n  | SourceUnavailable\n  | Unsupported"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ConfigError",
      "path": [
        "src",
        "ConfigError.ts"
      ]
    },
    "project": "effect",
    "name": "ConfigErrorTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type ConfigErrorTypeId = typeof ConfigErrorTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "ConfigProviderTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const ConfigProviderTypeId: typeof ConfigProviderTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "FlatConfigProviderTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const FlatConfigProviderTypeId: typeof FlatConfigProviderTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "ConfigProvider",
    "description": "The service tag for `ConfigProvider`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const ConfigProvider: Context.Tag<ConfigProvider, ConfigProvider>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new config provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: (options: { readonly load: <A>(config: Config.Config<A>) => Effect.Effect<A, ConfigError.ConfigError>; readonly flattened: ConfigProvider.Flat; }) => ConfigProvider"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "makeFlat",
    "description": "Creates a new flat config provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeFlat: (options: { readonly load: <A>(path: ReadonlyArray<string>, config: Config.Config.Primitive<A>, split: boolean) => Effect.Effect<Array<A>, ConfigError.ConfigError>; readonly enumerateChildren: (path: ReadonlyArray<string>) => Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError>; readonly patch: PathPatch.PathPatch; }) => ConfigProvider.Flat"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "fromEnv",
    "description": "A config provider that loads configuration from context variables,\nusing the default System service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromEnv: (config?: ConfigProvider.FromEnvConfig) => ConfigProvider"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "fromFlat",
    "description": "Constructs a new `ConfigProvider` from a key/value (flat) provider, where\nnesting is embedded into the string keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromFlat: (flat: ConfigProvider.Flat) => ConfigProvider"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "fromJson",
    "description": "Constructs a new `ConfigProvider` from a JSON object.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromJson: (json: unknown) => ConfigProvider"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "fromMap",
    "description": "Constructs a ConfigProvider using a map and the specified delimiter string,\nwhich determines how to split the keys in the map into path segments.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromMap: (map: Map<string, string>, config?: Partial<ConfigProvider.FromMapConfig>) => ConfigProvider"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "constantCase",
    "description": "Returns a new config provider that will automatically convert all property\nnames to constant case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const constantCase: (self: ConfigProvider) => ConfigProvider"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputPath",
    "description": "Returns a new config provider that will automatically tranform all path\nconfiguration names with the specified function. This can be utilized to\nadapt the names of configuration properties from one naming convention to\nanother.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mapInputPath: { (f: (path: string) => string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, f: (path: string) => string): ConfigProvider; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "kebabCase",
    "description": "Returns a new config provider that will automatically convert all property\nnames to kebab case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const kebabCase: (self: ConfigProvider) => ConfigProvider"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "lowerCase",
    "description": "Returns a new config provider that will automatically convert all property\nnames to lower case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const lowerCase: (self: ConfigProvider) => ConfigProvider"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "nested",
    "description": "Returns a new config provider that will automatically nest all\nconfiguration under the specified property name. This can be utilized to\naggregate separate configuration sources that are all required to load a\nsingle configuration value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const nested: { (name: string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, name: string): ConfigProvider; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "orElse",
    "description": "Returns a new config provider that preferentially loads configuration data\nfrom this one, but which will fall back to the specified alternate provider\nif there are any issues loading the configuration from this provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const orElse: { (that: LazyArg<ConfigProvider>): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, that: LazyArg<ConfigProvider>): ConfigProvider; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "unnested",
    "description": "Returns a new config provider that will automatically un-nest all\nconfiguration under the specified property name. This can be utilized to\nde-aggregate separate configuration sources that are all required to load a\nsingle configuration value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const unnested: { (name: string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, name: string): ConfigProvider; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "snakeCase",
    "description": "Returns a new config provider that will automatically convert all property\nnames to upper case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const snakeCase: (self: ConfigProvider) => ConfigProvider"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "upperCase",
    "description": "Returns a new config provider that will automatically convert all property\nnames to upper case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const upperCase: (self: ConfigProvider) => ConfigProvider"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "within",
    "description": "Returns a new config provider that transforms the config provider with the\nspecified function within the specified path.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const within: { (path: ReadonlyArray<string>, f: (self: ConfigProvider) => ConfigProvider): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, path: ReadonlyArray<string>, f: (self: ConfigProvider) => ConfigProvider): ConfigProvider; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "ConfigProvider",
    "description": "A ConfigProvider is a service that provides configuration given a description\nof the structure of that configuration.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ConfigProvider extends ConfigProvider.Proto, Pipeable {\n  /**\n   * Loads the specified configuration, or fails with a config error.\n   */\n  load<A>(config: Config.Config<A>): Effect.Effect<A, ConfigError.ConfigError>\n  /**\n   * Flattens this config provider into a simplified config provider that knows\n   * only how to deal with flat (key/value) properties.\n   */\n  readonly flattened: ConfigProvider.Flat\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "ConfigProviderTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type ConfigProviderTypeId = typeof ConfigProviderTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ConfigProvider",
      "path": [
        "src",
        "ConfigProvider.ts"
      ]
    },
    "project": "effect",
    "name": "FlatConfigProviderTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type FlatConfigProviderTypeId = typeof FlatConfigProviderTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProviderPathPatch",
      "path": [
        "src",
        "ConfigProviderPathPatch.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: PathPatch"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProviderPathPatch",
      "path": [
        "src",
        "ConfigProviderPathPatch.ts"
      ]
    },
    "project": "effect",
    "name": "andThen",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const andThen: { (that: PathPatch): (self: PathPatch) => PathPatch; (self: PathPatch, that: PathPatch): PathPatch; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProviderPathPatch",
      "path": [
        "src",
        "ConfigProviderPathPatch.ts"
      ]
    },
    "project": "effect",
    "name": "mapName",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const mapName: { (f: (string: string) => string): (self: PathPatch) => PathPatch; (self: PathPatch, f: (string: string) => string): PathPatch; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProviderPathPatch",
      "path": [
        "src",
        "ConfigProviderPathPatch.ts"
      ]
    },
    "project": "effect",
    "name": "nested",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const nested: { (name: string): (self: PathPatch) => PathPatch; (self: PathPatch, name: string): PathPatch; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ConfigProviderPathPatch",
      "path": [
        "src",
        "ConfigProviderPathPatch.ts"
      ]
    },
    "project": "effect",
    "name": "unnested",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unnested: { (name: string): (self: PathPatch) => PathPatch; (self: PathPatch, name: string): PathPatch; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProviderPathPatch",
      "path": [
        "src",
        "ConfigProviderPathPatch.ts"
      ]
    },
    "project": "effect",
    "name": "AndThen",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface AndThen {\n  readonly _tag: \"AndThen\"\n  readonly first: PathPatch\n  readonly second: PathPatch\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProviderPathPatch",
      "path": [
        "src",
        "ConfigProviderPathPatch.ts"
      ]
    },
    "project": "effect",
    "name": "Empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Empty {\n  readonly _tag: \"Empty\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProviderPathPatch",
      "path": [
        "src",
        "ConfigProviderPathPatch.ts"
      ]
    },
    "project": "effect",
    "name": "MapName",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MapName {\n  readonly _tag: \"MapName\"\n  f(string: string): string\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProviderPathPatch",
      "path": [
        "src",
        "ConfigProviderPathPatch.ts"
      ]
    },
    "project": "effect",
    "name": "Nested",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Nested {\n  readonly _tag: \"Nested\"\n  readonly name: string\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ConfigProviderPathPatch",
      "path": [
        "src",
        "ConfigProviderPathPatch.ts"
      ]
    },
    "project": "effect",
    "name": "Unnested",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Unnested {\n  readonly _tag: \"Unnested\"\n  readonly name: string\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ConfigProviderPathPatch",
      "path": [
        "src",
        "ConfigProviderPathPatch.ts"
      ]
    },
    "project": "effect",
    "name": "PathPatch",
    "description": "Represents a description of how to modify the path to a configuration\nvalue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type PathPatch = Empty | AndThen | MapName | Nested | Unnested"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "Console",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const Console: Context.Tag<Console, Console>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "withConsole",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "default services",
    "signature": "export declare const withConsole: { <C extends Console>(console: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, C extends Console>(effect: Effect<A, E, R>, console: C): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "setConsole",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "default services",
    "signature": "export declare const setConsole: <A extends Console>(console: A) => Layer.Layer<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "consoleWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const consoleWith: <A, E, R>(f: (console: Console) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "assert",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const assert: (condition: boolean, ...args: ReadonlyArray<any>) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "clear",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const clear: Effect<void, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "count",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const count: (label?: string) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "countReset",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const countReset: (label?: string) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "debug",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const debug: (...args: ReadonlyArray<any>) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "dir",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const dir: (item: any, options?: any) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "dirxml",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const dirxml: (...args: ReadonlyArray<any>) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "error",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const error: (...args: ReadonlyArray<any>) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "group",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const group: (options?: { label?: string | undefined; collapsed?: boolean | undefined; } | undefined) => Effect<void, never, Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "info",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const info: (...args: ReadonlyArray<any>) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "log",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const log: (...args: ReadonlyArray<any>) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "table",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const table: (tabularData: any, properties?: ReadonlyArray<string>) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "time",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const time: (label?: string | undefined) => Effect<void, never, Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "timeLog",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const timeLog: (label?: string, ...args: ReadonlyArray<any>) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "trace",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const trace: (...args: ReadonlyArray<any>) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "warn",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const warn: (...args: ReadonlyArray<any>) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "withGroup",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const withGroup: { (options?: { readonly label?: string | undefined; readonly collapsed?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, options?: { readonly label?: string | undefined; readonly collapsed?: boolean | undefined; }): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "withTime",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessor",
    "signature": "export declare const withTime: { (label?: string): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, label?: string): Effect<A, E, R>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "Console",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface Console {\n  readonly [TypeId]: TypeId\n  assert(condition: boolean, ...args: ReadonlyArray<any>): Effect<void>\n  readonly clear: Effect<void>\n  count(label?: string): Effect<void>\n  countReset(label?: string): Effect<void>\n  debug(...args: ReadonlyArray<any>): Effect<void>\n  dir(item: any, options?: any): Effect<void>\n  dirxml(...args: ReadonlyArray<any>): Effect<void>\n  error(...args: ReadonlyArray<any>): Effect<void>\n  group(options?: {\n    readonly label?: string | undefined\n    readonly collapsed?: boolean | undefined\n  }): Effect<void>\n  readonly groupEnd: Effect<void>\n  info(...args: ReadonlyArray<any>): Effect<void>\n  log(...args: ReadonlyArray<any>): Effect<void>\n  table(tabularData: any, properties?: ReadonlyArray<string>): Effect<void>\n  time(label?: string): Effect<void>\n  timeEnd(label?: string): Effect<void>\n  timeLog(label?: string, ...args: ReadonlyArray<any>): Effect<void>\n  trace(...args: ReadonlyArray<any>): Effect<void>\n  warn(...args: ReadonlyArray<any>): Effect<void>\n  readonly unsafe: UnsafeConsole\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "UnsafeConsole",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface UnsafeConsole {\n  assert(condition: boolean, ...args: ReadonlyArray<any>): void\n  clear(): void\n  count(label?: string): void\n  countReset(label?: string): void\n  debug(...args: ReadonlyArray<any>): void\n  dir(item: any, options?: any): void\n  dirxml(...args: ReadonlyArray<any>): void\n  error(...args: ReadonlyArray<any>): void\n  group(...args: ReadonlyArray<any>): void\n  groupCollapsed(...args: ReadonlyArray<any>): void\n  groupEnd(): void\n  info(...args: ReadonlyArray<any>): void\n  log(...args: ReadonlyArray<any>): void\n  table(tabularData: any, properties?: ReadonlyArray<string>): void\n  time(label?: string): void\n  timeEnd(label?: string): void\n  timeLog(label?: string, ...args: ReadonlyArray<any>): void\n  trace(...args: ReadonlyArray<any>): void\n  warn(...args: ReadonlyArray<any>): void\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Console",
      "path": [
        "src",
        "Console.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "GenericTag",
    "description": "Creates a new `Tag` instance with an optional key parameter.",
    "deprecated": false,
    "examples": [
      "import { Context } from \"effect\"\n\nassert.strictEqual(Context.GenericTag(\"PORT\").key === Context.GenericTag(\"PORT\").key, true)"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const GenericTag: <Identifier, Service = Identifier>(key: string) => Tag<Identifier, Service>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMake",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unsafeMake: <Services>(unsafeMap: Map<string, any>) => Context<Services>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "isContext",
    "description": "Checks if the provided argument is a `Context`.",
    "deprecated": false,
    "examples": [
      "import { Context } from \"effect\"\n\nassert.strictEqual(Context.isContext(Context.empty()), true)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isContext: (input: unknown) => input is Context<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "isTag",
    "description": "Checks if the provided argument is a `Tag`.",
    "deprecated": false,
    "examples": [
      "import { Context } from \"effect\"\n\nassert.strictEqual(Context.isTag(Context.GenericTag(\"Tag\")), true)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isTag: (input: unknown) => input is Tag<any, any>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "isReference",
    "description": "Checks if the provided argument is a `Reference`.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "guards",
    "signature": "export declare const isReference: (u: unknown) => u is Reference<any, any>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "Returns an empty `Context`.",
    "deprecated": false,
    "examples": [
      "import { Context } from \"effect\"\n\nassert.strictEqual(Context.isContext(Context.empty()), true)"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: () => Context<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new `Context` with a single service associated to the tag.",
    "deprecated": false,
    "examples": [
      "import { Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n\nconst Services = Context.make(Port, { PORT: 8080 })\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <T extends Tag<any, any>>(tag: T, service: Tag.Service<T>) => Context<Tag.Identifier<T>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "add",
    "description": "Adds a service to a given `Context`.",
    "deprecated": false,
    "examples": [
      "import { Context, pipe } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst someContext = Context.make(Port, { PORT: 8080 })\n\nconst Services = pipe(\n  someContext,\n  Context.add(Timeout, { TIMEOUT: 5000 })\n)\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const add: { <T extends Tag<any, any>>(tag: T, service: Tag.Service<T>): <Services>(self: Context<Services>) => Context<Services | Tag.Identifier<T>>; <Services, T extends Tag<any, any>>(self: Context<Services>, tag: T, service: Tag.Service<T>): Context<Services | Tag.Identifier<T>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Get a service from the context that corresponds to the given tag.",
    "deprecated": false,
    "examples": [
      "import { pipe, Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst Services = pipe(\n  Context.make(Port, { PORT: 8080 }),\n  Context.add(Timeout, { TIMEOUT: 5000 })\n)\n\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const get: { <I, S>(tag: Reference<I, S>): <Services>(self: Context<Services>) => S; <Services, T extends ValidTagsById<Services>>(tag: T): (self: Context<Services>) => Tag.Service<T>; <Services, I, S>(self: Context<Services>, tag: Reference<I, S>): S; <Services, T extends ValidTagsById<Services>>(self: Context<Services>, tag: T): Tag.Service<T>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "getOrElse",
    "description": "Get a service from the context that corresponds to the given tag, or\nuse the fallback value.",
    "deprecated": false,
    "examples": [],
    "since": "3.7.0",
    "category": "getters",
    "signature": "export declare const getOrElse: { <S, I, B>(tag: Tag<I, S>, orElse: LazyArg<B>): <Services>(self: Context<Services>) => S | B; <Services, S, I, B>(self: Context<Services>, tag: Tag<I, S>, orElse: LazyArg<B>): S | B; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeGet",
    "description": "Get a service from the context that corresponds to the given tag.\nThis function is unsafe because if the tag is not present in the context, a runtime error will be thrown.\n\nFor a safer version see {@link getOption}.",
    "deprecated": false,
    "examples": [
      "import { Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst Services = Context.make(Port, { PORT: 8080 })\n\nassert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })\nassert.throws(() => Context.unsafeGet(Services, Timeout))"
    ],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeGet: { <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => S; <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): S; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "getOption",
    "description": "Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not\nfound, the `Option` object will be `None`.",
    "deprecated": false,
    "examples": [
      "import { Context, Option } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst Services = Context.make(Port, { PORT: 8080 })\n\nassert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\nassert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const getOption: { <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => Option<S>; <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): Option<S>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "merge",
    "description": "Merges two `Context`s, returning a new `Context` containing the services of both.",
    "deprecated": false,
    "examples": [
      "import { Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst firstContext = Context.make(Port, { PORT: 8080 })\nconst secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n\nconst Services = Context.merge(firstContext, secondContext)\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const merge: { <R1>(that: Context<R1>): <Services>(self: Context<Services>) => Context<R1 | Services>; <Services, R1>(self: Context<Services>, that: Context<R1>): Context<Services | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "mergeAll",
    "description": "Merges any number of `Context`s, returning a new `Context` containing the services of all.",
    "deprecated": false,
    "examples": [
      "import { Context } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\nconst Host = Context.GenericTag<{ HOST: string }>(\"Host\")\n\nconst firstContext = Context.make(Port, { PORT: 8080 })\nconst secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\nconst thirdContext = Context.make(Host, { HOST: \"localhost\" })\n\nconst Services = Context.mergeAll(firstContext, secondContext, thirdContext)\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\nassert.deepStrictEqual(Context.get(Services, Host), { HOST: \"localhost\" })"
    ],
    "since": "3.12.0",
    "category": null,
    "signature": "export declare const mergeAll: <T extends Array<unknown>>(...ctxs_0: { [K in keyof T]: Context<T[K]>; }) => Context<T[number]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "pick",
    "description": "Returns a new `Context` that contains only the specified services.",
    "deprecated": false,
    "examples": [
      "import { pipe, Context, Option } from \"effect\"\n\nconst Port = Context.GenericTag<{ PORT: number }>(\"Port\")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n\nconst someContext = pipe(\n  Context.make(Port, { PORT: 8080 }),\n  Context.add(Timeout, { TIMEOUT: 5000 })\n)\n\nconst Services = pipe(someContext, Context.pick(Port))\n\nassert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\nassert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const pick: <Services, S extends Array<ValidTagsById<Services>>>(...tags: S) => (self: Context<Services>) => Context<{ [k in keyof S]: Tag.Identifier<S[k]>; }[number]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "omit",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const omit: <Services, S extends Array<ValidTagsById<Services>>>(...tags: S) => (self: Context<Services>) => Context<Exclude<Services, { [k in keyof S]: Tag.Identifier<S[k]>; }[keyof S]>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "Tag",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { Context, Layer } from \"effect\"\n\nclass MyTag extends Context.Tag(\"MyTag\")<\n MyTag,\n { readonly myNum: number }\n>() {\n static Live = Layer.succeed(this, { myNum: 108 })\n}"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Tag: <const Id extends string>(id: Id) => <Self, Shape>() => TagClass<Self, Id, Shape>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "Reference",
    "description": "Creates a context tag with a default value.\n\n**Details**\n\n`Context.Reference` allows you to create a tag that can hold a value. You can\nprovide a default value for the service, which will automatically be used\nwhen the context is accessed, or override it with a custom implementation\nwhen needed.",
    "deprecated": false,
    "examples": [
      "// Title: Declaring a Tag with a default value\nimport { Context, Effect } from \"effect\"\n\nclass SpecialNumber extends Context.Reference<SpecialNumber>()(\n  \"SpecialNumber\",\n  { defaultValue: () => 2048 }\n) {}\n\n//       Effect<void, never, never>\n//      \nconst program = Effect.gen(function* () {\n  const specialNumber = yield* SpecialNumber\n  console.log(`The special number is ${specialNumber}`)\n})\n\n// No need to provide the SpecialNumber implementation\nEffect.runPromise(program)\n// Output: The special number is 2048",
      "// Title: Overriding the default value\nimport { Context, Effect } from \"effect\"\n\nclass SpecialNumber extends Context.Reference<SpecialNumber>()(\n  \"SpecialNumber\",\n  { defaultValue: () => 2048 }\n) {}\n\nconst program = Effect.gen(function* () {\n  const specialNumber = yield* SpecialNumber\n  console.log(`The special number is ${specialNumber}`)\n})\n\nEffect.runPromise(program.pipe(Effect.provideService(SpecialNumber, -1)))\n// Output: The special number is -1"
    ],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "export declare const Reference: <Self>() => <const Id extends string, Service>(id: Id, options: { readonly defaultValue: () => Service; }) => ReferenceClass<Self, Id, Service>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "Context",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Context<in Services> extends Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _Services: Types.Contravariant<Services>\n  }\n  readonly unsafeMap: Map<string, any>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "Reference",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "models",
    "signature": "export interface Reference<in out Id, in out Value> extends Pipeable, Inspectable {\n  readonly [ReferenceTypeId]: ReferenceTypeId\n  readonly defaultValue: () => Value\n\n  readonly _op: \"Tag\"\n  readonly Service: Value\n  readonly Identifier: Id\n  readonly [TagTypeId]: {\n    readonly _Service: Types.Invariant<Value>\n    readonly _Identifier: Types.Invariant<Id>\n  }\n  of(self: Value): Value\n  context(self: Value): Context<Id>\n  readonly stack?: string | undefined\n  readonly key: string\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: TagUnify<this>\n  [Unify.ignoreSymbol]?: TagUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "ReferenceClass",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "models",
    "signature": "export interface ReferenceClass<Self, Id extends string, Type> extends Reference<Self, Type> {\n  new(_: never): TagClassShape<Id, Type>\n  readonly key: Id\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "Tag",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.5.9",
    "category": "models",
    "signature": "export interface Tag<in out Id, in out Value> extends Pipeable, Inspectable {\n  readonly _op: \"Tag\"\n  readonly Service: Value\n  readonly Identifier: Id\n  readonly [TagTypeId]: {\n    readonly _Service: Types.Invariant<Value>\n    readonly _Identifier: Types.Invariant<Id>\n  }\n  of(self: Value): Value\n  context(self: Value): Context<Id>\n  readonly stack?: string | undefined\n  readonly key: string\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: TagUnify<this>\n  [Unify.ignoreSymbol]?: TagUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "TagClass",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TagClass<Self, Id extends string, Type> extends Tag<Self, Type> {\n  new(_: never): TagClassShape<Id, Type>\n  readonly key: Id\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "TagClassShape",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TagClassShape<Id, Shape> {\n  readonly [TagTypeId]: TagTypeId\n  readonly Type: Shape\n  readonly Id: Id\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "TagUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TagUnify<A extends { [Unify.typeSymbol]?: any }> {\n  Tag?: () => Extract<A[Unify.typeSymbol], Tag<any, any>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "TagUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TagUnifyIgnore {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "ReferenceTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "symbol",
    "signature": "export type ReferenceTypeId = typeof ReferenceTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "TagTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TagTypeId = typeof TagTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Context",
      "path": [
        "src",
        "Context.ts"
      ]
    },
    "project": "effect",
    "name": "ValidTagsById",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type ValidTagsById<R> = R extends infer S ? Tag<S, any> : never"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "ParseError",
    "description": "Represents a checked exception which occurs when decoding fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export declare class ParseError"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "ParseErrorTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export declare const ParseErrorTypeId: typeof ParseErrorTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "sequence",
    "description": "Returns an `IterableIterator` which yields the sequence of `Date`s that match the `Cron` instance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const sequence: (cron: Cron, now?: DateTime.DateTime.Input) => IterableIterator<Date>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "Equivalence",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Equivalence: equivalence.Equivalence<Cron>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "equals",
    "description": "Checks if two `Cron`s are equal.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const equals: { (that: Cron): (self: Cron) => boolean; (self: Cron, that: Cron): boolean; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "isCron",
    "description": "Checks if a given value is a `Cron` instance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a `Cron` instance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "isParseError",
    "description": "Returns `true` if the specified value is an `ParseError`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "parse",
    "description": "Parses a cron expression into a `Cron` instance.",
    "deprecated": false,
    "examples": [
      "import { Cron, Either } from \"effect\"\n\n// At 04:00 on every day-of-month from 8 through 14.\nassert.deepStrictEqual(Cron.parse(\"0 0 4 8-14 * *\"), Either.right(Cron.make({\n  seconds: [0],\n  minutes: [0],\n  hours: [4],\n  days: [8, 9, 10, 11, 12, 13, 14],\n  months: [],\n  weekdays: []\n})))"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeParse",
    "description": "Parses a cron expression into a `Cron` instance.\n\n**Details**\n\nThis function takes a cron expression as a string and attempts to parse it\ninto a `Cron` instance. If the expression is valid, the resulting `Cron`\ninstance will represent the schedule defined by the cron expression.\n\nIf the expression is invalid, the function throws a `ParseError`.\n\nYou can optionally provide a time zone (`tz`) to interpret the cron\nexpression in a specific time zone. If no time zone is provided, the cron\nexpression will use the default time zone.",
    "deprecated": false,
    "examples": [
      "import { Cron } from \"effect\"\n\n// At 04:00 on every day-of-month from 8 through 14.\nconsole.log(Cron.unsafeParse(\"0 4 8-14 * *\"))\n// Output:\n// {\n//   _id: 'Cron',\n//   tz: { _id: 'Option', _tag: 'None' },\n//   seconds: [ 0 ],\n//   minutes: [ 0 ],\n//   hours: [ 4 ],\n//   days: [\n//      8,  9, 10, 11,\n//     12, 13, 14\n//   ],\n//   months: [],\n//   weekdays: []\n// }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Checks if a given `Date` falls within an active `Cron` time window.",
    "deprecated": false,
    "examples": [
      "import { Cron, Either } from \"effect\"\n\nconst cron = Either.getOrThrow(Cron.parse(\"0 4 8-14 * *\"))\nassert.deepStrictEqual(Cron.match(cron, new Date(\"2021-01-08 04:00:00\")), true)\nassert.deepStrictEqual(Cron.match(cron, new Date(\"2021-01-08 05:00:00\")), false)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "next",
    "description": "Returns the next run `Date` for the given `Cron` instance.\n\nUses the current time as a starting point if no value is provided for `now`.",
    "deprecated": false,
    "examples": [
      "import { Cron, Either } from \"effect\"\n\nconst after = new Date(\"2021-01-01 00:00:00\")\nconst cron = Either.getOrThrow(Cron.parse(\"0 4 8-14 * *\"))\nassert.deepStrictEqual(Cron.next(cron, after), new Date(\"2021-01-08 04:00:00\"))"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "Cron",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Cron extends Pipeable, Equal.Equal, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly tz: Option.Option<DateTime.TimeZone>\n  readonly seconds: ReadonlySet<number>\n  readonly minutes: ReadonlySet<number>\n  readonly hours: ReadonlySet<number>\n  readonly days: ReadonlySet<number>\n  readonly months: ReadonlySet<number>\n  readonly weekdays: ReadonlySet<number>\n  /** @internal */\n  readonly first: {\n    readonly second: number\n    readonly minute: number\n    readonly hour: number\n    readonly day: number\n    readonly month: number\n    readonly weekday: number\n  }\n  /** @internal */\n  readonly next: {\n    readonly second: ReadonlyArray<number | undefined>\n    readonly minute: ReadonlyArray<number | undefined>\n    readonly hour: ReadonlyArray<number | undefined>\n    readonly day: ReadonlyArray<number | undefined>\n    readonly month: ReadonlyArray<number | undefined>\n    readonly weekday: ReadonlyArray<number | undefined>\n  }\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "ParseErrorTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type ParseErrorTypeId = typeof ParseErrorTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Cron",
      "path": [
        "src",
        "Cron.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Data",
      "path": [
        "src",
        "Data.ts"
      ]
    },
    "project": "effect",
    "name": "struct",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { Data, Equal } from \"effect\"\n\nconst alice = Data.struct({ name: \"Alice\", age: 30 })\n\nconst bob = Data.struct({ name: \"Bob\", age: 40 })\n\nassert.deepStrictEqual(Equal.equals(alice, alice), true)\nassert.deepStrictEqual(Equal.equals(alice, Data.struct({ name: \"Alice\", age: 30 })), true)\n\nassert.deepStrictEqual(Equal.equals(alice, { name: \"Alice\", age: 30 }), false)\nassert.deepStrictEqual(Equal.equals(alice, bob), false)"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const struct: <A extends Record<string, any>>(a: A) => { readonly [P in keyof A]: A[P]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Data",
      "path": [
        "src",
        "Data.ts"
      ]
    },
    "project": "effect",
    "name": "Class",
    "description": "Provides a constructor for a Case Class.",
    "deprecated": false,
    "examples": [
      "import { Data, Equal } from \"effect\"\n\nclass Person extends Data.Class<{ readonly name: string }> {}\n\n// Creating instances of Person\nconst mike1 = new Person({ name: \"Mike\" })\nconst mike2 = new Person({ name: \"Mike\" })\nconst john = new Person({ name: \"John\" })\n\n// Checking equality\nassert.deepStrictEqual(Equal.equals(mike1, mike2), true)\nassert.deepStrictEqual(Equal.equals(mike1, john), false)"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Class: new <A extends Record<string, any> = {}>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P]; }) => Readonly<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Data",
      "path": [
        "src",
        "Data.ts"
      ]
    },
    "project": "effect",
    "name": "Structural",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Structural: new <A>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P]; }) => {}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Data",
      "path": [
        "src",
        "Data.ts"
      ]
    },
    "project": "effect",
    "name": "Error",
    "description": "Provides a constructor for a Case Class.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Error: new <A extends Record<string, any> = {}>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P]; }) => Cause.YieldableError & Readonly<A>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Data",
      "path": [
        "src",
        "Data.ts"
      ]
    },
    "project": "effect",
    "name": "case",
    "description": "Provides a constructor for the specified `Case`.",
    "deprecated": false,
    "examples": [
      "import { Data, Equal } from \"effect\"\n\ninterface Person {\n  readonly name: string\n}\n\n// Creating a constructor for the specified Case\nconst Person = Data.case<Person>()\n\n// Creating instances of Person\nconst mike1 = Person({ name: \"Mike\" })\nconst mike2 = Person({ name: \"Mike\" })\nconst john = Person({ name: \"John\" })\n\n// Checking equality\nassert.deepStrictEqual(Equal.equals(mike1, mike2), true)\nassert.deepStrictEqual(Equal.equals(mike1, john), false)\n"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const case: <A>() => Case.Constructor<A>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data",
      "path": [
        "src",
        "Data.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeStruct",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data",
      "path": [
        "src",
        "Data.ts"
      ]
    },
    "project": "effect",
    "name": "tuple",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { Data, Equal } from \"effect\"\n\nconst alice = Data.tuple(\"Alice\", 30)\n\nconst bob = Data.tuple(\"Bob\", 40)\n\nassert.deepStrictEqual(Equal.equals(alice, alice), true)\nassert.deepStrictEqual(Equal.equals(alice, Data.tuple(\"Alice\", 30)), true)\n\nassert.deepStrictEqual(Equal.equals(alice, [\"Alice\", 30]), false)\nassert.deepStrictEqual(Equal.equals(alice, bob), false)"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data",
      "path": [
        "src",
        "Data.ts"
      ]
    },
    "project": "effect",
    "name": "array",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { Data, Equal } from \"effect\"\n\nconst alice = Data.struct({ name: \"Alice\", age: 30 })\nconst bob = Data.struct({ name: \"Bob\", age: 40 })\n\nconst persons = Data.array([alice, bob])\n\nassert.deepStrictEqual(\n  Equal.equals(\n    persons,\n    Data.array([\n      Data.struct({ name: \"Alice\", age: 30 }),\n      Data.struct({ name: \"Bob\", age: 40 })\n    ])\n  ),\n  true\n)"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data",
      "path": [
        "src",
        "Data.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeArray",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data",
      "path": [
        "src",
        "Data.ts"
      ]
    },
    "project": "effect",
    "name": "tagged",
    "description": "Provides a tagged constructor for the specified `Case`.",
    "deprecated": false,
    "examples": [
      "import { Data } from \"effect\"\n\ninterface Person {\n  readonly _tag: \"Person\" // the tag\n  readonly name: string\n}\n\nconst Person = Data.tagged<Person>(\"Person\")\n\nconst mike = Person({ name: \"Mike\" })\n\nassert.deepEqual(mike, { _tag: \"Person\", name: \"Mike\" })"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data",
      "path": [
        "src",
        "Data.ts"
      ]
    },
    "project": "effect",
    "name": "TaggedClass",
    "description": "Provides a Tagged constructor for a Case Class.",
    "deprecated": false,
    "examples": [
      "import { Data, Equal } from \"effect\"\n\nclass Person extends Data.TaggedClass(\"Person\")<{ readonly name: string }> {}\n\n// Creating instances of Person\nconst mike1 = new Person({ name: \"Mike\" })\nconst mike2 = new Person({ name: \"Mike\" })\nconst john = new Person({ name: \"John\" })\n\n// Checking equality\nassert.deepStrictEqual(Equal.equals(mike1, mike2), true)\nassert.deepStrictEqual(Equal.equals(mike1, john), false)\n\nassert.deepStrictEqual(mike1._tag, \"Person\")"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data",
      "path": [
        "src",
        "Data.ts"
      ]
    },
    "project": "effect",
    "name": "taggedEnum",
    "description": "Create a constructor for a tagged union of `Data` structs.\n\nYou can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\nthe constructor.",
    "deprecated": false,
    "examples": [
      "import { Data } from \"effect\"\n\nconst { BadRequest, NotFound } = Data.taggedEnum<\n  | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n  | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n>()\n\nconst notFound = NotFound({ status: 404, message: \"Not Found\" })",
      "import { Data } from \"effect\"\n\ntype MyResult<E, A> = Data.TaggedEnum<{\n  Failure: { readonly error: E }\n  Success: { readonly value: A }\n}>\ninterface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n  readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n}\nconst { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n\nconst success = Success({ value: 1 })"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Data",
      "path": [
        "src",
        "Data.ts"
      ]
    },
    "project": "effect",
    "name": "TaggedError",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Data",
      "path": [
        "src",
        "Data.ts"
      ]
    },
    "project": "effect",
    "name": "TaggedEnum",
    "description": "Create a tagged enum data type, which is a union of `Data` structs.\n\n```ts\nimport { Data } from \"effect\"\n\ntype HttpError = Data.TaggedEnum<{\n  BadRequest: { readonly status: 400, readonly message: string }\n  NotFound: { readonly status: 404, readonly message: string }\n}>\n\n// Equivalent to:\ntype HttpErrorPlain =\n  | {\n    readonly _tag: \"BadRequest\"\n    readonly status: 400\n    readonly message: string\n  }\n  | {\n    readonly _tag: \"NotFound\"\n    readonly status: 404\n    readonly message: string\n  }\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type TaggedEnum<\n  A extends Record<string, Record<string, any>> & UntaggedChildren<A>\n> = keyof A extends infer Tag ?\n  Tag extends keyof A ? Types.Simplify<{ readonly _tag: Tag } & { readonly [K in keyof A[Tag]]: A[Tag][K] }>\n  : never\n  : never"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "CurrentTimeZone",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "current time zone",
    "signature": "export declare class CurrentTimeZone"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "type ids",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "TimeZoneTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "type ids",
    "signature": "export declare const TimeZoneTypeId: typeof TimeZoneTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "isDateTime",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "guards",
    "signature": "export declare const isDateTime: (u: unknown) => u is DateTime"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "isTimeZone",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "guards",
    "signature": "export declare const isTimeZone: (u: unknown) => u is TimeZone"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "isTimeZoneOffset",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "guards",
    "signature": "export declare const isTimeZoneOffset: (u: unknown) => u is TimeZone.Offset"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "isTimeZoneNamed",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "guards",
    "signature": "export declare const isTimeZoneNamed: (u: unknown) => u is TimeZone.Named"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "isUtc",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "guards",
    "signature": "export declare const isUtc: (self: DateTime) => self is Utc"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "isZoned",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "guards",
    "signature": "export declare const isZoned: (self: DateTime) => self is Zoned"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "Equivalence",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "instances",
    "signature": "export declare const Equivalence: equivalence.Equivalence<DateTime>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "Order",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "instances",
    "signature": "export declare const Order: order.Order<DateTime>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "clamp",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": null,
    "signature": "export declare const clamp: { <Min extends DateTime, Max extends DateTime>(options: { readonly minimum: Min; readonly maximum: Max; }): <A extends DateTime>(self: A) => A | Min | Max; <A extends DateTime, Min extends DateTime, Max extends DateTime>(self: A, options: { readonly minimum: Min; readonly maximum: Max; }): A | Min | Max; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeFromDate",
    "description": "Create a `DateTime` from a `Date`.\n\nIf the `Date` is invalid, an `IllegalArgumentException` will be thrown.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "export declare const unsafeFromDate: (date: Date) => Utc"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMake",
    "description": "Create a `DateTime` from one of the following:\n\n- A `DateTime`\n- A `Date` instance (invalid dates will throw an `IllegalArgumentException`)\n- The `number` of milliseconds since the Unix epoch\n- An object with the parts of a date\n- A `string` that can be parsed by `Date.parse`",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\n// from Date\nDateTime.unsafeMake(new Date())\n\n// from parts\nDateTime.unsafeMake({ year: 2024 })\n\n// from string\nDateTime.unsafeMake(\"2024-01-01\")"
    ],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "export declare const unsafeMake: <A extends DateTime.Input>(input: A) => DateTime.PreserveZone<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMakeZoned",
    "description": "Create a `DateTime.Zoned` using `DateTime.unsafeMake` and a time zone.\n\nThe input is treated as UTC and then the time zone is attached, unless\n`adjustForTimeZone` is set to `true`. In that case, the input is treated as\nalready in the time zone.",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\nDateTime.unsafeMakeZoned(new Date(), { timeZone: \"Europe/London\" })"
    ],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "export declare const unsafeMakeZoned: (input: DateTime.Input, options?: { readonly timeZone?: number | string | TimeZone | undefined; readonly adjustForTimeZone?: boolean | undefined; }) => Zoned"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "makeZoned",
    "description": "Create a `DateTime.Zoned` using `DateTime.make` and a time zone.\n\nThe input is treated as UTC and then the time zone is attached.\n\nIf the date time input or time zone is invalid, `None` will be returned.",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\nDateTime.makeZoned(new Date(), { timeZone: \"Europe/London\" })"
    ],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "export declare const makeZoned: (input: DateTime.Input, options?: { readonly timeZone?: number | string | TimeZone | undefined; readonly adjustForTimeZone?: boolean | undefined; }) => Option.Option<Zoned>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Create a `DateTime` from one of the following:\n\n- A `DateTime`\n- A `Date` instance (invalid dates will throw an `IllegalArgumentException`)\n- The `number` of milliseconds since the Unix epoch\n- An object with the parts of a date\n- A `string` that can be parsed by `Date.parse`\n\nIf the input is invalid, `None` will be returned.",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\n// from Date\nDateTime.make(new Date())\n\n// from parts\nDateTime.make({ year: 2024 })\n\n// from string\nDateTime.make(\"2024-01-01\")"
    ],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "export declare const make: <A extends DateTime.Input>(input: A) => Option.Option<DateTime.PreserveZone<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "makeZonedFromString",
    "description": "Create a `DateTime.Zoned` from a string.\n\nIt uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "export declare const makeZonedFromString: (input: string) => Option.Option<Zoned>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "now",
    "description": "Get the current time using the `Clock` service and convert it to a `DateTime`.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n})"
    ],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "export declare const now: Effect.Effect<Utc, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeNow",
    "description": "Get the current time using `Date.now`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "export declare const unsafeNow: LazyArg<Utc>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "toUtc",
    "description": "For a `DateTime` returns a new `DateTime.Utc`.",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\nconst now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: \"Europe/London\" })\n\n// set as UTC\nconst utc: DateTime.Utc = DateTime.toUtc(now)"
    ],
    "since": "3.13.0",
    "category": "time zones",
    "signature": "export declare const toUtc: (self: DateTime) => Utc"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "setZone",
    "description": "Set the time zone of a `DateTime`, returning a new `DateTime.Zoned`.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const zone = DateTime.zoneUnsafeMakeNamed(\"Europe/London\")\n\n  // set the time zone\n  const zoned: DateTime.Zoned = DateTime.setZone(now, zone)\n})"
    ],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "export declare const setZone: { (zone: TimeZone, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, zone: TimeZone, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "setZoneOffset",
    "description": "Add a fixed offset time zone to a `DateTime`.\n\nThe offset is in milliseconds.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n\n  // set the offset time zone in milliseconds\n  const zoned: DateTime.Zoned = DateTime.setZoneOffset(now, 3 * 60 * 60 * 1000)\n})"
    ],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "export declare const setZoneOffset: { (offset: number, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, offset: number, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "zoneUnsafeMakeNamed",
    "description": "Attempt to create a named time zone from a IANA time zone identifier.\n\nIf the time zone is invalid, an `IllegalArgumentException` will be thrown.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "export declare const zoneUnsafeMakeNamed: (zoneId: string) => TimeZone.Named"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "zoneMakeOffset",
    "description": "Create a fixed offset time zone.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "export declare const zoneMakeOffset: (offset: number) => TimeZone.Offset"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "zoneMakeNamed",
    "description": "Create a named time zone from a IANA time zone identifier. If the time zone\nis invalid, `None` will be returned.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "export declare const zoneMakeNamed: (zoneId: string) => Option.Option<TimeZone.Named>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "zoneMakeNamedEffect",
    "description": "Create a named time zone from a IANA time zone identifier. If the time zone\nis invalid, it will fail with an `IllegalArgumentException`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "export declare const zoneMakeNamedEffect: (zoneId: string) => Effect.Effect<TimeZone.Named, IllegalArgumentException>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "zoneMakeLocal",
    "description": "Create a named time zone from the system's local time zone.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "export declare const zoneMakeLocal: () => TimeZone.Named"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "zoneFromString",
    "description": "Try parse a TimeZone from a string",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "export declare const zoneFromString: (zone: string) => Option.Option<TimeZone>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "zoneToString",
    "description": "Format a `TimeZone` as a string.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\n// Outputs \"+03:00\"\nDateTime.zoneToString(DateTime.zoneMakeOffset(3 * 60 * 60 * 1000))\n\n// Outputs \"Europe/London\"\nDateTime.zoneToString(DateTime.zoneUnsafeMakeNamed(\"Europe/London\"))"
    ],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "export declare const zoneToString: (self: TimeZone) => string"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "setZoneNamed",
    "description": "Set the time zone of a `DateTime` from an IANA time zone identifier. If the\ntime zone is invalid, `None` will be returned.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  // set the time zone, returns an Option\n  DateTime.setZoneNamed(now, \"Europe/London\")\n})"
    ],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "export declare const setZoneNamed: { (zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Option.Option<Zoned>; (self: DateTime, zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Option.Option<Zoned>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeSetZoneNamed",
    "description": "Set the time zone of a `DateTime` from an IANA time zone identifier. If the\ntime zone is invalid, an `IllegalArgumentException` will be thrown.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  // set the time zone\n  DateTime.unsafeSetZoneNamed(now, \"Europe/London\")\n})"
    ],
    "since": "3.6.0",
    "category": "time zones",
    "signature": "export declare const unsafeSetZoneNamed: { (zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "distance",
    "description": "Calulate the difference between two `DateTime` values, returning the number\nof milliseconds the `other` DateTime is from `self`.\n\nIf `other` is *after* `self`, the result will be a positive number.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const other = DateTime.add(now, { minutes: 1 })\n\n  // returns 60000\n  DateTime.distance(now, other)\n})"
    ],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "export declare const distance: { (other: DateTime): (self: DateTime) => number; (self: DateTime, other: DateTime): number; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "distanceDurationEither",
    "description": "Calulate the difference between two `DateTime` values.\n\nIf the `other` DateTime is before `self`, the result will be a negative\n`Duration`, returned as a `Left`.\n\nIf the `other` DateTime is after `self`, the result will be a positive\n`Duration`, returned as a `Right`.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const other = DateTime.add(now, { minutes: 1 })\n\n  // returns Either.right(Duration.minutes(1))\n  DateTime.distanceDurationEither(now, other)\n\n  // returns Either.left(Duration.minutes(1))\n  DateTime.distanceDurationEither(other, now)\n})"
    ],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "export declare const distanceDurationEither: { (other: DateTime): (self: DateTime) => Either.Either<Duration.Duration, Duration.Duration>; (self: DateTime, other: DateTime): Either.Either<Duration.Duration, Duration.Duration>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "distanceDuration",
    "description": "Calulate the distance between two `DateTime` values.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const other = DateTime.add(now, { minutes: 1 })\n\n  // returns Duration.minutes(1)\n  DateTime.distanceDuration(now, other)\n})"
    ],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "export declare const distanceDuration: { (other: DateTime): (self: DateTime) => Duration.Duration; (self: DateTime, other: DateTime): Duration.Duration; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "min",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "export declare const min: { <That extends DateTime>(that: That): <Self extends DateTime>(self: Self) => Self | That; <Self extends DateTime, That extends DateTime>(self: Self, that: That): Self | That; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "max",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "export declare const max: { <That extends DateTime>(that: That): <Self extends DateTime>(self: Self) => Self | That; <Self extends DateTime, That extends DateTime>(self: Self, that: That): Self | That; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "export declare const greaterThan: { (that: DateTime): (self: DateTime) => boolean; (self: DateTime, that: DateTime): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanOrEqualTo",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "export declare const greaterThanOrEqualTo: { (that: DateTime): (self: DateTime) => boolean; (self: DateTime, that: DateTime): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "lessThan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "export declare const lessThan: { (that: DateTime): (self: DateTime) => boolean; (self: DateTime, that: DateTime): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanOrEqualTo",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "export declare const lessThanOrEqualTo: { (that: DateTime): (self: DateTime) => boolean; (self: DateTime, that: DateTime): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "between",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "export declare const between: { (options: { minimum: DateTime; maximum: DateTime; }): (self: DateTime) => boolean; (self: DateTime, options: { minimum: DateTime; maximum: DateTime; }): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "isFuture",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "export declare const isFuture: (self: DateTime) => Effect.Effect<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeIsFuture",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "export declare const unsafeIsFuture: (self: DateTime) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "isPast",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "export declare const isPast: (self: DateTime) => Effect.Effect<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeIsPast",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "comparisons",
    "signature": "export declare const unsafeIsPast: (self: DateTime) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "toDateUtc",
    "description": "Get the UTC `Date` of a `DateTime`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "conversions",
    "signature": "export declare const toDateUtc: (self: DateTime) => Date"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "toDate",
    "description": "Convert a `DateTime` to a `Date`, applying the time zone first.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "conversions",
    "signature": "export declare const toDate: (self: DateTime) => Date"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "zonedOffset",
    "description": "Calculate the time zone offset of a `DateTime.Zoned` in milliseconds.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "conversions",
    "signature": "export declare const zonedOffset: (self: Zoned) => number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "zonedOffsetIso",
    "description": "Calculate the time zone offset of a `DateTime` in milliseconds.\n\nThe offset is formatted as \"HH:MM\".",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "conversions",
    "signature": "export declare const zonedOffsetIso: (self: Zoned) => string"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "toEpochMillis",
    "description": "Get the milliseconds since the Unix epoch of a `DateTime`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "conversions",
    "signature": "export declare const toEpochMillis: (self: DateTime) => number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "removeTime",
    "description": "Remove the time aspect of a `DateTime`, first adjusting for the time\nzone. It will return a `DateTime.Utc` only containing the date.",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\n// returns \"2024-01-01T00:00:00Z\"\nDateTime.unsafeMakeZoned(\"2024-01-01T05:00:00Z\", {\n  timeZone: \"Pacific/Auckland\",\n  adjustForTimeZone: true\n}).pipe(\n  DateTime.removeTime,\n  DateTime.formatIso\n)"
    ],
    "since": "3.6.0",
    "category": "conversions",
    "signature": "export declare const removeTime: (self: DateTime) => Utc"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "toParts",
    "description": "Get the different parts of a `DateTime` as an object.\n\nThe parts will be time zone adjusted.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "parts",
    "signature": "export declare const toParts: (self: DateTime) => DateTime.PartsWithWeekday"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "toPartsUtc",
    "description": "Get the different parts of a `DateTime` as an object.\n\nThe parts will be in UTC.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "parts",
    "signature": "export declare const toPartsUtc: (self: DateTime) => DateTime.PartsWithWeekday"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "getPartUtc",
    "description": "Get a part of a `DateTime` as a number.\n\nThe part will be in the UTC time zone.",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\nconst now = DateTime.unsafeMake({ year: 2024 })\nconst year = DateTime.getPartUtc(now, \"year\")\nassert.strictEqual(year, 2024)"
    ],
    "since": "3.6.0",
    "category": "parts",
    "signature": "export declare const getPartUtc: { (part: keyof DateTime.PartsWithWeekday): (self: DateTime) => number; (self: DateTime, part: keyof DateTime.PartsWithWeekday): number; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "getPart",
    "description": "Get a part of a `DateTime` as a number.\n\nThe part will be time zone adjusted.",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\nconst now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: \"Europe/London\" })\nconst year = DateTime.getPart(now, \"year\")\nassert.strictEqual(year, 2024)"
    ],
    "since": "3.6.0",
    "category": "parts",
    "signature": "export declare const getPart: { (part: keyof DateTime.PartsWithWeekday): (self: DateTime) => number; (self: DateTime, part: keyof DateTime.PartsWithWeekday): number; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "setParts",
    "description": "Set the different parts of a `DateTime` as an object.\n\nThe Date will be time zone adjusted.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "parts",
    "signature": "export declare const setParts: { (parts: Partial<DateTime.PartsWithWeekday>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsWithWeekday>): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "setPartsUtc",
    "description": "Set the different parts of a `DateTime` as an object.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "parts",
    "signature": "export declare const setPartsUtc: { (parts: Partial<DateTime.PartsWithWeekday>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsWithWeekday>): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "withCurrentZone",
    "description": "Provide the `CurrentTimeZone` to an effect.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\nconst zone = DateTime.zoneUnsafeMakeNamed(\"Europe/London\")\n\nEffect.gen(function* () {\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZone(zone))"
    ],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "export declare const withCurrentZone: { (zone: TimeZone): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, zone: TimeZone): Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "withCurrentZoneOffset",
    "description": "Provide the `CurrentTimeZone` to an effect, using a offset.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  // will use the system's local time zone\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZoneOffset(3 * 60 * 60 * 1000))"
    ],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "export declare const withCurrentZoneOffset: { (offset: number): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, offset: number): Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "withCurrentZoneNamed",
    "description": "Provide the `CurrentTimeZone` to an effect using an IANA time zone\nidentifier.\n\nIf the time zone is invalid, it will fail with an `IllegalArgumentException`.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  // will use the \"Europe/London\" time zone\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZoneNamed(\"Europe/London\"))"
    ],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "export declare const withCurrentZoneNamed: { (zone: string): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E | IllegalArgumentException, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, zone: string): Effect.Effect<A, E | IllegalArgumentException, Exclude<R, CurrentTimeZone>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "nowInCurrentZone",
    "description": "Get the current time as a `DateTime.Zoned`, using the `CurrentTimeZone`.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  // will use the \"Europe/London\" time zone\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZoneNamed(\"Europe/London\"))"
    ],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "export declare const nowInCurrentZone: Effect.Effect<Zoned, never, CurrentTimeZone>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "mutate",
    "description": "Modify a `DateTime` by applying a function to a cloned `Date` instance.\n\nThe `Date` will first have the time zone applied if possible, and then be\nconverted back to a `DateTime` within the same time zone.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "mapping",
    "signature": "export declare const mutate: { (f: (date: Date) => void): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (date: Date) => void): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "mutateUtc",
    "description": "Modify a `DateTime` by applying a function to a cloned UTC `Date` instance.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "mapping",
    "signature": "export declare const mutateUtc: { (f: (date: Date) => void): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (date: Date) => void): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "mapEpochMillis",
    "description": "Transform a `DateTime` by applying a function to the number of milliseconds\nsince the Unix epoch.",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\n// add 10 milliseconds\nDateTime.unsafeMake(0).pipe(\n  DateTime.mapEpochMillis((millis) => millis + 10)\n)"
    ],
    "since": "3.6.0",
    "category": "mapping",
    "signature": "export declare const mapEpochMillis: { (f: (millis: number) => number): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (millis: number) => number): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "withDate",
    "description": "Using the time zone adjusted `Date`, apply a function to the `Date` and\nreturn the result.",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\n// get the time zone adjusted date in milliseconds\nDateTime.unsafeMakeZoned(0, { timeZone: \"Europe/London\" }).pipe(\n  DateTime.withDate((date) => date.getTime())\n)"
    ],
    "since": "3.6.0",
    "category": "mapping",
    "signature": "export declare const withDate: { <A>(f: (date: Date) => A): (self: DateTime) => A; <A>(self: DateTime, f: (date: Date) => A): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "withDateUtc",
    "description": "Using the time zone adjusted `Date`, apply a function to the `Date` and\nreturn the result.",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\n// get the date in milliseconds\nDateTime.unsafeMake(0).pipe(\n  DateTime.withDateUtc((date) => date.getTime())\n)"
    ],
    "since": "3.6.0",
    "category": "mapping",
    "signature": "export declare const withDateUtc: { <A>(f: (date: Date) => A): (self: DateTime) => A; <A>(self: DateTime, f: (date: Date) => A): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "mapping",
    "signature": "export declare const match: { <A, B>(options: { readonly onUtc: (_: Utc) => A; readonly onZoned: (_: Zoned) => B; }): (self: DateTime) => A | B; <A, B>(self: DateTime, options: { readonly onUtc: (_: Utc) => A; readonly onZoned: (_: Zoned) => B; }): A | B; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "addDuration",
    "description": "Add the given `Duration` to a `DateTime`.",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\n// add 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.addDuration(\"5 minutes\")\n)"
    ],
    "since": "3.6.0",
    "category": "math",
    "signature": "export declare const addDuration: { (duration: Duration.DurationInput): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, duration: Duration.DurationInput): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "subtractDuration",
    "description": "Subtract the given `Duration` from a `DateTime`.",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\n// subtract 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.subtractDuration(\"5 minutes\")\n)"
    ],
    "since": "3.6.0",
    "category": "math",
    "signature": "export declare const subtractDuration: { (duration: Duration.DurationInput): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, duration: Duration.DurationInput): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "add",
    "description": "Add the given `amount` of `unit`'s to a `DateTime`.\n\nThe time zone is taken into account when adding days, weeks, months, and\nyears.",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\n// add 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.add({ minutes: 5 })\n)"
    ],
    "since": "3.6.0",
    "category": "math",
    "signature": "export declare const add: { (parts: Partial<DateTime.PartsForMath>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsForMath>): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "subtract",
    "description": "Subtract the given `amount` of `unit`'s from a `DateTime`.",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\n// subtract 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.subtract({ minutes: 5 })\n)"
    ],
    "since": "3.6.0",
    "category": "math",
    "signature": "export declare const subtract: { (parts: Partial<DateTime.PartsForMath>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsForMath>): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "startOf",
    "description": "Converts a `DateTime` to the start of the given `part`.\n\nIf the part is `week`, the `weekStartsOn` option can be used to specify the\nday of the week that the week starts on. The default is 0 (Sunday).",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\n// returns \"2024-01-01T00:00:00Z\"\nDateTime.unsafeMake(\"2024-01-01T12:00:00Z\").pipe(\n  DateTime.startOf(\"day\"),\n  DateTime.formatIso\n)"
    ],
    "since": "3.6.0",
    "category": "math",
    "signature": "export declare const startOf: { (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "endOf",
    "description": "Converts a `DateTime` to the end of the given `part`.\n\nIf the part is `week`, the `weekStartsOn` option can be used to specify the\nday of the week that the week starts on. The default is 0 (Sunday).",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\n// returns \"2024-01-01T23:59:59.999Z\"\nDateTime.unsafeMake(\"2024-01-01T12:00:00Z\").pipe(\n  DateTime.endOf(\"day\"),\n  DateTime.formatIso\n)"
    ],
    "since": "3.6.0",
    "category": "math",
    "signature": "export declare const endOf: { (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "nearest",
    "description": "Converts a `DateTime` to the nearest given `part`.\n\nIf the part is `week`, the `weekStartsOn` option can be used to specify the\nday of the week that the week starts on. The default is 0 (Sunday).",
    "deprecated": false,
    "examples": [
      "import { DateTime } from \"effect\"\n\n// returns \"2024-01-02T00:00:00Z\"\nDateTime.unsafeMake(\"2024-01-01T12:01:00Z\").pipe(\n  DateTime.nearest(\"day\"),\n  DateTime.formatIso\n)"
    ],
    "since": "3.6.0",
    "category": "math",
    "signature": "export declare const nearest: { (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "format",
    "description": "Format a `DateTime` as a string using the `DateTimeFormat` API.\n\nThe `timeZone` option is set to the offset of the time zone.\n\nNote: On Node versions < 22, fixed \"Offset\" zones will set the time zone to\n\"UTC\" and use the adjusted `Date`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "export declare const format: { (options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): (self: DateTime) => string; (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): string; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "formatLocal",
    "description": "Format a `DateTime` as a string using the `DateTimeFormat` API.\n\nIt will use the system's local time zone & locale.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "export declare const formatLocal: { (options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): (self: DateTime) => string; (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): string; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "formatUtc",
    "description": "Format a `DateTime` as a string using the `DateTimeFormat` API.\n\nThis forces the time zone to be UTC.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "export declare const formatUtc: { (options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): (self: DateTime) => string; (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): string; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "formatIntl",
    "description": "Format a `DateTime` as a string using the `DateTimeFormat` API.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "export declare const formatIntl: { (format: Intl.DateTimeFormat): (self: DateTime) => string; (self: DateTime, format: Intl.DateTimeFormat): string; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "formatIso",
    "description": "Format a `DateTime` as a UTC ISO string.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "export declare const formatIso: (self: DateTime) => string"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "formatIsoDate",
    "description": "Format a `DateTime` as a time zone adjusted ISO date string.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "export declare const formatIsoDate: (self: DateTime) => string"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "formatIsoDateUtc",
    "description": "Format a `DateTime` as a UTC ISO date string.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "export declare const formatIsoDateUtc: (self: DateTime) => string"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "formatIsoOffset",
    "description": "Format a `DateTime.Zoned` as a ISO string with an offset.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "export declare const formatIsoOffset: (self: DateTime) => string"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "formatIsoZoned",
    "description": "Format a `DateTime.Zoned` as a string.\n\nIt uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "formatting",
    "signature": "export declare const formatIsoZoned: (self: Zoned) => string"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "layerCurrentZoneLocal",
    "description": "Create a Layer from the systems local time zone.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": "export declare const layerCurrentZoneLocal: Layer.Layer<CurrentTimeZone, never, never>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "setZoneCurrent",
    "description": "Set the time zone of a `DateTime` to the current time zone, which is\ndetermined by the `CurrentTimeZone` service.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n\n  // set the time zone to \"Europe/London\"\n  const zoned = yield* DateTime.setZoneCurrent(now)\n}).pipe(DateTime.withCurrentZoneNamed(\"Europe/London\"))"
    ],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "withCurrentZoneLocal",
    "description": "Provide the `CurrentTimeZone` to an effect, using the system's local time\nzone.",
    "deprecated": false,
    "examples": [
      "import { DateTime, Effect } from \"effect\"\n\nEffect.gen(function* () {\n  // will use the system's local time zone\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZoneLocal)"
    ],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "layerCurrentZone",
    "description": "Create a Layer from the given time zone.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "layerCurrentZoneOffset",
    "description": "Create a Layer from the given time zone offset.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "layerCurrentZoneNamed",
    "description": "Create a Layer from the given IANA time zone identifier.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "current time zone",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "Utc",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export interface Utc extends DateTime.Proto {\n  readonly _tag: \"Utc\"\n  readonly epochMillis: number\n  partsUtc: DateTime.PartsWithWeekday | undefined\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "Zoned",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export interface Zoned extends DateTime.Proto {\n  readonly _tag: \"Zoned\"\n  readonly epochMillis: number\n  readonly zone: TimeZone\n  adjustedEpochMillis: number | undefined\n  partsAdjusted: DateTime.PartsWithWeekday | undefined\n  partsUtc: DateTime.PartsWithWeekday | undefined\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "DateTime",
    "description": "A `DateTime` represents a point in time. It can optionally have a time zone\nassociated with it.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export type DateTime = Utc | Zoned"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "TimeZone",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export type TimeZone = TimeZone.Offset | TimeZone.Named"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "TimeZoneTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "type ids",
    "signature": "export type TimeZoneTypeId = typeof TimeZoneTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DateTime",
      "path": [
        "src",
        "DateTime.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "type ids",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DefaultServices",
      "path": [
        "src",
        "DefaultServices.ts"
      ]
    },
    "project": "effect",
    "name": "liveServices",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const liveServices: Context.Context<DefaultServices>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "DefaultServices",
      "path": [
        "src",
        "DefaultServices.ts"
      ]
    },
    "project": "effect",
    "name": "currentServices",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentServices: FiberRef.FiberRef<Context.Context<DefaultServices>>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "DefaultServices",
      "path": [
        "src",
        "DefaultServices.ts"
      ]
    },
    "project": "effect",
    "name": "DefaultServices",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type DefaultServices =\n  | Clock.Clock\n  | Console.Console\n  | Random.Random\n  | ConfigProvider.ConfigProvider\n  | Tracer.Tracer"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "DeferredTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const DeferredTypeId: typeof DeferredTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <A, E = never>() => Effect.Effect<Deferred<A, E>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "makeAs",
    "description": "Creates a new `Deferred` from the specified `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeAs: <A, E = never>(fiberId: FiberId.FiberId) => Effect.Effect<Deferred<A, E>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "complete",
    "description": "Completes the deferred with the result of the specified effect. If the\ndeferred has already been completed, the method will produce false.\n\nNote that `Deferred.completeWith` will be much faster, so consider using\nthat if you do not need to memoize the result of the specified effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const complete: { <A, E>(effect: Effect.Effect<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "completeWith",
    "description": "Completes the deferred with the result of the specified effect. If the\ndeferred has already been completed, the method will produce false.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const completeWith: { <A, E>(effect: Effect.Effect<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "done",
    "description": "Exits the `Deferred` with the specified `Exit` value, which will be\npropagated to all fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const done: { <A, E>(exit: Exit.Exit<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, exit: Exit.Exit<A, E>): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": "Fails the `Deferred` with the specified error, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const fail: { <E>(error: E): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, error: E): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "failSync",
    "description": "Fails the `Deferred` with the specified error, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const failSync: { <E>(evaluate: LazyArg<E>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<E>): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "failCause",
    "description": "Fails the `Deferred` with the specified `Cause`, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const failCause: { <E>(cause: Cause.Cause<E>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, cause: Cause.Cause<E>): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "failCauseSync",
    "description": "Fails the `Deferred` with the specified `Cause`, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const failCauseSync: { <E>(evaluate: LazyArg<Cause.Cause<E>>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<Cause.Cause<E>>): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "die",
    "description": "Kills the `Deferred` with the specified defect, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const die: { (defect: unknown): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, defect: unknown): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "dieSync",
    "description": "Kills the `Deferred` with the specified defect, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const dieSync: { (evaluate: LazyArg<unknown>): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<unknown>): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "interrupt",
    "description": "Completes the `Deferred` with interruption. This will interrupt all fibers\nwaiting on the value of the `Deferred` with the `FiberId` of the fiber\ncalling this method.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const interrupt: <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "interruptWith",
    "description": "Completes the `Deferred` with interruption. This will interrupt all fibers\nwaiting on the value of the `Deferred` with the specified `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const interruptWith: { (fiberId: FiberId.FiberId): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, fiberId: FiberId.FiberId): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "isDone",
    "description": "Returns `true` if this `Deferred` has already been completed with a value or\nan error, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isDone: <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "poll",
    "description": "Returns a `Some<Effect<A, E, R>>` from the `Deferred` if this `Deferred` has\nalready been completed, `None` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const poll: <A, E>(self: Deferred<A, E>) => Effect.Effect<Option.Option<Effect.Effect<A, E>>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": "Completes the `Deferred` with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const succeed: { <A>(value: A): <E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, value: A): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "sync",
    "description": "Completes the `Deferred` with the specified lazily evaluated value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const sync: { <A>(evaluate: LazyArg<A>): <E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<A>): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMake",
    "description": "Unsafely creates a new `Deferred` from the specified `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeMake: <A, E = never>(fiberId: FiberId.FiberId) => Deferred<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeDone",
    "description": "Unsafely exits the `Deferred` with the specified `Exit` value, which will be\npropagated to all fibers waiting on the value of the `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeDone: <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>) => void"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "await",
    "description": "Retrieves the value of the `Deferred`, suspending the fiber running the\nworkflow until the result is available.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const await: <A, E>(self: Deferred<A, E>) => Effect.Effect<A, E>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "Deferred",
    "description": "A `Deferred` represents an asynchronous variable that can be set exactly\nonce, with the ability for an arbitrary number of fibers to suspend (by\ncalling `Deferred.await`) and automatically resume when the variable is set.\n\n`Deferred` can be used for building primitive actions whose completions\nrequire the coordinated action of multiple fibers, and for building\nhigher-level concurrent or asynchronous structures.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Deferred<in out A, in out E = never> extends Effect.Effect<A, E>, Deferred.Variance<A, E> {\n  /** @internal */\n  readonly state: MutableRef.MutableRef<internal.State<A, E>>\n  /** @internal */\n  readonly blockingOn: FiberId.FiberId\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: DeferredUnify<this>\n  readonly [Unify.ignoreSymbol]?: DeferredUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "DeferredUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface DeferredUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Deferred?: () => Extract<A[Unify.typeSymbol], Deferred<any, any>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "DeferredUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface DeferredUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Deferred",
      "path": [
        "src",
        "Deferred.ts"
      ]
    },
    "project": "effect",
    "name": "DeferredTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type DeferredTypeId = typeof DeferredTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "diff",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "patch",
    "signature": "export declare const diff: { <Value>(oldValue: Value, newValue: Value): <Patch>(self: Differ<Value, Patch>) => Patch; <Value, Patch>(self: Differ<Value, Patch>, oldValue: Value, newValue: Value): Patch; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "combine",
    "description": "Combines two patches to produce a new patch that describes the updates of\nthe first patch and then the updates of the second patch. The combine\noperation should be associative. In addition, if the combine operation is\ncommutative then joining multiple fibers concurrently will result in\ndeterministic `FiberRef` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "patch",
    "signature": "export declare const combine: { <Patch>(first: Patch, second: Patch): <Value>(self: Differ<Value, Patch>) => Patch; <Value, Patch>(self: Differ<Value, Patch>, first: Patch, second: Patch): Patch; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "patch",
    "description": "Applies a patch to an old value to produce a new value that is equal to the\nold value with the updates described by the patch.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "patch",
    "signature": "export declare const patch: { <Patch, Value>(patch: Patch, oldValue: Value): (self: Differ<Value, Patch>) => Value; <Patch, Value>(self: Differ<Value, Patch>, patch: Patch, oldValue: Value): Value; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new `Differ`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <Value, Patch>(params: { readonly empty: Patch; readonly diff: (oldValue: Value, newValue: Value) => Patch; readonly combine: (first: Patch, second: Patch) => Patch; readonly patch: (patch: Patch, oldValue: Value) => Value; }) => Differ<Value, Patch>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "environment",
    "description": "Constructs a differ that knows how to diff `Env` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const environment: <A>() => Differ<Context<A>, Differ.Context.Patch<A, A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "chunk",
    "description": "Constructs a differ that knows how to diff a `Chunk` of values given a\ndiffer that knows how to diff the values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const chunk: <Value, Patch>(differ: Differ<Value, Patch>) => Differ<Chunk<Value>, Differ.Chunk.Patch<Value, Patch>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "hashMap",
    "description": "Constructs a differ that knows how to diff a `HashMap` of keys and values given\na differ that knows how to diff the values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const hashMap: <Key, Value, Patch>(differ: Differ<Value, Patch>) => Differ<HashMap<Key, Value>, Differ.HashMap.Patch<Key, Value, Patch>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "hashSet",
    "description": "Constructs a differ that knows how to diff a `HashSet` of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const hashSet: <Value>() => Differ<HashSet<Value>, Differ.HashSet.Patch<Value>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "orElseEither",
    "description": "Combines this differ and the specified differ to produce a differ that\nknows how to diff the sum of their values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const orElseEither: { <Value2, Patch2>(that: Differ<Value2, Patch2>): <Value, Patch>(self: Differ<Value, Patch>) => Differ<Either<Value2, Value>, Differ.Or.Patch<Value, Value2, Patch, Patch2>>; <Value, Patch, Value2, Patch2>(self: Differ<Value, Patch>, that: Differ<Value2, Patch2>): Differ<Either<Value2, Value>, Differ.Or.Patch<Value, Value2, Patch, Patch2>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "readonlyArray",
    "description": "Constructs a differ that knows how to diff a `ReadonlyArray` of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const readonlyArray: <Value, Patch>(differ: Differ<Value, Patch>) => Differ<ReadonlyArray<Value>, Differ.ReadonlyArray.Patch<Value, Patch>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "transform",
    "description": "Transforms the type of values that this differ knows how to differ using\nthe specified functions that map the new and old value types to each other.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const transform: { <Value, Value2>(options: { readonly toNew: (value: Value) => Value2; readonly toOld: (value: Value2) => Value; }): <Patch>(self: Differ<Value, Patch>) => Differ<Value2, Patch>; <Value, Patch, Value2>(self: Differ<Value, Patch>, options: { readonly toNew: (value: Value) => Value2; readonly toOld: (value: Value2) => Value; }): Differ<Value2, Patch>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "update",
    "description": "Constructs a differ that just diffs two values by returning a function that\nsets the value to the new value. This differ does not support combining\nmultiple updates to the value compositionally and should only be used when\nthere is no compositional way to update them.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const update: <A>() => Differ<A, (a: A) => A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "updateWith",
    "description": "A variant of `update` that allows specifying the function that will be used\nto combine old values with new values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const updateWith: <A>(f: (x: A, y: A) => A) => Differ<A, (a: A) => A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Combines this differ and the specified differ to produce a new differ that\nknows how to diff the product of their values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const zip: { <Value2, Patch2>(that: Differ<Value2, Patch2>): <Value, Patch>(self: Differ<Value, Patch>) => Differ<readonly [Value, Value2], readonly [Patch, Patch2]>; <Value, Patch, Value2, Patch2>(self: Differ<Value, Patch>, that: Differ<Value2, Patch2>): Differ<readonly [Value, Value2], readonly [Patch, Patch2]>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "An empty patch that describes no changes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "patch",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "Differ",
    "description": "A `Differ<Value, Patch>` knows how to compare an old value and new value of\ntype `Value` to produce a patch of type `Patch` that describes the\ndifferences between those values. A `Differ` also knows how to apply a patch\nto an old value to produce a new value that represents the old value updated\nwith the changes described by the patch.\n\nA `Differ` can be used to construct a `FiberRef` supporting compositional\nupdates using the `FiberRef.makePatch` constructor.\n\nThe `Differ` companion object contains constructors for `Differ` values for\ncommon data types such as `Chunk`, `HashMap`, and `HashSet``. In addition,\n`Differ`values can be transformed using the `transform` operator and combined\nusing the `orElseEither` and `zip` operators. This allows creating `Differ`\nvalues for arbitrarily complex data types compositionally.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Differ<in out Value, in out Patch> extends Pipeable {\n  readonly [TypeId]: {\n    readonly _V: Types.Invariant<Value>\n    readonly _P: Types.Invariant<Patch>\n  }\n  readonly empty: Patch\n  diff(oldValue: Value, newValue: Value): Patch\n  combine(first: Patch, second: Patch): Patch\n  patch(patch: Patch, oldValue: Value): Value\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Differ",
      "path": [
        "src",
        "Differ.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "decodeUnknown",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.5.0",
    "category": null,
    "signature": "export declare const decodeUnknown: (u: unknown) => Option.Option<Duration>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "zero",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const zero: Duration"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "infinity",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const infinity: Duration"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "export declare const match: { <A, B>(options: { readonly onMillis: (millis: number) => A; readonly onNanos: (nanos: bigint) => B; }): (self: DurationInput) => A | B; <A, B>(self: DurationInput, options: { readonly onMillis: (millis: number) => A; readonly onNanos: (nanos: bigint) => B; }): A | B; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "matchWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "export declare const matchWith: { <A, B>(that: DurationInput, options: { readonly onMillis: (self: number, that: number) => A; readonly onNanos: (self: bigint, that: bigint) => B; }): (self: DurationInput) => A | B; <A, B>(self: DurationInput, that: DurationInput, options: { readonly onMillis: (self: number, that: number) => A; readonly onNanos: (self: bigint, that: bigint) => B; }): A | B; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "Order",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Order: order.Order<Duration>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "between",
    "description": "Checks if a `Duration` is between a `minimum` and `maximum` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const between: { (options: { minimum: DurationInput; maximum: DurationInput; }): (self: DurationInput) => boolean; (self: DurationInput, options: { minimum: DurationInput; maximum: DurationInput; }): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "min",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const min: { (that: DurationInput): (self: DurationInput) => Duration; (self: DurationInput, that: DurationInput): Duration; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "max",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "order",
    "signature": "export declare const max: { (that: DurationInput): (self: DurationInput) => Duration; (self: DurationInput, that: DurationInput): Duration; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "clamp",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "order",
    "signature": "export declare const clamp: { (options: { minimum: DurationInput; maximum: DurationInput; }): (self: DurationInput) => Duration; (self: DurationInput, options: { minimum: DurationInput; maximum: DurationInput; }): Duration; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "divide",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.4.19",
    "category": "math",
    "signature": "export declare const divide: { (by: number): (self: DurationInput) => Option.Option<Duration>; (self: DurationInput, by: number): Option.Option<Duration>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeDivide",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.4.19",
    "category": "math",
    "signature": "export declare const unsafeDivide: { (by: number): (self: DurationInput) => Duration; (self: DurationInput, by: number): Duration; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "times",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const times: { (times: number): (self: DurationInput) => Duration; (self: DurationInput, times: number): Duration; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "subtract",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const subtract: { (that: DurationInput): (self: DurationInput) => Duration; (self: DurationInput, that: DurationInput): Duration; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "sum",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const sum: { (that: DurationInput): (self: DurationInput) => Duration; (self: DurationInput, that: DurationInput): Duration; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "lessThan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const lessThan: { (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanOrEqualTo",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const lessThanOrEqualTo: { (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const greaterThan: { (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanOrEqualTo",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const greaterThanOrEqualTo: { (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "equals",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const equals: { (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "decode",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "isDuration",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "isFinite",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "isZero",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "nanos",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "micros",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "millis",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "seconds",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "minutes",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "hours",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "days",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "weeks",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "toMillis",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "toSeconds",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "toMinutes",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "toHours",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "toDays",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "toWeeks",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "toNanos",
    "description": "Get the duration in nanoseconds as a bigint.\n\nIf the duration is infinite, returns `Option.none()`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeToNanos",
    "description": "Get the duration in nanoseconds as a bigint.\n\nIf the duration is infinite, it throws an error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "toHrTime",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "Equivalence",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "parts",
    "description": "Converts a `Duration` to its parts.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "format",
    "description": "Converts a `Duration` to a human readable string.",
    "deprecated": false,
    "examples": [
      "import { Duration } from \"effect\"\n\nDuration.format(Duration.millis(1000)) // \"1s\"\nDuration.format(Duration.millis(1001)) // \"1s 1ms\""
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeFormatIso",
    "description": "Formats a Duration into an ISO8601 duration string.\n\nMonths are assumed to be 30 days and years are assumed to be 365 days.\n\nMilliseconds and nanoseconds are expressed as fractional seconds.",
    "deprecated": false,
    "examples": [
      "import { Duration } from \"effect\"\n\nDuration.unsafeFormatIso(Duration.days(1)) // => \"P1D\"\nDuration.unsafeFormatIso(Duration.minutes(90)) // => \"PT1H30M\"\nDuration.unsafeFormatIso(Duration.millis(1500)) // => \"PT1.5S\""
    ],
    "since": "3.13.0",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "formatIso",
    "description": "Formats a Duration into an ISO8601 duration string.\n\nMonths are assumed to be 30 days and years are assumed to be 365 days.\n\nReturns `Option.none()` if the duration is infinite.",
    "deprecated": false,
    "examples": [
      "import { Duration, Option } from \"effect\"\n\nDuration.formatIso(Duration.days(1)) // => Option.some(\"P1D\")\nDuration.formatIso(Duration.minutes(90)) // => Option.some(\"PT1H30M\")\nDuration.formatIso(Duration.millis(1500)) // => Option.some(\"PT1.5S\")\nDuration.formatIso(Duration.infinity) // => Option.none()"
    ],
    "since": "3.13.0",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "fromIso",
    "description": "Parses an ISO8601 duration string into a `Duration`.\n\nMonths are assumed to be 30 days and years are assumed to be 365 days.",
    "deprecated": false,
    "examples": [
      "import { Duration, Option } from \"effect\"\n\nDuration.fromIso(\"P1D\") // => Option.some(Duration.days(1))\nDuration.fromIso(\"PT1H\") // => Option.some(Duration.hours(1))\nDuration.fromIso(\"PT1M\") // => Option.some(Duration.minutes(1))\nDuration.fromIso(\"PT1.5S\") // => Option.some(Duration.seconds(1.5))"
    ],
    "since": "3.13.0",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "Duration",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Duration extends Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly value: DurationValue\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "DurationInput",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type DurationInput =\n  | Duration\n  | number // millis\n  | bigint // nanos\n  | readonly [seconds: number, nanos: number]\n  | `${number} ${Unit}`"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "DurationValue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type DurationValue =\n  | {\n    readonly _tag: \"Millis\"\n    readonly millis: number\n  }\n  | {\n    readonly _tag: \"Nanos\"\n    readonly nanos: bigint\n  }\n  | {\n    readonly _tag: \"Infinity\"\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Duration",
      "path": [
        "src",
        "Duration.ts"
      ]
    },
    "project": "effect",
    "name": "Unit",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type Unit =\n  | \"nano\"\n  | \"nanos\"\n  | \"micro\"\n  | \"micros\"\n  | \"milli\"\n  | \"millis\"\n  | \"second\"\n  | \"seconds\"\n  | \"minute\"\n  | \"minutes\"\n  | \"hour\"\n  | \"hours\"\n  | \"day\"\n  | \"days\"\n  | \"week\"\n  | \"weeks\""
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "EffectTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export declare const EffectTypeId: typeof EffectTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "isEffect",
    "description": "Checks if a given value is an `Effect` value.\n\n**When to Use**\n\nThis function can be useful for checking the type of a value before\nattempting to operate on it as an `Effect` value. For example, you could use\n`Effect.isEffect` to check the type of a value before using it as an argument\nto a function that expects an `Effect` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isEffect: (u: unknown) => u is Effect<unknown, unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "cachedWithTTL",
    "description": "Returns an effect that caches its result for a specified `Duration`,\nknown as \"timeToLive\" (TTL).\n\n**Details**\n\nThis function is used to cache the result of an effect for a specified amount\nof time. This means that the first time the effect is evaluated, its result\nis computed and stored.\n\nIf the effect is evaluated again within the specified `timeToLive`, the\ncached result will be used, avoiding recomputation.\n\nAfter the specified duration has passed, the cache expires, and the effect\nwill be recomputed upon the next evaluation.\n\n**When to Use**\n\nUse this function when you have an effect that involves costly operations or\ncomputations, and you want to avoid repeating them within a short time frame.\n\nIt's ideal for scenarios where the result of an effect doesn't change\nfrequently and can be reused for a specified duration.\n\nBy caching the result, you can improve efficiency and reduce unnecessary\ncomputations, especially in performance-critical applications.",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log(\"expensive task...\")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  const cached = yield* Effect.cachedWithTTL(expensiveTask, \"150 millis\")\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* Effect.sleep(\"100 millis\")\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\n// Effect.runFork(program)\n// Output:\n// expensive task...\n// result 1\n// result 1\n// expensive task...\n// result 2"
    ],
    "since": "2.0.0",
    "category": "Caching",
    "signature": "export declare const cachedWithTTL: { (timeToLive: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E>, never, R>; <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.DurationInput): Effect<Effect<A, E>, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "cachedInvalidateWithTTL",
    "description": "Caches an effect's result for a specified duration and allows manual\ninvalidation before expiration.\n\n**Details**\n\nThis function behaves similarly to {@link cachedWithTTL} by caching the\nresult of an effect for a specified period of time. However, it introduces an\nadditional feature: it provides an effect that allows you to manually\ninvalidate the cached result before it naturally expires.\n\nThis gives you more control over the cache, allowing you to refresh the\nresult when needed, even if the original cache has not yet expired.\n\nOnce the cache is invalidated, the next time the effect is evaluated, the\nresult will be recomputed, and the cache will be refreshed.\n\n**When to Use**\n\nUse this function when you have an effect whose result needs to be cached for\na certain period, but you also want the option to refresh the cache manually\nbefore the expiration time.\n\nThis is useful when you need to ensure that the cached data remains valid for\na certain period but still want to invalidate it if the underlying data\nchanges or if you want to force a recomputation.",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log(\"expensive task...\")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(\n    expensiveTask,\n    \"1 hour\"\n  )\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* invalidate\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\n// Effect.runFork(program)\n// Output:\n// expensive task...\n// result 1\n// result 1\n// expensive task...\n// result 2"
    ],
    "since": "2.0.0",
    "category": "Caching",
    "signature": "export declare const cachedInvalidateWithTTL: { (timeToLive: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<[Effect<A, E>, Effect<void>], never, R>; <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.DurationInput): Effect<[Effect<A, E>, Effect<void>], never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "cached",
    "description": "Returns an effect that lazily computes a result and caches it for subsequent\nevaluations.\n\n**Details**\n\nThis function wraps an effect and ensures that its result is computed only\nonce. Once the result is computed, it is cached, meaning that subsequent\nevaluations of the same effect will return the cached result without\nre-executing the logic.\n\n**When to Use**\n\nUse this function when you have an expensive or time-consuming operation that\nyou want to avoid repeating. The first evaluation will compute the result,\nand all following evaluations will immediately return the cached value,\nimproving performance and reducing unnecessary work.",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log(\"expensive task...\")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  console.log(\"non-cached version:\")\n  yield* expensiveTask.pipe(Effect.andThen(Console.log))\n  yield* expensiveTask.pipe(Effect.andThen(Console.log))\n  console.log(\"cached version:\")\n  const cached = yield* Effect.cached(expensiveTask)\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\n// Effect.runFork(program)\n// Output:\n// non-cached version:\n// expensive task...\n// result 1\n// expensive task...\n// result 2\n// cached version:\n// expensive task...\n// result 3\n// result 3"
    ],
    "since": "2.0.0",
    "category": "Caching",
    "signature": "export declare const cached: <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E, R>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "cachedFunction",
    "description": "Returns a memoized version of a function with effects, reusing results for\nthe same inputs.\n\n**Details**\n\nThis function creates a memoized version of a given function that performs an\neffect. Memoization ensures that once a result is computed for a specific\ninput, it is stored and reused for subsequent calls with the same input,\nreducing the need to recompute the result.\n\nThe function can optionally take an `Equivalence` parameter to\ndetermine how inputs are compared for caching purposes.\n\n**When to Use**\n\nUse this function when you have a function that performs an effect and you\nwant to avoid recomputing the result for the same input multiple times.\n\nIt's ideal for functions that produce deterministic results based on their\ninputs, and you want to improve performance by caching the output.\n\nThis is particularly useful in scenarios where the function involves\nexpensive calculations or operations that should be avoided after the first\nexecution with the same parameters.",
    "deprecated": false,
    "examples": [
      "import { Effect, Random } from \"effect\"\n\nconst program = Effect.gen(function* () {\n  const randomNumber = (n: number) => Random.nextIntBetween(1, n)\n  console.log(\"non-memoized version:\")\n  console.log(yield* randomNumber(10))\n  console.log(yield* randomNumber(10))\n\n  console.log(\"memoized version:\")\n  const memoized = yield* Effect.cachedFunction(randomNumber)\n  console.log(yield* memoized(10))\n  console.log(yield* memoized(10))\n})\n\n// Effect.runFork(program)\n// Example Output:\n// non-memoized version:\n// 2\n// 8\n// memoized version:\n// 5\n// 5"
    ],
    "since": "2.0.0",
    "category": "Caching",
    "signature": "export declare const cachedFunction: <A, B, E, R>(f: (a: A) => Effect<B, E, R>, eq?: Equivalence<A>) => Effect<(a: A) => Effect<B, E, R>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "once",
    "description": "Returns an effect that executes only once, regardless of how many times it's\ncalled.\n\n**Details**\n\nThis function ensures that a specific effect is executed only a single time,\nno matter how many times it is invoked. The result of the effect will be\ncached, and subsequent calls to the effect will immediately return the cached\nresult without re-executing the original logic.\n\n**When to Use**\n\nUse this function when you need to perform a task only once, regardless of\nhow many times the effect is triggered. It's particularly useful when you\nhave initialization tasks, logging, or other one-time actions that should not\nbe repeated. This can help optimize performance and avoid redundant actions.",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\nconst program = Effect.gen(function* () {\n  const task1 = Console.log(\"task1\")\n  yield* Effect.repeatN(task1, 2)\n  const task2 = yield* Effect.once(Console.log(\"task2\"))\n  yield* Effect.repeatN(task2, 2)\n})\n\n// Effect.runFork(program)\n// Output:\n// task1\n// task1\n// task1\n// task2"
    ],
    "since": "2.0.0",
    "category": "Caching",
    "signature": "export declare const once: <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<void, E, R>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "all",
    "description": "Combines multiple effects into one, returning results based on the input\nstructure.\n\n**Details**\n\nUse this function when you need to run multiple effects and combine their\nresults into a single output. It supports tuples, iterables, structs, and\nrecords, making it flexible for different input types.\n\nFor instance, if the input is a tuple:\n\n```ts\n//          a tuple of effects\n//         \nEffect.all([effect1, effect2, ...])\n```\n\nthe effects are executed sequentially, and the result is a new effect\ncontaining the results as a tuple. The results in the tuple match the order\nof the effects passed to `Effect.all`.\n\n**Concurrency**\n\nYou can control the execution order (e.g., sequential vs. concurrent) using\nthe `concurrency` option.\n\n**Short-Circuiting Behavior**\n\nThis function stops execution on the first error it encounters, this is\ncalled \"short-circuiting\". If any effect in the collection fails, the\nremaining effects will not run, and the error will be propagated. To change\nthis behavior, you can use the `mode` option, which allows all effects to run\nand collect results as `Either` or `Option`.\n\n**The `mode` option**\n\nThe `{ mode: \"either\" }` option changes the behavior of `Effect.all` to\nensure all effects run, even if some fail. Instead of stopping on the first\nfailure, this mode collects both successes and failures, returning an array\nof `Either` instances where each result is either a `Right` (success) or a\n`Left` (failure).\n\nSimilarly, the `{ mode: \"validate\" }` option uses `Option` to indicate\nsuccess or failure. Each effect returns `None` for success and `Some` with\nthe error for failure.",
    "deprecated": false,
    "examples": [
      "// Title: Combining Effects in Tuples\nimport { Effect, Console } from \"effect\"\n\nconst tupleOfEffects = [\n  Effect.succeed(42).pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n] as const\n\n//       Effect<[number, string], never, never>\n//      \nconst resultsAsTuple = Effect.all(tupleOfEffects)\n\n// Effect.runPromise(resultsAsTuple).then(console.log)\n// Output:\n// 42\n// Hello\n// [ 42, 'Hello' ]",
      "// Title: Combining Effects in Iterables\nimport { Effect, Console } from \"effect\"\n\nconst iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(\n  (n) => Effect.succeed(n).pipe(Effect.tap(Console.log))\n)\n\n//       Effect<number[], never, never>\n//      \nconst resultsAsArray = Effect.all(iterableOfEffects)\n\n// Effect.runPromise(resultsAsArray).then(console.log)\n// Output:\n// 1\n// 2\n// 3\n// [ 1, 2, 3 ]",
      "// Title: Combining Effects in Structs\nimport { Effect, Console } from \"effect\"\n\nconst structOfEffects = {\n  a: Effect.succeed(42).pipe(Effect.tap(Console.log)),\n  b: Effect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n}\n\n//       Effect<{ a: number; b: string; }, never, never>\n//      \nconst resultsAsStruct = Effect.all(structOfEffects)\n\n// Effect.runPromise(resultsAsStruct).then(console.log)\n// Output:\n// 42\n// Hello\n// { a: 42, b: 'Hello' }",
      "// Title: Combining Effects in Records\nimport { Effect, Console } from \"effect\"\n\nconst recordOfEffects: Record<string, Effect.Effect<number>> = {\n  key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),\n  key2: Effect.succeed(2).pipe(Effect.tap(Console.log))\n}\n\n//       Effect<{ [x: string]: number; }, never, never>\n//      \nconst resultsAsRecord = Effect.all(recordOfEffects)\n\n// Effect.runPromise(resultsAsRecord).then(console.log)\n// Output:\n// 1\n// 2\n// { key1: 1, key2: 2 }",
      "// Title: Short-Circuiting Behavior\nimport { Effect, Console } from \"effect\"\n\nconst program = Effect.all([\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  // Won't execute due to earlier failure\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n])\n\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// Task1\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }\n// }",
      "// Title: Collecting Results with `mode: \"either\"`\nimport { Effect, Console } from \"effect\"\n\nconst effects = [\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n]\n\nconst program = Effect.all(effects, { mode: \"either\" })\n\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// Task1\n// Task3\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: [\n//     { _id: 'Either', _tag: 'Right', right: 'Task1' },\n//     { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },\n//     { _id: 'Either', _tag: 'Right', right: 'Task3' }\n//   ]\n// }",
      "//Example: Collecting Results with `mode: \"validate\"`\nimport { Effect, Console } from \"effect\"\n\nconst effects = [\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n]\n\nconst program = Effect.all(effects, { mode: \"validate\" })\n\n// Effect.runPromiseExit(program).then((result) => console.log(\"%o\", result))\n// Output:\n// Task1\n// Task3\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: [\n//       { _id: 'Option', _tag: 'None' },\n//       { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },\n//       { _id: 'Option', _tag: 'None' }\n//     ]\n//   }\n// }"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const all: <const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>, O extends { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: boolean | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }>(arg: Arg, options?: O) => All.Return<Arg, O>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "allWith",
    "description": "A data-last version of {@link all}, designed for use in pipelines.\n\n**When to Use**\n\nThis function enables you to combine multiple effects and customize execution\noptions such as concurrency levels. This version is useful in functional\npipelines where you first define your data and then apply operations to it.",
    "deprecated": false,
    "examples": [
      "import { Effect, pipe } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\n\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\nconst program = pipe(\n  [task1, task2],\n  // Run both effects concurrently using the concurrent option\n  Effect.allWith({ concurrency: 2 })\n)\n\n// Effect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#3 message=\"task2 done\"\n// timestamp=... level=INFO fiber=#2 message=\"task1 done\"\n// [ 1, 'hello' ]"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const allWith: <O extends { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: boolean | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }>(options?: O) => <const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>>(arg: Arg) => All.Return<Arg, O>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "allSuccesses",
    "description": "Evaluates and runs each effect in the iterable, collecting only the\nsuccessful results while discarding failures.\n\n**Details**\n\nThis function function processes an iterable of effects and runs each one. If\nan effect is successful, its result is collected; if it fails, the result is\ndiscarded. This ensures that only successful outcomes are kept.\n\n**Options**\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst tasks = [\n  Effect.succeed(1),\n  Effect.fail(\"Error 1\"),\n  Effect.succeed(2),\n  Effect.fail(\"Error 2\")\n]\n\nconst program = Effect.gen(function*() {\n  const successfulResults = yield* Effect.allSuccesses(tasks)\n  console.log(successfulResults)\n})\n\n// Effect.runFork(program)\n// Output: [1, 2]\n"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const allSuccesses: <X extends Effect<any, any, any>>(elements: Iterable<X>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined) => Effect<Array<Effect.Success<X>>, never, Effect.Context<X>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "dropUntil",
    "description": "Drops elements until the effectful predicate returns `true`.\n\n**Details**\n\nThis function processes a collection of elements and uses an effectful\npredicate to determine when to stop dropping elements. It drops elements from\nthe beginning of the collection until the predicate returns `true`.\n\nThe predicate is a function that takes an element and its index in the\ncollection and returns an effect that evaluates to a boolean.\n\nOnce the predicate returns `true`, the remaining elements of the collection\nare returned.\n\n**Note**: The first element for which the predicate returns `true` is also\ndropped.\n\n**When to Use**\n\nThis function allows you to conditionally skip over a part of the collection\nbased on some criteria defined in the predicate.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.dropUntil(numbers, predicate)\n  console.log(result)\n})\n\n// Effect.runFork(program)\n// Output: [5, 6]"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const dropUntil: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "dropWhile",
    "description": "Drops elements as long as the predicate returns `true`.\n\n**Details**\n\nThis function processes a collection of elements and uses a predicate to\ndecide whether to drop an element.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nAs long as the predicate returns `true`, elements will continue to be dropped\nfrom the collection.\n\nOnce the predicate returns `false`, the remaining elements are kept.\n\n**When to Use**\n\nThis function allows you to discard elements from the start of a collection\nbased on a condition, and only keep the rest when the condition no longer\nholds.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.dropWhile(numbers, predicate)\n  console.log(result)\n})\n\n// Effect.runFork(program)\n// Output: [4, 5, 6]"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const dropWhile: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "takeUntil",
    "description": "Takes elements from a collection until the effectful predicate returns\n`true`.\n\n**Details**\n\nThis function processes a collection of elements and uses an effectful\npredicate to decide when to stop taking elements. The elements are taken from\nthe beginning of the collection until the predicate returns `true`.\n\nThe predicate is a function that takes an element and its index in the\ncollection, and returns an effect that resolves to a boolean.\n\nOnce the predicate returns `true`, the remaining elements of the collection\nare discarded, and the function stops taking more elements.\n\n**Note**: The first element for which the predicate returns `true` is also\nincluded in the result.\n\n**When to Use**\n\nUse this function when you want to conditionally take elements from a\ncollection based on a dynamic condition. For example, you may want to collect\nnumbers from a list until a certain threshold is reached, or gather items\nuntil a specific condition is met.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.takeUntil(numbers, predicate)\n  console.log(result)\n})\n\n// Effect.runFork(program)\n// Output: [ 1, 2, 3, 4 ]"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const takeUntil: { <A, R, E>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "takeWhile",
    "description": "Takes elements as long as the predicate returns `true`.\n\n**Details**\n\nThis function processes a collection of elements and uses a predicate to\ndecide whether to take an element.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nAs long as the predicate returns `true`, elements will continue to be taken\nfrom the collection.\n\nOnce the predicate returns `false`, the remaining elements are discarded.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.takeWhile(numbers, predicate)\n  console.log(result)\n})\n\n// Effect.runFork(program)\n// Output: [1, 2, 3]"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const takeWhile: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "every",
    "description": "Determines whether all elements of the iterable satisfy the effectful\npredicate.\n\n**Details**\n\nThis function checks whether every element in a given collection (an\niterable) satisfies a condition defined by an effectful predicate.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nThe function will process each element and return `true` if all elements\nsatisfy the predicate; otherwise, it returns `false`.\n\n**When to Use**\n\nThis function is useful when you need to verify that all items in a\ncollection meet certain criteria, even when the evaluation of each item\ninvolves effects, such as asynchronous checks or complex computations.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst numbers = [2, 4, 6, 8]\nconst predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n\nconst program = Effect.gen(function*() {\n  const allEven = yield* Effect.every(numbers, predicate)\n  console.log(allEven)\n})\n\n// Effect.runFork(program)\n// Output: true"
    ],
    "since": "2.0.0",
    "category": "Condition Checking",
    "signature": "export declare const every: { <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<boolean, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<boolean, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "exists",
    "description": "Determines whether any element of the iterable satisfies the effectual\npredicate.\n\n**Details**\n\nThis function checks whether any element in a given collection (an iterable)\nsatisfies a condition defined by an effectful predicate.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nThe function will process each element, and if any element satisfies the\npredicate (returns `true`), the function will immediately return `true`.\n\nIf none of the elements satisfy the condition, it will return `false`.\n\n**When to Use**\n\nThis function allows you to quickly check for a condition in a collection\nwithout having to manually iterate over it.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 2)\n\nconst program = Effect.gen(function*() {\n  const hasLargeNumber = yield* Effect.exists(numbers, predicate)\n  console.log(hasLargeNumber)\n})\n\n// Effect.runFork(program)\n// Output: true"
    ],
    "since": "2.0.0",
    "category": "Condition Checking",
    "signature": "export declare const exists: { <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<boolean, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<boolean, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters an iterable using the specified effectful predicate.\n\n**Details**\n\nThis function filters a collection (an iterable) by applying an effectful\npredicate.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nThe function processes each element in the collection and keeps only those\nthat satisfy the condition defined by the predicate.\n\n**Options**\n\nYou can also adjust the behavior with options such as concurrency, batching,\nor whether to negate the condition.\n\n**When to Use**\n\nThis function allows you to selectively keep or remove elements based on a\ncondition that may involve asynchronous or side-effect-causing operations.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.filter(numbers, predicate)\n  console.log(result)\n})\n\n// Effect.runFork(program)\n// Output: [2, 4]"
    ],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "export declare const filter: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly negate?: boolean | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly negate?: boolean | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Array<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Filters and maps elements sequentially in one operation.\n\nThis function processes each element one by one. It applies a function that\nreturns an `Option` to each element. If the function returns `Some`, the\nelement is kept; if it returns `None`, the element is removed. The operation\nis done sequentially for each element.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect, Option } from \"effect\"\n\nconst task = (n: number) =>\n  Effect.succeed(n).pipe(\n    Effect.delay(1000 - (n * 100)),\n    Effect.tap(Console.log(`task${n} done`))\n  )\n\nconst program = Effect.filterMap(\n  [task(1), task(2), task(3), task(4)],\n  (n) => n % 2 === 0 ? Option.some(n) : Option.none()\n)\n\n// Effect.runPromise(program).then(console.log)\n// Output:\n// task1 done\n// task2 done\n// task3 done\n// task4 done\n// [ 2, 4 ]"
    ],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "export declare const filterMap: { <Eff extends Effect<any, any, any>, B>(pf: (a: Effect.Success<Eff>) => Option.Option<B>): (elements: Iterable<Eff>) => Effect<Array<B>, Effect.Error<Eff>, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, B>(elements: Iterable<Eff>, pf: (a: Effect.Success<Eff>) => Option.Option<B>): Effect<Array<B>, Effect.Error<Eff>, Effect.Context<Eff>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Returns the first element that satisfies the effectful predicate.\n\n**Details**\n\nThis function processes a collection of elements and applies an effectful\npredicate to each element.\n\nThe predicate is a function that takes an element and its index in the\ncollection, and it returns an effect that evaluates to a boolean.\n\nThe function stops as soon as it finds the first element for which the\npredicate returns `true` and returns that element wrapped in an `Option`.\n\nIf no element satisfies the predicate, the result will be `None`.\n\n**When to Use**\n\nThis function allows you to efficiently find an element that meets a specific\ncondition, even when the evaluation involves effects like asynchronous\noperations or side effects.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.findFirst(numbers, predicate)\n  console.log(result)\n})\n\n// Effect.runFork(program)\n// Output: { _id: 'Option', _tag: 'Some', value: 4 }"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const findFirst: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Option.Option<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Option.Option<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "Executes an effectful operation for each element in an `Iterable`.\n\n**Details**\n\nThis function applies a provided operation to each element in the iterable,\nproducing a new effect that returns an array of results.\n\nIf any effect fails, the iteration stops immediately (short-circuiting), and\nthe error is propagated.\n\n**Concurrency**\n\nThe `concurrency` option controls how many operations are performed\nconcurrently. By default, the operations are performed sequentially.\n\n**Discarding Results**\n\nIf the `discard` option is set to `true`, the intermediate results are not\ncollected, and the final result of the operation is `void`.",
    "deprecated": false,
    "examples": [
      "// Title: Applying Effects to Iterable Elements\nimport { Effect, Console } from \"effect\"\n\nconst result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>\n  Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))\n)\n\n// Effect.runPromise(result).then(console.log)\n// Output:\n// Currently at index 0\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// [ 2, 4, 6, 8, 10 ]",
      "// Title: Using discard to Ignore Results\nimport { Effect, Console } from \"effect\"\n\n// Apply effects but discard the results\nconst result = Effect.forEach(\n  [1, 2, 3, 4, 5],\n  (n, index) =>\n    Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),\n  { discard: true }\n)\n\n// Effect.runPromise(result).then(console.log)\n// Output:\n// Currently at index 0\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// undefined"
    ],
    "since": "2.0.0",
    "category": "Looping",
    "signature": "export declare const forEach: { <B, E, R, S extends Iterable<any>>(f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (self: S) => Effect<RA.ReadonlyArray.With<S, B>, E, R>; <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): (self: Iterable<A>) => Effect<void, E, R>; <B, E, R, S extends Iterable<any>>(self: S, f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<RA.ReadonlyArray.With<S, B>, E, R>; <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "head",
    "description": "Returns the first element of the iterable if the collection is non-empty, or\nfails with the error `NoSuchElementException` if the collection is empty.\n\n**When to Use**\n\nThis function is useful when you need to retrieve the first item from a\ncollection and want to handle the case where the collection might be empty\nwithout causing an unhandled exception.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\n// Simulate an async operation\nconst fetchNumbers = Effect.succeed([1, 2, 3]).pipe(Effect.delay(\"100 millis\"))\n\nconst program = Effect.gen(function*() {\n  const firstElement = yield* Effect.head(fetchNumbers)\n  console.log(firstElement)\n})\n\n// Effect.runFork(program)\n// Output: 1"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const head: <A, E, R>(self: Effect<Iterable<A>, E, R>) => Effect<A, Cause.NoSuchElementException | E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "mergeAll",
    "description": "Merges an `Iterable<Effect<A, E, R>>` to a single effect.\n\n**Details**\n\nThis function takes an iterable of effects and combines them into a single\neffect. It does this by iterating over each effect in the collection and\napplying a function that accumulates results into a \"zero\" value, which\nstarts with an initial value and is updated with each effect's success.\n\nThe provided function `f` is called for each element in the iterable,\nallowing you to specify how to combine the results.\n\n**Options**\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]\nconst add = (sum: number, value: number, i: number) => sum + value\nconst zero = 0\n\nconst program = Effect.gen(function*() {\n  const total = yield* Effect.mergeAll(numbers, zero, add)\n  console.log(total)\n})\n\n// Effect.runFork(program)\n// Output: 6"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const mergeAll: { <Z, Eff extends Effect<any, any, any>>(zero: Z, f: (z: Z, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<Eff>) => Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, Z>(elements: Iterable<Eff>, zero: Z, f: (z: Z, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "partition",
    "description": "Processes an iterable and applies an effectful function to each element,\ncategorizing the results into successes and failures.\n\n**Details**\n\nThis function processes each element in the provided iterable by applying an\neffectful function to it. The results are then categorized into two separate\nlists: one for failures and another for successes. This separation allows you\nto handle the two categories differently. Failures are collected in a list\nwithout interrupting the processing of the remaining elements, so the\noperation continues even if some elements fail. This is particularly useful\nwhen you need to handle both successful and failed results separately,\nwithout stopping the entire process on encountering a failure.\n\n**When to Use**\n\nUse this function when you want to process a collection of items and handle\nerrors or failures without interrupting the processing of other items. It's\nuseful when you need to distinguish between successful and failed results and\nprocess them separately, for example, when logging errors while continuing to\nwork with valid data. The function ensures that failures are captured, while\nsuccesses are processed normally.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\n//       Effect<[string[], number[]], never, never>\n//      \nconst program = Effect.partition([0, 1, 2, 3, 4], (n) => {\n  if (n % 2 === 0) {\n    return Effect.succeed(n)\n  } else {\n    return Effect.fail(`${n} is not even`)\n  }\n})\n\n// Effect.runPromise(program).then(console.log, console.error)\n// Output:\n// [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]"
    ],
    "since": "2.0.0",
    "category": "Error Accumulation",
    "signature": "export declare const partition: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": "Reduces an `Iterable<A>` using an effectual function `f`, working\nsequentially from left to right.\n\n**Details**\n\nThis function takes an iterable and applies a function `f` to each element in\nthe iterable. The function works sequentially, starting with an initial value\n`zero` and then combining it with each element in the collection. The\nprovided function `f` is called for each element in the iterable, allowing\nyou to accumulate a result based on the current value and the element being\nprocessed.\n\n**When to Use**\n\nThe function is often used for operations like summing a collection of\nnumbers or combining results from multiple tasks. It ensures that operations\nare performed one after the other, maintaining the order of the elements.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduce(\n  [1, 2, 3, 4],\n  0,\n  (acc, id, i) =>\n    processOrder(id)\n      .pipe(Effect.map((order) => acc + order.price))\n)\n\n// Effect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// Order 4 processed\n// 1000"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const reduce: { <Z, A, E, R>(zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, E, R>(elements: Iterable<A>, zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): Effect<Z, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "reduceWhile",
    "description": "Reduces an `Iterable<A>` using an effectual function `body`, working\nsequentially from left to right, stopping the process early when the\npredicate `while` is not satisfied.\n\n**Details**\n\nThis function processes a collection of elements, applying a function `body`\nto reduce them to a single value, starting from the first element. It checks\nthe value of the accumulator against a predicate (`while`). If at any point\nthe predicate returns `false`, the reduction stops, and the accumulated\nresult is returned.\n\n**When to Use**\n\nUse this function when you need to reduce a collection of elements, but only\ncontinue the process as long as a certain condition holds true. For example,\nif you want to sum values in a list but stop as soon as the sum exceeds a\ncertain threshold, you can use this function.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceWhile(\n  [1, 2, 3, 4],\n  0,\n  {\n    body: (acc, id, i) =>\n      processOrder(id)\n        .pipe(Effect.map((order) => acc + order.price)),\n    while: (acc) => acc < 500\n  }\n)\n\n// Effect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// 600"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const reduceWhile: { <Z, A, E, R>(zero: Z, options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R>; }): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, E, R>(elements: Iterable<A>, zero: Z, options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R>; }): Effect<Z, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "reduceRight",
    "description": "Reduces an `Iterable<A>` using an effectual function `f`, working\nsequentially from right to left.\n\n**Details**\n\nThis function takes an iterable and applies a function `f` to each element in\nthe iterable. The function works sequentially, starting with an initial value\n`zero` and then combining it with each element in the collection. The\nprovided function `f` is called for each element in the iterable, allowing\nyou to accumulate a result based on the current value and the element being\nprocessed.\n\n**When to Use**\n\nThe function is often used for operations like summing a collection of\nnumbers or combining results from multiple tasks. It ensures that operations\nare performed one after the other, maintaining the order of the elements.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceRight(\n  [1, 2, 3, 4],\n  0,\n  (id, acc, i) =>\n    processOrder(id)\n      .pipe(Effect.map((order) => acc + order.price))\n)\n\n// Effect.runPromise(program).then(console.log)\n// Output:\n// Order 4 processed\n// Order 3 processed\n// Order 2 processed\n// Order 1 processed\n// 1000"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const reduceRight: { <A, Z, R, E>(zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, R, E>(elements: Iterable<A>, zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): Effect<Z, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "reduceEffect",
    "description": "Reduces an `Iterable<Effect<A, E, R>>` to a single effect.\n\n**Details**\n\nThis function processes a collection of effects and combines them into one\nsingle effect. It starts with an initial effect (`zero`) and applies a\nfunction `f` to each element in the collection.\n\n**Options**\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceEffect(\n  [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],\n  Effect.succeed(0),\n  (acc, order, i) => acc + order.price\n)\n\n// Effect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// Order 4 processed\n// 1000"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const reduceEffect: { <Z, E, R, Eff extends Effect<any, any, any>>(zero: Effect<Z, E, R>, f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<Eff>) => Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, Z, E, R>(elements: Iterable<Eff>, zero: Effect<Z, E, R>, f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "replicate",
    "description": "Replicates the given effect `n` times.\n\n**Details**\n\nThis function takes an effect and replicates it a specified number of times\n(`n`). The result is an array of `n` effects, each of which is identical to\nthe original effect.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\nconst task = Effect.succeed(\"Hello, World!\").pipe(\n  Effect.tap(Console.log)\n)\n\nconst program = Effect.gen(function*() {\n  // Replicate the task 3 times\n  const tasks = Effect.replicate(task, 3)\n  for (const t of tasks) {\n    // Run each task\n    yield* t\n  }\n})\n\n// Effect.runFork(program)\n// Output:\n// Hello, World!\n// Hello, World!\n// Hello, World!"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const replicate: { (n: number): <A, E, R>(self: Effect<A, E, R>) => Array<Effect<A, E, R>>; <A, E, R>(self: Effect<A, E, R>, n: number): Array<Effect<A, E, R>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "replicateEffect",
    "description": "Performs this effect the specified number of times and collects the results.\n\n**Details**\n\nThis function repeats an effect multiple times and collects the results into\nan array. You specify how many times to execute the effect, and it runs that\nmany times, either in sequence or concurrently depending on the provided\noptions.\n\n**Options**\n\nIf the `discard` option is set to `true`, the intermediate results are not\ncollected, and the final result of the operation is `void`.\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\nlet counter = 0\n\nconst task = Effect.sync(() => ++counter).pipe(\n  Effect.tap(() => Console.log(`Task completed`))\n)\n\nconst program = Effect.gen(function*() {\n  // Replicate the task 3 times and collect the results\n  const results = yield* Effect.replicateEffect(task, 3)\n  yield* Console.log(`Results: ${results.join(\", \")}`)\n})\n\n// Effect.runFork(program)\n// Output:\n// Task completed\n// Task completed\n// Task completed\n// Results: 1, 2, 3"
    ],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const replicateEffect: { (n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<Array<A>, E, R>; (n: number, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<Array<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "validateAll",
    "description": "Applies an effectful operation to each element in a collection while\ncollecting both successes and failures.\n\n**Details**\n\nThis function allows you to apply an effectful operation to every item in a\ncollection.\n\nUnlike {@link forEach}, which would stop at the first error, this function\ncontinues processing all elements, accumulating both successes and failures.\n\n**When to Use**\n\nUse this function when you want to process every item in a collection, even\nif some items fail. This is particularly useful when you need to perform\noperations on all elements without halting due to an error.\n\nKeep in mind that if there are any failures, **all successes will be lost**,\nso this function is not suitable when you need to keep the successful results\nin case of errors.",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\n//       Effect<number[], [string, ...string[]], never>\n//      \nconst program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {\n  if (n < 4) {\n    return Console.log(`item ${n}`).pipe(Effect.as(n))\n  } else {\n    return Effect.fail(`${n} is not less that 4`)\n  }\n})\n\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// item 1\n// item 2\n// item 3\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: [ '4 is not less that 4', '5 is not less that 4' ]\n//   }\n// }"
    ],
    "since": "2.0.0",
    "category": "Error Accumulation",
    "signature": "export declare const validateAll: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<Array<B>, RA.NonEmptyArray<E>, R>; <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): (elements: Iterable<A>) => Effect<void, RA.NonEmptyArray<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Array<B>, RA.NonEmptyArray<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, RA.NonEmptyArray<E>, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "validateFirst",
    "description": "This function is similar to {@link validateAll} but with a key difference: it\nreturns the first successful result or all errors if none of the operations\nsucceed.\n\n**Details**\n\nThis function processes a collection of elements and applies an effectful\noperation to each. Unlike {@link validateAll}, which accumulates both\nsuccesses and failures, `Effect.validateFirst` stops and returns the first\nsuccess it encounters. If no success occurs, it returns all accumulated\nerrors. This can be useful when you are interested in the first successful\nresult and want to avoid processing further once a valid result is found.",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\n//       Effect<number, string[], never>\n//      \nconst program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {\n  if (n < 4) {\n    return Effect.fail(`${n} is not less that 4`)\n  } else {\n    return Console.log(`item ${n}`).pipe(Effect.as(n))\n  }\n})\n\n// Effect.runPromise(program).then(console.log, console.error)\n// Output:\n// item 4\n// 4"
    ],
    "since": "2.0.0",
    "category": "Error Accumulation",
    "signature": "export declare const validateFirst: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<B, Array<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<B, Array<E>, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "async",
    "description": "Creates an `Effect` from a callback-based asynchronous function.\n\n**Details**\n\nThe `resume` function:\n- Must be called exactly once. Any additional calls will be ignored.\n- Can return an optional `Effect` that will be run if the `Fiber` executing\n  this `Effect` is interrupted. This can be useful in scenarios where you\n  need to handle resource cleanup if the operation is interrupted.\n- Can receive an `AbortSignal` to handle interruption if needed.\n\nThe `FiberId` of the fiber that may complete the async callback may also be\nspecified using the `blockingOn` argument. This is called the \"blocking\nfiber\" because it suspends the fiber executing the `async` effect (i.e.\nsemantically blocks the fiber from making progress). Specifying this fiber id\nin cases where it is known will improve diagnostics, but not affect the\nbehavior of the returned effect.\n\n**When to Use**\n\nUse `Effect.async` when dealing with APIs that use callback-style instead of\n`async/await` or `Promise`.",
    "deprecated": false,
    "examples": [
      "// Title: Wrapping a Callback API\nimport { Effect } from \"effect\"\nimport * as NodeFS from \"node:fs\"\n\nconst readFile = (filename: string) =>\n  Effect.async<Buffer, Error>((resume) => {\n    NodeFS.readFile(filename, (error, data) => {\n      if (error) {\n        // Resume with a failed Effect if an error occurs\n        resume(Effect.fail(error))\n      } else {\n        // Resume with a succeeded Effect if successful\n        resume(Effect.succeed(data))\n      }\n    })\n  })\n\n//       Effect<Buffer, Error, never>\n//      \nconst program = readFile(\"example.txt\")",
      "// Title: Handling Interruption with Cleanup\nimport { Effect, Fiber } from \"effect\"\nimport * as NodeFS from \"node:fs\"\n\n// Simulates a long-running operation to write to a file\nconst writeFileWithCleanup = (filename: string, data: string) =>\n  Effect.async<void, Error>((resume) => {\n    const writeStream = NodeFS.createWriteStream(filename)\n\n    // Start writing data to the file\n    writeStream.write(data)\n\n    // When the stream is finished, resume with success\n    writeStream.on(\"finish\", () => resume(Effect.void))\n\n    // In case of an error during writing, resume with failure\n    writeStream.on(\"error\", (err) => resume(Effect.fail(err)))\n\n    // Handle interruption by returning a cleanup effect\n    return Effect.sync(() => {\n      console.log(`Cleaning up ${filename}`)\n      NodeFS.unlinkSync(filename)\n    })\n  })\n\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(\n    writeFileWithCleanup(\"example.txt\", \"Some long data...\")\n  )\n  // Simulate interrupting the fiber after 1 second\n  yield* Effect.sleep(\"1 second\")\n  yield* Fiber.interrupt(fiber) // This will trigger the cleanup\n})\n\n// Run the program\n// Effect.runPromise(program)\n// Output:\n// Cleaning up example.txt",
      "// Title: Handling Interruption with AbortSignal\nimport { Effect, Fiber } from \"effect\"\n\n// A task that supports interruption using AbortSignal\nconst interruptibleTask = Effect.async<void, Error>((resume, signal) => {\n  // Handle interruption\n  signal.addEventListener(\"abort\", () => {\n    console.log(\"Abort signal received\")\n    clearTimeout(timeoutId)\n  })\n\n  // Simulate a long-running task\n  const timeoutId = setTimeout(() => {\n    console.log(\"Operation completed\")\n    resume(Effect.void)\n  }, 2000)\n})\n\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(interruptibleTask)\n  // Simulate interrupting the fiber after 1 second\n  yield* Effect.sleep(\"1 second\")\n  yield* Fiber.interrupt(fiber)\n})\n\n// Run the program\n// Effect.runPromise(program)\n// Output:\n// Abort signal received"
    ],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const async: <A, E = never, R = never>(resume: (callback: (_: Effect<A, E, R>) => void, signal: AbortSignal) => void | Effect<void, never, R>, blockingOn?: FiberId.FiberId) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "asyncEffect",
    "description": "A variant of {@link async} where the registration function may return an `Effect`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const asyncEffect: <A, E, R, R3, E2, R2>(register: (callback: (_: Effect<A, E, R>) => void) => Effect<Effect<void, never, R3> | void, E2, R2>) => Effect<A, E | E2, R | R2 | R3>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "custom",
    "description": "Low level constructor that enables for custom stack tracing cutpoints.\n\nIt is meant to be called with a bag of instructions that become available in\nthe \"this\" of the effect.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst throwingFunction = () => { throw new Error() }\nconst blowUp = Effect.custom(throwingFunction, function() {\n  return Effect.succeed(this.effect_instruction_i0())\n})"
    ],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const custom: { <X, A, E, R>(i0: X, body: (this: { effect_instruction_i0: X; }) => Effect<A, E, R>): Effect<A, E, R>; <X, Y, A, E, R>(i0: X, i1: Y, body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; }) => Effect<A, E, R>): Effect<A, E, R>; <X, Y, Z, A, E, R>(i0: X, i1: Y, i2: Z, body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; effect_instruction_i2: Z; }) => Effect<A, E, R>): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withFiberRuntime",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const withFiberRuntime: <A, E = never, R = never>(withRuntime: (fiber: Fiber.RuntimeFiber<A, E>, status: FiberStatus.Running) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": "Creates an `Effect` that represents a recoverable error.\n\n**When to Use**\n\nUse this function to explicitly signal an error in an `Effect`. The error\nwill keep propagating unless it is handled. You can handle the error with\nfunctions like {@link catchAll} or {@link catchTag}.",
    "deprecated": false,
    "examples": [
      "// Title: Creating a Failed Effect\nimport { Effect } from \"effect\"\n\n//       Effect<never, Error, never>\n//      \nconst failure = Effect.fail(\n  new Error(\"Operation failed due to network error\")\n)"
    ],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const fail: <E>(error: E) => Effect<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "failSync",
    "description": "Creates an `Effect` that fails with the specified error, evaluated lazily.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const failSync: <E>(evaluate: LazyArg<E>) => Effect<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "failCause",
    "description": "Creates an `Effect` that fails with the specified `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const failCause: <E>(cause: Cause.Cause<E>) => Effect<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "failCauseSync",
    "description": "Creates an `Effect` that fails with the specified `Cause`, evaluated lazily.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Effect<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "die",
    "description": "Creates an effect that terminates a fiber with a specified error.\n\n**Details**\n\nThis function is used to signal a defect, which represents a critical and\nunexpected error in the code. When invoked, it produces an effect that does\nnot handle the error and instead terminates the fiber.\n\nThe error channel of the resulting effect is of type `never`, indicating that\nit cannot recover from this failure.\n\n**When to Use**\n\nUse this function when encountering unexpected conditions in your code that\nshould not be handled as regular errors but instead represent unrecoverable\ndefects.",
    "deprecated": false,
    "examples": [
      "// Title: Terminating on Division by Zero with a Specified Error\nimport { Effect } from \"effect\"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.die(new Error(\"Cannot divide by zero\"))\n    : Effect.succeed(a / b)\n\n//       Effect<number, never, never>\n//      \nconst program = divide(1, 0)\n\n// Effect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: Cannot divide by zero\n//   ...stack trace..."
    ],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const die: (defect: unknown) => Effect<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "dieMessage",
    "description": "Creates an effect that terminates a fiber with a `RuntimeException`\ncontaining the specified message.\n\n**Details**\n\nThis function is used to signal a defect, representing a critical and\nunexpected error in the code. When invoked, it produces an effect that\nterminates the fiber with a `RuntimeException` carrying the given message.\n\nThe resulting effect has an error channel of type `never`, indicating it does\nnot handle or recover from the error.\n\n**When to Use**\n\nUse this function when you want to terminate a fiber due to an unrecoverable\ndefect and include a clear explanation in the message.",
    "deprecated": false,
    "examples": [
      "// Title: Terminating on Division by Zero with a Specified Message\nimport { Effect } from \"effect\"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.dieMessage(\"Cannot divide by zero\")\n    : Effect.succeed(a / b)\n\n//       Effect<number, never, never>\n//      \nconst program = divide(1, 0)\n\n// Effect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) RuntimeException: Cannot divide by zero\n//   ...stack trace..."
    ],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const dieMessage: (message: string) => Effect<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "dieSync",
    "description": "Creates an effect that dies with the specified error, evaluated lazily.\n\n**Details**\n\nThis function allows you to create an effect that will terminate with a fatal error.\nThe error is provided as a lazy argument, meaning it will only be evaluated when the effect runs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const dieSync: (evaluate: LazyArg<unknown>) => Effect<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "gen",
    "description": "Provides a way to write effectful code using generator functions, simplifying\ncontrol flow and error handling.\n\n**When to Use**\n\n`Effect.gen` allows you to write code that looks and behaves like synchronous\ncode, but it can handle asynchronous tasks, errors, and complex control flow\n(like loops and conditions). It helps make asynchronous code more readable\nand easier to manage.\n\nThe generator functions work similarly to `async/await` but with more\nexplicit control over the execution of effects. You can `yield*` values from\neffects and return the final result at the end.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst addServiceCharge = (amount: number) => amount + 1\n\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst fetchDiscountRate = Effect.promise(() => Promise.resolve(5))\n\nexport const program = Effect.gen(function* () {\n  const transactionAmount = yield* fetchTransactionAmount\n  const discountRate = yield* fetchDiscountRate\n  const discountedAmount = yield* applyDiscount(\n    transactionAmount,\n    discountRate\n  )\n  const finalAmount = addServiceCharge(discountedAmount)\n  return `Final amount to charge: ${finalAmount}`\n})"
    ],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const gen: { <Eff extends YieldWrap<Effect<any, any, any>>, AEff>(f: (resume: Adapter) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never>; <Self, Eff extends YieldWrap<Effect<any, any, any>>, AEff>(self: Self, f: (this: Self, resume: Adapter) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "never",
    "description": "An effect that that runs indefinitely and never produces any result. The\nmoral equivalent of `while(true) {}`, only without the wasted CPU cycles.\n\n**When to Use**\n\nIt could be useful for long-running background tasks or to simulate waiting\nbehavior without actually consuming resources. This effect is ideal for cases\nwhere you want to keep the program alive or in a certain state without\nperforming any active work.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const never: Effect<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "none",
    "description": "Ensures the `Option` is `None`, returning `void`. Otherwise, raises a\n`NoSuchElementException`.\n\n**Details**\n\nThis function checks if the provided `Option` is `None`. If it is, it returns\nan effect that produces no result (i.e., `void`). If the `Option` is not\n`None` (i.e., it contains a value), the function will raise a\n`NoSuchElementException` error.\n\n**When to Use**\n\nThis is useful when you want to ensure that a certain value is absent (i.e.,\n`None`) before continuing execution, and to handle cases where the value is\nunexpectedly present.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const none: <A, E, R>(self: Effect<Option.Option<A>, E, R>) => Effect<void, E | Cause.NoSuchElementException, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "promise",
    "description": "Creates an `Effect` that represents an asynchronous computation guaranteed to\nsucceed.\n\n**Details**\n\nThe provided function (`thunk`) returns a `Promise` that should never reject; if it does, the error\nwill be treated as a \"defect\".\n\nThis defect is not a standard error but indicates a flaw in the logic that\nwas expected to be error-free. You can think of it similar to an unexpected\ncrash in the program, which can be further managed or logged using tools like\n{@link catchAllDefect}.\n\n**Interruptions**\n\nAn optional `AbortSignal` can be provided to allow for interruption of the\nwrapped `Promise` API.\n\n**When to Use**\n\nUse this function when you are sure the operation will not reject.",
    "deprecated": false,
    "examples": [
      "// Title: Delayed Message\nimport { Effect } from \"effect\"\n\nconst delay = (message: string) =>\n  Effect.promise<string>(\n    () =>\n      new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(message)\n        }, 2000)\n      })\n  )\n\n//       Effect<string, never, never>\n//      \nconst program = delay(\"Async operation completed successfully!\")"
    ],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const promise: <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>) => Effect<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": "Creates an `Effect` that always succeeds with a given value.\n\n**When to Use**\n\nUse this function when you need an effect that completes successfully with a\nspecific value without any errors or external dependencies.",
    "deprecated": false,
    "examples": [
      "// Title: Creating a Successful Effect\nimport { Effect } from \"effect\"\n\n// Creating an effect that represents a successful scenario\n//\n//       Effect<number, never, never>\n//      \nconst success = Effect.succeed(42)"
    ],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const succeed: <A>(value: A) => Effect<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "succeedNone",
    "description": "Returns an effect which succeeds with `None`.\n\n**When to Use**\n\nUse this function when you need to represent the absence of a value in your\ncode, especially when working with optional data. This can be helpful when\nyou want to indicate that no result is available without throwing an error or\nperforming additional logic.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const succeedNone: Effect<Option.Option<never>, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "succeedSome",
    "description": "Returns an effect which succeeds with the value wrapped in a `Some`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const succeedSome: <A>(value: A) => Effect<Option.Option<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "suspend",
    "description": "Delays the creation of an `Effect` until it is actually needed.\n\n**Details**\n\nThe `Effect.suspend` function takes a thunk that represents the effect and\nwraps it in a suspended effect. This means the effect will not be created\nuntil it is explicitly needed, which is helpful in various scenarios:\n- **Lazy Evaluation**: Helps optimize performance by deferring computations,\n  especially when the effect might not be needed, or when its computation is\n  expensive. This also ensures that any side effects or scoped captures are\n  re-executed on each invocation.\n- **Handling Circular Dependencies**: Useful in managing circular\n  dependencies, such as recursive functions that need to avoid eager\n  evaluation to prevent stack overflow.\n- **Unifying Return Types**: Can help TypeScript unify return types in\n  situations where multiple branches of logic return different effects,\n  simplifying type inference.\n\n**When to Use**\n\nUse this function when you need to defer the evaluation of an effect until it\nis required. This is particularly useful for optimizing expensive\ncomputations, managing circular dependencies, or resolving type inference\nissues.",
    "deprecated": false,
    "examples": [
      "// Title: Lazy Evaluation with Side Effects\nimport { Effect } from \"effect\"\n\nlet i = 0\n\nconst bad = Effect.succeed(i++)\n\nconst good = Effect.suspend(() => Effect.succeed(i++))\n\nconsole.log(Effect.runSync(bad)) // Output: 0\nconsole.log(Effect.runSync(bad)) // Output: 0\n\nconsole.log(Effect.runSync(good)) // Output: 1\nconsole.log(Effect.runSync(good)) // Output: 2",
      "// Title: Recursive Fibonacci\nimport { Effect } from \"effect\"\n\nconst blowsUp = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(1)\n    : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)\n\n// console.log(Effect.runSync(blowsUp(32)))\n// crash: JavaScript heap out of memory\n\nconst allGood = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(1)\n    : Effect.zipWith(\n        Effect.suspend(() => allGood(n - 1)),\n        Effect.suspend(() => allGood(n - 2)),\n        (a, b) => a + b\n      )\n\nconsole.log(Effect.runSync(allGood(32)))\n// Output: 3524578",
      "// Title: Using Effect.suspend to Help TypeScript Infer Types\nimport { Effect } from \"effect\"\n\n//   Without suspend, TypeScript may struggle with type inference.\n//   Inferred type:\n//     (a: number, b: number) =>\n//       Effect<never, Error, never> | Effect<number, never, never>\nconst withoutSuspend = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error(\"Cannot divide by zero\"))\n    : Effect.succeed(a / b)\n\n//   Using suspend to unify return types.\n//   Inferred type:\n//     (a: number, b: number) => Effect<number, Error, never>\nconst withSuspend = (a: number, b: number) =>\n  Effect.suspend(() =>\n    b === 0\n      ? Effect.fail(new Error(\"Cannot divide by zero\"))\n      : Effect.succeed(a / b)\n  )"
    ],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const suspend: <A, E, R>(effect: LazyArg<Effect<A, E, R>>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "sync",
    "description": "Creates an `Effect` that represents a synchronous side-effectful computation.\n\n**Details**\n\nThe provided function (`thunk`) must not throw errors; if it does, the error\nwill be treated as a \"defect\".\n\nThis defect is not a standard error but indicates a flaw in the logic that\nwas expected to be error-free. You can think of it similar to an unexpected\ncrash in the program, which can be further managed or logged using tools like\n{@link catchAllDefect}.\n\n**When to Use**\n\nUse this function when you are sure the operation will not fail.",
    "deprecated": false,
    "examples": [
      "// Title: Logging a Message\nimport { Effect } from \"effect\"\n\nconst log = (message: string) =>\n  Effect.sync(() => {\n    console.log(message) // side effect\n  })\n\n//       Effect<void, never, never>\n//      \nconst program = log(\"Hello, World!\")"
    ],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const sync: <A>(thunk: LazyArg<A>) => Effect<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "yieldNow",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const yieldNow: (options?: { readonly priority?: number | undefined; }) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "catchAll",
    "description": "Handles all errors in an effect by providing a fallback effect.\n\n**Details**\n\nThis function catches any errors that may occur during the execution of an\neffect and allows you to handle them by specifying a fallback effect. This\nensures that the program continues without failing by recovering from errors\nusing the provided fallback logic.\n\n**Note**: This function only handles recoverable errors. It will not recover\nfrom unrecoverable defects.",
    "deprecated": false,
    "examples": [
      "// Title: Providing Recovery Logic for Recoverable Errors\nimport { Effect, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//       Effect<string, HttpError | ValidationError, never>\n//      \nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//       Effect<string, never, never>\n//      \nconst recovered = program.pipe(\n  Effect.catchAll((error) =>\n    Effect.succeed(`Recovering from ${error._tag}`)\n  )\n)"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const catchAll: { <E, A2, E2, R2>(f: (e: E) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<A2, E2, R2>): Effect<A2 | A, E2, R2 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "catchAllCause",
    "description": "Handles both recoverable and unrecoverable errors by providing a recovery\neffect.\n\n**When to Use**\n\nThe `catchAllCause` function allows you to handle all errors, including\nunrecoverable defects, by providing a recovery effect. The recovery logic is\nbased on the `Cause` of the error, which provides detailed information about\nthe failure.\n\n**When to Recover from Defects**\n\nDefects are unexpected errors that typically shouldn't be recovered from, as\nthey often indicate serious issues. However, in some cases, such as\ndynamically loaded plugins, controlled recovery might be needed.",
    "deprecated": false,
    "examples": [
      "// Title: Recovering from All Errors\nimport { Cause, Effect } from \"effect\"\n\n// Define an effect that may fail with a recoverable or unrecoverable error\nconst program = Effect.fail(\"Something went wrong!\")\n\n// Recover from all errors by examining the cause\nconst recovered = program.pipe(\n  Effect.catchAllCause((cause) =>\n    Cause.isFailType(cause)\n      ? Effect.succeed(\"Recovered from a regular error\")\n      : Effect.succeed(\"Recovered from a defect\")\n  )\n)\n\n// Effect.runPromise(recovered).then(console.log)\n// Output: \"Recovered from a regular error\""
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const catchAllCause: { <E, A2, E2, R2>(f: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "catchAllDefect",
    "description": "Recovers from all defects using a provided recovery function.\n\n**When to Use**\n\nThere is no sensible way to recover from defects. This method should be used\nonly at the boundary between Effect and an external system, to transmit\ninformation on a defect for diagnostic or explanatory purposes.\n\n**Details**\n\n`catchAllDefect` allows you to handle defects, which are unexpected errors\nthat usually cause the program to terminate. This function lets you recover\nfrom these defects by providing a function that handles the error. However,\nit does not handle expected errors (like those from {@link fail}) or\nexecution interruptions (like those from {@link interrupt}).\n\n**When to Recover from Defects**\n\nDefects are unexpected errors that typically shouldn't be recovered from, as\nthey often indicate serious issues. However, in some cases, such as\ndynamically loaded plugins, controlled recovery might be needed.",
    "deprecated": false,
    "examples": [
      "// Title: Handling All Defects\nimport { Effect, Cause, Console } from \"effect\"\n\n// Simulating a runtime error\nconst task = Effect.dieMessage(\"Boom!\")\n\nconst program = Effect.catchAllDefect(task, (defect) => {\n  if (Cause.isRuntimeException(defect)) {\n    return Console.log(\n      `RuntimeException defect caught: ${defect.message}`\n    )\n  }\n  return Console.log(\"Unknown defect caught.\")\n})\n\n// We get an Exit.Success because we caught all defects\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// RuntimeException defect caught: Boom!\n// {\n//   _id: \"Exit\",\n//   _tag: \"Success\",\n//   value: undefined\n// }"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const catchAllDefect: { <A2, E2, R2>(f: (defect: unknown) => Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (defect: unknown) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "catchIf",
    "description": "Recovers from specific errors based on a predicate.\n\n**When to Use**\n\n`catchIf` works similarly to {@link catchSome}, but it allows you to\nrecover from errors by providing a predicate function. If the predicate\nmatches the error, the recovery effect is applied. This function doesn't\nalter the error type, so the resulting effect still carries the original\nerror type unless a user-defined type guard is used to narrow the type.",
    "deprecated": false,
    "examples": [
      "// Title: Catching Specific Errors with a Predicate\nimport { Effect, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//       Effect<string, HttpError | ValidationError, never>\n//      \nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//       Effect<string, ValidationError, never>\n//      \nconst recovered = program.pipe(\n  Effect.catchIf(\n    // Only handle HttpError errors\n    (error) => error._tag === \"HttpError\",\n    () => Effect.succeed(\"Recovering from HttpError\")\n  )\n)"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const catchIf: { <E, EB extends E, A2, E2, R2>(refinement: Refinement<NoInfer<E>, EB>, f: (e: EB) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>; <E, A2, E2, R2>(predicate: Predicate<NoInfer<E>>, f: (e: NoInfer<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, EB extends E, A2, E2, R2>(self: Effect<A, E, R>, refinement: Refinement<E, EB>, f: (e: EB) => Effect<A2, E2, R2>): Effect<A | A2, E2 | Exclude<E, EB>, R | R2>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, predicate: Predicate<E>, f: (e: E) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "catchSome",
    "description": "Catches and recovers from specific types of errors, allowing you to attempt\nrecovery only for certain errors.\n\n**Details**\n\n`catchSome` lets you selectively catch and handle errors of certain\ntypes by providing a recovery effect for specific errors. If the error\nmatches a condition, recovery is attempted; if not, it doesn't affect the\nprogram. This function doesn't alter the error type, meaning the error type\nremains the same as in the original effect.",
    "deprecated": false,
    "examples": [
      "// Title: Handling Specific Errors with Effect.catchSome\nimport { Effect, Random, Option } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//       Effect<string, HttpError | ValidationError, never>\n//      \nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//       Effect<string, HttpError | ValidationError, never>\n//      \nconst recovered = program.pipe(\n  Effect.catchSome((error) => {\n    // Only handle HttpError errors\n    if (error._tag === \"HttpError\") {\n      return Option.some(Effect.succeed(\"Recovering from HttpError\"))\n    } else {\n      return Option.none()\n    }\n  })\n)"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const catchSome: { <E, A2, E2, R2>(pf: (e: NoInfer<E>) => Option.Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, pf: (e: NoInfer<E>) => Option.Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "catchSomeCause",
    "description": "Recovers from specific causes using a provided partial function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const catchSomeCause: { <E, A2, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect<A2, E2, R2>>): Effect<A2 | A, E | E2, R2 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "catchSomeDefect",
    "description": "Recovers from specific defects using a provided partial function.\n\n**Details**\n\n`catchSomeDefect` allows you to handle specific defects, which are\nunexpected errors that can cause the program to stop. It uses a partial\nfunction to catch only certain defects and ignores others. The function does\nnot handle expected errors (such as those caused by {@link fail}) or\ninterruptions in execution (like those caused by {@link interrupt}).\n\nThis function provides a way to handle certain types of defects while\nallowing others to propagate and cause failure in the program.\n\n**Note**: There is no sensible way to recover from defects. This method\nshould be used only at the boundary between Effect and an external system, to\ntransmit information on a defect for diagnostic or explanatory purposes.\n\n**How the Partial Function Works**\n\nThe function provided to `catchSomeDefect` acts as a filter and a handler for defects:\n- It receives the defect as an input.\n- If the defect matches a specific condition (e.g., a certain error type), the function returns\n  an `Option.some` containing the recovery logic.\n- If the defect does not match, the function returns `Option.none`, allowing the defect to propagate.",
    "deprecated": false,
    "examples": [
      "// Title: Handling Specific Defects\nimport { Effect, Cause, Option, Console } from \"effect\"\n\n// Simulating a runtime error\nconst task = Effect.dieMessage(\"Boom!\")\n\nconst program = Effect.catchSomeDefect(task, (defect) => {\n  if (Cause.isIllegalArgumentException(defect)) {\n    return Option.some(\n      Console.log(\n        `Caught an IllegalArgumentException defect: ${defect.message}`\n      )\n    )\n  }\n  return Option.none()\n})\n\n// Since we are only catching IllegalArgumentException\n// we will get an Exit.Failure because we simulated a runtime error.\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Die',\n//     defect: { _tag: 'RuntimeException' }\n//   }\n// }"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const catchSomeDefect: { <A2, E2, R2>(pf: (defect: unknown) => Option.Option<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, pf: (defect: unknown) => Option.Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "catchTag",
    "description": "Catches and handles specific errors by their `_tag` field, which is used as a\ndiscriminator.\n\n**When to Use**\n\n`catchTag` is useful when your errors are tagged with a readonly `_tag` field\nthat identifies the error type. You can use this function to handle specific\nerror types by matching the `_tag` value. This allows for precise error\nhandling, ensuring that only specific errors are caught and handled.\n\nThe error type must have a readonly `_tag` field to use `catchTag`. This\nfield is used to identify and match errors.",
    "deprecated": false,
    "examples": [
      "// Title: Handling Errors by Tag\nimport { Effect, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//       Effect<string, HttpError | ValidationError, never>\n//      \nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//       Effect<string, ValidationError, never>\n//      \nconst recovered = program.pipe(\n  // Only handle HttpError errors\n  Effect.catchTag(\"HttpError\", (_HttpError) =>\n    Effect.succeed(\"Recovering from HttpError\")\n  )\n)"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const catchTag: { <K extends E extends { _tag: string; } ? E[\"_tag\"] : never, E, A1, E1, R1>(k: K, f: (e: NoInfer<Extract<E, { _tag: K; }>>) => Effect<A1, E1, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E[\"_tag\"] : never, R1, E1, A1>(self: Effect<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Effect<A1, E1, R1>): Effect<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "catchTags",
    "description": "Handles multiple errors in a single block of code using their `_tag` field.\n\n**When to Use**\n\n`catchTags` is a convenient way to handle multiple error types at\nonce. Instead of using {@link catchTag} multiple times, you can pass an\nobject where each key is an error type's `_tag`, and the value is the handler\nfor that specific error. This allows you to catch and recover from multiple\nerror types in a single call.\n\nThe error type must have a readonly `_tag` field to use `catchTag`. This\nfield is used to identify and match errors.",
    "deprecated": false,
    "examples": [
      "// Title: Handling Multiple Tagged Error Types at Once\nimport { Effect, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//       Effect<string, HttpError | ValidationError, never>\n//      \nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//       Effect<string, never, never>\n//      \nconst recovered = program.pipe(\n  Effect.catchTags({\n    HttpError: (_HttpError) =>\n      Effect.succeed(`Recovering from HttpError`),\n    ValidationError: (_ValidationError) =>\n      Effect.succeed(`Recovering from ValidationError`)\n  })\n)"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const catchTags: { <E, Cases extends { [K in Extract<E, { _tag: string; }>[\"_tag\"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>[\"_tag\"]>]: never; })>(cases: Cases): <A, R>(self: Effect<A, E, R>) => Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; <R, E, A, Cases extends { [K in Extract<E, { _tag: string; }>[\"_tag\"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>[\"_tag\"]>]: never; })>(self: Effect<A, E, R>, cases: Cases): Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "cause",
    "description": "Retrieves the cause of a failure in an effect.\n\n**Details**\n\nThis function allows you to expose the detailed cause of an effect, which\nincludes a more precise representation of failures, such as error messages\nand defects.\n\n**When to Use**\n\nThis function is helpful when you need to inspect the cause of a failure in\nan effect, giving you more information than just the error message. It can be\nused to log, handle, or analyze failures in more detail, including\ndistinguishing between different types of defects (e.g., runtime exceptions,\ninterruptions, etc.).",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\n//       Effect<number, string, never>\n//      \nconst program = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n\n//       Effect<void, never, never>\n//      \nconst recovered = Effect.gen(function* () {\n  const cause = yield* Effect.cause(program)\n  yield* Console.log(cause)\n})"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const cause: <A, E, R>(self: Effect<A, E, R>) => Effect<Cause.Cause<E>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "eventually",
    "description": "Runs an effect repeatedly until it succeeds, ignoring errors.\n\n**Details**\n\nThis function takes an effect and runs it repeatedly until the effect\nsuccessfully completes. If the effect fails, it will ignore the error and\nretry the operation. This is useful when you need to perform a task that may\nfail occasionally, but you want to keep trying until it eventually succeeds.\nIt works by repeatedly executing the effect until it no longer throws an\nerror.\n\n**When to Use**\n\nUse this function when you want to retry an operation multiple times until it\nsucceeds. It is helpful in cases where the operation may fail temporarily\n(e.g., a network request), and you want to keep trying without handling or\nworrying about the errors.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nlet counter = 0\n\nconst effect = Effect.try(() => {\n  counter++\n  if (counter < 3) {\n    console.log(\"running effect\")\n    throw new Error(\"error\")\n  } else {\n    console.log(\"effect done\")\n    return \"some result\"\n  }\n})\n\nconst program = Effect.eventually(effect)\n\n// Effect.runPromise(program).then(console.log)\n// Output:\n// running effect\n// running effect\n// effect done\n// some result"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const eventually: <A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "ignore",
    "description": "Discards both the success and failure values of an effect.\n\n**When to Use**\n\n`ignore` allows you to run an effect without caring about its result, whether\nit succeeds or fails. This is useful when you only care about the side\neffects of the effect and do not need to handle or process its outcome.",
    "deprecated": false,
    "examples": [
      "// Title: Using Effect.ignore to Discard Values\nimport { Effect } from \"effect\"\n\n//       Effect<number, string, never>\n//      \nconst task = Effect.fail(\"Uh oh!\").pipe(Effect.as(5))\n\n//       Effect<void, never, never>\n//      \nconst program = Effect.ignore(task)"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const ignore: <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "ignoreLogged",
    "description": "Ignores the result of an effect but logs any failures.\n\n**Details**\n\nThis function takes an effect and returns a new effect that ignores whether\nthe original effect succeeds or fails. However, if the effect fails, it will\nlog the failure at the Debug level, so you can keep track of any issues that\narise.\n\n**When to Use**\n\nThis is useful in scenarios where you want to continue with your program\nregardless of the result of the effect, but you still want to be aware of\npotential failures that may need attention later.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const ignoreLogged: <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "parallelErrors",
    "description": "Combines all errors from concurrent operations into a single error.\n\n**Details**\n\nThis function is used when you have multiple operations running at the same\ntime, and you want to capture all the errors that occur across those\noperations. Instead of handling each error separately, it combines all the\nerrors into one unified error.\n\n**When to Use**\n\nWhen using this function, any errors that occur in the concurrently running\noperations will be grouped together into a single error. This helps simplify\nerror handling in cases where you don't need to differentiate between each\nfailure, but simply want to know that multiple failures occurred.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst fail1 = Effect.fail(\"Oh uh!\")\nconst fail2 = Effect.fail(\"Oh no!\")\nconst die = Effect.dieMessage(\"Boom!\")\n\n// Run all effects concurrently and capture all errors\nconst program = Effect.all([fail1, fail2, die], {\n  concurrency: \"unbounded\"\n}).pipe(Effect.asVoid, Effect.parallelErrors)\n\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: [ 'Oh uh!', 'Oh no!' ] }\n// }"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const parallelErrors: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Array<E>, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "sandbox",
    "description": "Transforms an effect to expose detailed error causes.\n\n**Details**\n\nThis function enhances an effect by providing detailed information about any\nerror, defect, or interruption that may occur during its execution. It\nmodifies the error channel of the effect so that it includes a full cause of\nthe failure, wrapped in a `Cause<E>` type.\n\nAfter applying this function, you can use operators like {@link catchAll} and\n{@link catchTags} to handle specific types of errors.\n\nIf you no longer need the detailed cause information, you can revert the\nchanges using {@link unsandbox} to return to the original error-handling\nbehavior.",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\n//       Effect<string, Error, never>\n//      \nconst task = Effect.fail(new Error(\"Oh uh!\")).pipe(\n  Effect.as(\"primary result\")\n)\n\n//       Effect<string, Cause<Error>, never>\n//      \nconst sandboxed = Effect.sandbox(task)\n\nconst program = Effect.catchTags(sandboxed, {\n  Die: (cause) =>\n    Console.log(`Caught a defect: ${cause.defect}`).pipe(\n      Effect.as(\"fallback result on defect\")\n    ),\n  Interrupt: (cause) =>\n    Console.log(`Caught a defect: ${cause.fiberId}`).pipe(\n      Effect.as(\"fallback result on fiber interruption\")\n    ),\n  Fail: (cause) =>\n    Console.log(`Caught a defect: ${cause.error}`).pipe(\n      Effect.as(\"fallback result on failure\")\n    )\n})\n\n// Restore the original error handling with unsandbox\nconst main = Effect.unsandbox(program)\n\n// Effect.runPromise(main).then(console.log)\n// Output:\n// Caught a defect: Oh uh!\n// fallback result on failure"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const sandbox: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Cause.Cause<E>, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "retry",
    "description": "Retries a failing effect based on a defined retry policy.\n\n**Details**\n\nThe `Effect.retry` function takes an effect and a {@link Schedule} policy,\nand will automatically retry the effect if it fails, following the rules of\nthe policy.\n\nIf the effect ultimately succeeds, the result will be returned.\n\nIf the maximum retries are exhausted and the effect still fails, the failure\nis propagated.\n\n**When to Use**\n\nThis can be useful when dealing with intermittent failures, such as network\nissues or temporary resource unavailability. By defining a retry policy, you\ncan control the number of retries, the delay between them, and when to stop\nretrying.",
    "deprecated": false,
    "examples": [
      "// Title: Retrying with a Fixed Delay\nimport { Effect, Schedule } from \"effect\"\n\nlet count = 0\n\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\n  if (count <= 2) {\n    count++\n    console.log(\"failure\")\n    resume(Effect.fail(new Error()))\n  } else {\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\n// Define a repetition policy using a fixed delay between retries\nconst policy = Schedule.fixed(\"100 millis\")\n\nconst repeated = Effect.retry(task, policy)\n\n// Effect.runPromise(repeated).then(console.log)\n// Output:\n// failure\n// failure\n// failure\n// success\n// yay!",
      "// Title: Retrying a Task up to 5 times\nimport { Effect } from \"effect\"\n\nlet count = 0\n\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\n  if (count <= 2) {\n    count++\n    console.log(\"failure\")\n    resume(Effect.fail(new Error()))\n  } else {\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\n// Retry the task up to 5 times\n// Effect.runPromise(Effect.retry(task, { times: 5 }))\n// Output:\n// failure\n// failure\n// failure\n// success",
      "// Title: Retrying Until a Specific Condition is Met\nimport { Effect } from \"effect\"\n\nlet count = 0\n\n// Define an effect that simulates varying error on each invocation\nconst action = Effect.failSync(() => {\n  console.log(`Action called ${++count} time(s)`)\n  return `Error ${count}`\n})\n\n// Retry the action until a specific condition is met\nconst program = Effect.retry(action, {\n  until: (err) => err === \"Error 3\"\n})\n\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// Action called 1 time(s)\n// Action called 2 time(s)\n// Action called 3 time(s)\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }\n// }"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const retry: { <E, O extends Retry.Options<E>>(options: O): <A, R>(self: Effect<A, E, R>) => Retry.Return<R, E, A, O>; <B, E, R1>(policy: Schedule.Schedule<B, NoInfer<E>, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, O extends Retry.Options<E>>(self: Effect<A, E, R>, options: O): Retry.Return<R, E, A, O>; <A, E, R, B, R1>(self: Effect<A, E, R>, policy: Schedule.Schedule<B, E, R1>): Effect<A, E, R1 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "retryOrElse",
    "description": "Retries a failing effect and runs a fallback effect if retries are exhausted.\n\n**Details**\n\nThe `Effect.retryOrElse` function attempts to retry a failing effect multiple\ntimes according to a defined {@link Schedule} policy.\n\nIf the retries are exhausted and the effect still fails, it runs a fallback\neffect instead.\n\n**When to Use**\n\nThis function is useful when you want to handle failures gracefully by\nspecifying an alternative action after repeated failures.",
    "deprecated": false,
    "examples": [
      "// Title: Retrying with Fallback\nimport { Effect, Schedule, Console } from \"effect\"\n\nlet count = 0\n\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\n  if (count <= 2) {\n    count++\n    console.log(\"failure\")\n    resume(Effect.fail(new Error()))\n  } else {\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\n// Retry the task with a delay between retries and a maximum of 2 retries\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n\n// If all retries fail, run the fallback effect\nconst repeated = Effect.retryOrElse(\n  task,\n  policy,\n  // fallback\n  () => Console.log(\"orElse\").pipe(Effect.as(\"default value\"))\n)\n\n// Effect.runPromise(repeated).then(console.log)\n// Output:\n// failure\n// failure\n// failure\n// orElse\n// default value"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const retryOrElse: { <A1, E, R1, A2, E2, R2>(policy: Schedule.Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R1 | R2 | R>; <A, E, R, A1, R1, A2, E2, R2>(self: Effect<A, E, R>, policy: Schedule.Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R1 | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "tryMap",
    "description": "Returns an effect that maps its success using the specified side-effecting\n`try` function, converting any errors into typed failed effects using the\n`catch` function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const tryMap: { <A, B, E1>(options: { readonly try: (a: A) => B; readonly catch: (error: unknown) => E1; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>; <A, E, R, B, E1>(self: Effect<A, E, R>, options: { readonly try: (a: A) => B; readonly catch: (error: unknown) => E1; }): Effect<B, E | E1, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "tryMapPromise",
    "description": "Returns an effect that maps its success using the specified side-effecting\n`try` function, converting any promise rejections into typed failed effects\nusing the `catch` function.\n\nAn optional `AbortSignal` can be provided to allow for interruption of the\nwrapped `Promise` API.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const tryMapPromise: { <A, B, E1>(options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>; <A, E, R, B, E1>(self: Effect<A, E, R>, options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1; }): Effect<B, E | E1, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "tryPromise",
    "description": "Creates an `Effect` that represents an asynchronous computation that might\nfail.\n\n**When to Use**\n\nIn situations where you need to perform asynchronous operations that might\nfail, such as fetching data from an API, you can use the `tryPromise`\nconstructor. This constructor is designed to handle operations that could\nthrow exceptions by capturing those exceptions and transforming them into\nmanageable errors.\n\n**Error Handling**\n\nThere are two ways to handle errors with `tryPromise`:\n\n1. If you don't provide a `catch` function, the error is caught and the\n   effect fails with an `UnknownException`.\n2. If you provide a `catch` function, the error is caught and the `catch`\n   function maps it to an error of type `E`.\n\n**Interruptions**\n\nAn optional `AbortSignal` can be provided to allow for interruption of the\nwrapped `Promise` API.",
    "deprecated": false,
    "examples": [
      "// Title: Fetching a TODO Item\nimport { Effect } from \"effect\"\n\nconst getTodo = (id: number) =>\n  // Will catch any errors and propagate them as UnknownException\n  Effect.tryPromise(() =>\n    fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)\n  )\n\n//       Effect<Response, UnknownException, never>\n//      \nconst program = getTodo(1)",
      "// Title: Custom Error Handling\nimport { Effect } from \"effect\"\n\nconst getTodo = (id: number) =>\n  Effect.tryPromise({\n    try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),\n    // remap the error\n    catch: (unknown) => new Error(`something went wrong ${unknown}`)\n  })\n\n//       Effect<Response, Error, never>\n//      \nconst program = getTodo(1)"
    ],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const tryPromise: { <A, E>(options: { readonly try: (signal: AbortSignal) => PromiseLike<A>; readonly catch: (error: unknown) => E; }): Effect<A, E>; <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect<A, Cause.UnknownException>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "unsandbox",
    "description": "The `unsandbox` function is used to revert an effect that has been\nsandboxed by {@link sandbox}. When you apply `unsandbox`, the\neffect's error channel is restored to its original state, without the\ndetailed `Cause<E>` information. This means that any underlying causes of\nerrors, defects, or fiber interruptions are no longer exposed in the error\nchannel.\n\nThis function is useful when you want to remove the detailed error tracking\nprovided by `sandbox` and return to the standard error handling for\nyour effect. Once unsandboxed, the effect behaves as if `sandbox` was\nnever applied.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const unsandbox: <A, E, R>(self: Effect<A, Cause.Cause<E>, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "allowInterrupt",
    "description": "Allows interruption of the current fiber, even in uninterruptible regions.\n\n**Details**\n\nThis effect checks whether any other fibers are attempting to interrupt the\ncurrent fiber. If so, it allows the current fiber to perform a\nself-interruption.\n\n**When to Use**\n\nThis is useful in situations where you want to allow interruption to happen\neven in regions of the code that are normally uninterruptible.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "export declare const allowInterrupt: Effect<void, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "checkInterruptible",
    "description": "Checks if interruption is allowed and executes a callback accordingly.\n\n**Details**\n\nThis function checks the current interrupt status of the running fiber. It\nthen calls the provided callback, passing a boolean indicating whether\ninterruption is allowed.\n\n**When to Use**\n\nThis is useful for handling specific logic based on whether the current\noperation can be interrupted, such as when performing asynchronous operations\nor handling cancellation.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.checkInterruptible((isInterruptible) => {\n    if (isInterruptible) {\n      return Console.log(\"You can interrupt this operation.\")\n    } else {\n      return Console.log(\"This operation cannot be interrupted.\")\n    }\n  })\n})\n\n// Effect.runPromise(program)\n// Output: You can interrupt this operation.\n\n// Effect.runPromise(program.pipe(Effect.uninterruptible))\n// Output: This operation cannot be interrupted.\n"
    ],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "export declare const checkInterruptible: <A, E, R>(f: (isInterruptible: boolean) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "disconnect",
    "description": "Provides a way to handle timeouts in uninterruptible effects, allowing them\nto continue in the background while the main control flow proceeds with the\ntimeout error.\n\n**Details**\n\nThe `disconnect` function allows an uninterruptible effect to continue\nrunning in the background, while enabling the main control flow to\nimmediately recognize a timeout condition. This is useful when you want to\navoid blocking the program due to long-running tasks, especially when those\ntasks do not need to affect the flow of the rest of the program.\n\nWithout `disconnect`, an uninterruptible effect will ignore the\ntimeout and continue executing until it completes. The timeout error will\nonly be assessed after the effect finishes, which can cause delays in\nrecognizing a timeout.\n\nWith `disconnect`, the uninterruptible effect proceeds in the\nbackground while the main program flow can immediately handle the timeout\nerror or trigger alternative logic. This enables faster timeout handling\nwithout waiting for the completion of the long-running task.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst longRunningTask = Effect.gen(function* () {\n  console.log(\"Start heavy processing...\")\n  yield* Effect.sleep(\"5 seconds\") // Simulate a long process\n  console.log(\"Heavy processing done.\")\n  return \"Data processed\"\n})\n\nconst timedEffect = longRunningTask.pipe(\n  Effect.uninterruptible,\n  // Allows the task to finish in the background if it times out\n  Effect.disconnect,\n  Effect.timeout(\"1 second\")\n)\n\n// Effect.runPromiseExit(timedEffect).then(console.log)\n// Output:\n// Start heavy processing...\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: { _tag: 'TimeoutException' }\n//   }\n// }\n// Heavy processing done."
    ],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "export declare const disconnect: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "interrupt",
    "description": "Represents an effect that interrupts the current fiber.\n\n**Details**\n\nThis effect models the explicit interruption of the fiber in which it runs.\nWhen executed, it causes the fiber to stop its operation immediately,\ncapturing the interruption details such as the fiber's ID and its start time.\nThe resulting interruption can be observed in the `Exit` type if the effect\nis run with functions like {@link runPromiseExit}.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst program = Effect.gen(function* () {\n  console.log(\"start\")\n  yield* Effect.sleep(\"2 seconds\")\n  yield* Effect.interrupt\n  console.log(\"done\")\n  return \"some result\"\n})\n\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// start\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Interrupt',\n//     fiberId: {\n//       _id: 'FiberId',\n//       _tag: 'Runtime',\n//       id: 0,\n//       startTimeMillis: ...\n//     }\n//   }\n// }"
    ],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "export declare const interrupt: Effect<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "interruptWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "export declare const interruptWith: (fiberId: FiberId.FiberId) => Effect<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "interruptible",
    "description": "Marks an effect as interruptible.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "export declare const interruptible: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "interruptibleMask",
    "description": "This function behaves like {@link interruptible}, but it also provides a\n`restore` function. This function can be used to restore the interruptibility\nof any specific region of code.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "export declare const interruptibleMask: <A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "onInterrupt",
    "description": "Registers a cleanup effect to run when an effect is interrupted.\n\n**Details**\n\nThis function allows you to specify an effect to run when the fiber is\ninterrupted. This effect will be executed when the fiber is interrupted,\nallowing you to perform cleanup or other actions.",
    "deprecated": false,
    "examples": [
      "// Title: Running a Cleanup Action on Interruption\nimport { Console, Effect } from \"effect\"\n\n// This handler is executed when the fiber is interrupted\nconst handler = Effect.onInterrupt((_fibers) => Console.log(\"Cleanup completed\"))\n\nconst success = Console.log(\"Task completed\").pipe(Effect.as(\"some result\"), handler)\n\n// Effect.runFork(success)\n// Output:\n// Task completed\n\nconst failure = Console.log(\"Task failed\").pipe(Effect.andThen(Effect.fail(\"some error\")), handler)\n\n// Effect.runFork(failure)\n// Output:\n// Task failed\n\nconst interruption = Console.log(\"Task interrupted\").pipe(Effect.andThen(Effect.interrupt), handler)\n\n// Effect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed"
    ],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "export declare const onInterrupt: { <X, R2>(cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "uninterruptible",
    "description": "Marks an effect as uninterruptible.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "export declare const uninterruptible: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "uninterruptibleMask",
    "description": "This function behaves like {@link uninterruptible}, but it also provides a\n`restore` function. This function can be used to restore the interruptibility\nof any specific region of code.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Interruption",
    "signature": "export declare const uninterruptibleMask: <A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "liftPredicate",
    "description": "Transforms a `Predicate` function into an `Effect` returning the input value if the predicate returns `true`\nor failing with specified error if the predicate fails",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst isPositive = (n: number): boolean => n > 0\n\n// succeeds with `1`\nEffect.liftPredicate(1, isPositive, n => `${n} is not positive`)\n\n// fails with `\"0 is not positive\"`\nEffect.liftPredicate(0, isPositive, n => `${n} is not positive`)"
    ],
    "since": "3.4.0",
    "category": "Condition Checking",
    "signature": "export declare const liftPredicate: { <A, B extends A, E>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E): (a: A) => Effect<B, E>; <A, E>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E): (a: A) => Effect<A, E>; <A, E, B extends A>(self: A, refinement: Refinement<A, B>, orFailWith: (a: A) => E): Effect<B, E>; <A, E>(self: A, predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E): Effect<A, E>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "as",
    "description": "Replaces the value inside an effect with a constant value.\n\n**Details**\n\nThis function allows you to ignore the original value inside an effect and\nreplace it with a constant value.\n\n**When to Use**\n\nIt is useful when you no longer need the value produced by an effect but want\nto ensure that the effect completes successfully with a specific constant\nresult instead. For instance, you can replace the value produced by a\ncomputation with a predefined value, ignoring what was calculated before.",
    "deprecated": false,
    "examples": [
      "// Title: Replacing a Value\nimport { pipe, Effect } from \"effect\"\n\n// Replaces the value 5 with the constant \"new value\"\nconst program = pipe(Effect.succeed(5), Effect.as(\"new value\"))\n\n// Effect.runPromise(program).then(console.log)\n// Output: \"new value\""
    ],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const as: { <B>(value: B): <A, E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A, E, R, B>(self: Effect<A, E, R>, value: B): Effect<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "asSome",
    "description": "This function maps the success value of an `Effect` value to a `Some` value\nin an `Option` value. If the original `Effect` value fails, the returned\n`Effect` value will also fail.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const asSome: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "asSomeError",
    "description": "This function maps the error value of an `Effect` value to a `Some` value\nin an `Option` value. If the original `Effect` value succeeds, the returned\n`Effect` value will also succeed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const asSomeError: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Option.Option<E>, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "asVoid",
    "description": "This function maps the success value of an `Effect` value to `void`. If the\noriginal `Effect` value succeeds, the returned `Effect` value will also\nsucceed. If the original `Effect` value fails, the returned `Effect` value\nwill fail with the same error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const asVoid: <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "flip",
    "description": "Swaps the success and error channels of an effect.\n\n**Details**\n\nThis function reverses the flow of an effect by swapping its success and\nerror channels. The success value becomes an error, and the error value\nbecomes a success.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\n//       Effect<number, string, never>\n//      \nconst program = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n\n//       Effect<string, number, never>\n//      \nconst flipped = Effect.flip(program)"
    ],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const flip: <A, E, R>(self: Effect<A, E, R>) => Effect<E, A, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "flipWith",
    "description": "Swaps the error/value parameters, applies the function `f` and flips the\nparameters back",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const flipWith: { <E, A, R, E2, A2, R2>(f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): (self: Effect<A, E, R>) => Effect<A2, E2, R2>; <A, E, R, E2, A2, R2>(self: Effect<A, E, R>, f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): Effect<A2, E2, R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms the value inside an effect by applying a function to it.\n\n**Syntax**\n\n```ts\nconst mappedEffect = pipe(myEffect, Effect.map(transformation))\n// or\nconst mappedEffect = Effect.map(myEffect, transformation)\n// or\nconst mappedEffect = myEffect.pipe(Effect.map(transformation))\n```\n\n**Details**\n\n`map` takes a function and applies it to the value contained within an\neffect, creating a new effect with the transformed value.\n\nIt's important to note that effects are immutable, meaning that the original\neffect is not modified. Instead, a new effect is returned with the updated\nvalue.",
    "deprecated": false,
    "examples": [
      "// Title: Adding a Service Charge\nimport { pipe, Effect } from \"effect\"\n\nconst addServiceCharge = (amount: number) => amount + 1\n\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  Effect.map(addServiceCharge)\n)\n\n// Effect.runPromise(finalAmount).then(console.log)\n// Output: 101"
    ],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A, E, R, B>(self: Effect<A, E, R>, f: (a: A) => B): Effect<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "mapAccum",
    "description": "Applies a stateful transformation to each element of a collection, producing\nnew elements along with an updated state.\n\n**When to Use**\n\nUse `mapAccum` when you need to process each element of a collection while\nkeeping track of some state across iterations.\n\n**Details**\n\n`mapAccum` takes an initial state (`initial`) and a function (`f`) that is\napplied to each element. This function returns a new state and a transformed\nelement. The final effect produces both the accumulated state and the\ntransformed collection.\n\nIf the input collection is a non-empty array, the return type will match the\ninput collection type.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\n// Define an initial state and a transformation function\nconst initialState = 0\n\nconst transformation = (state: number, element: string) =>\n  Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])\n\n// Apply mapAccum to transform an array of strings\nconst program = Effect.mapAccum([\"a\", \"bb\", \"ccc\"], initialState, transformation)\n\n// Effect.runPromise(program).then(([finalState, transformedCollection]) => {\n//   console.log(finalState)\n//   console.log(transformedCollection)\n// })\n// Output:\n// 6\n// [ 'A', 'BB', 'CCC' ]"
    ],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const mapAccum: { <S, A, B, E, R, I extends Iterable<A> = Iterable<A>>(initial: S, f: (state: S, a: RA.ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>): (elements: I) => Effect<[S, RA.ReadonlyArray.With<I, B>], E, R>; <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(elements: I, initial: S, f: (state: S, a: RA.ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>): Effect<[S, RA.ReadonlyArray.With<I, B>], E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "mapBoth",
    "description": "Applies transformations to both the success and error channels of an effect.\n\n**Details**\n\nThis function takes two map functions as arguments: one for the error channel\nand one for the success channel. You can use it when you want to modify both\nthe error and the success values without altering the overall success or\nfailure status of the effect.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\n//       Effect<number, string, never>\n//      \nconst simulatedTask = Effect.fail(\"Oh no!\").pipe(Effect.as(1))\n\n//       Effect<boolean, Error, never>\n//      \nconst modified = Effect.mapBoth(simulatedTask, {\n  onFailure: (message) => new Error(message),\n  onSuccess: (n) => n > 0\n})"
    ],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Effect<A, E, R>) => Effect<A2, E2, R>; <A, E, R, E2, A2>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Effect<A2, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "mapError",
    "description": "Transforms or modifies the error produced by an effect without affecting its\nsuccess value.\n\n**When to Use**\n\nThis function is helpful when you want to enhance the error with additional\ninformation, change the error type, or apply custom error handling while\nkeeping the original behavior of the effect's success values intact. It only\noperates on the error channel and leaves the success channel unchanged.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\n//       Effect<number, string, never>\n//      \nconst simulatedTask = Effect.fail(\"Oh no!\").pipe(Effect.as(1))\n\n//       Effect<number, Error, never>\n//      \nconst mapped = Effect.mapError(\n  simulatedTask,\n  (message) => new Error(message)\n)"
    ],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const mapError: { <E, E2>(f: (e: E) => E2): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, f: (e: E) => E2): Effect<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "mapErrorCause",
    "description": "Maps the cause of failure of an effect using a specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const mapErrorCause: { <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Effect<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "merge",
    "description": "Combines both success and error channels of an effect into a single outcome.\n\n**Details**\n\nThis function transforms an effect that may fail into one that always returns\na value, where both success and failure outcomes are handled as values in the\nsuccess channel.\n\n**When to Use**\n\nThis can be useful when you want to continue execution regardless of the\nerror type and still capture both successful results and errors as part of\nthe outcome.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\n//       Effect<number, string, never>\n//      \nconst program = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n\n//       Effect<number | string, never, never>\n//      \nconst recovered = Effect.merge(program)"
    ],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const merge: <A, E, R>(self: Effect<A, E, R>) => Effect<E | A, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "negate",
    "description": "Returns a new effect with the boolean value of this effect negated.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const negate: <E, R>(self: Effect<boolean, E, R>) => Effect<boolean, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "acquireRelease",
    "description": "Creates a scoped resource using an `acquire` and `release` effect.\n\n**Details**\n\nThis function helps manage resources by combining two `Effect` values: one\nfor acquiring the resource and one for releasing it.\n\n`acquireRelease` does the following:\n\n  1. Ensures that the effect that acquires the resource will not be\n     interrupted. Note that acquisition may still fail due to internal\n     reasons (such as an uncaught exception).\n  2. Ensures that the `release` effect will not be interrupted, and will be\n     executed as long as the acquisition effect successfully acquires the\n     resource.\n\nIf the `acquire` function succeeds, the `release` function is added to the\nlist of finalizers for the scope. This ensures that the release will happen\nautomatically when the scope is closed.\n\nBoth `acquire` and `release` run uninterruptibly, meaning they cannot be\ninterrupted while they are executing.\n\nAdditionally, the `release` function can be influenced by the exit value when\nthe scope closes, allowing for custom handling of how the resource is\nreleased based on the execution outcome.\n\n**When to Use**\n\nThis function is used to ensure that an effect that represents the\nacquisition of a resource (for example, opening a file, launching a thread,\netc.) will not be interrupted, and that the resource will always be released\nwhen the `Effect` completes execution.",
    "deprecated": false,
    "examples": [
      "// Title: Defining a Simple Resource\nimport { Effect } from \"effect\"\n\n// Define an interface for a resource\ninterface MyResource {\n  readonly contents: string\n  readonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\n  Promise.resolve({\n    contents: \"lorem ipsum\",\n    close: () =>\n      new Promise((resolve) => {\n        console.log(\"Resource released\")\n        resolve()\n      })\n  })\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\n  try: () =>\n    getMyResource().then((res) => {\n      console.log(\"Resource acquired\")\n      return res\n    }),\n  catch: () => new Error(\"getMyResourceError\")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\n// Create the resource management workflow\n//\n//       Effect<MyResource, Error, Scope>\n//      \nconst resource = Effect.acquireRelease(acquire, release)"
    ],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const acquireRelease: { <A, X, R2>(release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): <E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope.Scope | R2 | R>; <A, E, R, X, R2>(acquire: Effect<A, E, R>, release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): Effect<A, E, Scope.Scope | R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "acquireReleaseInterruptible",
    "description": "Creates a scoped resource with an interruptible acquire action.\n\n**Details**\n\nThis function is similar to {@link acquireRelease}, but it allows the\nacquisition of the resource to be interrupted. The `acquire` effect, which\nrepresents the process of obtaining the resource, can be interrupted if\nnecessary.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const acquireReleaseInterruptible: { <X, R2>(release: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): <A, E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope.Scope | R2 | R>; <A, E, R, X, R2>(acquire: Effect<A, E, R>, release: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): Effect<A, E, Scope.Scope | R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "acquireUseRelease",
    "description": "Creates a scoped resource and automatically handles the use effect during the\nscope.\n\n**Details**\n\nThis function is similar to {@link acquireRelease}, but it introduces an\nadditional `use` effect. This allows you to automatically execute the `use`\neffect while the resource is acquired, and it also ensures that the `release`\neffect is performed when the scope is closed.\n\nThe `acquire` effect is used to obtain the resource, the `use` effect\noperates while the resource is in use, and the `release` effect cleans up the\nresource when the scope ends.",
    "deprecated": false,
    "examples": [
      "// Title: Automatically Managing Resource Lifetime\nimport { Effect, Console } from \"effect\"\n\n// Define an interface for a resource\ninterface MyResource {\n  readonly contents: string\n  readonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\n  Promise.resolve({\n    contents: \"lorem ipsum\",\n    close: () =>\n      new Promise((resolve) => {\n        console.log(\"Resource released\")\n        resolve()\n      })\n  })\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\n  try: () =>\n    getMyResource().then((res) => {\n      console.log(\"Resource acquired\")\n      return res\n    }),\n  catch: () => new Error(\"getMyResourceError\")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\nconst use = (res: MyResource) => Console.log(`content is ${res.contents}`)\n\n//       Effect<void, Error, never>\n//      \nconst program = Effect.acquireUseRelease(acquire, use, release)\n\n// Effect.runPromise(program)\n// Output:\n// Resource acquired\n// content is lorem ipsum\n// Resource released"
    ],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const acquireUseRelease: { <A2, E2, R2, A, X, R3>(use: (a: A) => Effect<A2, E2, R2>, release: (a: A, exit: Exit.Exit<A2, E2>) => Effect<X, never, R3>): <E, R>(acquire: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, X, R3>(acquire: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>, release: (a: A, exit: Exit.Exit<A2, E2>) => Effect<X, never, R3>): Effect<A2, E | E2, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "addFinalizer",
    "description": "Ensures a finalizer is added to the scope of the calling effect, guaranteeing\nit runs when the scope is closed.\n\n**Details**\n\nThis function adds a finalizer that will execute whenever the scope of the\neffect is closed, regardless of whether the effect succeeds, fails, or is\ninterrupted. The finalizer receives the `Exit` value of the effect's scope,\nallowing it to react differently depending on how the effect concludes.\n\nFinalizers are a reliable way to manage resource cleanup, ensuring that\nresources such as file handles, network connections, or database transactions\nare properly closed even in the event of an unexpected interruption or error.\n\nFinalizers operate in conjunction with Effect's scoped resources. If an\neffect with a finalizer is wrapped in a scope, the finalizer will execute\nautomatically when the scope ends.",
    "deprecated": false,
    "examples": [
      "// Title: Adding a Finalizer on Success\nimport { Effect, Console } from \"effect\"\n\n//       Effect<string, never, Scope>\n//      \nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return \"some result\"\n})\n\n// Wrapping the effect in a scope\n//\n//       Effect<string, never, never>\n//      \nconst runnable = Effect.scoped(program)\n\n// Effect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Success\n// { _id: 'Exit', _tag: 'Success', value: 'some result' }",
      "// Title: Adding a Finalizer on Failure\nimport { Effect, Console } from \"effect\"\n\n//       Effect<never, string, Scope>\n//      \nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return yield* Effect.fail(\"Uh oh!\")\n})\n\n// Wrapping the effect in a scope\n//\n//       Effect<never, string, never>\n//      \nconst runnable = Effect.scoped(program)\n\n// Effect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }\n// }",
      "// Title: Adding a Finalizer on Interruption\nimport { Effect, Console } from \"effect\"\n\n//       Effect<never, never, Scope>\n//      \nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return yield* Effect.interrupt\n})\n\n// Wrapping the effect in a scope\n//\n//       Effect<never, never, never>\n//      \nconst runnable = Effect.scoped(program)\n\n// Effect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Interrupt',\n//     fiberId: {\n//       _id: 'FiberId',\n//       _tag: 'Runtime',\n//       id: 0,\n//       startTimeMillis: ...\n//     }\n//   }\n// }"
    ],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const addFinalizer: <X, R>(finalizer: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R>) => Effect<void, never, Scope.Scope | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "ensuring",
    "description": "Guarantees the execution of a finalizer when an effect starts execution.\n\n**Details**\n\nThis function allows you to specify a `finalizer` effect that will always be\nrun once the effect starts execution, regardless of whether the effect\nsucceeds, fails, or is interrupted.\n\n**When to Use**\n\nThis is useful when you need to ensure that certain cleanup or final steps\nare executed in all cases, such as releasing resources or performing\nnecessary logging.\n\nWhile this function provides strong guarantees about executing the finalizer,\nit is considered a low-level tool, which may not be ideal for more complex\nresource management. For higher-level resource management with automatic\nacquisition and release, see the {@link acquireRelease} family of functions.\nFor use cases where you need access to the result of an effect, consider\nusing {@link onExit}.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\nconst handler = Effect.ensuring(Console.log(\"Cleanup completed\"))\n\nconst success = Console.log(\"Task completed\").pipe(Effect.as(\"some result\"), handler)\n\n// Effect.runFork(success)\n// Output:\n// Task completed\n// Cleanup completed\n\nconst failure = Console.log(\"Task failed\").pipe(Effect.andThen(Effect.fail(\"some error\")), handler)\n\n// Effect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed\n\nconst interruption = Console.log(\"Task interrupted\").pipe(Effect.andThen(Effect.interrupt), handler)\n\n// Effect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed"
    ],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const ensuring: { <X, R1>(finalizer: Effect<X, never, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, X, R1>(self: Effect<A, E, R>, finalizer: Effect<X, never, R1>): Effect<A, E, R1 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "onError",
    "description": "Ensures a cleanup effect runs whenever the calling effect fails, providing\nthe failure cause to the cleanup effect.\n\n**Details**\n\nThis function allows you to attach a cleanup effect that runs whenever the\ncalling effect fails. The cleanup effect receives the cause of the failure,\nallowing you to perform actions such as logging, releasing resources, or\nexecuting additional recovery logic based on the error. The cleanup effect\nwill execute even if the failure is due to interruption.\n\nImportantly, the cleanup effect itself is uninterruptible, ensuring that it\ncompletes regardless of external interruptions.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\n// This handler logs the failure cause when the effect fails\nconst handler = Effect.onError((cause) => Console.log(`Cleanup completed: ${cause}`))\n\nconst success = Console.log(\"Task completed\").pipe(Effect.as(\"some result\"), handler)\n\n// Effect.runFork(success)\n// Output:\n// Task completed\n\nconst failure = Console.log(\"Task failed\").pipe(Effect.andThen(Effect.fail(\"some error\")), handler)\n\n// Effect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed: Error: some error\n\nconst interruption = Console.log(\"Task interrupted\").pipe(Effect.andThen(Effect.interrupt), handler)\n\n// Effect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed: All fibers interrupted without errors."
    ],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const onError: { <E, X, R2>(cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>): Effect<A, E, R2 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "onExit",
    "description": "Guarantees that a cleanup function runs regardless of whether the effect\nsucceeds, fails, or is interrupted.\n\n**Details**\n\nThis function ensures that a provided cleanup function is executed after the\neffect completes, regardless of the outcome. The cleanup function is given\nthe `Exit` value of the effect, which provides detailed information about the\nresult:\n- If the effect succeeds, the `Exit` contains the success value.\n- If the effect fails, the `Exit` contains the error or failure cause.\n- If the effect is interrupted, the `Exit` reflects the interruption.\n\nThe cleanup function is guaranteed to run uninterruptibly, ensuring reliable\nresource management even in complex or high-concurrency scenarios.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect, Exit } from \"effect\"\n\n// Define a cleanup function that logs the outcome of the effect\nconst handler = Effect.onExit((exit) => Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`))\n\nconst success = Console.log(\"Task completed\").pipe(Effect.as(\"some result\"), handler)\n\n// Effect.runFork(success)\n// Output:\n// Task completed\n// Cleanup completed: some result\n\nconst failure = Console.log(\"Task failed\").pipe(Effect.andThen(Effect.fail(\"some error\")), handler)\n\n// Effect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed: Error: some error\n\nconst interruption = Console.log(\"Task interrupted\").pipe(Effect.andThen(Effect.interrupt), handler)\n\n// Effect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed: All fibers interrupted without errors."
    ],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const onExit: { <A, E, X, R2>(cleanup: (exit: Exit.Exit<A, E>) => Effect<X, never, R2>): <R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (exit: Exit.Exit<A, E>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "parallelFinalizers",
    "description": "Ensures that finalizers are run concurrently when the scope of an effect is\nclosed.\n\n**Details**\n\nThis function modifies the behavior of finalizers within a scoped workflow to\nallow them to run concurrently when the scope is closed.\n\nBy default, finalizers are executed sequentially in reverse order of their\naddition, but this function changes that behavior to execute all finalizers\nconcurrently.\n\n**When to Use**\n\nRunning finalizers concurrently can improve performance when multiple\nindependent cleanup tasks need to be performed. However, it requires that\nthese tasks do not depend on the order of execution or introduce race\nconditions.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\n// Define a program that adds multiple finalizers\nconst program = Effect.gen(function*() {\n  yield* Effect.addFinalizer(() => Console.log(\"Finalizer 1 executed\").pipe(Effect.delay(\"300 millis\")))\n  yield* Effect.addFinalizer(() => Console.log(\"Finalizer 2 executed\").pipe(Effect.delay(\"100 millis\")))\n  yield* Effect.addFinalizer(() => Console.log(\"Finalizer 3 executed\").pipe(Effect.delay(\"200 millis\")))\n  return \"some result\"\n})\n\n// Modify the program to ensure finalizers run in parallel\nconst modified = program.pipe(Effect.parallelFinalizers)\n\nconst runnable = Effect.scoped(modified)\n\n// Effect.runFork(runnable)\n// Output:\n// Finalizer 2 executed\n// Finalizer 3 executed\n// Finalizer 1 executed"
    ],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const parallelFinalizers: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "sequentialFinalizers",
    "description": "Ensures that finalizers are run sequentially in reverse order of their\naddition.\n\n**Details**\n\nThis function modifies the behavior of finalizers within a scoped workflow to\nensure they are run sequentially in reverse order when the scope is closed.\n\nBy default, finalizers are executed sequentially, so this only changes the\nbehavior if the scope is configured to run finalizers concurrently.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const sequentialFinalizers: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "finalizersMask",
    "description": "Applies a custom execution strategy to finalizers within a scoped workflow.\n\n**Details**\n\nThis function allows you to control how finalizers are executed in a scope by\napplying a specified `ExecutionStrategy`. The `strategy` can dictate whether\nfinalizers run (e.g., sequentially or in parallel).\n\nAdditionally, the function provides a `restore` operation, which ensures that\nthe effect passed to it is executed under the default execution strategy.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const finalizersMask: (strategy: ExecutionStrategy) => <A, E, R>(self: (restore: <A1, E1, R1>(self: Effect<A1, E1, R1>) => Effect<A1, E1, R1>) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "scope",
    "description": "Provides access to the current scope in a scoped workflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const scope: Effect<Scope.Scope, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "scopeWith",
    "description": "Accesses the current scope and uses it to perform the specified effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const scopeWith: <A, E, R>(f: (scope: Scope.Scope) => Effect<A, E, R>) => Effect<A, E, R | Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "scopedWith",
    "description": "Creates a `Scope`, passes it to the specified effectful function, and closes\nthe scope when the effect completes (whether through success, failure, or\ninterruption).",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "scoped",
    "description": "Scopes all resources used in an effect to the lifetime of the effect.\n\n**Details**\n\nThis function ensures that all resources used within an effect are tied to\nits lifetime. Finalizers for these resources are executed automatically when\nthe effect completes, whether through success, failure, or interruption. This\nguarantees proper resource cleanup without requiring explicit management.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const scoped: <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, Scope.Scope>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "using",
    "description": "Scopes all resources acquired by one effect to the lifetime of another\neffect.\n\n**Details**\n\nThis function allows you to scope the resources acquired by one effect\n(`self`) to the lifetime of another effect (`use`). This ensures that the\nresources are cleaned up as soon as the `use` effect completes, regardless of\nhow the `use` effect ends (success, failure, or interruption).",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\nconst acquire = Console.log(\"Acquiring resource\").pipe(\n  Effect.as(1),\n  Effect.tap(Effect.addFinalizer(() => Console.log(\"Releasing resource\")))\n)\nconst use = (resource: number) => Console.log(`Using resource: ${resource}`)\n\nconst program = acquire.pipe(Effect.using(use))\n\n// Effect.runFork(program)\n// Output:\n// Acquiring resource\n// Using resource: 1\n// Releasing resource"
    ],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const using: { <A, A2, E2, R2>(use: (a: A) => Effect<A2, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | Exclude<R, Scope.Scope>>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>): Effect<A2, E | E2, R2 | Exclude<R, Scope.Scope>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withEarlyRelease",
    "description": "Returns the result of the effect and a finalizer to close its scope.\n\n**Details**\n\nThis function allows you to retrieve both the result of an effect and a\nfinalizer that can be used to manually close its scope. This is useful for\nworkflows where you need early access to the result while retaining control\nover the resource cleanup process.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\nconst acquire = Console.log(\"Acquiring resource\").pipe(\n  Effect.as(1),\n  Effect.tap(Effect.addFinalizer(() => Console.log(\"Releasing resource\")))\n)\nconst program = Effect.gen(function*() {\n  const [finalizer, resource] = yield* Effect.withEarlyRelease(acquire)\n  console.log(`Using resource: ${resource}`)\n  yield* Effect.sleep(\"1 second\")\n  yield* finalizer\n})\n\nEffect.runFork(program.pipe(Effect.scoped))\n// Output:\n// Acquiring resource\n// Using resource: 1\n// Releasing resource"
    ],
    "since": "2.0.0",
    "category": "Scoping, Resources & Finalization",
    "signature": "export declare const withEarlyRelease: <A, E, R>(self: Effect<A, E, R>) => Effect<[finalizer: Effect<void>, result: A], E, R | Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "awaitAllChildren",
    "description": "Returns a new effect that will not succeed with its value before first\nwaiting for the end of all child fibers forked by the effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const awaitAllChildren: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "daemonChildren",
    "description": "Returns a new workflow that will not supervise any fibers forked by this\nworkflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const daemonChildren: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "descriptor",
    "description": "Constructs an effect with information about the current `Fiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const descriptor: Effect<Fiber.Fiber.Descriptor, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "descriptorWith",
    "description": "Constructs an effect based on information about the current `Fiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const descriptorWith: <A, E, R>(f: (descriptor: Fiber.Fiber.Descriptor) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "diffFiberRefs",
    "description": "Returns a new workflow that executes this one and captures the changes in\n`FiberRef` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const diffFiberRefs: <A, E, R>(self: Effect<A, E, R>) => Effect<[FiberRefsPatch.FiberRefsPatch, A], E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "ensuringChild",
    "description": "Acts on the children of this fiber (collected into a single fiber),\nguaranteeing the specified callback will be invoked, whether or not this\neffect succeeds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const ensuringChild: { <X, R2>(f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "ensuringChildren",
    "description": "Acts on the children of this fiber, guaranteeing the specified callback\nwill be invoked, whether or not this effect succeeds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const ensuringChildren: { <X, R2>(children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "fiberId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const fiberId: Effect<FiberId.FiberId, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "fiberIdWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const fiberIdWith: <A, E, R>(f: (descriptor: FiberId.Runtime) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "fork",
    "description": "Creates a new fiber to run an effect concurrently.\n\n**Details**\n\nThis function takes an effect and forks it into a separate fiber, allowing it\nto run concurrently without blocking the original effect. The new fiber\nstarts execution immediately after being created, and the fiber object is\nreturned immediately without waiting for the effect to begin. This is useful\nwhen you want to run tasks concurrently while continuing other tasks in the\nparent fiber.\n\nThe forked fiber is attached to the parent fiber's scope. This means that\nwhen the parent fiber terminates, the child fiber will also be terminated\nautomatically. This feature, known as \"auto supervision,\" ensures that no\nfibers are left running unintentionally. If you prefer not to have this auto\nsupervision behavior, you can use {@link forkDaemon} or {@link forkIn}.\n\n**When to Use**\n\nUse this function when you need to run an effect concurrently without\nblocking the current execution flow. For example, you might use it to launch\nbackground tasks or concurrent computations. However, working with fibers can\nbe complex, so before using this function directly, you might want to explore\nhigher-level functions like {@link raceWith}, {@link zip}, or others that can\nmanage concurrency for you.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst fib = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(n)\n    : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)\n\n//       Effect<RuntimeFiber<number, never>, never, never>\n//      \nconst fib10Fiber = Effect.fork(fib(10))"
    ],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const fork: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "forkDaemon",
    "description": "Creates a long-running background fiber that is independent of its parent.\n\n**Details**\n\nThis function creates a \"daemon\" fiber that runs in the background and is not\ntied to the lifecycle of its parent fiber. Unlike normal fibers that stop\nwhen the parent fiber terminates, a daemon fiber will continue running until\nthe global scope closes or the fiber completes naturally. This makes it\nuseful for tasks that need to run in the background independently, such as\nperiodic logging, monitoring, or background data processing.",
    "deprecated": false,
    "examples": [
      "// Title: Creating a Daemon Fibe\nimport { Effect, Console, Schedule } from \"effect\"\n\n// Daemon fiber that logs a message repeatedly every second\nconst daemon = Effect.repeat(\n  Console.log(\"daemon: still running!\"),\n  Schedule.fixed(\"1 second\")\n)\n\nconst parent = Effect.gen(function* () {\n  console.log(\"parent: started!\")\n  // Daemon fiber running independently\n  yield* Effect.forkDaemon(daemon)\n  yield* Effect.sleep(\"3 seconds\")\n  console.log(\"parent: finished!\")\n})\n\n// Effect.runFork(parent)\n// Output:\n// parent: started!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// parent: finished!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// ...etc..."
    ],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const forkDaemon: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "forkAll",
    "description": "Returns an effect that forks all of the specified values, and returns a\ncomposite fiber that produces a list of their results, in order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const forkAll: { (options?: { readonly discard?: false | undefined; } | undefined): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Fiber.Fiber<Array<Effect.Success<Eff>>, Effect.Error<Eff>>, never, Effect.Context<Eff>>; (options: { readonly discard: true; }): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<void, never, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options?: { readonly discard?: false | undefined; } | undefined): Effect<Fiber.Fiber<Array<Effect.Success<Eff>>, Effect.Error<Eff>>, never, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options: { readonly discard: true; }): Effect<void, never, Effect.Context<Eff>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "forkIn",
    "description": "Forks an effect in a specific scope, allowing finer control over its\nexecution.\n\n**Details**\n\nThere are some cases where we need more fine-grained control, so we want to\nfork a fiber in a specific scope. We can use the `Effect.forkIn` operator\nwhich takes the target scope as an argument.\n\nThe fiber will be interrupted when the scope is closed.",
    "deprecated": false,
    "examples": [
      "// Title: Forking a Fiber in a Specific Scope\n//\n// In this example, the child fiber is forked into the outerScope,\n// allowing it to outlive the inner scope but still be terminated\n// when the outerScope is closed.\n//\n\nimport { Console, Effect, Schedule } from \"effect\"\n\n// Child fiber that logs a message repeatedly every second\nconst child = Effect.repeat(\n  Console.log(\"child: still running!\"),\n  Schedule.fixed(\"1 second\")\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function* () {\n    yield* Effect.addFinalizer(() =>\n      Console.log(\"The outer scope is about to be closed!\")\n    )\n\n    // Capture the outer scope\n    const outerScope = yield* Effect.scope\n\n    // Create an inner scope\n    yield* Effect.scoped(\n      Effect.gen(function* () {\n        yield* Effect.addFinalizer(() =>\n          Console.log(\"The inner scope is about to be closed!\")\n        )\n        // Fork the child fiber in the outer scope\n        yield* Effect.forkIn(child, outerScope)\n        yield* Effect.sleep(\"3 seconds\")\n      })\n    )\n\n    yield* Effect.sleep(\"5 seconds\")\n  })\n)\n\n// Effect.runFork(program)\n// Output:\n// child: still running!\n// child: still running!\n// child: still running!\n// The inner scope is about to be closed!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// The outer scope is about to be closed!"
    ],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const forkIn: { (scope: Scope.Scope): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>; <A, E, R>(self: Effect<A, E, R>, scope: Scope.Scope): Effect<Fiber.RuntimeFiber<A, E>, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "forkScoped",
    "description": "Forks a fiber in a local scope, ensuring it outlives its parent.\n\n**Details**\n\nThis function is used to create fibers that are tied to a local scope,\nmeaning they are not dependent on their parent fiber's lifecycle. Instead,\nthey will continue running until the scope they were created in is closed.\nThis is particularly useful when you need a fiber to run independently of the\nparent fiber, but still want it to be terminated when the scope ends.\n\nFibers created with this function are isolated from the parent fibers\ntermination, so they can run for a longer period. This behavior is different\nfrom fibers created with {@link fork}, which are terminated when the parent fiber\nterminates. With `forkScoped`, the child fiber will keep running until the\nlocal scope ends, regardless of the state of the parent fiber.",
    "deprecated": false,
    "examples": [
      "// Title: Forking a Fiber in a Local Scope\n//\n// In this example, the child fiber continues to run beyond the lifetime of the parent fiber.\n// The child fiber is tied to the local scope and will be terminated only when the scope ends.\n//\n\nimport { Effect, Console, Schedule } from \"effect\"\n\n// Child fiber that logs a message repeatedly every second\nconst child = Effect.repeat(\n  Console.log(\"child: still running!\"),\n  Schedule.fixed(\"1 second\")\n)\n\n//       Effect<void, never, Scope>\n//      \nconst parent = Effect.gen(function* () {\n  console.log(\"parent: started!\")\n  // Child fiber attached to local scope\n  yield* Effect.forkScoped(child)\n  yield* Effect.sleep(\"3 seconds\")\n  console.log(\"parent: finished!\")\n})\n\n// Program runs within a local scope\nconst program = Effect.scoped(\n  Effect.gen(function* () {\n    console.log(\"Local scope started!\")\n    yield* Effect.fork(parent)\n    // Scope lasts for 5 seconds\n    yield* Effect.sleep(\"5 seconds\")\n    console.log(\"Leaving the local scope!\")\n  })\n)\n\n// Effect.runFork(program)\n// Output:\n// Local scope started!\n// parent: started!\n// child: still running!\n// child: still running!\n// child: still running!\n// parent: finished!\n// child: still running!\n// child: still running!\n// Leaving the local scope!"
    ],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const forkScoped: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, Scope.Scope | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "forkWithErrorHandler",
    "description": "Like {@link fork} but handles an error with the provided handler.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const forkWithErrorHandler: { <E, X>(handler: (e: E) => Effect<X>): <A, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>; <A, E, R, X>(self: Effect<A, E, R>, handler: (e: E) => Effect<X>): Effect<Fiber.RuntimeFiber<A, E>, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "fromFiber",
    "description": "Creates an `Effect` value that represents the exit value of the specified\nfiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const fromFiber: <A, E>(fiber: Fiber.Fiber<A, E>) => Effect<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "fromFiberEffect",
    "description": "Creates an `Effect` value that represents the exit value of a fiber obtained\nfrom an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const fromFiberEffect: <A, E, R>(fiber: Effect<Fiber.Fiber<A, E>, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "supervised",
    "description": "Supervises child fibers by reporting them to a specified supervisor.\n\n**Details**\n\nThis function takes a supervisor as an argument and returns an effect where\nall child fibers forked within it are supervised by the provided supervisor.\nThis enables you to capture detailed information about these child fibers,\nsuch as their status, through the supervisor.",
    "deprecated": false,
    "examples": [
      "// Title: Monitoring Fiber Count\nimport { Effect, Supervisor, Schedule, Fiber, FiberStatus } from \"effect\"\n\n// Main program that monitors fibers while calculating a Fibonacci number\nconst program = Effect.gen(function* () {\n  // Create a supervisor to track child fibers\n  const supervisor = yield* Supervisor.track\n\n  // Start a Fibonacci calculation, supervised by the supervisor\n  const fibFiber = yield* fib(20).pipe(\n    Effect.supervised(supervisor),\n    // Fork the Fibonacci effect into a fiber\n    Effect.fork\n  )\n\n  // Define a schedule to periodically monitor the fiber count every 500ms\n  const policy = Schedule.spaced(\"500 millis\").pipe(\n    Schedule.whileInputEffect((_) =>\n      Fiber.status(fibFiber).pipe(\n        // Continue while the Fibonacci fiber is not done\n        Effect.andThen((status) => status !== FiberStatus.done)\n      )\n    )\n  )\n\n  // Start monitoring the fibers, using the supervisor to track the count\n  const monitorFiber = yield* monitorFibers(supervisor).pipe(\n    // Repeat the monitoring according to the schedule\n    Effect.repeat(policy),\n    // Fork the monitoring into its own fiber\n    Effect.fork\n  )\n\n  // Join the monitor and Fibonacci fibers to ensure they complete\n  yield* Fiber.join(monitorFiber)\n  const result = yield* Fiber.join(fibFiber)\n\n  console.log(`fibonacci result: ${result}`)\n})\n\n// Function to monitor and log the number of active fibers\nconst monitorFibers = (\n  supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    const fibers = yield* supervisor.value // Get the current set of fibers\n    console.log(`number of fibers: ${fibers.length}`)\n  })\n\n// Recursive Fibonacci calculation, spawning fibers for each recursive step\nconst fib = (n: number): Effect.Effect<number> =>\n  Effect.gen(function* () {\n    if (n <= 1) {\n      return 1\n    }\n    yield* Effect.sleep(\"500 millis\") // Simulate work by delaying\n\n    // Fork two fibers for the recursive Fibonacci calls\n    const fiber1 = yield* Effect.fork(fib(n - 2))\n    const fiber2 = yield* Effect.fork(fib(n - 1))\n\n    // Join the fibers to retrieve their results\n    const v1 = yield* Fiber.join(fiber1)\n    const v2 = yield* Fiber.join(fiber2)\n\n    return v1 + v2 // Combine the results\n  })\n\n// Effect.runPromise(program)\n// Output:\n// number of fibers: 0\n// number of fibers: 2\n// number of fibers: 6\n// number of fibers: 14\n// number of fibers: 30\n// number of fibers: 62\n// number of fibers: 126\n// number of fibers: 254\n// number of fibers: 510\n// number of fibers: 1022\n// number of fibers: 2034\n// number of fibers: 3795\n// number of fibers: 5810\n// number of fibers: 6474\n// number of fibers: 4942\n// number of fibers: 2515\n// number of fibers: 832\n// number of fibers: 170\n// number of fibers: 18\n// number of fibers: 0\n// fibonacci result: 10946"
    ],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const supervised: { <X>(supervisor: Supervisor.Supervisor<X>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, X>(self: Effect<A, E, R>, supervisor: Supervisor.Supervisor<X>): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "transplant",
    "description": "Transplants specified effects so that when those effects fork other\neffects, the forked effects will be governed by the scope of the fiber that\nexecutes this effect.\n\nThis can be used to \"graft\" deep grandchildren onto a higher-level scope,\neffectively extending their lifespans into the parent scope.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const transplant: <A, E, R>(f: (grafter: <A2, E2, R2>(effect: Effect<A2, E2, R2>) => Effect<A2, E2, R2>) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withConcurrency",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Supervision & Fibers",
    "signature": "export declare const withConcurrency: { (concurrency: number | \"unbounded\"): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, concurrency: number | \"unbounded\"): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withScheduler",
    "description": "Sets the provided scheduler for usage in the wrapped effect",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scheduler",
    "signature": "export declare const withScheduler: { (scheduler: Scheduler.Scheduler): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, scheduler: Scheduler.Scheduler): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withSchedulingPriority",
    "description": "Sets the scheduling priority used when yielding",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scheduler",
    "signature": "export declare const withSchedulingPriority: { (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withMaxOpsBeforeYield",
    "description": "Sets the maximum number of operations before yield by the default schedulers",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Scheduler",
    "signature": "export declare const withMaxOpsBeforeYield: { (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "clock",
    "description": "Retrieves the `Clock` service from the context.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  const clock = yield* Effect.clock\n  const currentTime = yield* clock.currentTimeMillis\n  console.log(`Current time in milliseconds: ${currentTime}`)\n})\n\n// Effect.runFork(program)\n// Example Output:\n// Current time in milliseconds: 1735484796134"
    ],
    "since": "2.0.0",
    "category": "Clock",
    "signature": "export declare const clock: Effect<Clock.Clock, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "clockWith",
    "description": "Retrieves the `Clock` service from the context and provides it to the\nspecified effectful function.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\nconst program = Effect.clockWith((clock) =>\n  clock.currentTimeMillis.pipe(\n    Effect.map((currentTime) => `Current time is: ${currentTime}`),\n    Effect.tap(Console.log)\n  )\n)\n\n// Effect.runFork(program)\n// Example Output:\n// Current time is: 1735484929744"
    ],
    "since": "2.0.0",
    "category": "Clock",
    "signature": "export declare const clockWith: <A, E, R>(f: (clock: Clock.Clock) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withClockScoped",
    "description": "Sets the implementation of the `Clock` service to the specified value and\nrestores it to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Clock",
    "signature": "export declare const withClockScoped: <C extends Clock.Clock>(clock: C) => Effect<void, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withClock",
    "description": "Executes the specified workflow with the specified implementation of the\n`Clock` service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Clock",
    "signature": "export declare const withClock: { <C extends Clock.Clock>(clock: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <C extends Clock.Clock, A, E, R>(effect: Effect<A, E, R>, clock: C): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "console",
    "description": "Retreives the `Console` service from the context",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Console",
    "signature": "export declare const console: Effect<Console, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "consoleWith",
    "description": "Retreives the `Console` service from the context and provides it to the\nspecified effectful function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Console",
    "signature": "export declare const consoleWith: <A, E, R>(f: (console: Console) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withConsoleScoped",
    "description": "Sets the implementation of the console service to the specified value and\nrestores it to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const withConsoleScoped: <A extends Console>(console: A) => Effect<void, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withConsole",
    "description": "Executes the specified workflow with the specified implementation of the\nconsole service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Console",
    "signature": "export declare const withConsole: { <C extends Console>(console: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, C extends Console>(effect: Effect<A, E, R>, console: C): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "delay",
    "description": "Delays the execution of an effect by a specified `Duration`.\n\n**Details\n\nThis function postpones the execution of the provided effect by the specified\nduration. The duration can be provided in various formats supported by the\n`Duration` module.\n\nInternally, this function does not block the thread; instead, it uses an\nefficient, non-blocking mechanism to introduce the delay.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\nconst task = Console.log(\"Task executed\")\n\nconst program = Console.log(\"start\").pipe(\n  Effect.andThen(\n    // Delays the log message by 2 seconds\n    task.pipe(Effect.delay(\"2 seconds\"))\n  )\n)\n\n// Effect.runFork(program)\n// Output:\n// start\n// Task executed"
    ],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "export declare const delay: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "sleep",
    "description": "Suspends the execution of an effect for a specified `Duration`.\n\n**Details**\n\nThis function pauses the execution of an effect for a given duration. It is\nasynchronous, meaning that it does not block the fiber executing the effect.\nInstead, the fiber is suspended during the delay period and can resume once\nthe specified time has passed.\n\nThe duration can be specified using various formats supported by the\n`Duration` module, such as a string (`\"2 seconds\"`) or numeric value\nrepresenting milliseconds.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  console.log(\"Starting task...\")\n  yield* Effect.sleep(\"3 seconds\") // Waits for 3 seconds\n  console.log(\"Task completed!\")\n})\n\n// Effect.runFork(program)\n// Output:\n// Starting task...\n// Task completed!"
    ],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "export declare const sleep: (duration: Duration.DurationInput) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "timed",
    "description": "Executes an effect and measures the time it takes to complete.\n\n**Details**\n\nThis function wraps the provided effect and returns a new effect that, when\nexecuted, performs the original effect and calculates its execution duration.\n\nThe result of the new effect includes both the execution time (as a\n`Duration`) and the original effect's result. This is useful for monitoring\nperformance or gaining insights into the time taken by specific operations.\n\nThe original effect's behavior (success, failure, or interruption) remains\nunchanged, and the timing information is provided alongside the result in a\ntuple.",
    "deprecated": false,
    "examples": [
      "import { Duration, Effect } from \"effect\"\n\nconst task = Effect.gen(function*() {\n  yield* Effect.sleep(\"2 seconds\") // Simulates some work\n  return \"some result\"\n})\n\nconst timedTask = task.pipe(Effect.timed)\n\nconst program = Effect.gen(function*() {\n  const [duration, result] = yield* timedTask\n  console.log(`Task completed in ${Duration.toMillis(duration)} ms with result: ${result}`)\n})\n\n// Effect.runFork(program)\n// Output: Task completed in 2003.749125 ms with result: some result"
    ],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "export declare const timed: <A, E, R>(self: Effect<A, E, R>) => Effect<[duration: Duration.Duration, result: A], E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "timedWith",
    "description": "Executes an effect and measures its execution time using a custom clock.\n\n**Details**\n\nThis function extends the functionality of {@link timed} by allowing you to\nspecify a custom clock for measuring the execution duration. The provided\neffect (`nanoseconds`) represents the clock and should return the current\ntime in nanoseconds. The timing information is computed using this custom\nclock instead of the default system clock.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "export declare const timedWith: { <E1, R1>(nanoseconds: Effect<bigint, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<[Duration.Duration, A], E1 | E, R1 | R>; <A, E, R, E1, R1>(self: Effect<A, E, R>, nanoseconds: Effect<bigint, E1, R1>): Effect<[Duration.Duration, A], E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "timeout",
    "description": "Adds a time limit to an effect, triggering a timeout if the effect exceeds\nthe duration.\n\n**Details**\n\nThis function allows you to enforce a time limit on the execution of an\neffect. If the effect does not complete within the given duration, it fails\nwith a `TimeoutException`. This is useful for preventing tasks from hanging\nindefinitely, especially in scenarios where responsiveness or resource limits\nare critical.\n\nThe returned effect will either:\n- Succeed with the original effect's result if it completes within the\n  specified duration.\n- Fail with a `TimeoutException` if the time limit is exceeded.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\n// Output will show a TimeoutException as the task takes longer\n// than the specified timeout duration\nconst timedEffect = task.pipe(Effect.timeout(\"1 second\"))\n\n// Effect.runPromiseExit(timedEffect).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: { _tag: 'TimeoutException' }\n//   }\n// }"
    ],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "export declare const timeout: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | Cause.TimeoutException, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<A, Cause.TimeoutException | E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "timeoutOption",
    "description": "Gracefully handles timeouts by returning an `Option` that represents either\nthe result or a timeout.\n\n**Details**\n\nThis function wraps the outcome of an effect in an `Option` type. If the\neffect completes within the specified duration, it returns a `Some`\ncontaining the result. If the effect times out, it returns a `None`. Unlike\nother timeout methods, this approach does not raise errors or exceptions;\ninstead, it allows you to treat timeouts as a regular outcome, simplifying\nthe logic for handling delays.\n\n**When to Use**\n\nThis is useful when you want to handle timeouts without causing the program\nto fail, making it easier to manage situations where you expect tasks might\ntake too long but want to continue executing other tasks.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\nconst timedOutEffect = Effect.all([\n  task.pipe(Effect.timeoutOption(\"3 seconds\")),\n  task.pipe(Effect.timeoutOption(\"1 second\"))\n])\n\n// Effect.runPromise(timedOutEffect).then(console.log)\n// Output:\n// Start processing...\n// Processing complete.\n// Start processing...\n// [\n//   { _id: 'Option', _tag: 'Some', value: 'Result' },\n//   { _id: 'Option', _tag: 'None' }\n// ]"
    ],
    "since": "3.1.0",
    "category": "Delays & Timeouts",
    "signature": "export declare const timeoutOption: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<Option.Option<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "timeoutFail",
    "description": "Specifies a custom error to be produced when a timeout occurs.\n\n**Details**\n\nThis function allows you to handle timeouts in a customized way by defining a\nspecific error to be raised when an effect exceeds the given duration. Unlike\ndefault timeout behaviors that use generic exceptions, this function gives\nyou the flexibility to specify a meaningful error type that aligns with your\napplication's needs.\n\nWhen you apply this function, you provide:\n- A `duration`: The time limit for the effect.\n- An `onTimeout` function: A lazy evaluation function that generates the\n  custom error if the timeout occurs.\n\nIf the effect completes within the time limit, its result is returned\nnormally. Otherwise, the `onTimeout` function is triggered, and its output is\nused as the error for the effect.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\nclass MyTimeoutError {\n  readonly _tag = \"MyTimeoutError\"\n}\n\nconst program = task.pipe(\n  Effect.timeoutFail({\n    duration: \"1 second\",\n    onTimeout: () => new MyTimeoutError() // Custom timeout error\n  })\n)\n\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: MyTimeoutError { _tag: 'MyTimeoutError' }\n//   }\n// }"
    ],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "export declare const timeoutFail: { <E1>(options: { readonly onTimeout: LazyArg<E1>; readonly duration: Duration.DurationInput; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>; <A, E, R, E1>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<E1>; readonly duration: Duration.DurationInput; }): Effect<A, E | E1, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "timeoutFailCause",
    "description": "Specifies a custom defect to be thrown when a timeout occurs.\n\n**Details**\n\nThis function allows you to handle timeouts as exceptional cases by\ngenerating a custom defect when an effect exceeds the specified duration. You\nprovide:\n- A `duration`: The time limit for the effect.\n- An `onTimeout` function: A lazy evaluation function that generates the\n  custom defect (typically created using `Cause.die`).\n\nIf the effect completes within the time limit, its result is returned\nnormally. Otherwise, the custom defect is triggered, and the effect fails\nwith that defect.\n\n**When to Use**\n\nThis is especially useful when you need to treat timeouts as critical\nfailures in your application and wish to include meaningful information in\nthe defect.",
    "deprecated": false,
    "examples": [
      "import { Effect, Cause } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\nconst program = task.pipe(\n  Effect.timeoutFailCause({\n    duration: \"1 second\",\n    onTimeout: () => Cause.die(\"Timed out!\") // Custom defect for timeout\n  })\n)\n\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }\n// }"
    ],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "export declare const timeoutFailCause: { <E1>(options: { readonly onTimeout: LazyArg<Cause.Cause<E1>>; readonly duration: Duration.DurationInput; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>; <A, E, R, E1>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<Cause.Cause<E1>>; readonly duration: Duration.DurationInput; }): Effect<A, E | E1, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "timeoutTo",
    "description": "Provides custom behavior for successful and timed-out operations.\n\n**Details**\n\nThis function allows you to define distinct outcomes for an effect depending\non whether it completes within a specified time frame or exceeds the timeout\nduration. You can provide:\n- `onSuccess`: A handler for processing the result of the effect if it\n  completes successfully within the time limit.\n- `onTimeout`: A handler for generating a result when the effect times out.\n- `duration`: The maximum allowed time for the effect to complete.\n\n**When to Use**\n\nUnlike {@link timeout}, which raises an exception for timeouts, this function\ngives you full control over the behavior for both success and timeout\nscenarios. It is particularly useful when you want to encapsulate timeouts\nand successes into a specific data structure, like an `Either` type, to\nrepresent these outcomes in a meaningful way.",
    "deprecated": false,
    "examples": [
      "import { Effect, Either } from \"effect\"\n\nconst task = Effect.gen(function* () {\n  console.log(\"Start processing...\")\n  yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n  console.log(\"Processing complete.\")\n  return \"Result\"\n})\n\nconst program = task.pipe(\n  Effect.timeoutTo({\n    duration: \"1 second\",\n    onSuccess: (result): Either.Either<string, string> =>\n      Either.right(result),\n    onTimeout: (): Either.Either<string, string> =>\n      Either.left(\"Timed out!\")\n  })\n)\n\n// Effect.runPromise(program).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: \"Either\",\n//   _tag: \"Left\",\n//   left: \"Timed out!\"\n// }"
    ],
    "since": "2.0.0",
    "category": "Delays & Timeouts",
    "signature": "export declare const timeoutTo: { <A, B, B1>(options: { readonly onTimeout: LazyArg<B1>; readonly onSuccess: (a: A) => B; readonly duration: Duration.DurationInput; }): <E, R>(self: Effect<A, E, R>) => Effect<B | B1, E, R>; <A, E, R, B1, B>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<B1>; readonly onSuccess: (a: A) => B; readonly duration: Duration.DurationInput; }): Effect<B1 | B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "configProviderWith",
    "description": "Allows working with the default configuration provider.\n\n**Details**\n\nThis function retrieves the default configuration provider and passes it to\nthe provided function, which can use it to perform computations or retrieve\nconfiguration values. The function can return an effect that leverages the\nconfiguration provider for its operations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Config",
    "signature": "export declare const configProviderWith: <A, E, R>(f: (provider: ConfigProvider) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withConfigProvider",
    "description": "Executes an effect using a specific configuration provider.\n\n**Details**\n\nThis function lets you run an effect with a specified configuration provider.\nThe custom provider will override the default configuration provider for the\nduration of the effect's execution.\n\n**When to Use**\n\nThis is particularly useful when you need to use a different set of\nconfiguration values or sources for specific parts of your application.",
    "deprecated": false,
    "examples": [
      "import { Config, ConfigProvider, Effect } from \"effect\"\n\nconst customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(\n  new Map([[\"custom-key\", \"custom-value\"]])\n)\n\nconst program = Effect.withConfigProvider(customProvider)(\n  Effect.gen(function*() {\n    const value = yield* Config.string(\"custom-key\")\n    console.log(`Config value: ${value}`)\n  })\n)\n\n// Effect.runPromise(program)\n// Output:\n// Config value: custom-value"
    ],
    "since": "2.0.0",
    "category": "Config",
    "signature": "export declare const withConfigProvider: { (provider: ConfigProvider): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, provider: ConfigProvider): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withConfigProviderScoped",
    "description": "Sets a configuration provider within a scope.\n\n**Details**\n\nThis function sets the configuration provider to a specified value and\nensures that it is restored to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Config",
    "signature": "export declare const withConfigProviderScoped: (provider: ConfigProvider) => Effect<void, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "context",
    "description": "Accesses the full context of the effect.\n\n**Details**\n\nThis function provides the ability to access the entire context required by\nan effect. The context is a container that holds dependencies or environment\nvalues needed by an effect to run. By using this function, you can retrieve\nand work with the context directly within an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const context: <R>() => Effect<Context.Context<R>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "contextWith",
    "description": "Accesses the context and applies a transformation function.\n\n**Details**\n\nThis function retrieves the context of the effect and applies a pure\ntransformation function to it. The result of the transformation is then\nreturned within the effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const contextWith: <R, A>(f: (context: Context.Context<R>) => A) => Effect<A, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "contextWithEffect",
    "description": "Accesses the context and performs an effectful transformation.\n\n**Details**\n\nThis function retrieves the context and allows you to transform it\neffectually using another effect. It is useful when the transformation\ninvolves asynchronous or effectful operations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const contextWithEffect: <R2, A, E, R>(f: (context: Context.Context<R2>) => Effect<A, E, R>) => Effect<A, E, R | R2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputContext",
    "description": "Provides part of the required context while leaving the rest unchanged.\n\n**Details**\n\nThis function allows you to transform the context required by an effect,\nproviding part of the context and leaving the rest to be fulfilled later.",
    "deprecated": false,
    "examples": [
      "import { Context, Effect } from \"effect\"\n\nclass Service1 extends Context.Tag(\"Service1\")<Service1, { readonly port: number }>() {}\nclass Service2 extends Context.Tag(\"Service2\")<Service2, { readonly connection: string }>() {}\n\nconst program = Effect.gen(function*() {\n  const service1 = yield* Service1\n  console.log(service1.port)\n  const service2 = yield* Service2\n  console.log(service2.connection)\n  return \"some result\"\n})\n\n//       Effect<string, never, Service2>\n//      \nconst programWithService1 = Effect.mapInputContext(\n  program,\n  (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })\n)\n\nconst runnable = programWithService1.pipe(\n  Effect.provideService(Service2, { connection: \"localhost\" }),\n  Effect.provideService(Service1, { port: 3001 })\n)\n\nEffect.runPromise(runnable)\n// Output:\n// 3000\n// localhost"
    ],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const mapInputContext: { <R2, R>(f: (context: Context.Context<R2>) => Context.Context<R>): <A, E>(self: Effect<A, E, R>) => Effect<A, E, R2>; <A, E, R, R2>(self: Effect<A, E, R>, f: (context: Context.Context<R2>) => Context.Context<R>): Effect<A, E, R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "provide",
    "description": "Provides necessary dependencies to an effect, removing its environmental\nrequirements.\n\n**Details**\n\nThis function allows you to supply the required environment for an effect.\nThe environment can be provided in the form of one or more `Layer`s, a\n`Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\nprovided, the effect can run without requiring external dependencies.\n\nYou can compose layers to create a modular and reusable way of setting up the\nenvironment for effects. For example, layers can be used to configure\ndatabases, logging services, or any other required dependencies.",
    "deprecated": false,
    "examples": [
      "import { Context, Effect, Layer } from \"effect\"\n\nclass Database extends Context.Tag(\"Database\")<\n  Database,\n  { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n>() {}\n\nconst DatabaseLive = Layer.succeed(\n  Database,\n  {\n    // Simulate a database query\n    query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n  }\n)\n\n//       Effect<unknown[], never, Database>\n//      \nconst program = Effect.gen(function*() {\n  const database = yield* Database\n  const result = yield* database.query(\"SELECT * FROM users\")\n  return result\n})\n\n//       Effect<unknown[], never, never>\n//      \nconst runnable = Effect.provide(program, DatabaseLive)\n\n// Effect.runPromise(runnable).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"Executing query: SELECT * FROM users\"\n// []"
    ],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const provide: { <const Layers extends [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(layers: Layers): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]>; }[number]>>; <ROut, E2, RIn>(layer: Layer.Layer<ROut, E2, RIn>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, RIn | Exclude<R, ROut>>; <R2>(context: Context.Context<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; <R2>(runtime: Runtime.Runtime<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; <E2, R2>(managedRuntime: ManagedRuntime.ManagedRuntime<R2, E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, Exclude<R, R2>>; <A, E, R, const Layers extends [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(self: Effect<A, E, R>, layers: Layers): Effect<A, E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]>; }[number]>>; <A, E, R, ROut, E2, RIn>(self: Effect<A, E, R>, layer: Layer.Layer<ROut, E2, RIn>): Effect<A, E | E2, RIn | Exclude<R, ROut>>; <A, E, R, R2>(self: Effect<A, E, R>, context: Context.Context<R2>): Effect<A, E, Exclude<R, R2>>; <A, E, R, R2>(self: Effect<A, E, R>, runtime: Runtime.Runtime<R2>): Effect<A, E, Exclude<R, R2>>; <A, E, E2, R, R2>(self: Effect<A, E, R>, runtime: ManagedRuntime.ManagedRuntime<R2, E2>): Effect<A, E | E2, Exclude<R, R2>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "provideService",
    "description": "Provides an implementation for a service in the context of an effect.\n\n**Details**\n\nThis function allows you to supply a specific implementation for a service\nrequired by an effect. Services are typically defined using `Context.Tag`,\nwhich acts as a unique identifier for the service. By using this function,\nyou link the service to its concrete implementation, enabling the effect to\nexecute successfully without additional requirements.\n\nFor example, you can use this function to provide a random number generator,\na logger, or any other service your effect depends on. Once the service is\nprovided, all parts of the effect that rely on the service will automatically\nuse the implementation you supplied.",
    "deprecated": false,
    "examples": [
      "import { Effect, Context } from \"effect\"\n\n// Declaring a tag for a service that generates random numbers\nclass Random extends Context.Tag(\"MyRandomService\")<\n  Random,\n  { readonly next: Effect.Effect<number> }\n>() {}\n\n// Using the service\nconst program = Effect.gen(function* () {\n  const random = yield* Random\n  const randomNumber = yield* random.next\n  console.log(`random number: ${randomNumber}`)\n})\n\n// Providing the implementation\n//\n//       Effect<void, never, never>\n//      \nconst runnable = Effect.provideService(program, Random, {\n  next: Effect.sync(() => Math.random())\n})\n\n// Run successfully\n// Effect.runPromise(runnable)\n// Example Output:\n// random number: 0.8241872233134417"
    ],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, service: NoInfer<S>): Effect<A, E, Exclude<R, I>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "provideServiceEffect",
    "description": "Dynamically provides an implementation for a service using an effect.\n\n**Details**\n\nThis function allows you to provide an implementation for a service\ndynamically by using another effect. The provided effect is executed to\nproduce the service implementation, which is then made available to the\nconsuming effect. This is particularly useful when the service implementation\nitself requires asynchronous or resource-intensive initialization.\n\nFor example, you can use this function to lazily initialize a database\nconnection or fetch configuration values from an external source before\nmaking the service available to your effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const provideServiceEffect: { <I, S, E1, R1>(tag: Context.Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | Exclude<R, I>>; <A, E, R, I, S, E1, R1>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): Effect<A, E | E1, R1 | Exclude<R, I>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "serviceFunction",
    "description": "Creates a function that uses a service from the context to produce a value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const serviceFunction: <T extends Effect<any, any, any>, Args extends Array<any>, A>(getService: T, f: (_: Effect.Success<T>) => (...args: Args) => A) => (...args: Args) => Effect<A, Effect.Error<T>, Effect.Context<T>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "serviceFunctionEffect",
    "description": "Creates a function that uses a service from the context to produce an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const serviceFunctionEffect: <T extends Effect<any, any, any>, Args extends Array<any>, A, E, R>(getService: T, f: (_: Effect.Success<T>) => (...args: Args) => Effect<A, E, R>) => (...args: Args) => Effect<A, E | Effect.Error<T>, R | Effect.Context<T>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "serviceFunctions",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const serviceFunctions: <S, SE, SR>(getService: Effect<S, SE, SR>) => { [k in keyof S as S[k] extends (...args: Array<any>) => Effect<any, any, any> ? k : never]: S[k] extends (...args: infer Args) => Effect<infer A, infer E, infer R> ? (...args: Args) => Effect<A, SE | E, SR | R> : never; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "serviceConstants",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const serviceConstants: <S, SE, SR>(getService: Effect<S, SE, SR>) => { [k in { [k in keyof S]: k; }[keyof S]]: S[k] extends Effect<infer A, infer E, infer R> ? Effect<A, SE | E, SR | R> : Effect<S[k], SE, SR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "serviceMembers",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const serviceMembers: <S, SE, SR>(getService: Effect<S, SE, SR>) => { functions: { [k in keyof S as S[k] extends (...args: Array<any>) => Effect<any, any, any> ? k : never]: S[k] extends (...args: infer Args) => Effect<infer A, infer E, infer R> ? (...args: Args) => Effect<A, SE | E, SR | R> : never; }; constants: { [k in { [k in keyof S]: k; }[keyof S]]: S[k] extends Effect<infer A, infer E, infer R> ? Effect<A, SE | E, SR | R> : Effect<S[k], SE, SR>; }; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "serviceOption",
    "description": "Retrieves an optional service from the context as an `Option`.\n\n**Details**\n\nThis function retrieves a service from the context and wraps it in an\n`Option`. If the service is available, it returns a `Some` containing the\nservice. If the service is not found, it returns a `None`. This approach is\nuseful when you want to handle the absence of a service gracefully without\ncausing an error.\n\n**When to Use**\n\nUse this function when:\n- You need to access a service that may or may not be present in the context.\n- You want to handle the absence of a service using the `Option` type instead\n  of throwing an error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const serviceOption: <I, S>(tag: Context.Tag<I, S>) => Effect<Option.Option<S>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "serviceOptional",
    "description": "Retrieves a service from the context, throwing an error if it is missing.\n\n**Details**\n\nThis function retrieves a required service from the context. If the service\nis available, it returns the service. If the service is missing, it throws a\n`NoSuchElementException`, which can be handled using Effect's error-handling\nmechanisms. This is useful for services that are critical to the execution of\nyour effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const serviceOptional: <I, S>(tag: Context.Tag<I, S>) => Effect<S, Cause.NoSuchElementException>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "updateService",
    "description": "Updates a service in the context with a new implementation.\n\n**Details**\n\nThis function modifies the existing implementation of a service in the\ncontext. It retrieves the current service, applies the provided\ntransformation function `f`, and replaces the old service with the\ntransformed one.\n\n**When to Use**\n\nThis is useful for adapting or extending a service's behavior during the\nexecution of an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const updateService: { <I, S>(tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R | I>; <A, E, R, I, S>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): Effect<A, E, R | I>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "Do",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "import { Effect, pipe } from \"effect\"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind(\"x\", () => Effect.succeed(2)),\n  Effect.bind(\"y\", () => Effect.succeed(3)),\n  Effect.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })"
    ],
    "since": "2.0.0",
    "category": "Do notation",
    "signature": "export declare const Do: Effect<{}, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "bind",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "import { Effect, pipe } from \"effect\"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind(\"x\", () => Effect.succeed(2)),\n  Effect.bind(\"y\", () => Effect.succeed(3)),\n  Effect.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })"
    ],
    "since": "2.0.0",
    "category": "Do notation",
    "signature": "export declare const bind: { <N extends string, A extends object, B, E2, R2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): <E1, R1>(self: Effect<A, E1, R1>) => Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E1, R2 | R1>; <A extends object, N extends string, E1, R1, B, E2, R2>(self: Effect<A, E1, R1>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E1 | E2, R1 | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "bindAll",
    "description": "`bindAll` combines `all` with `bind`. It is useful\nwhen you want to concurrently run multiple effects and then combine their\nresults in a Do notation pipeline.",
    "deprecated": false,
    "examples": [
      "import { Effect, Either, pipe } from \"effect\"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind(\"x\", () => Effect.succeed(2)),\n  Effect.bindAll(({ x }) => ({\n    a: Effect.succeed(x),\n    b: Effect.fail(\"oops\"),\n  }), { concurrency: 2, mode: \"either\" })\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left(\"oops\") })"
    ],
    "since": "3.7.0",
    "category": "Do notation",
    "signature": "export declare const bindAll: { <A extends object, X extends Record<string, Effect<any, any, any>>, O extends { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }>(f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`, options?: undefined | O): <E1, R1>(self: Effect<A, E1, R1>) => [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>] ? Effect<{ [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never; }, E1 | Error, R1 | Context> : never; <A extends object, X extends Record<string, Effect<any, any, any>>, O extends { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, E1, R1>(self: Effect<A, E1, R1>, f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`, options?: undefined | { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>] ? Effect<{ [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never; }, E1 | Error, R1 | Context> : never; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "bindTo",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "import { Effect, pipe } from \"effect\"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind(\"x\", () => Effect.succeed(2)),\n  Effect.bind(\"y\", () => Effect.succeed(3)),\n  Effect.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })"
    ],
    "since": "2.0.0",
    "category": "Do notation",
    "signature": "export declare const bindTo: { <N extends string>(name: N): <A, E, R>(self: Effect<A, E, R>) => Effect<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Effect<A, E, R>, name: N): Effect<{ [K in N]: A; }, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "option",
    "description": "Encapsulates the result of an effect in an `Option`.\n\n**Details**\n\nThis function wraps the outcome of an effect in an `Option` type. If the\noriginal effect succeeds, the success value is wrapped in `Option.some`. If\nthe effect fails, the failure is converted to `Option.none`.\n\nThis is particularly useful for scenarios where you want to represent the\nabsence of a value explicitly, without causing the resulting effect to fail.\nThe resulting effect has an error type of `never`, meaning it cannot fail\ndirectly. However, unrecoverable errors, also referred to as defects, are\nnot captured and will still result in failure.",
    "deprecated": false,
    "examples": [
      "// Title: Using Effect.option to Handle Errors\nimport { Effect } from \"effect\"\n\nconst maybe1 = Effect.option(Effect.succeed(1))\n\n// Effect.runPromiseExit(maybe1).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: { _id: 'Option', _tag: 'Some', value: 1 }\n// }\n\nconst maybe2 = Effect.option(Effect.fail(\"Uh oh!\"))\n\n// Effect.runPromiseExit(maybe2).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: { _id: 'Option', _tag: 'None' }\n// }\n\nconst maybe3 = Effect.option(Effect.die(\"Boom!\"))\n\n// Effect.runPromiseExit(maybe3).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Boom!' }\n// }"
    ],
    "since": "2.0.0",
    "category": "Outcome Encapsulation",
    "signature": "export declare const option: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "either",
    "description": "Encapsulates both success and failure of an `Effect` into an `Either` type.\n\n**Details**\n\nThis function converts an effect that may fail into an effect that always\nsucceeds, wrapping the outcome in an `Either` type. The result will be\n`Either.Left` if the effect fails, containing the recoverable error, or\n`Either.Right` if it succeeds, containing the result.\n\nUsing this function, you can handle recoverable errors explicitly without\ncausing the effect to fail. This is particularly useful in scenarios where\nyou want to chain effects and manage both success and failure in the same\nlogical flow.\n\nIt's important to note that unrecoverable errors, often referred to as\n\"defects,\" are still thrown and not captured within the `Either` type. Only\nfailures that are explicitly represented as recoverable errors in the effect\nare encapsulated.\n\nThe resulting effect cannot fail directly because all recoverable failures\nare represented inside the `Either` type.",
    "deprecated": false,
    "examples": [
      "import { Effect, Either, Random } from \"effect\"\n\nclass HttpError {\n  readonly _tag = \"HttpError\"\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n//       Effect<string, HttpError | ValidationError, never>\n//      \nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return \"some result\"\n})\n\n//       Effect<string, never, never>\n//      \nconst recovered = Effect.gen(function* () {\n  //       Either<string, HttpError | ValidationError>\n  //      \n  const failureOrSuccess = yield* Effect.either(program)\n  return Either.match(failureOrSuccess, {\n    onLeft: (error) => `Recovering from ${error._tag}`,\n    onRight: (value) => value // Do nothing in case of success\n  })\n})"
    ],
    "since": "2.0.0",
    "category": "Outcome Encapsulation",
    "signature": "export declare const either: <A, E, R>(self: Effect<A, E, R>) => Effect<Either.Either<A, E>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "exit",
    "description": "Encapsulates both success and failure of an `Effect` using the `Exit` type.\n\n**Details**\n\nThis function converts an effect into one that always succeeds, wrapping its\noutcome in the `Exit` type. The `Exit` type provides explicit handling of\nboth success (`Exit.Success`) and failure (`Exit.Failure`) cases, including\ndefects (unrecoverable errors).\n\nUnlike {@link either} or {@link option}, this function also encapsulates\ndefects, which are typically unrecoverable and would otherwise terminate the\neffect. With the `Exit` type, defects are represented in `Exit.Failure`,\nallowing for detailed introspection and structured error handling.\n\nThis makes the resulting effect robust and incapable of direct failure (its\nerror type is `never`). It is particularly useful for workflows where all\noutcomes, including unexpected defects, must be managed and analyzed.",
    "deprecated": false,
    "examples": [
      "import { Effect, Cause, Console, Exit } from \"effect\"\n\n// Simulating a runtime error\nconst task = Effect.dieMessage(\"Boom!\")\n\nconst program = Effect.gen(function* () {\n  const exit = yield* Effect.exit(task)\n  if (Exit.isFailure(exit)) {\n    const cause = exit.cause\n    if (\n      Cause.isDieType(cause) &&\n      Cause.isRuntimeException(cause.defect)\n    ) {\n      yield* Console.log(\n        `RuntimeException defect caught: ${cause.defect.message}`\n      )\n    } else {\n      yield* Console.log(\"Unknown failure caught.\")\n    }\n  }\n})\n\n// We get an Exit.Success because we caught all failures\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// RuntimeException defect caught: Boom!\n// {\n//   _id: \"Exit\",\n//   _tag: \"Success\",\n//   value: undefined\n// }"
    ],
    "since": "2.0.0",
    "category": "Outcome Encapsulation",
    "signature": "export declare const exit: <A, E, R>(self: Effect<A, E, R>) => Effect<Exit.Exit<A, E>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "intoDeferred",
    "description": "Converts an `Effect` into an operation that completes a `Deferred` with its result.\n\n**Details**\n\nThe `intoDeferred` function takes an effect and a `Deferred` and ensures that the `Deferred`\nis completed based on the outcome of the effect. If the effect succeeds, the `Deferred` is\ncompleted with the success value. If the effect fails, the `Deferred` is completed with the\nfailure. Additionally, if the effect is interrupted, the `Deferred` will also be interrupted.",
    "deprecated": false,
    "examples": [
      "import { Deferred, Effect } from \"effect\"\n\n// Define an effect that succeeds\nconst successEffect = Effect.succeed(42)\n\nconst program = Effect.gen(function*() {\n  // Create a deferred\n  const deferred = yield* Deferred.make<number, string>()\n\n  // Complete the deferred using the successEffect\n  const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)\n\n  // Access the value of the deferred\n  const value = yield* Deferred.await(deferred)\n  console.log(value)\n\n  return isCompleted\n})\n\n// Effect.runPromise(program).then(console.log)\n// Output:\n// 42\n// true"
    ],
    "since": "2.0.0",
    "category": "Synchronization Utilities",
    "signature": "export declare const intoDeferred: { <A, E>(deferred: Deferred.Deferred<A, E>): <R>(self: Effect<A, E, R>) => Effect<boolean, never, R>; <A, E, R>(self: Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect<boolean, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "filterOrDie",
    "description": "Filters an effect, dying with a custom defect if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect dies with a custom defect\ngenerated by the `orDieWith` function.\n\n**When to Use**\n\nThis is useful for enforcing constraints on values and treating violations as\nfatal program errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "export declare const filterOrDie: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, orDieWith: (a: NoInfer<A>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, orDieWith: (a: NoInfer<A>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orDieWith: (a: A) => unknown): Effect<B, E, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, orDieWith: (a: A) => unknown): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "filterOrDieMessage",
    "description": "Filters an effect, dying with a custom message if the predicate fails.\n\n**Details**\n\nThis function works like {@link filterOrDie} but allows you to specify a\ncustom error message to describe the reason for the failure. The message is\nincluded in the defect when the predicate evaluates to `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "export declare const filterOrDieMessage: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, message: string): Effect<B, E, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, message: string): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "filterOrElse",
    "description": "Filters an effect, providing an alternative effect if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, it executes the `orElse` effect instead. The\n`orElse` effect can produce an alternative value or perform additional\ncomputations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "export declare const filterOrElse: { <A, B extends A, C, E2, R2>(refinement: Refinement<NoInfer<A>, B>, orElse: (a: NoInfer<A>) => Effect<C, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<B | C, E2 | E, R2 | R>; <A, B, E2, R2>(predicate: Predicate<NoInfer<A>>, orElse: (a: NoInfer<A>) => Effect<B, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A | B, E2 | E, R2 | R>; <A, E, R, B extends A, C, E2, R2>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orElse: (a: A) => Effect<C, E2, R2>): Effect<B | C, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Effect<A, E, R>, predicate: Predicate<A>, orElse: (a: A) => Effect<B, E2, R2>): Effect<A | B, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "filterOrFail",
    "description": "Filters an effect, failing with a custom error if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect fails with a custom error\ngenerated by the `orFailWith` function.\n\n**When to Use**\n\nThis is useful for enforcing constraints and treating violations as\nrecoverable errors.\n\n**Providing a Guard**\n\nIn addition to the filtering capabilities discussed earlier, you have the\noption to further refine and narrow down the type of the success channel by\nproviding a [user-defined type\nguard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).\nLet's explore this concept through an example:",
    "deprecated": false,
    "examples": [
      "import { Effect, pipe } from \"effect\"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterOrFail with a custom type guard to ensure user is not null\n  Effect.filterOrFail(\n    (user): user is User => user !== null, // Type guard\n    () => new Error(\"Unauthorized\")\n  ),\n  // 'user' now has the type `User` (not `User | null`)\n  Effect.andThen((user) => user.name)\n)"
    ],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "export declare const filterOrFail: { <A, B extends A, E2>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R>; <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Effect<A, E, R>) => Effect<B, Cause.NoSuchElementException | E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Effect<A, E, R>) => Effect<A, Cause.NoSuchElementException | E, R>; <A, E, R, B extends A, E2>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): Effect<B, E | E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Effect<A, E | E2, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>): Effect<B, E | Cause.NoSuchElementException, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>): Effect<A, E | Cause.NoSuchElementException, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "filterEffectOrElse",
    "description": "Filters an effect with an effectful predicate, falling back to an alternative\neffect if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect falls back to the `orElse`\neffect. The `orElse` effect can produce an alternative value or perform\nadditional computations.",
    "deprecated": false,
    "examples": [
      "import { Effect, pipe } from \"effect\"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterEffectOrElse with an effectful predicate\n  Effect.filterEffectOrElse({\n    predicate: (user) => Effect.succeed(user !== null),\n    orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))\n  }),\n)"
    ],
    "since": "3.13.0",
    "category": "Filtering",
    "signature": "export declare const filterEffectOrElse: { <A, E2, R2, A2, E3, R3>(options: { readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>; readonly orElse: (a: NoInfer<A>) => Effect<A2, E3, R3>; }): <E, R>(self: Effect<A, E, R>) => Effect<A | A2, E | E2 | E3, R | R2 | R3>; <A, E, R, E2, R2, A2, E3, R3>(self: Effect<A, E, R>, options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orElse: (a: A) => Effect<A2, E3, R3>; }): Effect<A | A2, E | E2 | E3, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "filterEffectOrFail",
    "description": "Filters an effect with an effectful predicate, failing with a custom error if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect fails with a custom error\ngenerated by the `orFailWith` function.\n\n**When to Use**\n\nThis is useful for enforcing constraints and treating violations as\nrecoverable errors.",
    "deprecated": false,
    "examples": [
      "import { Effect, pipe } from \"effect\"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterEffectOrFail with an effectful predicate\n  Effect.filterEffectOrFail({\n    predicate: (user) => Effect.succeed(user !== null),\n    orFailWith: () => new Error(\"Unauthorized\")\n  }),\n)"
    ],
    "since": "3.13.0",
    "category": "Filtering",
    "signature": "export declare const filterEffectOrFail: { <A, E2, R2, E3>(options: { readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>; readonly orFailWith: (a: NoInfer<A>) => E3; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R | R2>; <A, E, R, E2, R2, E3>(self: Effect<A, E, R>, options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orFailWith: (a: A) => E3; }): Effect<A, E | E2 | E3, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "unless",
    "description": "Executes an effect only if the condition is `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Conditional Operators",
    "signature": "export declare const unless: { (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option.Option<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "unlessEffect",
    "description": "Conditionally execute an effect based on the result of another effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Conditional Operators",
    "signature": "export declare const unlessEffect: { <E2, R2>(condition: Effect<boolean, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Effect<A, E, R>, condition: Effect<boolean, E2, R2>): Effect<Option.Option<A>, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "when",
    "description": "Conditionally executes an effect based on a boolean condition.\n\n**Details**\n\nThis function allows you to run an effect only if a given condition evaluates\nto `true`. If the condition is `true`, the effect is executed, and its result\nis wrapped in an `Option.some`. If the condition is `false`, the effect is\nskipped, and the result is `Option.none`.\n\n**When to Use**\n\nThis function is useful for scenarios where you need to dynamically decide\nwhether to execute an effect based on runtime logic, while also representing\nthe skipped case explicitly.",
    "deprecated": false,
    "examples": [
      "// Title: Conditional Effect Execution\nimport { Effect, Option } from \"effect\"\n\nconst validateWeightOption = (\n  weight: number\n): Effect.Effect<Option.Option<number>> =>\n  // Conditionally execute the effect if the weight is non-negative\n  Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))\n\n// Run with a valid weight\n// Effect.runPromise(validateWeightOption(100)).then(console.log)\n// Output:\n// {\n//   _id: \"Option\",\n//   _tag: \"Some\",\n//   value: 100\n// }\n\n// Run with an invalid weight\n// Effect.runPromise(validateWeightOption(-5)).then(console.log)\n// Output:\n// {\n//   _id: \"Option\",\n//   _tag: \"None\"\n// }"
    ],
    "since": "2.0.0",
    "category": "Conditional Operators",
    "signature": "export declare const when: { (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option.Option<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "whenEffect",
    "description": "Conditionally executes an effect based on the result of another effect.\n\n**Details**\n\nThis function allows you to run an effect only if a conditional effect\nevaluating to a boolean resolves to `true`. If the conditional effect\nevaluates to `true`, the specified effect is executed, and its result is\nwrapped in `Option.some`. If the conditional effect evaluates to `false`, the\neffect is skipped, and the result is `Option.none`.\n\n**When to Use**\n\nThis function is particularly useful when the decision to execute an effect\ndepends on the result of another effect, such as a random value, a\nuser-provided input, or a network request result.",
    "deprecated": false,
    "examples": [
      "// Title: Using an Effect as a Condition\nimport { Effect, Random } from \"effect\"\n\nconst randomIntOption = Random.nextInt.pipe(\n  Effect.whenEffect(Random.nextBoolean)\n)\n\nconsole.log(Effect.runSync(randomIntOption))\n// Example Output:\n// { _id: 'Option', _tag: 'Some', value: 8609104974198840 }"
    ],
    "since": "2.0.0",
    "category": "Conditional Operators",
    "signature": "export declare const whenEffect: { <E, R>(condition: Effect<boolean, E, R>): <A, E2, R2>(effect: Effect<A, E2, R2>) => Effect<Option.Option<A>, E | E2, R | R2>; <A, E2, R2, E, R>(self: Effect<A, E2, R2>, condition: Effect<boolean, E, R>): Effect<Option.Option<A>, E2 | E, R2 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "whenFiberRef",
    "description": "Executes an effect conditionally based on the value of a `FiberRef` that\nsatisfies a predicate.\n\n**Details**\n\nThis function enables you to execute an effect only when the value of a\nspecified `FiberRef` meets a certain condition defined by a predicate. If the\nvalue satisfies the predicate, the effect is executed, and the result is\nwrapped in an `Option.some`. If the predicate is not satisfied, the effect is\nskipped, and the result is `Option.none`. In both cases, the current value of\nthe `FiberRef` is included in the result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Conditional Operators",
    "signature": "export declare const whenFiberRef: { <S>(fiberRef: FiberRef.FiberRef<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option.Option<A>], E, R>; <A, E, R, S>(self: Effect<A, E, R>, fiberRef: FiberRef.FiberRef<S>, predicate: Predicate<S>): Effect<[S, Option.Option<A>], E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "whenRef",
    "description": "Executes an effect conditionally based on the value of a `Ref` that satisfies\na predicate.\n\n**Details**\n\nThis function allows you to execute an effect only when the value of a\nspecified `Ref` meets a condition defined by a predicate. If the value\nsatisfies the predicate, the effect is executed, and the result is wrapped in\nan `Option.some`. If the predicate is not satisfied, the effect is skipped,\nand the result is `Option.none`. In both cases, the current value of the\n`Ref` is included in the result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Conditional Operators",
    "signature": "export declare const whenRef: { <S>(ref: Ref.Ref<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option.Option<A>], E, R>; <A, E, R, S>(self: Effect<A, E, R>, ref: Ref.Ref<S>, predicate: Predicate<S>): Effect<[S, Option.Option<A>], E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Chains effects to produce new `Effect` instances, useful for combining\noperations that depend on previous results.\n\n**Syntax**\n```ts\nconst flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))\n// or\nconst flatMappedEffect = Effect.flatMap(myEffect, transformation)\n// or\nconst flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))\n```\n\n**Details**\n\n`flatMap` lets you sequence effects so that the result of one effect can be\nused in the next step. It is similar to `flatMap` used with arrays but works\nspecifically with `Effect` instances, allowing you to avoid deeply nested\neffect structures.\n\nSince effects are immutable, `flatMap` always returns a new effect instead of\nchanging the original one.\n\n**When to Use**\n\nUse `flatMap` when you need to chain multiple effects, ensuring that each\nstep produces a new `Effect` while flattening any nested effects that may\noccur.",
    "deprecated": false,
    "examples": [
      "import { pipe, Effect } from \"effect\"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\n// Chaining the fetch and discount application using `flatMap`\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\n// Effect.runPromise(finalAmount).then(console.log)\n// Output: 95"
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const flatMap: { <A, B, E1, R1>(f: (a: A) => Effect<B, E1, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect<A, E, R>, f: (a: A) => Effect<B, E1, R1>): Effect<B, E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "andThen",
    "description": "Chains two actions, where the second action can depend on the result of the\nfirst.\n\n**Syntax**\n```ts\nconst transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))\n// or\nconst transformedEffect = Effect.andThen(myEffect, anotherEffect)\n// or\nconst transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))\n```\n\n**When to Use**\n\nUse `andThen` when you need to run multiple actions in sequence, with the\nsecond action depending on the result of the first. This is useful for\ncombining effects or handling computations that must happen in order.\n\n**Details**\n\nThe second action can be:\n\n- A constant value (similar to {@link as})\n- A function returning a value (similar to {@link map})\n- A `Promise`\n- A function returning a `Promise`\n- An `Effect`\n- A function returning an `Effect` (similar to {@link flatMap})\n\n**Note:** `andThen` works well with both `Option` and `Either` types,\ntreating them as effects.",
    "deprecated": false,
    "examples": [
      "// Title: Applying a Discount Based on Fetched Amount\nimport { pipe, Effect } from \"effect\"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\n// Using Effect.map and Effect.flatMap\nconst result1 = pipe(\n  fetchTransactionAmount,\n  Effect.map((amount) => amount * 2),\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\n// Effect.runPromise(result1).then(console.log)\n// Output: 190\n\n// Using Effect.andThen\nconst result2 = pipe(\n  fetchTransactionAmount,\n  Effect.andThen((amount) => amount * 2),\n  Effect.andThen((amount) => applyDiscount(amount, 5))\n)\n\n// Effect.runPromise(result2).then(console.log)\n// Output: 190"
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const andThen: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "flatten",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const flatten: <A, E1, R1, E, R>(self: Effect<Effect<A, E1, R1>, E, R>) => Effect<A, E | E1, R | R1>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "race",
    "description": "Races two effects and returns the result of the first successful one.\n\n**Details**\n\nThis function takes two effects and runs them concurrently. The first effect\nthat successfully completes will determine the result of the race, and the\nother effect will be interrupted.\n\nIf neither effect succeeds, the function will fail with a `Cause`\ncontaining all the errors.\n\n**When to Use**\n\nThis is useful when you want to run two effects concurrently, but only care\nabout the first one to succeed. It is commonly used in cases like timeouts,\nretries, or when you want to optimize for the faster response without\nworrying about the other effect.\n\n**Handling Success or Failure with Either**\n\nIf you want to handle the result of whichever task completes first, whether\nit succeeds or fails, you can use the `Effect.either` function. This function\nwraps the result in an `Either` type, allowing you to see if the result\nwas a success (`Right`) or a failure (`Left`).",
    "deprecated": false,
    "examples": [
      "// Title: Both Tasks Succeed\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\n// Effect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted",
      "// Title: One Task Fails, One Succeeds\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\n// Effect.runFork(program)\n// Output:\n// task2 done",
      "// Title: Both Tasks Fail\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.fail(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Parallel',\n//     left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },\n//     right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }\n//   }\n// }",
      "// Title: Handling Success or Failure with Either\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\n// Run both tasks concurrently, wrapping the result\n// in Either to capture success or failure\nconst program = Effect.race(Effect.either(task1), Effect.either(task2))\n\n// Effect.runPromise(program).then(console.log)\n// Output:\n// task2 interrupted\n// { _id: 'Either', _tag: 'Left', left: 'task1' }"
    ],
    "since": "2.0.0",
    "category": "Racing",
    "signature": "export declare const race: { <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "raceAll",
    "description": "Races multiple effects and returns the first successful result.\n\n**Details**\n\nThis function runs multiple effects concurrently and returns the result of\nthe first one to succeed. If one effect succeeds, the others will be\ninterrupted.\n\nIf none of the effects succeed, the function will fail with the last error\nencountered.\n\n**When to Use**\n\nThis is useful when you want to race multiple effects, but only care about\nthe first one to succeed. It is commonly used in cases like timeouts,\nretries, or when you want to optimize for the faster response without\nworrying about the other effects.",
    "deprecated": false,
    "examples": [
      "// Title: All Tasks Succeed\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst task3 = Effect.succeed(\"task3\").pipe(\n  Effect.delay(\"150 millis\"),\n  Effect.tap(Console.log(\"task3 done\")),\n  Effect.onInterrupt(() => Console.log(\"task3 interrupted\"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\n// Effect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted\n// task3 interrupted",
      "// Title: One Task Fails, Two Tasks Succeed\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst task3 = Effect.succeed(\"task3\").pipe(\n  Effect.delay(\"150 millis\"),\n  Effect.tap(Console.log(\"task3 done\")),\n  Effect.onInterrupt(() => Console.log(\"task3 interrupted\"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\n// Effect.runFork(program)\n// Output:\n// task3 done\n// task2 interrupted",
      "// Title: All Tasks Fail\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.fail(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst task3 = Effect.fail(\"task3\").pipe(\n  Effect.delay(\"150 millis\"),\n  Effect.tap(Console.log(\"task3 done\")),\n  Effect.onInterrupt(() => Console.log(\"task3 interrupted\"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }\n// }"
    ],
    "since": "2.0.0",
    "category": "Racing",
    "signature": "export declare const raceAll: <Eff extends Effect<any, any, any>>(all: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "raceFirst",
    "description": "Races two effects and returns the result of the first one to complete.\n\n**Details**\n\nThis function takes two effects and runs them concurrently, returning the\nresult of the first one that completes, regardless of whether it succeeds or\nfails.\n\n**When to Use**\n\nThis function is useful when you want to race two operations, and you want to\nproceed with whichever one finishes first, regardless of whether it succeeds\nor fails.\n\n**Disconnecting Effects**\n\nThe `Effect.raceFirst` function safely interrupts the loser effect once the other completes, but it will not resume until the loser is cleanly terminated.\n\nIf you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling:\n\n```ts\nEffect.raceFirst(task1, task2)\n```\n\nYou can use:\n\n```ts\nEffect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))\n```\n\nThis allows both effects to complete independently while still terminating the losing effect in the background.",
    "deprecated": false,
    "examples": [
      "// Title: Both Tasks Succeed\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\n\nconst program = Effect.raceFirst(task1, task2).pipe(\n  Effect.tap(Console.log(\"more work...\"))\n)\n\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// task1 done\n// task2 interrupted\n// more work...\n// { _id: 'Exit', _tag: 'Success', value: 'task1' }",
      "// Title: One Task Fails, One Succeeds\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\n\nconst program = Effect.raceFirst(task1, task2).pipe(\n  Effect.tap(Console.log(\"more work...\"))\n)\n\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// task2 interrupted\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }\n// }",
      "// Title: Using Effect.disconnect for Quicker Return\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\n\n// Race the two tasks with disconnect to allow quicker return\nconst program = Effect.raceFirst(\n  Effect.disconnect(task1),\n  Effect.disconnect(task2)\n).pipe(Effect.tap(Console.log(\"more work...\")))\n\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// task1 done\n// more work...\n// { _id: 'Exit', _tag: 'Success', value: 'task1' }\n// task2 interrupted"
    ],
    "since": "2.0.0",
    "category": "Racing",
    "signature": "export declare const raceFirst: { <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "raceWith",
    "description": "Races two effects and calls a finisher when the first one completes.\n\n**Details**\n\nThis function runs two effects concurrently and calls a specified finisher\nfunction once one of the effects completes, regardless of whether it succeeds\nor fails.\n\nThe finisher functions for each effect allow you to handle the results of\neach effect as soon as they complete.\n\nThe function takes two finisher callbacks, one for each effect, and allows\nyou to specify how to handle the result of the race.\n\n**When to Use**\n\nThis function is useful when you need to react to the completion of either\neffect without waiting for both to finish. It can be used whenever you want\nto take action based on the first available result.",
    "deprecated": false,
    "examples": [
      "// Title: Handling Results of Concurrent Tasks\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Console.log(\"task1 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Console.log(\"task2 done\")),\n  Effect.onInterrupt(() =>\n    Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n  )\n)\n\nconst program = Effect.raceWith(task1, task2, {\n  onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),\n  onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)\n})\n\n// Effect.runFork(program)\n// Output:\n// task1 done\n// task1 exited with {\n//   \"_id\": \"Exit\",\n//   \"_tag\": \"Success\",\n//   \"value\": \"task1\"\n// }\n// task2 interrupted"
    ],
    "since": "2.0.0",
    "category": "Racing",
    "signature": "export declare const raceWith: { <A1, E1, R1, E, A, A2, E2, R2, A3, E3, R3>(other: Effect<A1, E1, R1>, options: { readonly onSelfDone: (exit: Exit.Exit<A, E>, fiber: Fiber.Fiber<A1, E1>) => Effect<A2, E2, R2>; readonly onOtherDone: (exit: Exit.Exit<A1, E1>, fiber: Fiber.Fiber<A, E>) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R1 | R2 | R3 | R>; <A, E, R, A1, E1, R1, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, other: Effect<A1, E1, R1>, options: { readonly onSelfDone: (exit: Exit.Exit<A, E>, fiber: Fiber.Fiber<A1, E1>) => Effect<A2, E2, R2>; readonly onOtherDone: (exit: Exit.Exit<A1, E1>, fiber: Fiber.Fiber<A, E>) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R | R1 | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "summarized",
    "description": "Summarizes a effect by computing some value before and after execution, and\nthen combining the values to produce a summary, together with the result of\nexecution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const summarized: { <B, E2, R2, C>(summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): <A, E, R>(self: Effect<A, E, R>) => Effect<[C, A], E2 | E, R2 | R>; <A, E, R, B, E2, R2, C>(self: Effect<A, E, R>, summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): Effect<[C, A], E2 | E, R2 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "tap",
    "description": "Runs a side effect with the result of an effect without changing the original\nvalue.\n\n**Details**\n\nThis function works similarly to `flatMap`, but it ignores the result of the\nfunction passed to it. The value from the previous effect remains available\nfor the next part of the chain. Note that if the side effect fails, the\nentire chain will fail too.\n\n**When to Use**\n\nUse this function when you want to perform a side effect, like logging or\ntracking, without modifying the main value. This is useful when you need to\nobserve or record an action but want the original value to be passed to the\nnext step.",
    "deprecated": false,
    "examples": [
      "// Title: Logging a step in a pipeline\nimport { Console, Effect, pipe } from \"effect\"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  // Log the fetched transaction amount\n  Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n  // `amount` is still available!\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\n// Effect.runPromise(finalAmount).then(console.log)\n// Output:\n// Apply a discount to: 100\n// 95"
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const tap: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, X, E1, R1>(f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R | R1>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <X, E1, R1>(f: Effect<X, E1, R1>, options: { onlyEffect: true; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R | R1>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "tapBoth",
    "description": "Allows you to inspect both success and failure outcomes of an effect and\nperform side effects for each.\n\n**Details**\n\nThis function enables you to handle both success and failure cases\nseparately, without modifying the main effect's result. It is particularly\nuseful for scenarios where you need to log, monitor, or perform additional\nactions depending on whether the effect succeeded or failed.\n\nWhen the effect succeeds, the `onSuccess` handler is executed with the\nsuccess value. When the effect fails, the `onFailure` handler is executed\nwith the failure value. Both handlers can include side effects such as\nlogging or analytics, and neither modifies the original effect's output.\n\nIf either the success or failure handler fails, the overall effect will also\nfail.",
    "deprecated": false,
    "examples": [
      "import { Effect, Random, Console } from \"effect\"\n\n// Simulate a task that might fail\nconst task = Effect.filterOrFail(\n  Random.nextRange(-1, 1),\n  (n) => n >= 0,\n  () => \"random number is negative\"\n)\n\n// Use tapBoth to log both success and failure outcomes\nconst tapping = Effect.tapBoth(task, {\n  onFailure: (error) => Console.log(`failure: ${error}`),\n  onSuccess: (randomNumber) =>\n    Console.log(`random number: ${randomNumber}`)\n})\n\n// Effect.runFork(tapping)\n// Example Output:\n// failure: random number is negative"
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const tapBoth: { <E, X, E2, R2, A, X1, E3, R3>(options: { readonly onFailure: (e: NoInfer<E>) => Effect<X, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect<X1, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, X, E2, R2, X1, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<X, E2, R2>; readonly onSuccess: (a: A) => Effect<X1, E3, R3>; }): Effect<A, E | E2 | E3, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "tapDefect",
    "description": "Inspect severe errors or defects (non-recoverable failures) in an effect.\n\n**Details**\n\nThis function is specifically designed to handle and inspect defects, which\nare critical failures in your program, such as unexpected runtime exceptions\nor system-level errors. Unlike normal recoverable errors, defects typically\nindicate serious issues that cannot be addressed through standard error\nhandling.\n\nWhen a defect occurs in an effect, the function you provide to this function\nwill be executed, allowing you to log, monitor, or handle the defect in some\nway. Importantly, this does not alter the main result of the effect. If no\ndefect occurs, the effect behaves as if this function was not used.",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\n// Simulate a task that fails with a recoverable error\nconst task1: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n\n// tapDefect won't log anything because NetworkError is not a defect\nconst tapping1 = Effect.tapDefect(task1, (cause) =>\n  Console.log(`defect: ${cause}`)\n)\n\n// Effect.runFork(tapping1)\n// No Output\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n  \"Something went wrong\"\n)\n\n// Log the defect using tapDefect\nconst tapping2 = Effect.tapDefect(task2, (cause) =>\n  Console.log(`defect: ${cause}`)\n)\n\n// Effect.runFork(tapping2)\n// Output:\n// defect: RuntimeException: Something went wrong\n//   ... stack trace ..."
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const tapDefect: { <X, E2, R2>(f: (cause: Cause.Cause<never>) => Effect<X, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<never>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "tapError",
    "description": "Execute a side effect on failure without modifying the original effect.\n\n**Details**\n\nThis function allows you to inspect and react to the failure of an effect by\nexecuting an additional effect. The failure value is passed to the provided\nfunction, enabling you to log it, track it, or perform any other operation.\nImportantly, the original failure remains intact and is re-propagated, so the\neffect's behavior is unchanged.\n\nThe side effect you provide is only executed when the effect fails. If the\neffect succeeds, the function is ignored, and the success value is propagated\nas usual.",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\n// Simulate a task that fails with an error\nconst task: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n\n// Use tapError to log the error message when the task fails\nconst tapping = Effect.tapError(task, (error) =>\n  Console.log(`expected error: ${error}`)\n)\n\n// Effect.runFork(tapping)\n// Output:\n// expected error: NetworkError"
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const tapError: { <E, X, E2, R2>(f: (e: NoInfer<E>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "tapErrorTag",
    "description": "Inspect errors matching a specific tag without altering the original effect.\n\n**Details**\n\nThis function allows you to inspect and handle specific error types based on\ntheir `_tag` property. It is particularly useful in applications where errors\nare modeled with tagged types (e.g., union types with discriminating tags).\nBy targeting errors with a specific `_tag`, you can log or perform actions on\nthem while leaving the error channel and overall effect unchanged.\n\nIf the error doesn't match the specified tag, this function does nothing, and\nthe effect proceeds as usual.",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\nclass NetworkError {\n  readonly _tag = \"NetworkError\"\n  constructor(readonly statusCode: number) {}\n}\n\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n  constructor(readonly field: string) {}\n}\n\n// Create a task that fails with a NetworkError\nconst task: Effect.Effect<number, NetworkError | ValidationError> =\n  Effect.fail(new NetworkError(504))\n\n// Use tapErrorTag to inspect only NetworkError types and log the status code\nconst tapping = Effect.tapErrorTag(task, \"NetworkError\", (error) =>\n  Console.log(`expected error: ${error.statusCode}`)\n)\n\n// Effect.runFork(tapping)\n// Output:\n// expected error: 504"
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const tapErrorTag: { <K extends E extends { _tag: string; } ? E[\"_tag\"] : never, E, A1, E1, R1>(k: K, f: (e: NoInfer<Extract<E, { _tag: K; }>>) => Effect<A1, E1, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E[\"_tag\"] : never, A1, E1, R1>(self: Effect<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Effect<A1, E1, R1>): Effect<A, E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "tapErrorCause",
    "description": "Inspect the complete cause of an error, including failures and defects.\n\n**Details**\n\nThis function provides access to the full cause of an error, including both\nrecoverable failures and irrecoverable defects. It allows you to handle, log,\nor monitor specific error causes without modifying the result of the effect.\nThe full `Cause` object encapsulates the error and its contextual\ninformation, making it useful for debugging and understanding failure\nscenarios in complex workflows.\n\nThe effect itself is not modified, and any errors or defects remain in the\nerror channel of the original effect.",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\n// Create a task that fails with a NetworkError\nconst task1: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n\nconst tapping1 = Effect.tapErrorCause(task1, (cause) =>\n  Console.log(`error cause: ${cause}`)\n)\n\n// Effect.runFork(tapping1)\n// Output:\n// error cause: Error: NetworkError\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n  \"Something went wrong\"\n)\n\nconst tapping2 = Effect.tapErrorCause(task2, (cause) =>\n  Console.log(`error cause: ${cause}`)\n)\n\n// Effect.runFork(tapping2)\n// Output:\n// error cause: RuntimeException: Something went wrong\n//   ... stack trace ..."
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const tapErrorCause: { <E, X, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "forever",
    "description": "Repeats an effect indefinitely until an error occurs.\n\n**Details**\n\nThis function executes an effect repeatedly in an infinite loop. Each\niteration is executed sequentially, and the loop continues until the first\nerror occurs. If the effect succeeds, it starts over from the beginning. If\nthe effect fails, the error is propagated, and the loop stops.\n\nBe cautious when using this function, as it will run indefinitely unless an\nerror interrupts it. This makes it suitable for long-running processes or\ncontinuous polling tasks, but you should ensure proper error handling or\ncombine it with other operators like `timeout` or `schedule` to prevent\nunintentional infinite loops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "export declare const forever: <A, E, R>(self: Effect<A, E, R>) => Effect<never, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "iterate",
    "description": "Repeatedly updates a state through an effectful operation until a condition\nis no longer met.\n\n**Details**\n\nThis function provides a way to implement effectful loops, similar to a\n`while` loop in JavaScript.\n\n```ts\nlet result = initial\n\nwhile (options.while(result)) {\n  result = options.body(result)\n}\n\nreturn result\n```\n\nIt starts with an initial state, checks a\ncondition (`while`), and executes a body operation to update the state if the\ncondition evaluates to `true`. The process repeats until the condition\nreturns `false`.\n\nThe state is passed between iterations, allowing the body operation to modify\nit dynamically. The final state after the loop ends is returned as the result\nof the effect.\n\n**When to Use**\n\nThis is particularly useful for scenarios where looping logic involves\nasynchronous or side-effectful operations, such as polling or iterative\ncomputations that depend on external factors.",
    "deprecated": false,
    "examples": [
      "// Title: Effectful Iteration\nimport { Effect } from \"effect\"\n\nconst result = Effect.iterate(\n  // Initial result\n  1,\n  {\n    // Condition to continue iterating\n    while: (result) => result <= 5,\n    // Operation to change the result\n    body: (result) => Effect.succeed(result + 1)\n  }\n)\n\n// Effect.runPromise(result).then(console.log)\n// Output: 6"
    ],
    "since": "2.0.0",
    "category": "Looping",
    "signature": "export declare const iterate: { <A, B extends A, R, E>(initial: A, options: { readonly while: Refinement<A, B>; readonly body: (b: B) => Effect<A, E, R>; }): Effect<A, E, R>; <A, R, E>(initial: A, options: { readonly while: Predicate<A>; readonly body: (a: A) => Effect<A, E, R>; }): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "loop",
    "description": "Repeatedly executes a loop with a state, collecting results or discarding\nthem based on configuration.\n\n**Details**\n\nThis function performs an effectful loop, starting with an initial state and\niterating as long as the `while` condition evaluates to `true`, similar to a\n`while` loop in JavaScript.\n\n```ts\nlet state = initial\nconst result = []\n\nwhile (options.while(state)) {\n  result.push(options.body(state)) // Perform the effectful operation\n  state = options.step(state) // Update the state\n}\n\nreturn result\n```\n\nDuring each iteration, the `step` function updates the state, and the `body`\neffect is executed.\n\nThe results of the body effect can be collected in an array or discarded\nbased on the `discard` option.\n\n**Discarding Intermediate Results**\n\n- If `discard` is `false` or not provided, the intermediate results are\n  collected into an array and returned as the final result.\n- If `discard` is `true`, the intermediate results are ignored, and the\n  effect returns `void`.\n\n**When to Use**\n\nThis is useful for implementing loops where you need to perform effectful\ncomputations repeatedly, such as processing items in a list, generating\nvalues, or performing iterative updates.",
    "deprecated": false,
    "examples": [
      "// Title: Looping with Collected Results\nimport { Effect } from \"effect\"\n\n// A loop that runs 5 times, collecting each iteration's result\nconst result = Effect.loop(\n  // Initial state\n  1,\n  {\n    // Condition to continue looping\n    while: (state) => state <= 5,\n    // State update function\n    step: (state) => state + 1,\n    // Effect to be performed on each iteration\n    body: (state) => Effect.succeed(state)\n  }\n)\n\n// Effect.runPromise(result).then(console.log)\n// Output: [1, 2, 3, 4, 5]",
      "// Title: Loop with Discarded Results\nimport { Effect, Console } from \"effect\"\n\nconst result = Effect.loop(\n  // Initial state\n  1,\n  {\n    // Condition to continue looping\n    while: (state) => state <= 5,\n    // State update function\n    step: (state) => state + 1,\n    // Effect to be performed on each iteration\n    body: (state) => Console.log(`Currently at state ${state}`),\n    // Discard intermediate results\n    discard: true\n  }\n)\n\n// Effect.runPromise(result).then(console.log)\n// Output:\n// Currently at state 1\n// Currently at state 2\n// Currently at state 3\n// Currently at state 4\n// Currently at state 5\n// undefined"
    ],
    "since": "2.0.0",
    "category": "Looping",
    "signature": "export declare const loop: { <A, B extends A, C, E, R>(initial: A, options: { readonly while: Refinement<A, B>; readonly step: (b: B) => A; readonly body: (b: B) => Effect<C, E, R>; readonly discard?: false | undefined; }): Effect<Array<C>, E, R>; <A, C, E, R>(initial: A, options: { readonly while: (a: A) => boolean; readonly step: (a: A) => A; readonly body: (a: A) => Effect<C, E, R>; readonly discard?: false | undefined; }): Effect<Array<C>, E, R>; <A, B extends A, C, E, R>(initial: A, options: { readonly while: Refinement<A, B>; readonly step: (b: B) => A; readonly body: (b: B) => Effect<C, E, R>; readonly discard: true; }): Effect<void, E, R>; <A, C, E, R>(initial: A, options: { readonly while: (a: A) => boolean; readonly step: (a: A) => A; readonly body: (a: A) => Effect<C, E, R>; readonly discard: true; }): Effect<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "repeat",
    "description": "Repeats an effect based on a specified schedule or until the first failure.\n\n**Details**\n\nThis function executes an effect repeatedly according to the given schedule.\nEach repetition occurs after the initial execution of the effect, meaning\nthat the schedule determines the number of additional repetitions. For\nexample, using `Schedule.once` will result in the effect being executed twice\n(once initially and once as part of the repetition).\n\nIf the effect succeeds, it is repeated according to the schedule. If it\nfails, the repetition stops immediately, and the failure is returned.\n\nThe schedule can also specify delays between repetitions, making it useful\nfor tasks like retrying operations with backoff, periodic execution, or\nperforming a series of dependent actions.\n\nYou can combine schedules for more advanced repetition logic, such as adding\ndelays, limiting recursions, or dynamically adjusting based on the outcome of\neach execution.",
    "deprecated": false,
    "examples": [
      "// Success Example\nimport { Effect, Schedule, Console } from \"effect\"\n\nconst action = Console.log(\"success\")\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\nconst program = Effect.repeat(action, policy)\n\n// Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))",
      "// Failure Example\nimport { Effect, Schedule } from \"effect\"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\n  if (count > 1) {\n    console.log(\"failure\")\n    resume(Effect.fail(\"Uh oh!\"))\n  } else {\n    count++\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\nconst program = Effect.repeat(action, policy)\n\n// Effect.runPromiseExit(program).then(console.log)"
    ],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "export declare const repeat: { <O extends Repeat.Options<A>, A>(options: O): <E, R>(self: Effect<A, E, R>) => Repeat.Return<R, E, A, O>; <B, A, R1>(schedule: Schedule.Schedule<B, A, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R1 | R>; <A, E, R, O extends Repeat.Options<A>>(self: Effect<A, E, R>, options: O): Repeat.Return<R, E, A, O>; <A, E, R, B, R1>(self: Effect<A, E, R>, schedule: Schedule.Schedule<B, A, R1>): Effect<B, E, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "repeatN",
    "description": "Repeats an effect a specified number of times or until the first failure.\n\n**Details**\n\nThis function executes an effect initially and then repeats it the specified\nnumber of times, as long as it succeeds. For example, calling\n`repeatN(action, 2)` will execute `action` once initially and then repeat it\ntwo additional times if there are no failures.\n\nIf the effect fails during any repetition, the failure is returned, and no\nfurther repetitions are attempted.\n\n**When to Use**\n\nThis function is useful for tasks that need to be retried a fixed number of\ntimes or for performing repeated actions without requiring a schedule.",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\nconst action = Console.log(\"success\")\nconst program = Effect.repeatN(action, 2)\n\n// Effect.runPromise(program)"
    ],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "export declare const repeatN: { (n: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "repeatOrElse",
    "description": "Repeats an effect with a schedule, handling failures using a custom handler.\n\n**Details**\n\nThis function allows you to execute an effect repeatedly based on a specified\nschedule. If the effect fails at any point, a custom failure handler is\ninvoked. The handler is provided with both the failure value and the output\nof the schedule at the time of failure. This enables advanced error recovery\nor alternative fallback logic while maintaining flexibility in how\nrepetitions are handled.\n\nFor example, using a schedule with `recurs(2)` will allow for two additional\nrepetitions after the initial execution, provided the effect succeeds. If a\nfailure occurs during any iteration, the failure handler is invoked to handle\nthe situation.",
    "deprecated": false,
    "examples": [
      "import { Effect, Schedule } from \"effect\"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\n  if (count > 1) {\n    console.log(\"failure\")\n    resume(Effect.fail(\"Uh oh!\"))\n  } else {\n    count++\n    console.log(\"success\")\n    resume(Effect.succeed(\"yay!\"))\n  }\n})\n\nconst policy = Schedule.addDelay(\n  Schedule.recurs(2), // Repeat for a maximum of 2 times\n  () => \"100 millis\" // Add a delay of 100 milliseconds between repetitions\n)\n\nconst program = Effect.repeatOrElse(action, policy, () =>\n  Effect.sync(() => {\n    console.log(\"orElse\")\n    return count - 1\n  })\n)\n\n// Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))"
    ],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "export declare const repeatOrElse: { <R2, A, B, E, E2, R3>(schedule: Schedule.Schedule<B, A, R2>, orElse: (error: E, option: Option.Option<B>) => Effect<B, E2, R3>): <R>(self: Effect<A, E, R>) => Effect<B, E2, R2 | R3 | R>; <A, E, R, R2, B, E2, R3>(self: Effect<A, E, R>, schedule: Schedule.Schedule<B, A, R2>, orElse: (error: E, option: Option.Option<B>) => Effect<B, E2, R3>): Effect<B, E2, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "schedule",
    "description": "Repeats an effect based on a specified schedule.\n\n**Details**\n\nThis function allows you to execute an effect repeatedly according to a given\nschedule. The schedule determines the timing and number of repetitions. Each\nrepetition can also depend on the decision of the schedule, providing\nflexibility for complex workflows. This function does not modify the effect's\nsuccess or failure; it only controls its repetition.\n\nFor example, you can use a schedule that recurs a specific number of times,\nadds delays between repetitions, or customizes repetition behavior based on\nexternal inputs. The effect runs initially and is repeated according to the\nschedule.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "export declare const schedule: { <A, R2, Out>(schedule: Schedule.Schedule<Out, NoInfer<A> | undefined, R2>): <E, R>(self: Effect<A, E, R>) => Effect<Out, E, R2 | R>; <A, E, R, R2, Out>(self: Effect<A, E, R>, schedule: Schedule.Schedule<Out, A | undefined, R2>): Effect<Out, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "scheduleForked",
    "description": "Runs an effect repeatedly on a new fiber according to a given schedule.\n\n**Details**\n\nThis function starts the provided effect on a new fiber and runs it\nrepeatedly based on the specified schedule. The repetitions are managed by\nthe schedule's rules, which define the timing and number of iterations. The\nfiber is attached to the current scope, meaning it is automatically managed\nand cleaned up when the scope is closed.\n\nThe function returns a `RuntimeFiber` that allows you to monitor or interact\nwith the running fiber.\n\n**When to Use**\n\nThis is particularly useful for concurrent execution of scheduled tasks or\nwhen you want to continue processing without waiting for the repetitions to\ncomplete.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "export declare const scheduleForked: { <Out, R2>(schedule: Schedule.Schedule<Out, unknown, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<Out, E>, never, Scope.Scope | R2 | R>; <A, E, R, Out, R2>(self: Effect<A, E, R>, schedule: Schedule.Schedule<Out, unknown, R2>): Effect<Fiber.RuntimeFiber<Out, E>, never, Scope.Scope | R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "scheduleFrom",
    "description": "Runs an effect repeatedly according to a schedule, starting from a specified\ninput value.\n\n**Details**\n\nThis function allows you to repeatedly execute an effect based on a schedule.\nThe schedule starts with the given `initial` input value, which is passed to\nthe first execution. Subsequent executions of the effect are controlled by\nthe schedule's rules, using the output of the previous iteration as the input\nfor the next one.\n\nThe returned effect will complete when the schedule ends or the effect fails,\npropagating the error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "export declare const scheduleFrom: { <R2, In, Out>(initial: In, schedule: Schedule.Schedule<Out, In, R2>): <E, R>(self: Effect<In, E, R>) => Effect<Out, E, R2 | R>; <In, E, R, R2, Out>(self: Effect<In, E, R>, initial: In, schedule: Schedule.Schedule<Out, In, R2>): Effect<Out, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "whileLoop",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Repetition / Recursion",
    "signature": "export declare const whileLoop: <A, E, R>(options: { readonly while: LazyArg<boolean>; readonly body: LazyArg<Effect<A, E, R>>; readonly step: (a: A) => void; }) => Effect<void, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "getFiberRefs",
    "description": "Returns a collection of all `FiberRef` values for the fiber running this\neffect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "export declare const getFiberRefs: Effect<FiberRefs.FiberRefs, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "inheritFiberRefs",
    "description": "Inherits values from all `FiberRef` instances into current fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "export declare const inheritFiberRefs: (childFiberRefs: FiberRefs.FiberRefs) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "locally",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "export declare const locally: { <A>(self: FiberRef.FiberRef<A>, value: A): <B, E, R>(use: Effect<B, E, R>) => Effect<B, E, R>; <B, E, R, A>(use: Effect<B, E, R>, self: FiberRef.FiberRef<A>, value: A): Effect<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "locallyWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "export declare const locallyWith: { <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A): <B, E, R>(use: Effect<B, E, R>) => Effect<B, E, R>; <B, E, R, A>(use: Effect<B, E, R>, self: FiberRef.FiberRef<A>, f: (a: A) => A): Effect<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "locallyScoped",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "export declare const locallyScoped: { <A>(value: A): (self: FiberRef.FiberRef<A>) => Effect<void, never, Scope.Scope>; <A>(self: FiberRef.FiberRef<A>, value: A): Effect<void, never, Scope.Scope>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "locallyScopedWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "export declare const locallyScopedWith: { <A>(f: (a: A) => A): (self: FiberRef.FiberRef<A>) => Effect<void, never, Scope.Scope>; <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A): Effect<void, never, Scope.Scope>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "patchFiberRefs",
    "description": "Applies the specified changes to the `FiberRef` values for the fiber\nrunning this workflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "export declare const patchFiberRefs: (patch: FiberRefsPatch.FiberRefsPatch) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "setFiberRefs",
    "description": "Sets the `FiberRef` values for the fiber running this effect to the values\nin the specified collection of `FiberRef` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "export declare const setFiberRefs: (fiberRefs: FiberRefs.FiberRefs) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "updateFiberRefs",
    "description": "Updates the `FiberRef` values for the fiber running this effect using the\nspecified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Fiber Refs",
    "signature": "export declare const updateFiberRefs: (f: (fiberId: FiberId.Runtime, fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "isFailure",
    "description": "Checks if an effect has failed.\n\n**Details**\n\nThis function evaluates whether an effect has resulted in a failure. It\nreturns a boolean value wrapped in an effect, with `true` indicating the\neffect failed and `false` otherwise.\n\nThe resulting effect cannot fail (`never` in the error channel) but retains\nthe context of the original effect.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst failure = Effect.fail(\"Uh oh!\")\n\n// console.log(Effect.runSync(Effect.isFailure(failure)))\n// Output: true\n\nconst defect = Effect.dieMessage(\"BOOM!\")\n\n// Effect.runSync(Effect.isFailure(defect))\n// throws: BOOM!"
    ],
    "since": "2.0.0",
    "category": "Condition Checking",
    "signature": "export declare const isFailure: <A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "isSuccess",
    "description": "Checks if an effect has succeeded.\n\n**Details**\n\nThis function evaluates whether an effect has resulted in a success. It\nreturns a boolean value wrapped in an effect, with `true` indicating the\neffect succeeded and `false` otherwise.\n\nThe resulting effect cannot fail (`never` in the error channel) but retains\nthe context of the original effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Condition Checking",
    "signature": "export declare const isSuccess: <A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Handles both success and failure cases of an effect without performing side\neffects.\n\n**Details**\n\n`match` lets you define custom handlers for both success and failure\nscenarios. You provide separate functions to handle each case, allowing you\nto process the result if the effect succeeds, or handle the error if the\neffect fails.\n\n**When to Use**\n\nThis is useful for structuring your code to respond differently to success or\nfailure without triggering side effects.",
    "deprecated": false,
    "examples": [
      "// Title: Handling Both Success and Failure Cases\nimport { Effect } from \"effect\"\n\nconst success: Effect.Effect<number, Error> = Effect.succeed(42)\n\nconst program1 = Effect.match(success, {\n  onFailure: (error) => `failure: ${error.message}`,\n  onSuccess: (value) => `success: ${value}`\n})\n\n// Run and log the result of the successful effect\n// Effect.runPromise(program1).then(console.log)\n// Output: \"success: 42\"\n\nconst failure: Effect.Effect<number, Error> = Effect.fail(\n  new Error(\"Uh oh!\")\n)\n\nconst program2 = Effect.match(failure, {\n  onFailure: (error) => `failure: ${error.message}`,\n  onSuccess: (value) => `success: ${value}`\n})\n\n// Run and log the result of the failed effect\n// Effect.runPromise(program2).then(console.log)\n// Output: \"failure: Uh oh!\""
    ],
    "since": "2.0.0",
    "category": "Matching",
    "signature": "export declare const match: { <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): Effect<A2 | A3, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "matchCause",
    "description": "Handles failures by matching the cause of failure.\n\n**Details**\n\nThe `matchCause` function allows you to handle failures with access to the\nfull cause of the failure within a fiber.\n\n**When to Use**\n\nThis is useful for differentiating between different types of errors, such as\nregular failures, defects, or interruptions. You can provide specific\nhandling logic for each failure type based on the cause.",
    "deprecated": false,
    "examples": [
      "// Title: Handling Different Failure Causes\nimport { Effect } from \"effect\"\n\nconst task: Effect.Effect<number, Error> = Effect.die(\"Uh oh!\")\n\nconst program = Effect.matchCause(task, {\n  onFailure: (cause) => {\n    switch (cause._tag) {\n      case \"Fail\":\n        // Handle standard failure\n        return `Fail: ${cause.error.message}`\n      case \"Die\":\n        // Handle defects (unexpected errors)\n        return `Die: ${cause.defect}`\n      case \"Interrupt\":\n        // Handle interruption\n        return `${cause.fiberId} interrupted!`\n    }\n    // Fallback for other causes\n    return \"failed due to other causes\"\n  },\n  onSuccess: (value) =>\n    // task completes successfully\n    `succeeded with ${value} value`\n})\n\n// Effect.runPromise(program).then(console.log)\n// Output: \"Die: Uh oh!\"\n"
    ],
    "since": "2.0.0",
    "category": "Matching",
    "signature": "export declare const matchCause: { <E, A2, A, A3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): Effect<A2 | A3, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "matchCauseEffect",
    "description": "Handles failures with access to the cause and allows performing side effects.\n\n**Details**\n\nThe `matchCauseEffect` function works similarly to {@link matchCause}, but it\nalso allows you to perform additional side effects based on the failure\ncause. This function provides access to the complete cause of the failure,\nmaking it possible to differentiate between various failure types, and allows\nyou to respond accordingly while performing side effects (like logging or\nother operations).",
    "deprecated": false,
    "examples": [
      "// Title: Handling Different Failure Causes with Side Effects\nimport { Effect, Console } from \"effect\"\n\nconst task: Effect.Effect<number, Error> = Effect.die(\"Uh oh!\")\n\nconst program = Effect.matchCauseEffect(task, {\n  onFailure: (cause) => {\n    switch (cause._tag) {\n      case \"Fail\":\n        // Handle standard failure with a logged message\n        return Console.log(`Fail: ${cause.error.message}`)\n      case \"Die\":\n        // Handle defects (unexpected errors) by logging the defect\n        return Console.log(`Die: ${cause.defect}`)\n      case \"Interrupt\":\n        // Handle interruption and log the fiberId that was interrupted\n        return Console.log(`${cause.fiberId} interrupted!`)\n    }\n    // Fallback for other causes\n    return Console.log(\"failed due to other causes\")\n  },\n  onSuccess: (value) =>\n    // Log success if the task completes successfully\n    Console.log(`succeeded with ${value} value`)\n})\n\n// Effect.runPromise(program)\n// Output: \"Die: Uh oh!\""
    ],
    "since": "2.0.0",
    "category": "Matching",
    "signature": "export declare const matchCauseEffect: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R2 | R3 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "matchEffect",
    "description": "Handles both success and failure cases of an effect, allowing for additional\nside effects.\n\n**Details**\n\nThe `matchEffect` function is similar to {@link match}, but it enables you to\nperform side effects in the handlers for both success and failure outcomes.\n\n**When to Use**\n\nThis is useful when you need to execute additional actions, like logging or\nnotifying users, based on whether an effect succeeds or fails.",
    "deprecated": false,
    "examples": [
      "// Title: Handling Both Success and Failure Cases with Side Effects\nimport { Effect } from \"effect\"\n\nconst success: Effect.Effect<number, Error> = Effect.succeed(42)\nconst failure: Effect.Effect<number, Error> = Effect.fail(\n  new Error(\"Uh oh!\")\n)\n\nconst program1 = Effect.matchEffect(success, {\n  onFailure: (error) =>\n    Effect.succeed(`failure: ${error.message}`).pipe(\n      Effect.tap(Effect.log)\n    ),\n  onSuccess: (value) =>\n    Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n})\n\nconsole.log(Effect.runSync(program1))\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"success: 42\"\n// success: 42\n\nconst program2 = Effect.matchEffect(failure, {\n  onFailure: (error) =>\n    Effect.succeed(`failure: ${error.message}`).pipe(\n      Effect.tap(Effect.log)\n    ),\n  onSuccess: (value) =>\n    Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n})\n\nconsole.log(Effect.runSync(program2))\n// Output:\n// timestamp=... level=INFO fiber=#1 message=\"failure: Uh oh!\"\n// failure: Uh oh!"
    ],
    "since": "2.0.0",
    "category": "Matching",
    "signature": "export declare const matchEffect: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R2 | R3 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "log",
    "description": "Logs one or more messages or error causes at the current log level.\n\n**Details**\n\nThis function provides a simple way to log messages or error causes during\nthe execution of your effects. By default, logs are recorded at the `INFO`\nlevel, but this can be adjusted using other logging utilities\n(`Logger.withMinimumLogLevel`). Multiple items, including `Cause` instances,\ncan be logged in a single call. When logging `Cause` instances, detailed\nerror information is included in the log output.\n\nThe log output includes useful metadata like the current timestamp, log\nlevel, and fiber ID, making it suitable for debugging and tracking purposes.\nThis function does not interrupt or alter the effect's execution flow.",
    "deprecated": false,
    "examples": [
      "import { Cause, Effect } from \"effect\"\n\nconst program = Effect.log(\n  \"message1\",\n  \"message2\",\n  Cause.die(\"Oh no!\"),\n  Cause.die(\"Oh uh!\")\n)\n\n// Effect.runFork(program)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause=\"Error: Oh no!\n// Error: Oh uh!\""
    ],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "export declare const log: (...message: ReadonlyArray<any>) => Effect<void, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "logTrace",
    "description": "Logs messages at the TRACE log level.\n\n**Details**\n\nThis function logs the specified messages at the TRACE level. TRACE logs are\ntypically used for very detailed diagnostic information. These messages are\nnot displayed by default. To view them, you must adjust the logging\nconfiguration by setting the minimum log level to `LogLevel.Trace` using\n`Logger.withMinimumLogLevel`.",
    "deprecated": false,
    "examples": [
      "import { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.logTrace(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Trace))\n\n// Effect.runFork(program)\n// timestamp=... level=TRACE fiber=#0 message=message1"
    ],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "export declare const logTrace: (...message: ReadonlyArray<any>) => Effect<void, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "logDebug",
    "description": "Logs messages at the DEBUG log level.\n\n**Details**\n\nThis function logs messages at the DEBUG level, which is typically used for\ndiagnosing application behavior during development. DEBUG messages provide\nless detailed information than TRACE logs but are still not shown by default.\nTo view these logs, adjust the log level using `Logger.withMinimumLogLevel`.",
    "deprecated": false,
    "examples": [
      "import { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.logDebug(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n\n// Effect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message1"
    ],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "export declare const logDebug: (...message: ReadonlyArray<any>) => Effect<void, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "logInfo",
    "description": "Logs messages at the INFO log level.\n\n**Details**\n\nThis function logs messages at the INFO level, suitable for general\napplication events or operational messages. INFO logs are shown by default\nand are commonly used for highlighting normal, non-error operations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "export declare const logInfo: (...message: ReadonlyArray<any>) => Effect<void, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "logWarning",
    "description": "Logs messages at the WARNING log level.\n\n**Details**\n\nThis function logs messages at the WARNING level, suitable for highlighting\npotential issues that are not errors but may require attention. These\nmessages indicate that something unexpected occurred or might lead to errors\nin the future.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "export declare const logWarning: (...message: ReadonlyArray<any>) => Effect<void, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "logError",
    "description": "Logs messages at the ERROR log level.\n\n**Details**\n\nThis function logs messages at the ERROR level, suitable for reporting\napplication errors or failures. These logs are typically used for unexpected\nissues that need immediate attention.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "export declare const logError: (...message: ReadonlyArray<any>) => Effect<void, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "logFatal",
    "description": "Logs messages at the FATAL log level.\n\n**Details**\n\nThis function logs messages at the FATAL level, suitable for reporting\ncritical errors that cause the application to terminate or stop functioning.\nThese logs are typically used for unrecoverable errors that require immediate\nattention.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "export declare const logFatal: (...message: ReadonlyArray<any>) => Effect<void, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withLogSpan",
    "description": "Adds a log span to an effect for tracking and logging its execution duration.\n\n**Details**\n\nThis function wraps an effect with a log span, providing performance\nmonitoring and debugging capabilities. The log span tracks the duration of\nthe wrapped effect and logs it with the specified label. This is particularly\nuseful when analyzing time-sensitive operations or understanding the\nexecution time of specific tasks in your application.\n\nThe logged output will include the label and the total time taken for the\noperation. The span information is included in the log metadata, making it\neasy to trace performance metrics in logs.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.sleep(\"1 second\")\n  yield* Effect.log(\"The job is finished!\")\n}).pipe(Effect.withLogSpan(\"myspan\"))\n\n// Effect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=\"The job is finished!\" myspan=1011ms"
    ],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "export declare const withLogSpan: { (label: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, label: string): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "annotateLogs",
    "description": "Adds custom annotations to log entries generated within an effect.\n\n**Details**\n\nThis function allows you to enhance log messages by appending additional\ncontext in the form of key-value pairs. These annotations are included in\nevery log message created during the execution of the effect, making the logs\nmore informative and easier to trace.\n\nThe annotations can be specified as a single key-value pair or as a record of\nmultiple key-value pairs. This is particularly useful for tracking\noperations, debugging, or associating specific metadata with logs for better\nobservability.\n\nThe annotated key-value pairs will appear alongside the log message in the\noutput.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"message1\")\n  yield* Effect.log(\"message2\")\n}).pipe(Effect.annotateLogs(\"taskId\", \"1234\")) // Annotation as key/value pair\n\n// Effect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=message1 taskId=1234\n// timestamp=... level=INFO fiber=#0 message=message2 taskId=1234"
    ],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "export declare const annotateLogs: { (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "annotateLogsScoped",
    "description": "Adds log annotations with a limited scope to enhance contextual logging.\n\n**Details**\n\nThis function allows you to apply key-value annotations to log entries\ngenerated within a specific scope of your effect computations. The\nannotations are restricted to the defined `Scope`, ensuring that they are\nonly applied to logs produced during that scope. Once the scope ends, the\nannotations are automatically removed, making it easier to manage\ncontext-specific logging without affecting other parts of your application.\n\nThe annotations can be provided as a single key-value pair or as a record of\nmultiple key-value pairs. This flexibility enables fine-grained control over\nthe additional metadata included in logs for specific tasks or operations.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"no annotations\")\n  yield* Effect.annotateLogsScoped({ key: \"value\" })\n  yield* Effect.log(\"message1\") // Annotation is applied to this log\n  yield* Effect.log(\"message2\") // Annotation is applied to this log\n}).pipe(Effect.scoped, Effect.andThen(Effect.log(\"no annotations again\")))\n\n// Effect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=\"no annotations\"\n// timestamp=... level=INFO fiber=#0 message=message1 key=value\n// timestamp=... level=INFO fiber=#0 message=message2 key=value\n// timestamp=... level=INFO fiber=#0 message=\"no annotations again\""
    ],
    "since": "3.1.0",
    "category": "Logging",
    "signature": "export declare const annotateLogsScoped: { (key: string, value: unknown): Effect<void, never, Scope.Scope>; (values: Record<string, unknown>): Effect<void, never, Scope.Scope>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "logAnnotations",
    "description": "Retrieves the current log annotations for the current scope.\n\n**Details**\n\nThis function provides access to the log annotations associated with the\ncurrent scope. Log annotations are key-value pairs that provide additional\ncontext to log entries. They are often used to add metadata such as tags,\nidentifiers, or extra debugging information to logs.\n\nBy using this function, you can inspect or utilize the annotations applied to\nthe current scope, making it easier to trace and debug specific sections of\nyour application.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "export declare const logAnnotations: Effect<HashMap.HashMap<string, unknown>, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withUnhandledErrorLogLevel",
    "description": "Configures whether child fibers will log unhandled errors and at what log\nlevel.\n\n**Details**\n\nThis function allows you to control whether unhandled errors from child\nfibers are logged and to specify the log level for these errors. By default,\nunhandled errors are reported via the logger. However, using this function,\nyou can choose to suppress these logs by passing `Option.none` or adjust the\nlog level to a specific severity, such as `Error`, `Warning`, or `Info`.\n\nThis configuration is scoped to the effect it is applied to, meaning the\nchanges only apply to the child fibers created within that effect's context.\nIt is especially useful when you want to reduce noise in logs or prioritize\ncertain types of errors.",
    "deprecated": false,
    "examples": [
      "import { Effect, Fiber, LogLevel, Option } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  const fiber = yield* Effect.fork(Effect.fail(\"Unhandled error!\"))\n  yield* Fiber.join(fiber)\n})\n\n// Effect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))\n// Output:\n// timestamp=... level=ERROR fiber=#1 message=\"Fiber terminated with an unhandled error\" cause=\"Error: Unhandled error!\""
    ],
    "since": "2.0.0",
    "category": "Logging",
    "signature": "export declare const withUnhandledErrorLogLevel: { (level: Option.Option<LogLevel.LogLevel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, level: Option.Option<LogLevel.LogLevel>): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "whenLogLevel",
    "description": "Conditionally executes an effect based on the specified log level and currently enabled log level.\n\n**Details**\n\nThis function runs the provided effect only if the specified log level is\nenabled. If the log level is enabled, the effect is executed and its result\nis wrapped in `Some`. If the log level is not enabled, the effect is not\nexecuted and `None` is returned.\n\nThis function is useful for conditionally executing logging-related effects\nor other operations that depend on the current log level configuration.",
    "deprecated": false,
    "examples": [
      "import { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.gen(function* () {\n  yield* Effect.whenLogLevel(Effect.logTrace(\"message1\"), LogLevel.Trace); // returns `None`\n  yield* Effect.whenLogLevel(Effect.logDebug(\"message2\"), LogLevel.Debug); // returns `Some`\n}).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));\n\n// Effect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message2"
    ],
    "since": "3.13.0",
    "category": "Logging",
    "signature": "export declare const whenLogLevel: { (level: LogLevel.LogLevel | LogLevel.Literal): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, level: LogLevel.LogLevel | LogLevel.Literal): Effect<Option.Option<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "orDie",
    "description": "Converts an effect's failure into a fiber termination, removing the error\nfrom the effect's type.\n\n**Details**\n\nThe `orDie` function is used when you encounter errors that you do not want\nto handle or recover from. It removes the error type from the effect and\nensures that any failure will terminate the fiber. This is useful for\npropagating failures as defects, signaling that they should not be handled\nwithin the effect.\n\n**When to Use*\n\nUse `orDie` when failures should be treated as unrecoverable defects and no\nerror handling is required.",
    "deprecated": false,
    "examples": [
      "// Title: Propagating an Error as a Defect\nimport { Effect } from \"effect\"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error(\"Cannot divide by zero\"))\n    : Effect.succeed(a / b)\n\n//       Effect<number, never, never>\n//      \nconst program = Effect.orDie(divide(1, 0))\n\n// Effect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: Cannot divide by zero\n//   ...stack trace..."
    ],
    "since": "2.0.0",
    "category": "Converting Failures to Defects",
    "signature": "export declare const orDie: <A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "orDieWith",
    "description": "Converts an effect's failure into a fiber termination with a custom error.\n\n**Details**\n\nThe `orDieWith` function behaves like {@link orDie}, but it allows you to provide a mapping\nfunction to transform the error before terminating the fiber. This is useful for cases where\nyou want to include a more detailed or user-friendly error when the failure is propagated\nas a defect.\n\n**When to Use**\n\nUse `orDieWith` when failures should terminate the fiber as defects, and you want to customize\nthe error for clarity or debugging purposes.",
    "deprecated": false,
    "examples": [
      "// Title: Customizing Defect\nimport { Effect } from \"effect\"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error(\"Cannot divide by zero\"))\n    : Effect.succeed(a / b)\n\n//       Effect<number, never, never>\n//      \nconst program = Effect.orDieWith(\n  divide(1, 0),\n  (error) => new Error(`defect: ${error.message}`)\n)\n\n// Effect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: defect: Cannot divide by zero\n//   ...stack trace..."
    ],
    "since": "2.0.0",
    "category": "Converting Failures to Defects",
    "signature": "export declare const orDieWith: { <E>(f: (error: E) => unknown): <A, R>(self: Effect<A, E, R>) => Effect<A, never, R>; <A, E, R>(self: Effect<A, E, R>, f: (error: E) => unknown): Effect<A, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "orElse",
    "description": "Attempts one effect, and if it fails, falls back to another effect.\n\n**Details**\n\nThis function allows you to try executing an effect, and if it fails\n(produces an error), a fallback effect is executed instead. The fallback\neffect is defined as a lazy argument, meaning it will only be evaluated if\nthe first effect fails. This provides a way to recover from errors by\nspecifying an alternative path of execution.\n\nThe error type of the resulting effect will be that of the fallback effect,\nas the first effect's error is replaced when the fallback is executed.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst success = Effect.succeed(\"success\")\nconst failure = Effect.fail(\"failure\")\nconst fallback = Effect.succeed(\"fallback\")\n\n// Try the success effect first, fallback is not used\nconst program1 = Effect.orElse(success, () => fallback)\nconsole.log(Effect.runSync(program1))\n// Output: \"success\"\n\n// Try the failure effect first, fallback is used\nconst program2 = Effect.orElse(failure, () => fallback)\nconsole.log(Effect.runSync(program2))\n// Output: \"fallback\""
    ],
    "since": "2.0.0",
    "category": "Fallback",
    "signature": "export declare const orElse: { <A2, E2, R2>(that: LazyArg<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: LazyArg<Effect<A2, E2, R2>>): Effect<A2 | A, E2, R2 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "orElseFail",
    "description": "Replaces the failure of an effect with a custom failure value.\n\n**Details**\n\nThis function allows you to handle the failure of an effect by replacing it\nwith a predefined failure value. If the effect fails, the new failure value\nprovided by the `evaluate` function will be returned instead of the original\nfailure. If the effect succeeds, the original success value is returned\nunchanged.\n\n**When to Use**\n\nThis is particularly useful when you want to standardize error handling or\nprovide a consistent failure value for specific operations. It simplifies\nerror management by ensuring that all failures are replaced with a controlled\nalternative.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst validate = (age: number): Effect.Effect<number, string> => {\n  if (age < 0) {\n    return Effect.fail(\"NegativeAgeError\")\n  } else if (age < 18) {\n    return Effect.fail(\"IllegalAgeError\")\n  } else {\n    return Effect.succeed(age)\n  }\n}\n\nconst program = Effect.orElseFail(validate(-1), () => \"invalid age\")\n\nconsole.log(Effect.runSyncExit(program))\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }\n// }"
    ],
    "since": "2.0.0",
    "category": "Fallback",
    "signature": "export declare const orElseFail: { <E2>(evaluate: LazyArg<E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, evaluate: LazyArg<E2>): Effect<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "orElseSucceed",
    "description": "Ensures the effect always succeeds by replacing failures with a default\nsuccess value.\n\n**Details**\n\nThis function transforms an effect that may fail into one that cannot fail by\nreplacing any failure with a provided success value. If the original effect\nfails, the failure is \"swallowed,\" and the specified success value is\nreturned instead. If the original effect succeeds, its value remains\nunchanged.\n\n**When to Use**\n\nThis is especially useful for providing default values in case of failure,\nensuring that an effect always completes successfully. By using this\nfunction, you can avoid the need for complex error handling and guarantee a\nfallback result.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst validate = (age: number): Effect.Effect<number, string> => {\n  if (age < 0) {\n    return Effect.fail(\"NegativeAgeError\")\n  } else if (age < 18) {\n    return Effect.fail(\"IllegalAgeError\")\n  } else {\n    return Effect.succeed(age)\n  }\n}\n\nconst program = Effect.orElseSucceed(validate(-1), () => 18)\n\nconsole.log(Effect.runSyncExit(program))\n// Output:\n// { _id: 'Exit', _tag: 'Success', value: 18 }"
    ],
    "since": "2.0.0",
    "category": "Fallback",
    "signature": "export declare const orElseSucceed: { <A2>(evaluate: LazyArg<A2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, never, R>; <A, E, R, A2>(self: Effect<A, E, R>, evaluate: LazyArg<A2>): Effect<A | A2, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "firstSuccessOf",
    "description": "Runs a sequence of effects and returns the result of the first successful\none.\n\n**Details**\n\nThis function allows you to execute a collection of effects in sequence,\nstopping at the first success. If an effect succeeds, its result is\nimmediately returned, and no further effects in the sequence are executed.\nHowever, if all the effects fail, the function will return the error of the\nlast effect.\n\nThe execution is sequential, meaning that effects are evaluated one at a time\nin the order they are provided. This ensures predictable behavior and avoids\nunnecessary computations.\n\nIf the collection of effects is empty, an `IllegalArgumentException` is\nthrown, indicating that the operation is invalid without any effects to try.\n\n**When to Use**\n\nThis is particularly useful when you have multiple fallback strategies or\nalternative sources to obtain a result, such as attempting multiple APIs,\nretrieving configurations, or accessing resources in a prioritized manner.",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\ninterface Config {\n  host: string\n  port: number\n  apiKey: string\n}\n\n// Create a configuration object with sample values\nconst makeConfig = (name: string): Config => ({\n  host: `${name}.example.com`,\n  port: 8080,\n  apiKey: \"12345-abcde\"\n})\n\n// Simulate retrieving configuration from a remote node\nconst remoteConfig = (name: string): Effect.Effect<Config, Error> =>\n  Effect.gen(function* () {\n    // Simulate node3 being the only one with available config\n    if (name === \"node3\") {\n      yield* Console.log(`Config for ${name} found`)\n      return makeConfig(name)\n    } else {\n      yield* Console.log(`Unavailable config for ${name}`)\n      return yield* Effect.fail(new Error(`Config not found for ${name}`))\n    }\n  })\n\n// Define the master configuration and potential fallback nodes\nconst masterConfig = remoteConfig(\"master\")\nconst nodeConfigs = [\"node1\", \"node2\", \"node3\", \"node4\"].map(remoteConfig)\n\n// Attempt to find a working configuration,\n// starting with the master and then falling back to other nodes\nconst config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])\n\n// Run the effect to retrieve the configuration\nconst result = Effect.runSync(config)\n\nconsole.log(result)\n// Output:\n// Unavailable config for master\n// Unavailable config for node1\n// Unavailable config for node2\n// Config for node3 found\n// { host: 'node3.example.com', port: 8080, apiKey: '12345-abcde' }"
    ],
    "since": "2.0.0",
    "category": "Fallback",
    "signature": "export declare const firstSuccessOf: <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "random",
    "description": "Retrieves the `Random` service from the context.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Random",
    "signature": "export declare const random: Effect<Random.Random, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "randomWith",
    "description": "Retrieves the `Random` service from the context and uses it to run the\nspecified effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Random",
    "signature": "export declare const randomWith: <A, E, R>(f: (random: Random.Random) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withRandom",
    "description": "Executes the specified effect with the specified implementation of the\n`Random` service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Random",
    "signature": "export declare const withRandom: { <X extends Random.Random>(value: X): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <X extends Random.Random, A, E, R>(effect: Effect<A, E, R>, value: X): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withRandomScoped",
    "description": "Sets the implementation of the `Random` service to the specified value and\nrestores it to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Random",
    "signature": "export declare const withRandomScoped: <A extends Random.Random>(value: A) => Effect<void, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "runtime",
    "description": "Returns an effect that accesses the runtime, which can be used to (unsafely)\nexecute tasks.\n\n**When to Use**\n\nThis is useful for integration with legacy code that must call back into\nEffect code.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Runtime",
    "signature": "export declare const runtime: <R = never>() => Effect<Runtime.Runtime<R>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "getRuntimeFlags",
    "description": "Retrieves an effect that succeeds with the current runtime flags, which\ngovern behavior and features of the runtime system.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Runtime",
    "signature": "export declare const getRuntimeFlags: Effect<RuntimeFlags.RuntimeFlags, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "patchRuntimeFlags",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Runtime",
    "signature": "export declare const patchRuntimeFlags: (patch: RuntimeFlagsPatch.RuntimeFlagsPatch) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withRuntimeFlagsPatch",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Runtime",
    "signature": "export declare const withRuntimeFlagsPatch: { (update: RuntimeFlagsPatch.RuntimeFlagsPatch): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, update: RuntimeFlagsPatch.RuntimeFlagsPatch): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withRuntimeFlagsPatchScoped",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Runtime",
    "signature": "export declare const withRuntimeFlagsPatchScoped: (update: RuntimeFlagsPatch.RuntimeFlagsPatch) => Effect<void, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "tagMetrics",
    "description": "Tags each metric in an effect with specific key-value pairs.\n\n**Details**\n\nThis function allows you to tag all metrics in an effect with a set of\nkey-value pairs or a single key-value pair. Tags help you add metadata to\nmetrics, making it easier to filter and categorize them in monitoring\nsystems. The provided tags will apply to all metrics generated within the\neffect's scope.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Metrics",
    "signature": "export declare const tagMetrics: { (key: string, value: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, string>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: string): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, string>): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "labelMetrics",
    "description": "Adds labels to metrics within an effect using `MetricLabel` objects.\n\n**Details**\n\nThis function allows you to label metrics using `MetricLabel` objects. Labels\nhelp add structured metadata to metrics for categorization and filtering in\nmonitoring systems. The provided labels will apply to all metrics within the\neffect's execution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Metrics",
    "signature": "export declare const labelMetrics: { (labels: Iterable<MetricLabel.MetricLabel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, labels: Iterable<MetricLabel.MetricLabel>): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "tagMetricsScoped",
    "description": "Tags metrics within a scope with a specific key-value pair.\n\n**Details**\n\nThis function tags all metrics within a scope with the provided key-value\npair. Once the scope is closed, the tag is automatically removed. This is\nuseful for applying temporary context-specific tags to metrics during scoped\noperations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Metrics",
    "signature": "export declare const tagMetricsScoped: (key: string, value: string) => Effect<void, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "labelMetricsScoped",
    "description": "Adds labels to metrics within a scope using `MetricLabel` objects.\n\n**Details**\n\nThis function allows you to apply labels to all metrics generated within a\nspecific scope using an array of `MetricLabel` objects. These labels provide\nadditional metadata to metrics, which can be used for categorization,\nfiltering, or monitoring purposes. The labels are scoped and will be removed\nautomatically once the scope is closed, ensuring they are only applied\ntemporarily within the defined context.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Metrics",
    "signature": "export declare const labelMetricsScoped: (labels: ReadonlyArray<MetricLabel.MetricLabel>) => Effect<void, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "metricLabels",
    "description": "Retrieves the metric labels associated with the current scope.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Metrics",
    "signature": "export declare const metricLabels: Effect<readonly MetricLabel.MetricLabel[], never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withMetric",
    "description": "Associates a metric with the current effect, updating it as the effect progresses.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Metrics",
    "signature": "export declare const withMetric: { <Type, In, Out>(metric: Metric.Metric<Type, In, Out>): <A extends In, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A extends In, E, R, Type, In, Out>(self: Effect<A, E, R>, metric: Metric.Metric<Type, In, Out>): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMakeSemaphore",
    "description": "Unsafely creates a new Semaphore.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Semaphore",
    "signature": "export declare const unsafeMakeSemaphore: (permits: number) => Semaphore"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "makeSemaphore",
    "description": "Creates a new semaphore with the specified number of permits.\n\n**Details**\n\nThis function initializes a semaphore that controls concurrent access to a\nshared resource. The number of permits determines how many tasks can access\nthe resource concurrently.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\n// Create a semaphore with 3 permits\nconst mutex = Effect.makeSemaphore(3)"
    ],
    "since": "2.0.0",
    "category": "Semaphore",
    "signature": "export declare const makeSemaphore: (permits: number) => Effect<Semaphore>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMakeLatch",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "Latch",
    "signature": "export declare const unsafeMakeLatch: (open?: boolean | undefined) => Latch"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "makeLatch",
    "description": "Creates a new `Latch`, starting in the specified state.\n\n**Details**\n\nThis function initializes a `Latch` safely, ensuring proper runtime\nguarantees. By default, the latch starts in the closed state.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  // Create a latch, starting in the closed state\n  const latch = yield* Effect.makeLatch(false)\n\n  // Fork a fiber that logs \"open sesame\" when the latch is opened\n  const fiber = yield* Console.log(\"open sesame\").pipe(\n    latch.whenOpen,\n    Effect.fork\n  )\n\n  yield* Effect.sleep(\"1 second\")\n\n  // Open the latch\n  yield* latch.open\n  yield* fiber.await\n})\n\n// Effect.runFork(program)\n// Output: open sesame (after 1 second)"
    ],
    "since": "3.8.0",
    "category": "Latch",
    "signature": "export declare const makeLatch: (open?: boolean | undefined) => Effect<Latch, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "runFork",
    "description": "Runs an effect in the background, returning a fiber that can be observed or\ninterrupted.\n\nUnless you specifically need a `Promise` or synchronous operation, `runFork`\nis a good default choice.\n\n**Details**\n\nThis function is the foundational way to execute an effect in the background.\nIt creates a \"fiber,\" a lightweight, cooperative thread of execution that can\nbe observed (to access its result), interrupted, or joined. Fibers are useful\nfor concurrent programming and allow effects to run independently of the main\nprogram flow.\n\nOnce the effect is running in a fiber, you can monitor its progress, cancel\nit if necessary, or retrieve its result when it completes. If the effect\nfails, the fiber will propagate the failure, which you can observe and\nhandle.\n\n**When to Use**\n\nUse this function when you need to run an effect in the background,\nespecially if the effect is long-running or performs periodic tasks. It's\nsuitable for tasks that need to run independently but might still need\nobservation or management, like logging, monitoring, or scheduled tasks.\n\nThis function is ideal if you don't need the result immediately or if the\neffect is part of a larger concurrent workflow.",
    "deprecated": false,
    "examples": [
      "// Title: Running an Effect in the Background\nimport { Effect, Console, Schedule, Fiber } from \"effect\"\n\n//       Effect<number, never, never>\n//      \nconst program = Effect.repeat(\n  Console.log(\"running...\"),\n  Schedule.spaced(\"200 millis\")\n)\n\n//       RuntimeFiber<number, never>\n//      \nconst fiber = Effect.runFork(program)\n\nsetTimeout(() => {\n  Effect.runFork(Fiber.interrupt(fiber))\n}, 500)"
    ],
    "since": "2.0.0",
    "category": "Running Effects",
    "signature": "export declare const runFork: <A, E>(effect: Effect<A, E>, options?: Runtime.RunForkOptions) => Fiber.RuntimeFiber<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "runCallback",
    "description": "Executes an effect asynchronously and handles the result using a callback.\n\n**Details**\n\nThis function runs an effect asynchronously and passes the result (`Exit`) to\na specified callback. The callback is invoked with the outcome of the effect:\n- On success, the callback receives the successful result.\n- On failure, the callback receives the failure information.\n\n**When to Use**\n\nThis function is effectful and should only be invoked at the edges of your\nprogram.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Running Effects",
    "signature": "export declare const runCallback: <A, E>(effect: Effect<A, E>, options?: Runtime.RunCallbackOptions<A, E> | undefined) => Runtime.Cancel<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "runPromise",
    "description": "Executes an effect and returns the result as a `Promise`.\n\n**Details**\n\nThis function runs an effect and converts its result into a `Promise`. If the\neffect succeeds, the `Promise` will resolve with the successful result. If\nthe effect fails, the `Promise` will reject with an error, which includes the\nfailure details of the effect.\n\nThe optional `options` parameter allows you to pass an `AbortSignal` for\ncancellation, enabling more fine-grained control over asynchronous tasks.\n\n**When to Use**\n\nUse this function when you need to execute an effect and work with its result\nin a promise-based system, such as when integrating with third-party\nlibraries that expect `Promise` results.",
    "deprecated": false,
    "examples": [
      "// Title: Running a Successful Effect as a Promise\nimport { Effect } from \"effect\"\n\n// Effect.runPromise(Effect.succeed(1)).then(console.log)\n// Output: 1",
      "//Example: Handling a Failing Effect as a Rejected Promise\nimport { Effect } from \"effect\"\n\n// Effect.runPromise(Effect.fail(\"my error\")).catch(console.error)\n// Output:\n// (FiberFailure) Error: my error"
    ],
    "since": "2.0.0",
    "category": "Running Effects",
    "signature": "export declare const runPromise: <A, E>(effect: Effect<A, E, never>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "runPromiseExit",
    "description": "Runs an effect and returns a `Promise` that resolves to an `Exit`,\nrepresenting the outcome.\n\n**Details**\n\nThis function executes an effect and resolves to an `Exit` object. The `Exit`\ntype provides detailed information about the result of the effect:\n- If the effect succeeds, the `Exit` will be of type `Success` and include\n  the value produced by the effect.\n- If the effect fails, the `Exit` will be of type `Failure` and contain a\n  `Cause` object, detailing the failure.\n\nUsing this function allows you to examine both successful results and failure\ncases in a unified way, while still leveraging `Promise` for handling the\nasynchronous behavior of the effect.\n\n**When to Use**\n\nUse this function when you need to understand the outcome of an effect,\nwhether it succeeded or failed, and want to work with this result using\n`Promise` syntax. This is particularly useful when integrating with systems\nthat rely on promises but need more detailed error handling than a simple\nrejection.",
    "deprecated": false,
    "examples": [
      "// Title: Handling Results as Exit\nimport { Effect } from \"effect\"\n\n// Execute a successful effect and get the Exit result as a Promise\n// Effect.runPromiseExit(Effect.succeed(1)).then(console.log)\n// Output:\n// {\n//   _id: \"Exit\",\n//   _tag: \"Success\",\n//   value: 1\n// }\n\n// Execute a failing effect and get the Exit result as a Promise\n// Effect.runPromiseExit(Effect.fail(\"my error\")).then(console.log)\n// Output:\n// {\n//   _id: \"Exit\",\n//   _tag: \"Failure\",\n//   cause: {\n//     _id: \"Cause\",\n//     _tag: \"Fail\",\n//     failure: \"my error\"\n//   }\n// }"
    ],
    "since": "2.0.0",
    "category": "Running Effects",
    "signature": "export declare const runPromiseExit: <A, E>(effect: Effect<A, E, never>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<Exit.Exit<A, E>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "runSync",
    "description": "Executes an effect synchronously, running it immediately and returning the\nresult.\n\n**Details**\n\nThis function evaluates the provided effect synchronously, returning its\nresult directly. It is ideal for effects that do not fail or include\nasynchronous operations. If the effect does fail or involves async tasks, it\nwill throw an error. Execution stops at the point of failure or asynchronous\noperation, making it unsuitable for effects that require asynchronous\nhandling.\n\n**Important**: Attempting to run effects that involve asynchronous operations\nor failures will result in exceptions being thrown, so use this function with\ncare for purely synchronous and error-free effects.\n\n**When to Use**\n\nUse this function when:\n- You are sure that the effect will not fail or involve asynchronous\n  operations.\n- You need a direct, synchronous result from the effect.\n- You are working within a context where asynchronous effects are not\n  allowed.\n\nAvoid using this function for effects that can fail or require asynchronous\nhandling. For such cases, consider using {@link runPromise} or\n{@link runSyncExit}.",
    "deprecated": false,
    "examples": [
      "// Title: Synchronous Logging\nimport { Effect } from \"effect\"\n\nconst program = Effect.sync(() => {\n  console.log(\"Hello, World!\")\n  return 1\n})\n\nconst result = Effect.runSync(program)\n// Output: Hello, World!\n\nconsole.log(result)\n// Output: 1",
      "// Title: Incorrect Usage with Failing or Async Effects\nimport { Effect } from \"effect\"\n\ntry {\n  // Attempt to run an effect that fails\n  Effect.runSync(Effect.fail(\"my error\"))\n} catch (e) {\n  console.error(e)\n}\n// Output:\n// (FiberFailure) Error: my error\n\ntry {\n  // Attempt to run an effect that involves async work\n  Effect.runSync(Effect.promise(() => Promise.resolve(1)))\n} catch (e) {\n  console.error(e)\n}\n// Output:\n// (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work"
    ],
    "since": "2.0.0",
    "category": "Running Effects",
    "signature": "export declare const runSync: <A, E>(effect: Effect<A, E>) => A"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "runSyncExit",
    "description": "Runs an effect synchronously and returns the result as an `Exit` type.\n\n**Details**\n\nThis function executes the provided effect synchronously and returns an `Exit`\ntype that encapsulates the outcome of the effect:\n- If the effect succeeds, the result is wrapped in a `Success`.\n- If the effect fails, it returns a `Failure` containing a `Cause` that explains\n  the failure.\n\nIf the effect involves asynchronous operations, this function will return a `Failure`\nwith a `Die` cause, indicating that it cannot resolve the effect synchronously.\nThis makes the function suitable for use only with effects that are synchronous\nin nature.\n\n**When to Use**\n\nUse this function when:\n- You want to handle both success and failure outcomes in a structured way using the `Exit` type.\n- You are working with effects that are purely synchronous and do not involve asynchronous operations.\n- You need to debug or inspect failures, including their causes, in a detailed manner.\n\nAvoid using this function for effects that involve asynchronous operations, as it will fail with a `Die` cause.",
    "deprecated": false,
    "examples": [
      "// Title: Handling Results as Exit\nimport { Effect } from \"effect\"\n\nconsole.log(Effect.runSyncExit(Effect.succeed(1)))\n// Output:\n// {\n//   _id: \"Exit\",\n//   _tag: \"Success\",\n//   value: 1\n// }\n\nconsole.log(Effect.runSyncExit(Effect.fail(\"my error\")))\n// Output:\n// {\n//   _id: \"Exit\",\n//   _tag: \"Failure\",\n//   cause: {\n//     _id: \"Cause\",\n//     _tag: \"Fail\",\n//     failure: \"my error\"\n//   }\n// }",
      "// Title: Asynchronous Operation Resulting in Die\nimport { Effect } from \"effect\"\n\nconsole.log(Effect.runSyncExit(Effect.promise(() => Promise.resolve(1))))\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Die',\n//     defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {\n//       fiber: [FiberRuntime],\n//       _tag: 'AsyncFiberException',\n//       name: 'AsyncFiberException'\n//     }\n//   }\n// }"
    ],
    "since": "2.0.0",
    "category": "Running Effects",
    "signature": "export declare const runSyncExit: <A, E>(effect: Effect<A, E>) => Exit.Exit<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "validate",
    "description": "Combines multiple effects and accumulates both successes and failures.\n\n**Details**\n\nThis function allows you to combine multiple effects, continuing through all\neffects even if some of them fail. Unlike other functions that stop execution\nupon encountering an error, this function collects all errors into a `Cause`.\nThe final result includes all successes and the accumulated failures.\n\nBy default, effects are executed sequentially, but you can control\nconcurrency and batching behavior using the `options` parameter. This\nprovides flexibility in scenarios where you want to maximize performance or\nensure specific ordering.",
    "deprecated": false,
    "examples": [
      "import { Effect, Console } from \"effect\"\n\nconst task1 = Console.log(\"task1\").pipe(Effect.as(1))\nconst task2 = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\nconst task3 = Console.log(\"task2\").pipe(Effect.as(3))\nconst task4 = Effect.fail(\"Oh no!\").pipe(Effect.as(4))\n\nconst program = task1.pipe(\n  Effect.validate(task2),\n  Effect.validate(task3),\n  Effect.validate(task4)\n)\n\n// Effect.runPromiseExit(program).then(console.log)\n// Output:\n// task1\n// task2\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Sequential',\n//     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },\n//     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }\n//   }\n// }"
    ],
    "since": "2.0.0",
    "category": "Error Accumulation",
    "signature": "export declare const validate: { <B, E1, R1>(that: Effect<B, E1, R1>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, B], E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect<A, E, R>, that: Effect<B, E1, R1>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[A, B], E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "validateWith",
    "description": "Sequentially combines two effects using a specified combiner function while\naccumulating errors.\n\n**Details**\n\nThis function combines two effects, `self` and `that`, into a single effect\nby applying the provided combiner function to their results. If both effects\nsucceed, the combiner function is applied to their results to produce the\nfinal value. If either effect fails, the failures are accumulated into a\ncombined `Cause`.\n\nBy default, effects are executed sequentially. However, the execution mode\ncan be controlled using the `options` parameter to enable concurrency,\nbatching, or customized finalizer behavior.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error Accumulation",
    "signature": "export declare const validateWith: { <B, E1, R1, A, C>(that: Effect<B, E1, R1>, f: (a: A, b: B) => C, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <E, R>(self: Effect<A, E, R>) => Effect<C, E1 | E, R1 | R>; <A, E, R, B, E1, R1, C>(self: Effect<A, E, R>, that: Effect<B, E1, R1>, f: (a: A, b: B) => C, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<C, E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Combines two effects into a single effect, producing a tuple of their\nresults.\n\n**Details**\n\nThis function combines two effects, `self` and `that`, into one. It executes\nthe first effect (`self`) and then the second effect (`that`), collecting\ntheir results into a tuple. Both effects must succeed for the resulting\neffect to succeed. If either effect fails, the entire operation fails.\n\nBy default, the effects are executed sequentially. If the `concurrent` option\nis set to `true`, the effects will run concurrently, potentially improving\nperformance for independent operations.",
    "deprecated": false,
    "examples": [
      "// Title: Combining Two Effects Sequentially\nimport { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\n// Combine the two effects together\n//\n//       Effect<[number, string], never, never>\n//      \nconst program = Effect.zip(task1, task2)\n\n// Effect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n// timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n// [ 1, 'hello' ]",
      "// Title: Combining Two Effects Concurrently\nimport { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\n// Run both effects concurrently using the concurrent option\nconst program = Effect.zip(task1, task2, { concurrent: true })\n\n// Effect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n// timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n// [ 1, 'hello' ]"
    ],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "export declare const zip: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[A, A2], E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Executes two effects sequentially, returning the result of the first effect\nand ignoring the result of the second.\n\n**Details**\n\nThis function allows you to run two effects in sequence, where the result of\nthe first effect is preserved, and the result of the second effect is\ndiscarded. By default, the two effects are executed sequentially. If you need\nthem to run concurrently, you can pass the `{ concurrent: true }` option.\n\nThe second effect will always be executed, even though its result is ignored.\nThis makes it useful for cases where you want to execute an effect for its\nside effects while keeping the result of another effect.\n\n**When to Use**\n\nUse this function when you are only interested in the result of the first\neffect but still need to run the second effect for its side effects, such as\nlogging or performing a cleanup action.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\nconst program = Effect.zipLeft(task1, task2)\n\n// Effect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n// timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n// 1"
    ],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "export declare const zipLeft: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Executes two effects sequentially, returning the result of the second effect\nwhile ignoring the result of the first.\n\n**Details**\n\nThis function allows you to run two effects in sequence, keeping the result\nof the second effect and discarding the result of the first. By default, the\ntwo effects are executed sequentially. If you need them to run concurrently,\nyou can pass the `{ concurrent: true }` option.\n\nThe first effect will always be executed, even though its result is ignored.\nThis makes it useful for scenarios where the first effect is needed for its\nside effects, but only the result of the second effect is important.\n\n**When to Use**\n\nUse this function when you are only interested in the result of the second\neffect but still need to run the first effect for its side effects, such as\ninitialization or setup tasks.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\nconst program = Effect.zipRight(task1, task2)\n\n// Effect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n// timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n// hello"
    ],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "export declare const zipRight: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<A2, E2 | E, R2 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Combines two effects sequentially and applies a function to their results to\nproduce a single value.\n\n**Details**\n\nThis function runs two effects in sequence (or concurrently, if the `{\nconcurrent: true }` option is provided) and combines their results using a\nprovided function. Unlike {@link zip}, which returns a tuple of the results,\nthis function processes the results with a custom function to produce a\nsingle output.",
    "deprecated": false,
    "examples": [
      "// Title: Combining Effects with a Custom Function\nimport { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay(\"200 millis\"),\n  Effect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\n  Effect.delay(\"100 millis\"),\n  Effect.tap(Effect.log(\"task2 done\"))\n)\n\nconst task3 = Effect.zipWith(\n  task1,\n  task2,\n  // Combines results into a single value\n  (number, string) => number + string.length\n)\n\n// Effect.runPromise(task3).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#3 message=\"task1 done\"\n// timestamp=... level=INFO fiber=#2 message=\"task2 done\"\n// 6"
    ],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "export declare const zipWith: { <A2, E2, R2, A, B>(that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, B>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<B, E2 | E, R2 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "ap",
    "description": "Applies the function produced by one effect to the value produced by another effect.\n\n**Details**\n\nThis function combines two effects:\n- The first effect produces a function of type `(a: A) => B`.\n- The second effect produces a value of type `A`.\n\nOnce both effects complete successfully, the function is applied to the value, resulting in an effect that produces a value of type `B`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const ap: { <A, E2, R2>(that: Effect<A, E2, R2>): <B, R, E>(self: Effect<(a: A) => B, E, R>) => Effect<B, E | E2, R | R2>; <A, B, E, R, E2, R2>(self: Effect<(a: A) => B, E, R>, that: Effect<A, E2, R2>): Effect<B, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "blocked",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "export declare const blocked: <A, E>(blockedRequests: RequestBlock, _continue: Effect<A, E>) => Blocked<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "runRequestBlock",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "export declare const runRequestBlock: (blockedRequests: RequestBlock) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "step",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "export declare const step: <A, E, R>(self: Effect<A, E, R>) => Effect<Exit.Exit<A, E> | Blocked<A, E>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "request",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "export declare const request: { <A extends Request.Request<any, any>, Ds extends RequestResolver<A> | Effect<RequestResolver<A>, any, any>>(dataSource: Ds): (self: A) => Effect<Request.Request.Success<A>, Request.Request.Error<A>, [Ds] extends [Effect<any, any, any>] ? Effect.Context<Ds> : never>; <Ds extends RequestResolver<A> | Effect<RequestResolver<A>, any, any>, A extends Request.Request<any, any>>(self: A, dataSource: Ds): Effect<Request.Request.Success<A>, Request.Request.Error<A>, [Ds] extends [Effect<any, any, any>] ? Effect.Context<Ds> : never>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "cacheRequestResult",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "export declare const cacheRequestResult: <A extends Request.Request<any, any>>(request: A, result: Request.Request.Result<A>) => Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withRequestBatching",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "export declare const withRequestBatching: { (requestBatching: boolean): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, requestBatching: boolean): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withRequestCaching",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "export declare const withRequestCaching: { (strategy: boolean): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, strategy: boolean): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withRequestCache",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Requests & Batching",
    "signature": "export declare const withRequestCache: { (cache: Request.Cache): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, cache: Request.Cache): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "tracer",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const tracer: Effect<Tracer.Tracer, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "tracerWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const tracerWith: <A, E, R>(f: (tracer: Tracer.Tracer) => Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withTracer",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const withTracer: { (value: Tracer.Tracer): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, value: Tracer.Tracer): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withTracerScoped",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const withTracerScoped: (value: Tracer.Tracer) => Effect<void, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withTracerEnabled",
    "description": "Disable the tracer for the given Effect.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nEffect.succeed(42).pipe(\n  Effect.withSpan(\"my-span\"),\n  // the span will not be registered with the tracer\n  Effect.withTracerEnabled(false)\n)"
    ],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const withTracerEnabled: { (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withTracerTiming",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const withTracerTiming: { (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "annotateSpans",
    "description": "Adds annotations to each span in the effect for enhanced traceability.\n\n**Details**\n\nThis function lets you attach key-value annotations to all spans generated\nduring the execution of an effect. Annotations provide additional context,\nsuch as metadata or labels, which can help you understand and debug\nasynchronous workflows more effectively.\n\nYou can either pass a single key-value pair or a record of key-value pairs to\nannotate the spans. These annotations can then be visualized in tracing tools\nthat support span annotations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const annotateSpans: { (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "annotateCurrentSpan",
    "description": "Adds annotations to the currently active span for traceability.\n\n**Details**\n\nThis function adds key-value annotations to the currently active span in the\neffect's trace. These annotations help provide more context about the\noperation being executed at a specific point in time. Unlike\n{@link annotateSpans}, which applies to all spans in an effect, this function\nfocuses solely on the active span.\n\nYou can either pass a single key-value pair or a record of key-value pairs to\nannotate the span. These annotations are useful for adding metadata to\noperations, especially in systems with detailed observability requirements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const annotateCurrentSpan: { (key: string, value: unknown): Effect<void>; (values: Record<string, unknown>): Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "currentSpan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const currentSpan: Effect<Tracer.Span, Cause.NoSuchElementException, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "currentParentSpan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const currentParentSpan: Effect<Tracer.AnySpan, Cause.NoSuchElementException, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "spanAnnotations",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const spanAnnotations: Effect<HashMap.HashMap<string, unknown>, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "spanLinks",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const spanLinks: Effect<Chunk.Chunk<Tracer.SpanLink>, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "linkSpans",
    "description": "For all spans in this effect, add a link with the provided span.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const linkSpans: { (span: Tracer.AnySpan, attributes?: Record<string, unknown>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, span: Tracer.AnySpan, attributes?: Record<string, unknown>): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "makeSpan",
    "description": "Create a new span for tracing.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const makeSpan: (name: string, options?: Tracer.SpanOptions) => Effect<Tracer.Span>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "makeSpanScoped",
    "description": "Create a new span for tracing, and automatically close it when the Scope\nfinalizes.\n\nThe span is not added to the current span stack, so no child spans will be\ncreated for it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const makeSpanScoped: (name: string, options?: Tracer.SpanOptions | undefined) => Effect<Tracer.Span, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "useSpan",
    "description": "Create a new span for tracing, and automatically close it when the effect\ncompletes.\n\nThe span is not added to the current span stack, so no child spans will be\ncreated for it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const useSpan: { <A, E, R>(name: string, evaluate: (span: Tracer.Span) => Effect<A, E, R>): Effect<A, E, R>; <A, E, R>(name: string, options: Tracer.SpanOptions, evaluate: (span: Tracer.Span) => Effect<A, E, R>): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withSpan",
    "description": "Wraps the effect with a new span for tracing.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const withSpan: { (name: string, options?: Tracer.SpanOptions | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Effect<A, E, R>, name: string, options?: Tracer.SpanOptions | undefined): Effect<A, E, Exclude<R, Tracer.ParentSpan>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "functionWithSpan",
    "description": "Wraps a function that returns an effect with a new span for tracing.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nconst getTodo = Effect.functionWithSpan({\n  body: (id: number) => Effect.succeed(`Got todo ${id}!`),\n  options: (id) => ({\n    name: `getTodo-${id}`,\n    attributes: { id }\n  })\n})"
    ],
    "since": "3.2.0",
    "category": "Tracing",
    "signature": "export declare const functionWithSpan: <Args extends Array<any>, Ret extends Effect<any, any, any>>(options: { readonly body: (...args: Args) => Ret; readonly options: FunctionWithSpanOptions | ((...args: Args) => FunctionWithSpanOptions); readonly captureStackTrace?: boolean | undefined; }) => (...args: Args) => Unify.Unify<Ret>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withSpanScoped",
    "description": "Wraps the effect with a new span for tracing.\n\nThe span is ended when the Scope is finalized.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const withSpanScoped: { (name: string, options?: Tracer.SpanOptions): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan> | Scope.Scope>; <A, E, R>(self: Effect<A, E, R>, name: string, options?: Tracer.SpanOptions): Effect<A, E, Exclude<R, Tracer.ParentSpan> | Scope.Scope>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "withParentSpan",
    "description": "Adds the provided span to the current span stack.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tracing",
    "signature": "export declare const withParentSpan: { (span: Tracer.AnySpan): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Effect<A, E, R>, span: Tracer.AnySpan): Effect<A, E, Exclude<R, Tracer.ParentSpan>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "fromNullable",
    "description": "Safely handles nullable values by creating an effect that fails for `null` or\n`undefined`.\n\n**Details**\n\nThis function ensures that an input value is non-null and non-undefined\nbefore processing it. If the value is valid, the effect succeeds with the\nvalue. If the value is `null` or `undefined`, the effect fails with a\n`NoSuchElementException`. This is particularly useful for avoiding\nnull-related errors by clearly separating valid values from invalid ones in\neffectful computations.\n\nThe failure with `NoSuchElementException` allows you to explicitly handle\ncases where a value is expected but not provided, leading to safer and more\npredictable code.\n\n**When to Use**\n\nUse this function when working with values that may be `null` or `undefined`\nand you want to ensure that only non-null values are processed. It helps\nenforce null-safety and makes error handling more explicit.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\n//       Effect<number, NoSuchElementException, never>\n//      \nconst maybe1 = Effect.fromNullable(1)\n\n// Effect.runPromiseExit(maybe1).then(console.log)\n// Output:\n// { _id: 'Exit', _tag: 'Success', value: 1 }\n\n//       Effect<number, NoSuchElementException, never>\n//      \nconst maybe2 = Effect.fromNullable(null as number | null)\n\n// Effect.runPromiseExit(maybe2).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: { _tag: 'NoSuchElementException' }\n//   }\n// }"
    ],
    "since": "2.0.0",
    "category": "Optional Wrapping & Unwrapping",
    "signature": "export declare const fromNullable: <A>(value: A) => Effect<NonNullable<A>, Cause.NoSuchElementException>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "optionFromOptional",
    "description": "Converts an effect that may fail with a `NoSuchElementException` into an\neffect that succeeds with an `Option`.\n\n**Details**\n\nThis function transforms an effect that might fail with\n`Cause.NoSuchElementException` into an effect that succeeds with an `Option`\ntype. If the original effect succeeds, its value is wrapped in `Option.some`.\nIf it fails specifically due to a `NoSuchElementException`, the failure is\nmapped to `Option.none`. Other types of failures remain unchanged and are\npassed through as they are.\n\nThis is useful when working with effects where you want to gracefully handle\nthe absence of a value while preserving other potential failures.\n\n**When to Use**\n\nUse this function when you need to handle missing values as `Option.none`\nrather than throwing or propagating errors like `NoSuchElementException`.\nIts ideal for scenarios where you want to explicitly represent optionality\nin a type-safe way while retaining other failure information.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\n//       Effect<number, NoSuchElementException, never>\n//      \nconst maybe1 = Effect.fromNullable(1)\n\n//       Effect<Option<number>, never, never>\n//      \nconst option1 = Effect.optionFromOptional(maybe1)\n\n// Effect.runPromise(option1).then(console.log)\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\n//       Effect<number, NoSuchElementException, never>\n//      \nconst maybe2 = Effect.fromNullable(null as number | null)\n\n//       Effect<Option<number>, never, never>\n//      \nconst option2 = Effect.optionFromOptional(maybe2)\n\n// Effect.runPromise(option2).then(console.log)\n// Output: { _tag: 'None' }"
    ],
    "since": "2.0.0",
    "category": "Optional Wrapping & Unwrapping",
    "signature": "export declare const optionFromOptional: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, Exclude<E, Cause.NoSuchElementException>, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "Service",
    "description": "Simplifies the creation and management of services in Effect by defining both\na `Tag` and a `Layer`.\n\n**Details**\n\nThis function allows you to streamline the creation of services by combining\nthe definition of a `Context.Tag` and a `Layer` in a single step. It supports\nvarious ways of providing the service implementation:\n- Using an `effect` to define the service dynamically.\n- Using `sync` or `succeed` to define the service statically.\n- Using `scoped` to create services with lifecycle management.\n\nIt also allows you to specify dependencies for the service, which will be\nprovided automatically when the service is used. Accessors can be optionally\ngenerated for the service, making it more convenient to use.",
    "deprecated": false,
    "examples": [
      "import { Effect } from 'effect';\n\nclass Prefix extends Effect.Service<Prefix>()(\"Prefix\", {\n sync: () => ({ prefix: \"PRE\" })\n}) {}\n\nclass Logger extends Effect.Service<Logger>()(\"Logger\", {\n accessors: true,\n effect: Effect.gen(function* () {\n   const { prefix } = yield* Prefix\n   return {\n     info: (message: string) =>\n       Effect.sync(() => {\n         console.log(`[${prefix}][${message}]`)\n       })\n   }\n }),\n dependencies: [Prefix.Default]\n}) {}"
    ],
    "since": "3.9.0",
    "category": "Context",
    "signature": "export declare const Service: <Self = never>() => [Self] extends [never] ? MissingSelfGeneric : { <const Key extends string, const Make extends { readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly _: never; } | { readonly effect: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly _: never; } | { readonly sync: LazyArg<Service.AllowedType<Key, Make>>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly _: never; } | { readonly succeed: Service.AllowedType<Key, Make>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly _: never; }>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly effect: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly sync: LazyArg<Service.AllowedType<Key, Make>>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly succeed: Service.AllowedType<Key, Make>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "fn",
    "description": "Creates a function that returns an Effect, which includes a stack trace\nwith relevant location information if an error occurs and is automatically\ntraced with a span pointing to the call site.\n\nThe name passed as the first argument is used as a span.\n\nThe name is optional; if not provided, the span won't be added, but the stack trace will still be present.\n\nThe function can be created using either a generator function that can yield\neffects or a normal function that returns an effect.\n\n`Effect.fn` also acts as a `pipe` function, allowing you to create a pipeline\nafter the function definition using the effect returned by the generator\nfunction as the starting value of the pipeline.",
    "deprecated": false,
    "examples": [
      "// Title: Creating a traced function with a generator function\nimport { Effect } from \"effect\"\n\nconst logExample = Effect.fn(\"logExample\")( // Definition location: 4\n  function*<N extends number>(n: N) {\n    yield* Effect.annotateCurrentSpan(\"n\", n)\n    console.log(`got: ${n}`)\n    yield* Effect.fail(new Error()) // Raise location: 8\n  }\n)\n\n// Effect.runFork(\n//   logExample(100).pipe( // Call location: 13\n//     Effect.catchAllCause(Effect.logError)\n//   )\n// )\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause=\"Error: An error has occurred\n//     at <anonymous> (/.../index.ts:8:24) <= Raise location\n//     at logExample (/.../index.ts:4:27)  <= Definition location\n//     at logExample (/.../index.ts:13:3)\" <= Call location",
      "// Title: Creating a traced function with a function\nimport { Effect } from \"effect\"\n\nconst logExample = Effect.fn(\"logExample\")(\n  function(n: number) {\n    console.log(`got: ${n}`)\n    return Effect.fail(new Error(`An error has occurred`))\n  }\n)",
      "// Title: Creating a traced function and a pipeline\nimport { Effect } from \"effect\"\n\nconst logExample = Effect.fn(\"logExample\")(\n  function(n: number) {\n    console.log(`got: ${n}`)\n    return Effect.fail(new Error(`An error has occurred`))\n  },\n  // Add a delay to the effect\n  Effect.delay(\"1 second\")\n)"
    ],
    "since": "3.11.0",
    "category": "Tracing",
    "signature": "export declare const fn: fn.Gen & fn.NonGen & ((name: string, options?: Tracer.SpanOptions) => fn.Gen & fn.NonGen)"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "fnUntraced",
    "description": "Same as {@link fn}, but allows you to create a function that is not traced, for when performance is critical.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "Tracing",
    "signature": "export declare const fnUntraced: fn.Gen"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "void",
    "description": "Represents an effect that does nothing and produces no value.\n\n**When to Use**\n\nUse this effect when you need to represent an effect that does nothing.\nThis is useful in scenarios where you need to satisfy an effect-based\ninterface or control program flow without performing any operations. For\nexample, it can be used in situations where you want to return an effect\nfrom a function but do not need to compute or return any result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const void: Effect<void, never, never>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "catch",
    "description": "Recovers from a specified error by catching it and handling it with a provided function.\n\n**Details**\n\nThis function allows you to recover from specific errors that occur during\nthe execution of an effect. It works by catching a specific type of error\n(identified by a discriminator) and then handling it using a provided\nhandler function. The handler can return a new effect that helps recover\nfrom the error, allowing the program to continue. If the error doesn't\nmatch the specified type, the function allows the original effect to\ncontinue as it was.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect } from \"effect\"\n\nclass NetworkError {\n  readonly _tag = \"NetworkError\"\n}\nclass ValidationError {\n  readonly _tag = \"ValidationError\"\n}\n\n// Simulate an effect that may fail\nconst task: Effect.Effect<never, NetworkError | ValidationError, never> = Effect.fail(new NetworkError())\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.catch(task, \"_tag\", {\n    failure: \"NetworkError\",\n    onFailure: (error) => Effect.succeed(`recovered from error: ${error._tag}`)\n  })\n  console.log(`Result: ${result}`)\n})\n\n// Effect.runFork(program)\n// Output: Result: recovered from error: NetworkError"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const catch: { <N extends keyof E, K extends E[N] & string, E, A1, E1, R1>(discriminator: N, options: { readonly failure: K; readonly onFailure: (error: Extract<E, { [n in N]: K; }>) => Effect<A1, E1, R1>; }): <A, R>(self: Effect<A, E, R>) => Effect<A1 | A, E1 | Exclude<E, { [n in N]: K; }>, R1 | R>; <A, E, R, N extends keyof E, K extends E[N] & string, A1, E1, R1>(self: Effect<A, E, R>, discriminator: N, options: { readonly failure: K; readonly onFailure: (error: Extract<E, { [n in N]: K; }>) => Effect<A1, E1, R1>; }): Effect<A | A1, E1 | Exclude<E, { [n in N]: K; }>, R | R1>; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "try",
    "description": "Creates an `Effect` that represents a synchronous computation that might\nfail.\n\n**When to Use**\n\nIn situations where you need to perform synchronous operations that might\nfail, such as parsing JSON, you can use the `try` constructor. This\nconstructor is designed to handle operations that could throw exceptions by\ncapturing those exceptions and transforming them into manageable errors.\n\n**Error Handling**\n\nThere are two ways to handle errors with `try`:\n\n1. If you don't provide a `catch` function, the error is caught and the\n   effect fails with an `UnknownException`.\n2. If you provide a `catch` function, the error is caught and the `catch`\n   function maps it to an error of type `E`.",
    "deprecated": false,
    "examples": [
      "// Title: Safe JSON Parsing\nimport { Effect } from \"effect\"\n\nconst parse = (input: string) =>\n  // This might throw an error if input is not valid JSON\n  Effect.try(() => JSON.parse(input))\n\n//       Effect<any, UnknownException, never>\n//      \nconst program = parse(\"\")\n",
      "// Title: Custom Error Handling\nimport { Effect } from \"effect\"\n\nconst parse = (input: string) =>\n  Effect.try({\n    // JSON.parse may throw for bad input\n    try: () => JSON.parse(input),\n    // remap the error\n    catch: (unknown) => new Error(`something went wrong ${unknown}`)\n  })\n\n//       Effect<any, Error, never>\n//      \nconst program = parse(\"\")"
    ],
    "since": "2.0.0",
    "category": "Creating Effects",
    "signature": "export declare const try: { <A, E>(options: { readonly try: LazyArg<A>; readonly catch: (error: unknown) => E; }): Effect<A, E>; <A>(thunk: LazyArg<A>): Effect<A, Cause.UnknownException>; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "let",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "import { Effect, pipe } from \"effect\"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind(\"x\", () => Effect.succeed(2)),\n  Effect.bind(\"y\", () => Effect.succeed(3)),\n  Effect.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n"
    ],
    "since": "2.0.0",
    "category": "Do notation",
    "signature": "export declare const let: { <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): <E, R>(self: Effect<A, E, R>) => Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E, R>; <A extends object, N extends string, E, R, B>(self: Effect<A, E, R>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E, R>; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "if",
    "description": "Executes one of two effects based on a condition evaluated by an effectful predicate.\n\nUse `if` to run one of two effects depending on whether the predicate effect\nevaluates to `true` or `false`. If the predicate is `true`, the `onTrue` effect\nis executed. If it is `false`, the `onFalse` effect is executed instead.",
    "deprecated": false,
    "examples": [
      "// Title: Simulating a Coin Flip\nimport { Effect, Random, Console } from \"effect\"\n\nconst flipTheCoin = Effect.if(Random.nextBoolean, {\n  onTrue: () => Console.log(\"Head\"), // Runs if the predicate is true\n  onFalse: () => Console.log(\"Tail\") // Runs if the predicate is false\n})\n\n// Effect.runFork(flipTheCoin)\n"
    ],
    "since": "2.0.0",
    "category": "Conditional Operators",
    "signature": "export declare const if: { <A1, E1, R1, A2, E2, R2>(options: { readonly onTrue: LazyArg<Effect<A1, E1, R1>>; readonly onFalse: LazyArg<Effect<A2, E2, R2>>; }): <E = never, R = never>(self: boolean | Effect<boolean, E, R>) => Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R>; <A1, E1, R1, A2, E2, R2, E = never, R = never>(self: boolean | Effect<boolean, E, R>, options: { readonly onTrue: LazyArg<Effect<A1, E1, R1>>; readonly onFalse: LazyArg<Effect<A2, E2, R2>>; }): Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "logWithLevel",
    "description": "Logs messages or error causes at a specified log level.\n\n**Details**\n\nThis function allows you to log one or more messages or error causes while\nspecifying the desired log level (e.g., DEBUG, INFO, ERROR). It provides\nflexibility in categorizing logs based on their importance or severity,\nmaking it easier to filter logs during debugging or production monitoring.",
    "deprecated": false,
    "examples": [
      "import { Cause, Effect, LogLevel } from \"effect\"\n\nconst program = Effect.logWithLevel(\n  LogLevel.Error,\n  \"Critical error encountered\",\n  Cause.die(\"System failure!\")\n)\n\n// Effect.runFork(program)\n// Output:\n// timestamp=... level=ERROR fiber=#0 message=Critical error encountered cause=\"Error: System failure!\""
    ],
    "since": "2.0.0",
    "category": "Logging",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "transposeOption",
    "description": "Converts an `Option` of an `Effect` into an `Effect` of an `Option`.\n\n**Details**\n\nThis function transforms an `Option<Effect<A, E, R>>` into an\n`Effect<Option<A>, E, R>`. If the `Option` is `None`, the resulting `Effect`\nwill immediately succeed with a `None` value. If the `Option` is `Some`, the\ninner `Effect` will be executed, and its result wrapped in a `Some`.",
    "deprecated": false,
    "examples": [
      "import { Effect, Option } from \"effect\"\n\n//       Option<Effect<number, never, never>>\n//      \nconst maybe = Option.some(Effect.succeed(42))\n\n//       Effect<Option<number>, never, never>\n//      \nconst result = Effect.transposeOption(maybe)\n\nconsole.log(Effect.runSync(result))\n// Output: { _id: 'Option', _tag: 'Some', value: 42 }"
    ],
    "since": "3.13.0",
    "category": "Optional Wrapping & Unwrapping",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "Tag",
    "description": "Creates a unique tag for a dependency, embedding the service's methods as\nstatic properties.\n\n**Details**\n\nThis function allows you to define a `Tag` for a service or dependency in\nyour application. The `Tag` not only acts as an identifier but also provides\ndirect access to the service's methods via static properties. This makes it\neasier to access and use the service in your code without manually managing\ncontexts.\n\nIn the example below, the fields of the service (in this case, the `notify`\nmethod) are turned into static properties of the Notifications class, making\nit easier to access them.",
    "deprecated": false,
    "examples": [
      "import { Effect } from \"effect\"\n\nclass Notifications extends Effect.Tag(\"Notifications\")<\n  Notifications,\n  { readonly notify: (message: string) => Effect.Effect<void> }\n>() {}\n\n// Create an effect that depends on the Notifications service\nconst action = Notifications.notify(\"Hello, world!\")"
    ],
    "since": "2.0.0",
    "category": "Context",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "Adapter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Adapter {\n  <A, E, R>(self: Effect<A, E, R>): Effect<A, E, R>\n  <A, _A, _E, _R>(a: A, ab: (a: A) => Effect<_A, _E, _R>): Effect<_A, _E, _R>\n  <A, B, _A, _E, _R>(a: A, ab: (a: A) => B, bc: (b: B) => Effect<_A, _E, _R>): Effect<_A, _E, _R>\n  <A, B, C, _A, _E, _R>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => Effect<_A, _E, _R>): Effect<_A, _E, _R>\n  <A, B, C, D, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (g: H) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => T,\n    tu: (s: T) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "Blocked",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Blocked<out A, out E> extends Effect<A, E> {\n  readonly _op: \"Blocked\"\n  readonly effect_instruction_i0: RequestBlock\n  readonly effect_instruction_i1: Effect<A, E>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "Effect",
    "description": "The `Effect` interface defines a value that describes a workflow or job,\nwhich can succeed or fail.\n\n**Details**\n\nThe `Effect` interface represents a computation that can model a workflow\ninvolving various types of operations, such as synchronous, asynchronous,\nconcurrent, and parallel interactions. It operates within a context of type\n`R`, and the result can either be a success with a value of type `A` or a\nfailure with an error of type `E`. The `Effect` is designed to handle complex\ninteractions with external resources, offering advanced features such as\nfiber-based concurrency, scheduling, interruption handling, and scalability.\nThis makes it suitable for tasks that require fine-grained control over\nconcurrency and error management.\n\nTo execute an `Effect` value, you need a `Runtime`, which provides the\nenvironment necessary to run and manage the computation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Effect<out A, out E = never, out R = never> extends Effect.Variance<A, E, R>, Pipeable {\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: EffectUnify<this>\n  readonly [Unify.ignoreSymbol]?: EffectUnifyIgnore\n  [Symbol.iterator](): EffectGenerator<Effect<A, E, R>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "EffectGenerator",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.0.0",
    "category": "Models",
    "signature": "export interface EffectGenerator<T extends Effect<any, any, any>> {\n  next(...args: ReadonlyArray<any>): IteratorResult<YieldWrap<T>, Effect.Success<T>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "EffectTypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Type lambdas",
    "signature": "export interface EffectTypeLambda extends TypeLambda {\n  readonly type: Effect<this[\"Target\"], this[\"Out1\"], this[\"Out2\"]>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "EffectUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface EffectUnify<A extends { [Unify.typeSymbol]?: any }>\n  extends Either.EitherUnify<A>, Option.OptionUnify<A>, Context.TagUnify<A>\n{\n  Effect?: () => A[Unify.typeSymbol] extends Effect<infer A0, infer E0, infer R0> | infer _ ? Effect<A0, E0, R0> : never\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "EffectUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface EffectUnifyIgnore {\n  Tag?: true\n  Option?: true\n  Either?: true\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "FunctionWithSpanOptions",
    "description": "Wraps a function that returns an effect with a new span for tracing.",
    "deprecated": false,
    "examples": [],
    "since": "3.2.0",
    "category": "Models",
    "signature": "export interface FunctionWithSpanOptions {\n  readonly name: string\n  readonly attributes?: Record<string, unknown> | undefined\n  readonly links?: ReadonlyArray<Tracer.SpanLink> | undefined\n  readonly parent?: Tracer.AnySpan | undefined\n  readonly root?: boolean | undefined\n  readonly context?: Context.Context<never> | undefined\n  readonly kind?: Tracer.SpanKind | undefined\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "Latch",
    "description": "A `Latch` is a synchronization primitive that allows you to control the\nexecution of fibers based on an open or closed state. It acts as a gate,\nwhere fibers can wait for the latch to open before proceeding.\n\n**Details**\n\nA `Latch` can be in one of two states: open or closed. Fibers can:\n- Wait for the latch to open using `await`.\n- Proceed only when the latch is open using `whenOpen`.\n- Open the latch to release all waiting fibers using `open`.\n- Close the latch to block fibers using `close`.\n\nAdditionally, fibers can be released without changing the state of the latch\nusing `release`.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "Latch",
    "signature": "export interface Latch extends Effect<void> {\n  /**\n   * Opens the latch, releasing all fibers waiting on it.\n   *\n   * **Details**\n   *\n   * Once the latch is opened, it remains open. Any fibers waiting on `await`\n   * will be released and can continue execution.\n   */\n  readonly open: Effect<void>\n\n  /**\n   * Releases all fibers waiting on the latch without opening it.\n   *\n   * **Details**\n   *\n   * This function lets waiting fibers proceed without permanently changing the\n   * state of the latch.\n   */\n  readonly release: Effect<void>\n\n  /**\n   * Waits for the latch to be opened.\n   *\n   * **Details**\n   *\n   * If the latch is already open, this effect completes immediately. Otherwise,\n   * it suspends the fiber until the latch is opened.\n   */\n  readonly await: Effect<void>\n\n  /**\n   * Closes the latch, blocking fibers from proceeding.\n   *\n   * **Details**\n   *\n   * This operation puts the latch into a closed state, requiring it to be\n   * reopened before waiting fibers can proceed.\n   */\n  readonly close: Effect<void>\n\n  /**\n   * Unsafely closes the latch, blocking fibers without effect guarantees.\n   *\n   * **Details**\n   *\n   * Use this operation cautiously, as it does not run within an effect context\n   * and bypasses runtime guarantees.\n   */\n  readonly unsafeClose: () => void\n\n  /**\n   * Runs the given effect only when the latch is open.\n   *\n   * **Details**\n   *\n   * This function ensures that the provided effect executes only if the latch\n   * is open. If the latch is closed, the fiber will wait until it opens.\n   */\n  readonly whenOpen: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: LatchUnify<this>\n  readonly [Unify.ignoreSymbol]?: LatchUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "LatchUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "Models",
    "signature": "export interface LatchUnify<A extends { [Unify.typeSymbol]?: any }> extends EffectUnify<A> {\n  Latch?: () => Latch\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "LatchUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "Models",
    "signature": "export interface LatchUnifyIgnore extends EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "Permit",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Semaphore",
    "signature": "export interface Permit {\n  readonly index: number\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "Semaphore",
    "description": "A semaphore is a synchronization mechanism used to manage access to a shared\nresource. In Effect, semaphores help control resource access or coordinate\ntasks within asynchronous, concurrent operations.\n\nA semaphore acts as a generalized mutex, allowing a set number of permits to\nbe held and released concurrently. Permits act like tickets, giving tasks or\nfibers controlled access to a shared resource. When no permits are available,\ntasks trying to acquire one will wait until a permit is released.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Semaphore",
    "signature": "export interface Semaphore {\n  /**\n   * Runs an effect with the given number of permits and releases the permits\n   * when the effect completes.\n   *\n   * **Details**\n   *\n   * This function acquires the specified number of permits before executing\n   * the provided effect. Once the effect finishes, the permits are released.\n   * If insufficient permits are available, the function will wait until they\n   * are released by other tasks.\n   */\n  withPermits(permits: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n\n  /**\n   * Runs an effect only if the specified number of permits are immediately\n   * available.\n   *\n   * **Details**\n   *\n   * This function attempts to acquire the specified number of permits. If they\n   * are available, it runs the effect and releases the permits after the effect\n   * completes. If permits are not available, the effect does not execute, and\n   * the result is `Option.none`.\n   */\n  withPermitsIfAvailable(permits: number): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>\n\n  /**\n   * Acquires the specified number of permits and returns the resulting\n   * available permits, suspending the task if they are not yet available.\n   * Concurrent pending `take` calls are processed in a first-in, first-out manner.\n   */\n  take(permits: number): Effect<number>\n\n  /**\n   * Releases the specified number of permits and returns the resulting\n   * available permits.\n   */\n  release(permits: number): Effect<number>\n\n  /**\n   * Releases all permits held by this semaphore and returns the resulting available permits.\n   */\n  releaseAll: Effect<number>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effect",
      "path": [
        "src",
        "Effect.ts"
      ]
    },
    "project": "effect",
    "name": "EffectTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export type EffectTypeId = typeof EffectTypeId"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Effectable",
      "path": [
        "src",
        "Effectable.ts"
      ]
    },
    "project": "effect",
    "name": "Class",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare class Class<A, E, R>"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Effectable",
      "path": [
        "src",
        "Effectable.ts"
      ]
    },
    "project": "effect",
    "name": "StructuralClass",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare class StructuralClass<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effectable",
      "path": [
        "src",
        "Effectable.ts"
      ]
    },
    "project": "effect",
    "name": "EffectTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "export declare const EffectTypeId: typeof Effect.EffectTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effectable",
      "path": [
        "src",
        "Effectable.ts"
      ]
    },
    "project": "effect",
    "name": "StreamTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "export declare const StreamTypeId: typeof Stream.StreamTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effectable",
      "path": [
        "src",
        "Effectable.ts"
      ]
    },
    "project": "effect",
    "name": "SinkTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "export declare const SinkTypeId: typeof Sink.SinkTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effectable",
      "path": [
        "src",
        "Effectable.ts"
      ]
    },
    "project": "effect",
    "name": "ChannelTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "export declare const ChannelTypeId: typeof Channel.ChannelTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effectable",
      "path": [
        "src",
        "Effectable.ts"
      ]
    },
    "project": "effect",
    "name": "EffectPrototype",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "prototypes",
    "signature": "export declare const EffectPrototype: Effect.Effect<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effectable",
      "path": [
        "src",
        "Effectable.ts"
      ]
    },
    "project": "effect",
    "name": "CommitPrototype",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "prototypes",
    "signature": "export declare const CommitPrototype: Effect.Effect<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Effectable",
      "path": [
        "src",
        "Effectable.ts"
      ]
    },
    "project": "effect",
    "name": "StructuralCommitPrototype",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "prototypes",
    "signature": "export declare const StructuralCommitPrototype: Effect.Effect<never, never, never>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Effectable",
      "path": [
        "src",
        "Effectable.ts"
      ]
    },
    "project": "effect",
    "name": "CommitPrimitive",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface CommitPrimitive {\n  new<A, E = never, R = never>(): Effect.Effect<A, E, R>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effectable",
      "path": [
        "src",
        "Effectable.ts"
      ]
    },
    "project": "effect",
    "name": "ChannelTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "export type ChannelTypeId = Channel.ChannelTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effectable",
      "path": [
        "src",
        "Effectable.ts"
      ]
    },
    "project": "effect",
    "name": "EffectTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "export type EffectTypeId = Effect.EffectTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effectable",
      "path": [
        "src",
        "Effectable.ts"
      ]
    },
    "project": "effect",
    "name": "SinkTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "export type SinkTypeId = Sink.SinkTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Effectable",
      "path": [
        "src",
        "Effectable.ts"
      ]
    },
    "project": "effect",
    "name": "StreamTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "export type StreamTypeId = Stream.StreamTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "right",
    "description": "Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\nof this structure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const right: <R>(right: R) => Either<R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "left",
    "description": "Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\nstructure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const left: <L>(left: L) => Either<never, L>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "fromNullable",
    "description": "Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\nthe provided default as a `Left`.",
    "deprecated": false,
    "examples": [
      "import { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))\nassert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromNullable: { <R, L>(onNullable: (right: R) => L): (self: R) => Either<NonNullable<R>, L>; <R, L>(self: R, onNullable: (right: R) => L): Either<NonNullable<R>, L>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "fromOption",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { Either, Option } from \"effect\"\n\nassert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))\nassert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromOption: { <L>(onNone: () => L): <R>(self: Option<R>) => Either<R, L>; <R, L>(self: Option<R>, onNone: () => L): Either<R, L>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "isEither",
    "description": "Tests if a value is a `Either`.",
    "deprecated": false,
    "examples": [
      "import { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.isEither(Either.right(1)), true)\nassert.deepStrictEqual(Either.isEither(Either.left(\"a\")), true)\nassert.deepStrictEqual(Either.isEither({ right: 1 }), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isEither: (input: unknown) => input is Either<unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "isLeft",
    "description": "Determine if a `Either` is a `Left`.",
    "deprecated": false,
    "examples": [
      "import { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.isLeft(Either.right(1)), false)\nassert.deepStrictEqual(Either.isLeft(Either.left(\"a\")), true)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isLeft: <R, L>(self: Either<R, L>) => self is Left<L, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "isRight",
    "description": "Determine if a `Either` is a `Right`.",
    "deprecated": false,
    "examples": [
      "import { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.isRight(Either.right(1)), true)\nassert.deepStrictEqual(Either.isRight(Either.left(\"a\")), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isRight: <R, L>(self: Either<R, L>) => self is Right<L, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "getRight",
    "description": "Converts a `Either` to an `Option` discarding the `Left`.",
    "deprecated": false,
    "examples": [
      "import { Either, Option } from \"effect\"\n\nassert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))\nassert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const getRight: <R, L>(self: Either<R, L>) => Option<R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "getLeft",
    "description": "Converts a `Either` to an `Option` discarding the value.",
    "deprecated": false,
    "examples": [
      "import { Either, Option } from \"effect\"\n\nassert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())\nassert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const getLeft: <R, L>(self: Either<R, L>) => Option<L>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "mapBoth",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapBoth: { <L, L2, R, R2>(options: { readonly onLeft: (left: L) => L2; readonly onRight: (right: R) => R2; }): (self: Either<R, L>) => Either<R2, L2>; <L, R, L2, R2>(self: Either<R, L>, options: { readonly onLeft: (left: L) => L2; readonly onRight: (right: R) => R2; }): Either<R2, L2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "mapLeft",
    "description": "Maps the `Left` side of an `Either` value to a new `Either` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapLeft: { <L, L2>(f: (left: L) => L2): <R>(self: Either<R, L>) => Either<R, L2>; <R, L, L2>(self: Either<R, L>, f: (left: L) => L2): Either<R, L2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Maps the `Right` side of an `Either` value to a new `Either` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <R, R2>(f: (right: R) => R2): <L>(self: Either<R, L>) => Either<R2, L>; <R, L, R2>(self: Either<R, L>, f: (right: R) => R2): Either<R2, L>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\nif the value is a `Right` the inner value is applied to the `onRight` function.",
    "deprecated": false,
    "examples": [
      "import { pipe, Either } from \"effect\"\n\nconst onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n\nconst onRight = (value: number): string => `Ok: ${value}`\n\nassert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')\nassert.deepStrictEqual(\n  pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),\n  'strings: string 1, string 2'\n)"
    ],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "export declare const match: { <L, B, R, C = B>(options: { readonly onLeft: (left: L) => B; readonly onRight: (right: R) => C; }): (self: Either<R, L>) => B | C; <R, L, B, C = B>(self: Either<R, L>, options: { readonly onLeft: (left: L) => B; readonly onRight: (right: R) => C; }): B | C; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "liftPredicate",
    "description": "Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\nor `Left` of the result of the provided function if the predicate returns false",
    "deprecated": false,
    "examples": [
      "import { pipe, Either } from \"effect\"\n\nconst isPositive = (n: number): boolean => n > 0\n\nassert.deepStrictEqual(\n  pipe(\n    1,\n    Either.liftPredicate(isPositive, n => `${n} is not positive`)\n  ),\n  Either.right(1)\n)\nassert.deepStrictEqual(\n  pipe(\n    0,\n    Either.liftPredicate(isPositive, n => `${n} is not positive`)\n  ),\n  Either.left(\"0 is not positive\")\n)"
    ],
    "since": "3.4.0",
    "category": "lifting",
    "signature": "export declare const liftPredicate: { <A, B extends A, E>(refinement: Refinement<NoInfer<A>, B>, orLeftWith: (a: NoInfer<A>) => E): (a: A) => Either<B, E>; <A, E>(predicate: Predicate<NoInfer<A>>, orLeftWith: (a: NoInfer<A>) => E): (a: A) => Either<A, E>; <A, E, B extends A>(self: A, refinement: Refinement<A, B>, orLeftWith: (a: A) => E): Either<B, E>; <A, E>(self: A, predicate: Predicate<NoInfer<A>>, orLeftWith: (a: NoInfer<A>) => E): Either<A, E>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "filterOrLeft",
    "description": "Filter the right value with the provided function.\nIf the predicate fails, set the left value with the result of the provided function.",
    "deprecated": false,
    "examples": [
      "import { pipe, Either } from \"effect\"\n\nconst isPositive = (n: number): boolean => n > 0\n\nassert.deepStrictEqual(\n  pipe(\n    Either.right(1),\n    Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n  ),\n  Either.right(1)\n)\nassert.deepStrictEqual(\n  pipe(\n    Either.right(0),\n    Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n  ),\n  Either.left(\"0 is not positive\")\n)"
    ],
    "since": "2.0.0",
    "category": "filtering & conditionals",
    "signature": "export declare const filterOrLeft: { <R, B extends R, L2>(refinement: Refinement<NoInfer<R>, B>, orLeftWith: (right: NoInfer<R>) => L2): <L>(self: Either<R, L>) => Either<B, L2 | L>; <R, L2>(predicate: Predicate<NoInfer<R>>, orLeftWith: (right: NoInfer<R>) => L2): <L>(self: Either<R, L>) => Either<R, L2 | L>; <R, L, B extends R, L2>(self: Either<R, L>, refinement: Refinement<R, B>, orLeftWith: (right: R) => L2): Either<B, L | L2>; <R, L, E2>(self: Either<R, L>, predicate: Predicate<R>, orLeftWith: (right: R) => E2): Either<R, L | E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "merge",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const merge: <R, L>(self: Either<R, L>) => L | R"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "getOrElse",
    "description": "Returns the wrapped value if it's a `Right` or a default value if is a `Left`.",
    "deprecated": false,
    "examples": [
      "import { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + \"!\"), 1)\nassert.deepStrictEqual(Either.getOrElse(Either.left(\"not a number\"), (error) => error + \"!\"), \"not a number!\")"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const getOrElse: { <L, R2>(onLeft: (left: L) => R2): <R>(self: Either<R, L>) => R2 | R; <R, L, R2>(self: Either<R, L>, onLeft: (left: L) => R2): R | R2; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "getOrNull",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.getOrNull(Either.right(1)), 1)\nassert.deepStrictEqual(Either.getOrNull(Either.left(\"a\")), null)"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const getOrNull: <R, L>(self: Either<R, L>) => R | null"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "getOrUndefined",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.getOrUndefined(Either.right(1)), 1)\nassert.deepStrictEqual(Either.getOrUndefined(Either.left(\"a\")), undefined)"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const getOrUndefined: <R, L>(self: Either<R, L>) => R | undefined"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "getOrThrowWith",
    "description": "Extracts the value of an `Either` or throws if the `Either` is `Left`.\n\nIf a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.",
    "deprecated": false,
    "examples": [
      "import { Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),\n  1\n)\nassert.throws(() => Either.getOrThrowWith(Either.left(\"error\"), () => new Error('Unexpected Left')))"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const getOrThrowWith: { <L>(onLeft: (left: L) => unknown): <A>(self: Either<A, L>) => A; <R, L>(self: Either<R, L>, onLeft: (left: L) => unknown): R; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "getOrThrow",
    "description": "Extracts the value of an `Either` or throws if the `Either` is `Left`.\n\nThe thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.",
    "deprecated": false,
    "examples": [
      "import { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)\nassert.throws(() => Either.getOrThrow(Either.left(\"error\")))"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const getOrThrow: <R, L>(self: Either<R, L>) => R"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "orElse",
    "description": "Returns `self` if it is a `Right` or `that` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElse: { <L, R2, L2>(that: (left: L) => Either<R2, L2>): <R>(self: Either<R, L>) => Either<R | R2, L2>; <R, L, R2, L2>(self: Either<R, L>, that: (left: L) => Either<R2, L2>): Either<R | R2, L2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMap: { <R, R2, L2>(f: (right: R) => Either<R2, L2>): <L>(self: Either<R, L>) => Either<R2, L | L2>; <R, L, R2, L2>(self: Either<R, L>, f: (right: R) => Either<R2, L2>): Either<R2, L | L2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "andThen",
    "description": "Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const andThen: { <R, R2, L2>(f: (right: R) => Either<R2, L2>): <L>(self: Either<R, L>) => Either<R2, L | L2>; <R2, L2>(f: Either<R2, L2>): <L, R1>(self: Either<R1, L>) => Either<R2, L | L2>; <R, R2>(f: (right: R) => R2): <L>(self: Either<R, L>) => Either<R2, L>; <R2>(right: NotFunction<R2>): <R1, L>(self: Either<R1, L>) => Either<R2, L>; <R, L, R2, L2>(self: Either<R, L>, f: (right: R) => Either<R2, L2>): Either<R2, L | L2>; <R, L, R2, L2>(self: Either<R, L>, f: Either<R2, L2>): Either<R2, L | L2>; <R, L, R2>(self: Either<R, L>, f: (right: R) => R2): Either<R2, L>; <R, L, R2>(self: Either<R, L>, f: NotFunction<R2>): Either<R2, L>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWith: { <R2, L2, R, B>(that: Either<R2, L2>, f: (right: R, right2: R2) => B): <L>(self: Either<R, L>) => Either<B, L2 | L>; <R, L, R2, L2, B>(self: Either<R, L>, that: Either<R2, L2>, f: (right: R, right2: R2) => B): Either<B, L | L2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "ap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "export declare const ap: { <R, L2>(that: Either<R, L2>): <R2, L>(self: Either<(right: R) => R2, L>) => Either<R2, L | L2>; <R, R2, L, L2>(self: Either<(right: R) => R2, L>, that: Either<R, L2>): Either<R2, L | L2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "Do",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "import { Either, pipe } from \"effect\"\n\nconst result = pipe(\n  Either.Do,\n  Either.bind(\"x\", () => Either.right(2)),\n  Either.bind(\"y\", () => Either.right(3)),\n  Either.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))"
    ],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "export declare const Do: Either<{}, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "bind",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "import { Either, pipe } from \"effect\"\n\nconst result = pipe(\n  Either.Do,\n  Either.bind(\"x\", () => Either.right(2)),\n  Either.bind(\"y\", () => Either.right(3)),\n  Either.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))"
    ],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "export declare const bind: { <N extends string, A extends object, B, L2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Either<B, L2>): <L1>(self: Either<A, L1>) => Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, L1 | L2>; <A extends object, L1, N extends string, B, L2>(self: Either<A, L1>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Either<B, L2>): Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, L1 | L2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "bindTo",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "import { Either, pipe } from \"effect\"\n\nconst result = pipe(\n  Either.Do,\n  Either.bind(\"x\", () => Either.right(2)),\n  Either.bind(\"y\", () => Either.right(3)),\n  Either.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))"
    ],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "export declare const bindTo: { <N extends string>(name: N): <R, L>(self: Either<R, L>) => Either<{ [K in N]: R; }, L>; <R, L, N extends string>(self: Either<R, L>, name: N): Either<{ [K in N]: R; }, L>; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "void",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "constructors",
    "signature": "export declare const void: Either<void, never>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "try",
    "description": "Imports a synchronous side-effect into a pure `Either` value, translating any\nthrown exceptions into typed failed eithers creating with `Either.left`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const try: { <R, L>(options: { readonly try: LazyArg<R>; readonly catch: (error: unknown) => L; }): Either<R, L>; <R>(evaluate: LazyArg<R>): Either<R, unknown>; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "let",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "import { Either, pipe } from \"effect\"\n\nconst result = pipe(\n  Either.Do,\n  Either.bind(\"x\", () => Either.right(2)),\n  Either.bind(\"y\", () => Either.right(3)),\n  Either.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))\n"
    ],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "export declare const let: { <N extends string, R extends object, B>(name: Exclude<N, keyof R>, f: (r: NoInfer<R>) => B): <L>(self: Either<R, L>) => Either<{ [K in N | keyof R]: K extends keyof R ? R[K] : B; }, L>; <R extends object, L, N extends string, B>(self: Either<R, L>, name: Exclude<N, keyof R>, f: (r: NoInfer<R>) => B): Either<{ [K in N | keyof R]: K extends keyof R ? R[K] : B; }, L>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "equivalence",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "all",
    "description": "Takes a structure of `Either`s and returns an `Either` of values with the same structure.\n\n- If a tuple is supplied, then the returned `Either` will contain a tuple with the same length.\n- If a struct is supplied, then the returned `Either` will contain a struct with the same keys.\n- If an iterable is supplied, then the returned `Either` will contain an array.",
    "deprecated": false,
    "examples": [
      "import { Either } from \"effect\"\n\nassert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))\nassert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.right(\"hello\") }), Either.right({ right: 1, b: \"hello\" }))\nassert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left(\"error\") }), Either.left(\"error\"))"
    ],
    "since": "2.0.0",
    "category": "combining",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "flip",
    "description": "Returns an `Either` that swaps the error/success cases. This allows you to\nuse all methods on the error channel, possibly before flipping back.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "gen",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "generators",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "EitherTypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface EitherTypeLambda extends TypeLambda {\n  readonly type: Either<this[\"Target\"], this[\"Out1\"]>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "EitherUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface EitherUnify<A extends { [Unify.typeSymbol]?: any }> {\n  Either?: () => A[Unify.typeSymbol] extends Either<infer R0, infer L0> | infer _ ? Either<R0, L0> : never\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "EitherUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface EitherUnifyIgnore {}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "Left",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Left<out L, out R> extends Pipeable, Inspectable {\n  readonly _tag: \"Left\"\n  readonly _op: \"Left\"\n  readonly left: L\n  readonly [TypeId]: {\n    readonly _R: Covariant<R>\n    readonly _L: Covariant<L>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: EitherUnify<this>\n  [Unify.ignoreSymbol]?: EitherUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "Right",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Right<out L, out R> extends Pipeable, Inspectable {\n  readonly _tag: \"Right\"\n  readonly _op: \"Right\"\n  readonly right: R\n  readonly [TypeId]: {\n    readonly _R: Covariant<R>\n    readonly _L: Covariant<L>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: EitherUnify<this>\n  [Unify.ignoreSymbol]?: EitherUnifyIgnore\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "Either",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type Either<R, L = never> = Left<L, R> | Right<L, R>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Either",
      "path": [
        "src",
        "Either.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "DecodeExceptionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const DecodeExceptionTypeId: typeof DecodeExceptionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "DecodeException",
    "description": "Creates a checked exception which occurs when decoding fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "errors",
    "signature": "export declare const DecodeException: (input: string, message?: string) => DecodeException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "isDecodeException",
    "description": "Returns `true` if the specified value is an `DecodeException`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isDecodeException: (u: unknown) => u is DecodeException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "EncodeExceptionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "symbols",
    "signature": "export declare const EncodeExceptionTypeId: typeof EncodeExceptionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "EncodeException",
    "description": "Creates a checked exception which occurs when encoding fails.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "errors",
    "signature": "export declare const EncodeException: (input: string, message?: string) => EncodeException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "isEncodeException",
    "description": "Returns `true` if the specified value is an `Exception`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "refinements",
    "signature": "export declare const isEncodeException: (u: unknown) => u is EncodeException"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "encodeBase64",
    "description": "Encodes the given value into a base64 (RFC4648) `string`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "decodeBase64",
    "description": "Decodes a base64 (RFC4648) encoded `string` into a `Uint8Array`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "decodeBase64String",
    "description": "Decodes a base64 (RFC4648) encoded `string` into a UTF-8 `string`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "encodeBase64Url",
    "description": "Encodes the given value into a base64 (URL) `string`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "decodeBase64Url",
    "description": "Decodes a base64 (URL) encoded `string` into a `Uint8Array`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "decodeBase64UrlString",
    "description": "Decodes a base64 (URL) encoded `string` into a UTF-8 `string`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "encodeHex",
    "description": "Encodes the given value into a hex `string`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "decodeHex",
    "description": "Decodes a hex encoded `string` into a `Uint8Array`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "decodeHexString",
    "description": "Decodes a hex encoded `string` into a UTF-8 `string`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "encodeUriComponent",
    "description": "Encodes a UTF-8 `string` into a URI component `string`.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "decodeUriComponent",
    "description": "Decodes a URI component `string` into a UTF-8 `string`.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "DecodeException",
    "description": "Represents a checked exception which occurs when decoding fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface DecodeException {\n  readonly _tag: \"DecodeException\"\n  readonly [DecodeExceptionTypeId]: DecodeExceptionTypeId\n  readonly input: string\n  readonly message?: string\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "EncodeException",
    "description": "Represents a checked exception which occurs when encoding fails.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "models",
    "signature": "export interface EncodeException {\n  readonly _tag: \"EncodeException\"\n  readonly [EncodeExceptionTypeId]: EncodeExceptionTypeId\n  readonly input: string\n  readonly message?: string\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "DecodeExceptionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type DecodeExceptionTypeId = typeof DecodeExceptionTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Encoding",
      "path": [
        "src",
        "Encoding.ts"
      ]
    },
    "project": "effect",
    "name": "EncodeExceptionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "symbols",
    "signature": "export type EncodeExceptionTypeId = typeof EncodeExceptionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equal",
      "path": [
        "src",
        "Equal.ts"
      ]
    },
    "project": "effect",
    "name": "symbol",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const symbol: typeof symbol"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equal",
      "path": [
        "src",
        "Equal.ts"
      ]
    },
    "project": "effect",
    "name": "equals",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "equality",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equal",
      "path": [
        "src",
        "Equal.ts"
      ]
    },
    "project": "effect",
    "name": "isEqual",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equal",
      "path": [
        "src",
        "Equal.ts"
      ]
    },
    "project": "effect",
    "name": "equivalence",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Equal",
      "path": [
        "src",
        "Equal.ts"
      ]
    },
    "project": "effect",
    "name": "Equal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Equal extends Hash.Hash {\n  [symbol](that: Equal): boolean\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "string",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const string: Equivalence<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "number",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const number: Equivalence<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "boolean",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const boolean: Equivalence<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "bigint",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const bigint: Equivalence<bigint>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "symbol",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const symbol: Equivalence<symbol>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "combine",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "export declare const combine: { <A>(that: Equivalence<A>): (self: Equivalence<A>) => Equivalence<A>; <A>(self: Equivalence<A>, that: Equivalence<A>): Equivalence<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "combineMany",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "export declare const combineMany: { <A>(collection: Iterable<Equivalence<A>>): (self: Equivalence<A>) => Equivalence<A>; <A>(self: Equivalence<A>, collection: Iterable<Equivalence<A>>): Equivalence<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "mapInput",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapInput: { <B, A>(f: (b: B) => A): (self: Equivalence<A>) => Equivalence<B>; <A, B>(self: Equivalence<A>, f: (b: B) => A): Equivalence<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "Date",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Date: Equivalence<Date>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "product",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "export declare const product: { <B>(that: Equivalence<B>): <A>(self: Equivalence<A>) => Equivalence<readonly [A, B]>; <A, B>(self: Equivalence<A>, that: Equivalence<B>): Equivalence<readonly [A, B]>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "strict",
    "description": "Return an `Equivalence` that uses strict equality (===) to compare values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "combineAll",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "all",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "productMany",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "tuple",
    "description": "Similar to `Promise.all` but operates on `Equivalence`s.\n\n```\n[Equivalence<A>, Equivalence<B>, ...] -> Equivalence<[A, B, ...]>\n```\n\nGiven a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\nby applying each `Equivalence` to the corresponding element of the tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "array",
    "description": "Creates a new `Equivalence` for an array of values based on a given `Equivalence` for the elements of the array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "struct",
    "description": "Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct\nby applying each `Equivalence` to the corresponding property of the struct.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "Equivalence",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type class",
    "signature": "export interface Equivalence<in A> {\n  (self: A, that: A): boolean\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Equivalence",
      "path": [
        "src",
        "Equivalence.ts"
      ]
    },
    "project": "effect",
    "name": "EquivalenceTypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface EquivalenceTypeLambda extends TypeLambda {\n  readonly type: Equivalence<this[\"Target\"]>\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ExecutionStrategy",
      "path": [
        "src",
        "ExecutionStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "sequential",
    "description": "Execute effects sequentially.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sequential: ExecutionStrategy"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ExecutionStrategy",
      "path": [
        "src",
        "ExecutionStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "parallel",
    "description": "Execute effects in parallel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const parallel: ExecutionStrategy"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ExecutionStrategy",
      "path": [
        "src",
        "ExecutionStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "parallelN",
    "description": "Execute effects in parallel, up to the specified number of concurrent fibers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const parallelN: (parallelism: number) => ExecutionStrategy"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ExecutionStrategy",
      "path": [
        "src",
        "ExecutionStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "isSequential",
    "description": "Returns `true` if the specified `ExecutionStrategy` is an instance of\n`Sequential`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isSequential: (self: ExecutionStrategy) => self is Sequential"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ExecutionStrategy",
      "path": [
        "src",
        "ExecutionStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "isParallel",
    "description": "Returns `true` if the specified `ExecutionStrategy` is an instance of\n`Sequential`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isParallel: (self: ExecutionStrategy) => self is Parallel"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ExecutionStrategy",
      "path": [
        "src",
        "ExecutionStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "isParallelN",
    "description": "Returns `true` if the specified `ExecutionStrategy` is an instance of\n`Sequential`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isParallelN: (self: ExecutionStrategy) => self is ParallelN"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ExecutionStrategy",
      "path": [
        "src",
        "ExecutionStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Folds over the specified `ExecutionStrategy` using the provided case\nfunctions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const match: { <A>(options: { readonly onSequential: LazyArg<A>; readonly onParallel: LazyArg<A>; readonly onParallelN: (n: number) => A; }): (self: ExecutionStrategy) => A; <A>(self: ExecutionStrategy, options: { readonly onSequential: LazyArg<A>; readonly onParallel: LazyArg<A>; readonly onParallelN: (n: number) => A; }): A; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ExecutionStrategy",
      "path": [
        "src",
        "ExecutionStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "Parallel",
    "description": "Execute effects in parallel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Parallel {\n  readonly _tag: \"Parallel\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ExecutionStrategy",
      "path": [
        "src",
        "ExecutionStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "ParallelN",
    "description": "Execute effects in parallel, up to the specified number of concurrent fibers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ParallelN {\n  readonly _tag: \"ParallelN\"\n  readonly parallelism: number\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ExecutionStrategy",
      "path": [
        "src",
        "ExecutionStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "Sequential",
    "description": "Execute effects sequentially.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Sequential {\n  readonly _tag: \"Sequential\"\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ExecutionStrategy",
      "path": [
        "src",
        "ExecutionStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "ExecutionStrategy",
    "description": "Describes a strategy for evaluating multiple effects, potentially in\nparallel.\n\nThere are 3 possible execution strategies: `Sequential`, `Parallel`,\n`ParallelN`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type ExecutionStrategy = Sequential | Parallel | ParallelN"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "isExit",
    "description": "Returns `true` if the specified value is an `Exit`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isExit: (u: unknown) => u is Exit<unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "isFailure",
    "description": "Returns `true` if the specified `Exit` is a `Failure`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isFailure: <A, E>(self: Exit<A, E>) => self is Failure<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "isSuccess",
    "description": "Returns `true` if the specified `Exit` is a `Success`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isSuccess: <A, E>(self: Exit<A, E>) => self is Success<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "isInterrupted",
    "description": "Returns `true` if the specified exit is a `Failure` **and** the `Cause` of\nthe failure was due to interruption, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isInterrupted: <A, E>(self: Exit<A, E>) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "as",
    "description": "Maps the `Success` value of the specified exit to the provided constant\nvalue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const as: { <A2>(value: A2): <A, E>(self: Exit<A, E>) => Exit<A2, E>; <A, E, A2>(self: Exit<A, E>, value: A2): Exit<A2, E>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "asVoid",
    "description": "Maps the `Success` value of the specified exit to a void.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const asVoid: <A, E>(self: Exit<A, E>) => Exit<void, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "causeOption",
    "description": "Returns a `Some<Cause<E>>` if the specified exit is a `Failure`, `None`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const causeOption: <A, E>(self: Exit<A, E>) => Option.Option<Cause.Cause<E>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "all",
    "description": "Collects all of the specified exit values into a `Some<Exit<List<A>, E>>`. If\nthe provided iterable contains no elements, `None` will be returned.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const all: <A, E>(exits: Iterable<Exit<A, E>>, options?: { readonly parallel?: boolean | undefined; } | undefined) => Option.Option<Exit<Array<A>, E>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "die",
    "description": "Constructs a new `Exit.Failure` from the specified unrecoverable defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const die: (defect: unknown) => Exit<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "exists",
    "description": "Executes the predicate on the value of the specified exit if it is a\n`Success`, otherwise returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const exists: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E>(self: Exit<A, E>) => self is Exit<B>; <A>(predicate: Predicate<NoInfer<A>>): <E>(self: Exit<A, E>) => boolean; <A, E, B extends A>(self: Exit<A, E>, refinement: Refinement<A, B>): self is Exit<B>; <A, E>(self: Exit<A, E>, predicate: Predicate<A>): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": "Constructs a new `Exit.Failure` from the specified recoverable error of type\n`E`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fail: <E>(error: E) => Exit<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "failCause",
    "description": "Constructs a new `Exit.Failure` from the specified `Cause` of type `E`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failCause: <E>(cause: Cause.Cause<E>) => Exit<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMap: { <A, A2, E2>(f: (a: A) => Exit<A2, E2>): <E>(self: Exit<A, E>) => Exit<A2, E2 | E>; <A, E, E2, A2>(self: Exit<A, E>, f: (a: A) => Exit<A2, E2>): Exit<A2, E | E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "flatMapEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMapEffect: { <A, E, A2, E2, R>(f: (a: A) => Effect.Effect<Exit<A2, E>, E2, R>): (self: Exit<A, E>) => Effect.Effect<Exit<A2, E>, E2, R>; <A, E, A2, E2, R>(self: Exit<A, E>, f: (a: A) => Effect.Effect<Exit<A2, E>, E2, R>): Effect.Effect<Exit<A2, E>, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "flatten",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatten: <A, E, E2>(self: Exit<Exit<A, E>, E2>) => Exit<A, E | E2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "forEachEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const forEachEffect: { <A, B, E2, R>(f: (a: A) => Effect.Effect<B, E2, R>): <E>(self: Exit<A, E>) => Effect.Effect<Exit<B, E2 | E>, never, R>; <A, E, B, E2, R>(self: Exit<A, E>, f: (a: A) => Effect.Effect<B, E2, R>): Effect.Effect<Exit<B, E | E2>, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "fromEither",
    "description": "Converts an `Either<R, L>` into an `Exit<R, L>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "export declare const fromEither: <R, L>(either: Either.Either<R, L>) => Exit<R, L>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "fromOption",
    "description": "Converts an `Option<A>` into an `Exit<void, A>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "export declare const fromOption: <A>(option: Option.Option<A>) => Exit<A, void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "getOrElse",
    "description": "Returns the `A` if specified exit is a `Success`, otherwise returns the\nalternate `A` value computed from the specified function which receives the\n`Cause<E>` of the exit `Failure`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const getOrElse: { <E, A2>(orElse: (cause: Cause.Cause<E>) => A2): <A>(self: Exit<A, E>) => A2 | A; <A, E, A2>(self: Exit<A, E>, orElse: (cause: Cause.Cause<E>) => A2): A | A2; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "interrupt",
    "description": "Constructs a new `Exit.Failure` from the specified `FiberId` indicating that\nthe `Fiber` running an `Effect` workflow was terminated due to interruption.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const interrupt: (fiberId: FiberId.FiberId) => Exit<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Maps over the `Success` value of the specified exit using the provided\nfunction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <A, B>(f: (a: A) => B): <E>(self: Exit<A, E>) => Exit<B, E>; <A, E, B>(self: Exit<A, E>, f: (a: A) => B): Exit<B, E>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "mapBoth",
    "description": "Maps over the `Success` and `Failure` cases of the specified exit using the\nprovided functions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapBoth: { <E, A, E2, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): (self: Exit<A, E>) => Exit<A2, E2>; <A, E, E2, A2>(self: Exit<A, E>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Exit<A2, E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "mapError",
    "description": "Maps over the error contained in the `Failure` of the specified exit using\nthe provided function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapError: { <E, E2>(f: (e: E) => E2): <A>(self: Exit<A, E>) => Exit<A, E2>; <A, E, E2>(self: Exit<A, E>, f: (e: E) => E2): Exit<A, E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "mapErrorCause",
    "description": "Maps over the `Cause` contained in the `Failure` of the specified exit using\nthe provided function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapErrorCause: { <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A>(self: Exit<A, E>) => Exit<A, E2>; <E, A, E2>(self: Exit<A, E>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Exit<A, E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const match: { <E, A, Z1, Z2>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Z1; readonly onSuccess: (a: A) => Z2; }): (self: Exit<A, E>) => Z1 | Z2; <A, E, Z1, Z2>(self: Exit<A, E>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Z1; readonly onSuccess: (a: A) => Z2; }): Z1 | Z2; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "matchEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const matchEffect: { <E, A2, E2, R, A, A3, E3, R2>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>; readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>; }): (self: Exit<A, E>) => Effect.Effect<A2 | A3, E2 | E3, R | R2>; <A, E, A2, E2, R, A3, E3, R2>(self: Exit<A, E>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>; readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>; }): Effect.Effect<A2 | A3, E2 | E3, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": "Constructs a new `Exit.Success` containing the specified value of type `A`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const succeed: <A>(value: A) => Exit<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Sequentially zips the this result with the specified result or else returns\nthe failed `Cause<E | E2>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zip: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Sequentially zips the this result with the specified result discarding the\nsecond element of the tuple or else returns the failed `Cause<E | E2>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipLeft: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Sequentially zips the this result with the specified result discarding the\nfirst element of the tuple or else returns the failed `Cause<E | E2>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipRight: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "zipPar",
    "description": "Parallelly zips the this result with the specified result or else returns\nthe failed `Cause<E | E2>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipPar: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "zipParLeft",
    "description": "Parallelly zips the this result with the specified result discarding the\nsecond element of the tuple or else returns the failed `Cause<E | E2>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipParLeft: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "zipParRight",
    "description": "Parallelly zips the this result with the specified result discarding the\nfirst element of the tuple or else returns the failed `Cause<E | E2>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipParRight: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Zips this exit together with that exit using the specified combination\nfunctions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWith: { <B, E2, A, C, E>(that: Exit<B, E2>, options: { readonly onSuccess: (a: A, b: B) => C; readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<any>; }): (self: Exit<A, E>) => Exit<C, any>; <A, E, B, E2, C>(self: Exit<A, E>, that: Exit<B, E2>, options: { readonly onSuccess: (a: A, b: B) => C; readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>; }): Exit<C, E | E2>; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "void",
    "description": "Represents an `Exit` which succeeds with `undefined`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const void: Exit<void, never>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "ExitUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ExitUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Exit?: () => A[Unify.typeSymbol] extends Exit<infer A0, infer E0> | infer _ ? Exit<A0, E0> : never\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "ExitUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ExitUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "Failure",
    "description": "Represents a failed `Effect` workflow containing the `Cause` of the failure\nof type `E`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Failure<out A, out E> extends Effect.Effect<A, E>, Pipeable, Inspectable {\n  readonly _tag: \"Failure\"\n  readonly _op: \"Failure\"\n  readonly cause: Cause.Cause<E>\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: ExitUnify<this>\n  [Unify.ignoreSymbol]?: ExitUnifyIgnore\n  /** @internal */\n  readonly effect_instruction_i0: Cause.Cause<E>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "Success",
    "description": "Represents a successful `Effect` workflow and containing the returned value\nof type `A`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Success<out A, out E> extends Effect.Effect<A, E>, Pipeable, Inspectable {\n  readonly _tag: \"Success\"\n  readonly _op: \"Success\"\n  readonly value: A\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: ExitUnify<this>\n  [Unify.ignoreSymbol]?: ExitUnifyIgnore\n  /** @internal */\n  readonly effect_instruction_i0: A\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Exit",
      "path": [
        "src",
        "Exit.ts"
      ]
    },
    "project": "effect",
    "name": "Exit",
    "description": "An `Exit<A, E = never>` describes the result of a executing an `Effect` workflow.\n\nThere are two possible values for an `Exit<A, E>`:\n  - `Exit.Success` contain a success value of type `A`\n  - `Exit.Failure` contains a failure `Cause` of type `E`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type Exit<A, E = never> = Success<A, E> | Failure<A, E>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "FastCheck",
      "path": [
        "src",
        "FastCheck.ts"
      ]
    },
    "project": "effect",
    "name": "From \"fast-check\"",
    "description": "Re-exports all named exports from the \"fast-check\" module.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "exports",
    "signature": "export * from \"fast-check\""
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "FiberTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const FiberTypeId: typeof FiberTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "RuntimeFiberTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const RuntimeFiberTypeId: typeof RuntimeFiberTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "Order",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Order: order.Order<RuntimeFiber<unknown, unknown>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "isFiber",
    "description": "Returns `true` if the specified value is a `Fiber`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isFiber: (u: unknown) => u is Fiber<unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "isRuntimeFiber",
    "description": "Returns `true` if the specified `Fiber` is a `RuntimeFiber`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isRuntimeFiber: <A, E>(self: Fiber<A, E>) => self is RuntimeFiber<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "id",
    "description": "The identity of the fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const id: <A, E>(self: Fiber<A, E>) => FiberId.FiberId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "awaitAll",
    "description": "Awaits on all fibers to be completed, successfully or not.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const awaitAll: <const T extends Iterable<Fiber<any, any>>>(fibers: T) => Effect.Effect<[T] extends [ReadonlyArray<infer U>] ? number extends T[\"length\"] ? Array<U extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never> : { -readonly [K in keyof T]: T[K] extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never; } : Array<T extends Iterable<infer U> ? U extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never : never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "children",
    "description": "Retrieves the immediate children of the fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const children: <A, E>(self: Fiber<A, E>) => Effect.Effect<Array<RuntimeFiber<any, any>>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "all",
    "description": "Collects all fibers into a single fiber producing an in-order list of the\nresults.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const all: <A, E>(fibers: Iterable<Fiber<A, E>>) => Fiber<ReadonlyArray<A>, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "done",
    "description": "A fiber that is done with the specified `Exit` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const done: <A, E>(exit: Exit.Exit<A, E>) => Fiber<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "dump",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const dump: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<Fiber.Dump>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "dumpAll",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const dumpAll: (fibers: Iterable<RuntimeFiber<unknown, unknown>>) => Effect.Effect<Array<Fiber.Dump>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": "A fiber that has already failed with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fail: <E>(error: E) => Fiber<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "failCause",
    "description": "Creates a `Fiber` that has already failed with the specified cause.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failCause: <E>(cause: Cause.Cause<E>) => Fiber<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "fromEffect",
    "description": "Lifts an `Effect` into a `Fiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "export declare const fromEffect: <A, E>(effect: Effect.Effect<A, E>) => Effect.Effect<Fiber<A, E>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "getCurrentFiber",
    "description": "Gets the current fiber if one is running.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utilities",
    "signature": "export declare const getCurrentFiber: () => Option.Option<RuntimeFiber<any, any>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "inheritAll",
    "description": "Inherits values from all `FiberRef` instances into current fiber. This\nwill resume immediately.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const inheritAll: <A, E>(self: Fiber<A, E>) => Effect.Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "interrupt",
    "description": "Interrupts the fiber from whichever fiber is calling this method. If the\nfiber has already exited, the returned effect will resume immediately.\nOtherwise, the effect will resume when the fiber exits.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "interruption",
    "signature": "export declare const interrupt: <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "interrupted",
    "description": "Constructrs a `Fiber` that is already interrupted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const interrupted: (fiberId: FiberId.FiberId) => Fiber<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "interruptAs",
    "description": "Interrupts the fiber as if interrupted from the specified fiber. If the\nfiber has already exited, the returned effect will resume immediately.\nOtherwise, the effect will resume when the fiber exits.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "interruption",
    "signature": "export declare const interruptAs: { (fiberId: FiberId.FiberId): <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>; <A, E>(self: Fiber<A, E>, fiberId: FiberId.FiberId): Effect.Effect<Exit.Exit<A, E>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "interruptAsFork",
    "description": "Interrupts the fiber as if interrupted from the specified fiber. If the\nfiber has already exited, the returned effect will resume immediately.\nOtherwise, the effect will resume when the fiber exits.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "interruption",
    "signature": "export declare const interruptAsFork: { (fiberId: FiberId.FiberId): <A, E>(self: Fiber<A, E>) => Effect.Effect<void>; <A, E>(self: Fiber<A, E>, fiberId: FiberId.FiberId): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "interruptAll",
    "description": "Interrupts all fibers, awaiting their interruption.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "interruption",
    "signature": "export declare const interruptAll: (fibers: Iterable<Fiber<any, any>>) => Effect.Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "interruptAllAs",
    "description": "Interrupts all fibers as by the specified fiber, awaiting their\ninterruption.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "interruption",
    "signature": "export declare const interruptAllAs: { (fiberId: FiberId.FiberId): (fibers: Iterable<Fiber<any, any>>) => Effect.Effect<void>; (fibers: Iterable<Fiber<any, any>>, fiberId: FiberId.FiberId): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "interruptFork",
    "description": "Interrupts the fiber from whichever fiber is calling this method. The\ninterruption will happen in a separate daemon fiber, and the returned\neffect will always resume immediately without waiting.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "interruption",
    "signature": "export declare const interruptFork: <A, E>(self: Fiber<A, E>) => Effect.Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "join",
    "description": "Joins the fiber, which suspends the joining fiber until the result of the\nfiber has been determined. Attempting to join a fiber that has erred will\nresult in a catchable error. Joining an interrupted fiber will result in an\n\"inner interruption\" of this fiber, unlike interruption triggered by\nanother fiber, \"inner interruption\" can be caught and recovered.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const join: <A, E>(self: Fiber<A, E>) => Effect.Effect<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "joinAll",
    "description": "Joins all fibers, awaiting their _successful_ completion. Attempting to\njoin a fiber that has erred will result in a catchable error, _if_ that\nerror does not result from interruption.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const joinAll: <A, E>(fibers: Iterable<Fiber<A, E>>) => Effect.Effect<Array<A>, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Maps over the value the Fiber computes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <A, B>(f: (a: A) => B): <E>(self: Fiber<A, E>) => Fiber<B, E>; <A, E, B>(self: Fiber<A, E>, f: (a: A) => B): Fiber<B, E>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "mapEffect",
    "description": "Effectually maps over the value the fiber computes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapEffect: { <A, A2, E2>(f: (a: A) => Effect.Effect<A2, E2>): <E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, f: (a: A) => Effect.Effect<A2, E2>): Fiber<A2, E | E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "mapFiber",
    "description": "Passes the success of this fiber to the specified callback, and continues\nwith the fiber that it returns.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapFiber: { <E, E2, A, B>(f: (a: A) => Fiber<B, E2>): (self: Fiber<A, E>) => Effect.Effect<Fiber<B, E | E2>>; <A, E, E2, B>(self: Fiber<A, E>, f: (a: A) => Fiber<B, E2>): Effect.Effect<Fiber<B, E | E2>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Folds over the `Fiber` or `RuntimeFiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const match: { <A, E, Z>(options: { readonly onFiber: (fiber: Fiber<A, E>) => Z; readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z; }): (self: Fiber<A, E>) => Z; <A, E, Z>(self: Fiber<A, E>, options: { readonly onFiber: (fiber: Fiber<A, E>) => Z; readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z; }): Z; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "never",
    "description": "A fiber that never fails or succeeds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const never: Fiber<never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "orElse",
    "description": "Returns a fiber that prefers `this` fiber, but falls back to the `that` one\nwhen `this` one fails. Interrupting the returned fiber will interrupt both\nfibers, sequentially, from left to right.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "alternatives",
    "signature": "export declare const orElse: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2 | A, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A | A2, E | E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "orElseEither",
    "description": "Returns a fiber that prefers `this` fiber, but falls back to the `that` one\nwhen `this` one fails. Interrupting the returned fiber will interrupt both\nfibers, sequentially, from left to right.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "alternatives",
    "signature": "export declare const orElseEither: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<Either.Either<A2, A>, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<Either.Either<A2, A>, E | E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "poll",
    "description": "Tentatively observes the fiber, but returns immediately if it is not\nalready done.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const poll: <A, E>(self: Fiber<A, E>) => Effect.Effect<Option.Option<Exit.Exit<A, E>>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "pretty",
    "description": "Pretty-prints a `RuntimeFiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const pretty: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "roots",
    "description": "Returns a chunk containing all root fibers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const roots: Effect.Effect<RuntimeFiber<any, any>[], never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeRoots",
    "description": "Returns a chunk containing all root fibers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unsafeRoots: (_: void) => Array<RuntimeFiber<any, any>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "scoped",
    "description": "Converts this fiber into a scoped effect. The fiber is interrupted when the\nscope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const scoped: <A, E>(self: Fiber<A, E>) => Effect.Effect<Fiber<A, E>, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "status",
    "description": "Returns the `FiberStatus` of a `RuntimeFiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const status: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<FiberStatus.FiberStatus>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": "Returns a fiber that has already succeeded with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const succeed: <A>(value: A) => Fiber<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Zips this fiber and the specified fiber together, producing a tuple of\ntheir output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zip: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<[A, A2], E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<[A, A2], E | E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Same as `zip` but discards the output of that `Fiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipLeft: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A, E | E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Same as `zip` but discards the output of this `Fiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipRight: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A2, E | E2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Zips this fiber with the specified fiber, combining their results using the\nspecified combiner function. Both joins and interruptions are performed in\nsequential order from left to right.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWith: { <B, E2, A, C>(that: Fiber<B, E2>, f: (a: A, b: B) => C): <E>(self: Fiber<A, E>) => Fiber<C, E2 | E>; <A, E, B, E2, C>(self: Fiber<A, E>, that: Fiber<B, E2>, f: (a: A, b: B) => C): Fiber<C, E | E2>; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "await",
    "description": "Awaits the fiber, which suspends the awaiting fiber until the result of the\nfiber has been determined.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const await: <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "void",
    "description": "A fiber that has already succeeded with unit.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const void: Fiber<void, never>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "Fiber",
    "description": "A fiber is a lightweight thread of execution that never consumes more than a\nwhole thread (but may consume much less, depending on contention and\nasynchronicity). Fibers are spawned by forking effects, which run\nconcurrently with the parent effect.\n\nFibers can be joined, yielding their result to other fibers, or interrupted,\nwhich terminates the fiber, safely releasing all resources.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Fiber<out A, out E = never> extends Effect.Effect<A, E>, Fiber.Variance<A, E> {\n  /**\n   * The identity of the fiber.\n   */\n  id(): FiberId.FiberId\n\n  /**\n   * Awaits the fiber, which suspends the awaiting fiber until the result of the\n   * fiber has been determined.\n   */\n  readonly await: Effect.Effect<Exit.Exit<A, E>>\n\n  /**\n   * Retrieves the immediate children of the fiber.\n   */\n  readonly children: Effect.Effect<Array<Fiber.Runtime<any, any>>>\n\n  /**\n   * Inherits values from all `FiberRef` instances into current fiber. This\n   * will resume immediately.\n   */\n  readonly inheritAll: Effect.Effect<void>\n\n  /**\n   * Tentatively observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  readonly poll: Effect.Effect<Option.Option<Exit.Exit<A, E>>>\n\n  /**\n   * In the background, interrupts the fiber as if interrupted from the\n   * specified fiber. If the fiber has already exited, the returned effect will\n   * resume immediately. Otherwise, the effect will resume when the fiber exits.\n   */\n  interruptAsFork(fiberId: FiberId.FiberId): Effect.Effect<void>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: FiberUnify<this>\n  readonly [Unify.ignoreSymbol]?: FiberUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "FiberUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface FiberUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Fiber?: () => A[Unify.typeSymbol] extends Fiber<infer A0, infer E0> | infer _ ? Fiber<A0, E0> : never\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "FiberUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface FiberUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "RuntimeFiber",
    "description": "A runtime fiber that is executing an effect. Runtime fibers have an\nidentity and a trace.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RuntimeFiber<out A, out E = never> extends Fiber<A, E>, Fiber.RuntimeVariance<A, E> {\n  /**\n   * Reads the current number of ops that have occurred since the last yield\n   */\n  get currentOpCount(): number\n\n  /**\n   * Reads the current value of a fiber ref\n   */\n  getFiberRef<X>(fiberRef: FiberRef<X>): X\n\n  /**\n   * The identity of the fiber.\n   */\n  id(): FiberId.Runtime\n\n  /**\n   * The status of the fiber.\n   */\n  readonly status: Effect.Effect<FiberStatus.FiberStatus>\n\n  /**\n   * Returns the current `RuntimeFlags` the fiber is running with.\n   */\n  readonly runtimeFlags: Effect.Effect<RuntimeFlags.RuntimeFlags>\n\n  /**\n   * Adds an observer to the list of observers.\n   */\n  addObserver(observer: (exit: Exit.Exit<A, E>) => void): void\n\n  /**\n   * Removes the specified observer from the list of observers that will be\n   * notified when the fiber exits.\n   */\n  removeObserver(observer: (exit: Exit.Exit<A, E>) => void): void\n\n  /**\n   * Retrieves all fiber refs of the fiber.\n   */\n  getFiberRefs(): FiberRefs.FiberRefs\n\n  /**\n   * Unsafely observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  unsafePoll(): Exit.Exit<A, E> | null\n\n  /**\n   * In the background, interrupts the fiber as if interrupted from the\n   * specified fiber. If the fiber has already exited, the returned effect will\n   * resume immediately. Otherwise, the effect will resume when the fiber exits.\n   */\n  unsafeInterruptAsFork(fiberId: FiberId.FiberId): void\n\n  /**\n   * Gets the current context\n   */\n  get currentContext(): Context<never>\n\n  /**\n   * Gets the current context\n   */\n  get currentDefaultServices(): Context<DefaultServices>\n\n  /**\n   * Gets the current scheduler\n   */\n  get currentScheduler(): Scheduler\n\n  /**\n   * Gets the current tracer\n   */\n  get currentTracer(): Tracer\n\n  /**\n   * Gets the current span\n   */\n  get currentSpan(): AnySpan | undefined\n\n  /**\n   * Gets the current supervisor\n   */\n  get currentSupervisor(): Supervisor<unknown>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: RuntimeFiberUnify<this>\n  readonly [Unify.ignoreSymbol]?: RuntimeFiberUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "RuntimeFiberUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface RuntimeFiberUnify<A extends { [Unify.typeSymbol]?: any }> extends FiberUnify<A> {\n  RuntimeFiber?: () => A[Unify.typeSymbol] extends RuntimeFiber<infer A0, infer E0> | infer _ ? RuntimeFiber<A0, E0>\n    : never\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "RuntimeFiberUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface RuntimeFiberUnifyIgnore extends FiberUnifyIgnore {\n  Fiber?: true\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "FiberTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type FiberTypeId = typeof FiberTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Fiber",
      "path": [
        "src",
        "Fiber.ts"
      ]
    },
    "project": "effect",
    "name": "RuntimeFiberTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type RuntimeFiberTypeId = typeof RuntimeFiberTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeSet",
    "description": "Set the fiber in a FiberHandle. When the fiber completes, it will be removed from the FiberHandle.\nIf a fiber is already running, it will be interrupted unless `options.onlyIfMissing` is set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const unsafeSet: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }): (self: FiberHandle<A, E>) => void; <A, E, XE extends E, XA extends A>(self: FiberHandle<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": "Set the fiber in the FiberHandle. When the fiber completes, it will be removed from the FiberHandle.\nIf a fiber already exists in the FiberHandle, it will be interrupted unless `options.onlyIfMissing` is set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const set: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): (self: FiberHandle<A, E>) => Effect.Effect<void>; <A, E, XE extends E, XA extends A>(self: FiberHandle<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "run",
    "description": "Run an Effect and add the forked fiber to the FiberHandle.\nWhen the fiber completes, it will be removed from the FiberHandle.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const run: { <A, E>(self: FiberHandle<A, E>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <A, E, R, XE extends E, XA extends A>(self: FiberHandle<A, E>, effect: Effect.Effect<XA, XE, R>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "isFiberHandle",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "A FiberHandle can be used to store a single fiber.\nWhen the associated Scope is closed, the contained fiber will be interrupted.\n\nYou can add a fiber to the handle using `FiberHandle.run`, and the fiber will\nbe automatically removed from the FiberHandle when it completes.",
    "deprecated": false,
    "examples": [
      "import { Effect, FiberHandle } from \"effect\"\n\nEffect.gen(function*() {\n  const handle = yield* FiberHandle.make()\n\n  // run some effects\n  yield* FiberHandle.run(handle, Effect.never)\n  // this will interrupt the previous fiber\n  yield* FiberHandle.run(handle, Effect.never)\n\n  yield* Effect.sleep(1000)\n}).pipe(\n  Effect.scoped // The fiber will be interrupted when the scope is closed\n)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "makeRuntime",
    "description": "Create an Effect run function that is backed by a FiberHandle.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "makeRuntimePromise",
    "description": "Create an Effect run function that is backed by a FiberHandle.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeGet",
    "description": "Retrieve the fiber from the FiberHandle.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieve the fiber from the FiberHandle.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "clear",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "runtime",
    "description": "Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberHandle.",
    "deprecated": false,
    "examples": [
      "import { Context, Effect, FiberHandle } from \"effect\"\n\ninterface Users {\n  readonly _: unique symbol\n}\nconst Users = Context.GenericTag<Users, {\n   getAll: Effect.Effect<Array<unknown>>\n}>(\"Users\")\n\nEffect.gen(function*() {\n  const handle = yield* FiberHandle.make()\n  const run = yield* FiberHandle.runtime(handle)<Users>()\n\n  // run an effect and set the fiber in the handle\n  run(Effect.andThen(Users, _ => _.getAll))\n\n  // this will interrupt the previous fiber\n  run(Effect.andThen(Users, _ => _.getAll))\n}).pipe(\n  Effect.scoped // The fiber will be interrupted when the scope is closed\n)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "runtimePromise",
    "description": "Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberHandle.\n\nThe returned run function will return Promise's that will resolve when the\nfiber completes.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "join",
    "description": "If any of the Fiber's in the handle terminate with a failure,\nthe returned Effect will terminate with the first failure that occurred.",
    "deprecated": false,
    "examples": [
      "import { Effect, FiberHandle } from \"effect\";\n\nEffect.gen(function* (_) {\n  const handle = yield* _(FiberHandle.make());\n  yield* _(FiberHandle.set(handle, Effect.runFork(Effect.fail(\"error\"))));\n\n  // parent fiber will fail with \"error\"\n  yield* _(FiberHandle.join(handle));\n});"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "awaitEmpty",
    "description": "Wait for the fiber in the FiberHandle to complete.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "FiberHandle",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface FiberHandle<out A = unknown, out E = unknown> extends Pipeable, Inspectable.Inspectable {\n  readonly [TypeId]: TypeId\n  readonly deferred: Deferred.Deferred<void, unknown>\n  /** @internal */\n  state: {\n    readonly _tag: \"Open\"\n    fiber: Fiber.RuntimeFiber<A, E> | undefined\n  } | {\n    readonly _tag: \"Closed\"\n  }\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberHandle",
      "path": [
        "src",
        "FiberHandle.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "FiberIdTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const FiberIdTypeId: typeof FiberIdTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "none",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const none: None"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "runtime",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const runtime: (id: number, startTimeMillis: number) => Runtime"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "composite",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const composite: (left: FiberId, right: FiberId) => Composite"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "isFiberId",
    "description": "Returns `true` if the specified unknown value is a `FiberId`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isFiberId: (self: unknown) => self is FiberId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "isNone",
    "description": "Returns `true` if the `FiberId` is a `None`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isNone: (self: FiberId) => self is None"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "isRuntime",
    "description": "Returns `true` if the `FiberId` is a `Runtime`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isRuntime: (self: FiberId) => self is Runtime"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "isComposite",
    "description": "Returns `true` if the `FiberId` is a `Composite`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isComposite: (self: FiberId) => self is Composite"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "combine",
    "description": "Combine two `FiberId`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const combine: { (that: FiberId): (self: FiberId) => FiberId; (self: FiberId, that: FiberId): FiberId; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "combineAll",
    "description": "Combines a set of `FiberId`s into a single `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const combineAll: (fiberIds: HashSet.HashSet<FiberId>) => FiberId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "getOrElse",
    "description": "Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getOrElse: { (that: FiberId): (self: FiberId) => FiberId; (self: FiberId, that: FiberId): FiberId; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "ids",
    "description": "Get the set of identifiers for this `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const ids: (self: FiberId) => HashSet.HashSet<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: (id: number, startTimeSeconds: number) => FiberId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "threadName",
    "description": "Creates a string representing the name of the current thread of execution\nrepresented by the specified `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const threadName: (self: FiberId) => string"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "toOption",
    "description": "Convert a `FiberId` into an `Option<FiberId>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toOption: (self: FiberId) => Option.Option<FiberId>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "toSet",
    "description": "Convert a `FiberId` into a `HashSet<FiberId>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toSet: (self: FiberId) => HashSet.HashSet<Runtime>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMake",
    "description": "Unsafely creates a new `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeMake: (_: void) => Runtime"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "Composite",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Composite extends Equal.Equal, Inspectable {\n  readonly [FiberIdTypeId]: FiberIdTypeId\n  readonly _tag: \"Composite\"\n  readonly left: FiberId\n  readonly right: FiberId\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "None",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface None extends Equal.Equal, Inspectable {\n  readonly [FiberIdTypeId]: FiberIdTypeId\n  readonly _tag: \"None\"\n  readonly id: -1\n  readonly startTimeMillis: -1\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "Runtime",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Runtime extends Equal.Equal, Inspectable {\n  readonly [FiberIdTypeId]: FiberIdTypeId\n  readonly _tag: \"Runtime\"\n  readonly id: number\n  readonly startTimeMillis: number\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "FiberId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type FiberId = Single | Composite"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "FiberIdTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type FiberIdTypeId = typeof FiberIdTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberId",
      "path": [
        "src",
        "FiberId.ts"
      ]
    },
    "project": "effect",
    "name": "Single",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type Single = None | Runtime"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeSet",
    "description": "Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.\nIf the key already exists in the FiberMap, the previous fiber will be interrupted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const unsafeSet: { <K, A, E, XE extends E, XA extends A>(key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberMap<K, A, E>) => void; <K, A, E, XE extends E, XA extends A>(self: FiberMap<K, A, E>, key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": "Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.\nIf the key already exists in the FiberMap, the previous fiber will be interrupted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const set: { <K, A, E, XE extends E, XA extends A>(key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberMap<K, A, E>) => Effect.Effect<void>; <K, A, E, XE extends E, XA extends A>(self: FiberMap<K, A, E>, key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeGet",
    "description": "Retrieve a fiber from the FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const unsafeGet: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Option.Option<Fiber.RuntimeFiber<A, E>>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Option.Option<Fiber.RuntimeFiber<A, E>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieve a fiber from the FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const get: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeHas",
    "description": "Check if a key exists in the FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const unsafeHas: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => boolean; <K, A, E>(self: FiberMap<K, A, E>, key: K): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "has",
    "description": "Check if a key exists in the FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const has: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<boolean>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "remove",
    "description": "Remove a fiber from the FiberMap, interrupting it if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const remove: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "run",
    "description": "Run an Effect and add the forked fiber to the FiberMap.\nWhen the fiber completes, it will be removed from the FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const run: { <K, A, E>(self: FiberMap<K, A, E>, key: K, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <K, A, E, R, XE extends E, XA extends A>(self: FiberMap<K, A, E>, key: K, effect: Effect.Effect<XA, XE, R>, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "isFiberMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "A FiberMap can be used to store a collection of fibers, indexed by some key.\nWhen the associated Scope is closed, all fibers in the map will be interrupted.\n\nYou can add fibers to the map using `FiberMap.set` or `FiberMap.run`, and the fibers will\nbe automatically removed from the FiberMap when they complete.",
    "deprecated": false,
    "examples": [
      "import { Effect, FiberMap } from \"effect\"\n\nEffect.gen(function*() {\n  const map = yield* FiberMap.make<string>()\n\n  // run some effects and add the fibers to the map\n  yield* FiberMap.run(map, \"fiber a\", Effect.never)\n  yield* FiberMap.run(map, \"fiber b\", Effect.never)\n\n  yield* Effect.sleep(1000)\n}).pipe(\n  Effect.scoped // The fibers will be interrupted when the scope is closed\n)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "makeRuntime",
    "description": "Create an Effect run function that is backed by a FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "makeRuntimePromise",
    "description": "Create an Effect run function that is backed by a FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "clear",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "runtime",
    "description": "Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.",
    "deprecated": false,
    "examples": [
      "import { Context, Effect, FiberMap } from \"effect\"\n\ninterface Users {\n  readonly _: unique symbol\n}\nconst Users = Context.GenericTag<Users, {\n   getAll: Effect.Effect<Array<unknown>>\n}>(\"Users\")\n\nEffect.gen(function*() {\n  const map = yield* FiberMap.make<string>()\n  const run = yield* FiberMap.runtime(map)<Users>()\n\n  // run some effects and add the fibers to the map\n  run(\"effect-a\", Effect.andThen(Users, _ => _.getAll))\n  run(\"effect-b\", Effect.andThen(Users, _ => _.getAll))\n}).pipe(\n  Effect.scoped // The fibers will be interrupted when the scope is closed\n)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "runtimePromise",
    "description": "Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "join",
    "description": "Join all fibers in the FiberMap. If any of the Fiber's in the map terminate with a failure,\nthe returned Effect will terminate with the first failure that occurred.",
    "deprecated": false,
    "examples": [
      "import { Effect, FiberMap } from \"effect\";\n\nEffect.gen(function* (_) {\n  const map = yield* _(FiberMap.make());\n  yield* _(FiberMap.set(map, \"a\", Effect.runFork(Effect.fail(\"error\"))));\n\n  // parent fiber will fail with \"error\"\n  yield* _(FiberMap.join(map));\n});"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "awaitEmpty",
    "description": "Wait for the FiberMap to be empty.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "FiberMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface FiberMap<in out K, out A = unknown, out E = unknown>\n  extends Pipeable, Inspectable.Inspectable, Iterable<[K, Fiber.RuntimeFiber<A, E>]>\n{\n  readonly [TypeId]: TypeId\n  readonly deferred: Deferred.Deferred<void, unknown>\n  /** @internal */\n  state: {\n    readonly _tag: \"Open\"\n    readonly backing: MutableHashMap.MutableHashMap<K, Fiber.RuntimeFiber<A, E>>\n  } | {\n    readonly _tag: \"Closed\"\n  }\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberMap",
      "path": [
        "src",
        "FiberMap.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "FiberRefTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const FiberRefTypeId: typeof FiberRefTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <A>(initial: A, options?: { readonly fork?: ((a: A) => A) | undefined; readonly join?: ((left: A, right: A) => A) | undefined; }) => Effect.Effect<FiberRef<A>, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "makeWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeWith: <Value>(ref: LazyArg<FiberRef<Value>>) => Effect.Effect<FiberRef<Value>, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "makeContext",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeContext: <A>(initial: Context.Context<A>) => Effect.Effect<FiberRef<Context.Context<A>>, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "makeRuntimeFlags",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeRuntimeFlags: (initial: RuntimeFlags.RuntimeFlags) => Effect.Effect<FiberRef<RuntimeFlags.RuntimeFlags>, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMake",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unsafeMake: <Value>(initial: Value, options?: { readonly fork?: ((a: Value) => Value) | undefined; readonly join?: ((left: Value, right: Value) => Value) | undefined; }) => FiberRef<Value>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMakeHashSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unsafeMakeHashSet: <A>(initial: HashSet.HashSet<A>) => FiberRef<HashSet.HashSet<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMakeContext",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unsafeMakeContext: <A>(initial: Context.Context<A>) => FiberRef<Context.Context<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMakeSupervisor",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unsafeMakeSupervisor: (initial: Supervisor.Supervisor<any>) => FiberRef<Supervisor.Supervisor<any>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMakePatch",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unsafeMakePatch: <Value, Patch>(initial: Value, options: { readonly differ: Differ.Differ<Value, Patch>; readonly fork: Patch; readonly join?: ((oldV: Value, newV: Value) => Value) | undefined; }) => FiberRef<Value>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const get: <A>(self: FiberRef<A>) => Effect.Effect<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndSet: { <A>(value: A): (self: FiberRef<A>) => Effect.Effect<A>; <A>(self: FiberRef<A>, value: A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndUpdate: { <A>(f: (a: A) => A): (self: FiberRef<A>) => Effect.Effect<A>; <A>(self: FiberRef<A>, f: (a: A) => A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdateSome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndUpdateSome: { <A>(pf: (a: A) => Option.Option<A>): (self: FiberRef<A>) => Effect.Effect<A>; <A>(self: FiberRef<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "getWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getWith: { <A, B, E, R>(f: (a: A) => Effect.Effect<B, E, R>): (self: FiberRef<A>) => Effect.Effect<B, E, R>; <A, B, E, R>(self: FiberRef<A>, f: (a: A) => Effect.Effect<B, E, R>): Effect.Effect<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const set: { <A>(value: A): (self: FiberRef<A>) => Effect.Effect<void>; <A>(self: FiberRef<A>, value: A): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "reset",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const reset: <A>(self: FiberRef<A>) => Effect.Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "modify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const modify: { <A, B>(f: (a: A) => readonly [B, A]): (self: FiberRef<A>) => Effect.Effect<B>; <A, B>(self: FiberRef<A>, f: (a: A) => readonly [B, A]): Effect.Effect<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "modifySome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const modifySome: <A, B>(self: FiberRef<A>, def: B, f: (a: A) => Option.Option<readonly [B, A]>) => Effect.Effect<B>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "update",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const update: { <A>(f: (a: A) => A): (self: FiberRef<A>) => Effect.Effect<void>; <A>(self: FiberRef<A>, f: (a: A) => A): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateSome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateSome: { <A>(pf: (a: A) => Option.Option<A>): (self: FiberRef<A>) => Effect.Effect<void>; <A>(self: FiberRef<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateAndGet: { <A>(f: (a: A) => A): (self: FiberRef<A>) => Effect.Effect<A>; <A>(self: FiberRef<A>, f: (a: A) => A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateSomeAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateSomeAndGet: { <A>(pf: (a: A) => Option.Option<A>): (self: FiberRef<A>) => Effect.Effect<A>; <A>(self: FiberRef<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentConcurrency",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentConcurrency: FiberRef<number | \"unbounded\">"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentRequestBatchingEnabled",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentRequestBatchingEnabled: FiberRef<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentRequestCache",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentRequestCache: FiberRef<Request.Cache>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentRequestCacheEnabled",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentRequestCacheEnabled: FiberRef<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentContext",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentContext: FiberRef<Context.Context<never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentSchedulingPriority",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentSchedulingPriority: FiberRef<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentMaxOpsBeforeYield",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentMaxOpsBeforeYield: FiberRef<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "unhandledErrorLogLevel",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const unhandledErrorLogLevel: FiberRef<Option.Option<LogLevel.LogLevel>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentLogAnnotations",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentLogAnnotations: FiberRef<HashMap.HashMap<string, unknown>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentLoggers",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentLoggers: FiberRef<HashSet.HashSet<Logger.Logger<unknown, any>>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentLogLevel",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentLogLevel: FiberRef<LogLevel.LogLevel>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentMinimumLogLevel",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentMinimumLogLevel: FiberRef<LogLevel.LogLevel>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentLogSpan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentLogSpan: FiberRef<List.List<LogSpan.LogSpan>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentRuntimeFlags",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentRuntimeFlags: FiberRef<RuntimeFlags.RuntimeFlags>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentScheduler",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentScheduler: FiberRef<Scheduler.Scheduler>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentSupervisor",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentSupervisor: FiberRef<Supervisor.Supervisor<any>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentMetricLabels",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentMetricLabels: FiberRef<readonly MetricLabel.MetricLabel[]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentTracerEnabled",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentTracerEnabled: FiberRef<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentTracerTimingEnabled",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentTracerTimingEnabled: FiberRef<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentTracerSpanAnnotations",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentTracerSpanAnnotations: FiberRef<HashMap.HashMap<string, unknown>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "currentTracerSpanLinks",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const currentTracerSpanLinks: FiberRef<Chunk.Chunk<Tracer.SpanLink>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "interruptedCause",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiberRefs",
    "signature": "export declare const interruptedCause: FiberRef<Cause.Cause<never>>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "delete",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const delete: <A>(self: FiberRef<A>) => Effect.Effect<void>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "FiberRef",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface FiberRef<in out A> extends Effect.Effect<A>, Variance<A> {\n  /** @internal */\n  readonly initial: A\n  /** @internal */\n  diff(oldValue: A, newValue: A): unknown\n  /** @internal */\n  combine(first: unknown, second: unknown): unknown\n  /** @internal */\n  patch(patch: unknown): (oldValue: A) => A\n  /** @internal */\n  readonly fork: unknown\n  /** @internal */\n  join(oldValue: A, newValue: A): A\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: FiberRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: FiberRefUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "FiberRefUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface FiberRefUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  FiberRef?: () => Extract<A[Unify.typeSymbol], FiberRef<any>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "FiberRefUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface FiberRefUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "Variance",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out A> {\n  readonly [FiberRefTypeId]: {\n    readonly _A: Types.Invariant<A>\n  }\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberRef",
      "path": [
        "src",
        "FiberRef.ts"
      ]
    },
    "project": "effect",
    "name": "FiberRefTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type FiberRefTypeId = typeof FiberRefTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs",
      "path": [
        "src",
        "FiberRefs.ts"
      ]
    },
    "project": "effect",
    "name": "FiberRefsSym",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const FiberRefsSym: typeof FiberRefsSym"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs",
      "path": [
        "src",
        "FiberRefs.ts"
      ]
    },
    "project": "effect",
    "name": "fiberRefs",
    "description": "Returns a set of each `FiberRef` in this collection.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const fiberRefs: (self: FiberRefs) => HashSet.HashSet<FiberRef.FiberRef<any>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs",
      "path": [
        "src",
        "FiberRefs.ts"
      ]
    },
    "project": "effect",
    "name": "forkAs",
    "description": "Forks this collection of fiber refs as the specified child fiber id. This\nwill potentially modify the value of the fiber refs, as determined by the\nindividual fiber refs that make up the collection.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const forkAs: { (childId: FiberId.Single): (self: FiberRefs) => FiberRefs; (self: FiberRefs, childId: FiberId.Single): FiberRefs; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs",
      "path": [
        "src",
        "FiberRefs.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Gets the value of the specified `FiberRef` in this collection of `FiberRef`\nvalues if it exists or `None` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const get: { <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => Option.Option<A>; <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): Option.Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs",
      "path": [
        "src",
        "FiberRefs.ts"
      ]
    },
    "project": "effect",
    "name": "getOrDefault",
    "description": "Gets the value of the specified `FiberRef` in this collection of `FiberRef`\nvalues if it exists or the `initial` value of the `FiberRef` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const getOrDefault: { <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => A; <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs",
      "path": [
        "src",
        "FiberRefs.ts"
      ]
    },
    "project": "effect",
    "name": "joinAs",
    "description": "Joins this collection of fiber refs to the specified collection, as the\nspecified fiber id. This will perform diffing and merging to ensure\npreservation of maximum information from both child and parent refs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const joinAs: { (fiberId: FiberId.Single, that: FiberRefs): (self: FiberRefs) => FiberRefs; (self: FiberRefs, fiberId: FiberId.Single, that: FiberRefs): FiberRefs; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs",
      "path": [
        "src",
        "FiberRefs.ts"
      ]
    },
    "project": "effect",
    "name": "setAll",
    "description": "Set each ref to either its value or its default.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const setAll: (self: FiberRefs) => Effect.Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs",
      "path": [
        "src",
        "FiberRefs.ts"
      ]
    },
    "project": "effect",
    "name": "updateAs",
    "description": "Updates the value of the specified `FiberRef` using the provided `FiberId`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateAs: { <A>(options: { readonly fiberId: FiberId.Single; readonly fiberRef: FiberRef.FiberRef<A>; readonly value: A; }): (self: FiberRefs) => FiberRefs; <A>(self: FiberRefs, options: { readonly fiberId: FiberId.Single; readonly fiberRef: FiberRef.FiberRef<A>; readonly value: A; }): FiberRefs; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs",
      "path": [
        "src",
        "FiberRefs.ts"
      ]
    },
    "project": "effect",
    "name": "updateManyAs",
    "description": "Updates the values of the specified `FiberRef` & value pairs using the provided `FiberId`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateManyAs: { (options: { readonly forkAs?: FiberId.Single | undefined; readonly entries: readonly [readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]], ...Array<readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]]>]; }): (self: FiberRefs) => FiberRefs; (self: FiberRefs, options: { readonly forkAs?: FiberId.Single | undefined; readonly entries: readonly [readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]], ...Array<readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]]>]; }): FiberRefs; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs",
      "path": [
        "src",
        "FiberRefs.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMake",
    "description": "Note: it will not copy the provided Map, make sure to provide a fresh one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeMake: (fiberRefLocals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>) => FiberRefs"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefs",
      "path": [
        "src",
        "FiberRefs.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "The empty collection of `FiberRef` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: () => FiberRefs"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "FiberRefs",
      "path": [
        "src",
        "FiberRefs.ts"
      ]
    },
    "project": "effect",
    "name": "delete",
    "description": "Deletes the specified `FiberRef` from the `FibterRefs`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const delete: { <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => FiberRefs; <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): FiberRefs; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRefs",
      "path": [
        "src",
        "FiberRefs.ts"
      ]
    },
    "project": "effect",
    "name": "FiberRefs",
    "description": "`FiberRefs` is a data type that represents a collection of `FiberRef` values.\n\nThis allows safely propagating `FiberRef` values across fiber boundaries, for\nexample between an asynchronous producer and consumer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface FiberRefs extends Pipeable {\n  readonly [FiberRefsSym]: FiberRefsSym\n  readonly locals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberRefs",
      "path": [
        "src",
        "FiberRefs.ts"
      ]
    },
    "project": "effect",
    "name": "FiberRefsSym",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type FiberRefsSym = typeof FiberRefsSym"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefsPatch",
      "path": [
        "src",
        "FiberRefsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: FiberRefsPatch"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefsPatch",
      "path": [
        "src",
        "FiberRefsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "diff",
    "description": "Constructs a patch that describes the changes between the specified\ncollections of `FiberRef`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const diff: (oldValue: FiberRefs.FiberRefs, newValue: FiberRefs.FiberRefs) => FiberRefsPatch"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefsPatch",
      "path": [
        "src",
        "FiberRefsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "combine",
    "description": "Combines this patch and the specified patch to create a new patch that\ndescribes applying the changes from this patch and the specified patch\nsequentially.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const combine: { (that: FiberRefsPatch): (self: FiberRefsPatch) => FiberRefsPatch; (self: FiberRefsPatch, that: FiberRefsPatch): FiberRefsPatch; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberRefsPatch",
      "path": [
        "src",
        "FiberRefsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "patch",
    "description": "Applies the changes described by this patch to the specified collection\nof `FiberRef` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const patch: { (fiberId: FiberId.Runtime, oldValue: FiberRefs.FiberRefs): (self: FiberRefsPatch) => FiberRefs.FiberRefs; (self: FiberRefsPatch, fiberId: FiberId.Runtime, oldValue: FiberRefs.FiberRefs): FiberRefs.FiberRefs; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRefsPatch",
      "path": [
        "src",
        "FiberRefsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "Add",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Add {\n  readonly _tag: \"Add\"\n  readonly fiberRef: FiberRef.FiberRef<unknown>\n  readonly value: unknown\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRefsPatch",
      "path": [
        "src",
        "FiberRefsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "AndThen",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface AndThen {\n  readonly _tag: \"AndThen\"\n  readonly first: FiberRefsPatch\n  readonly second: FiberRefsPatch\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRefsPatch",
      "path": [
        "src",
        "FiberRefsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "Empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Empty {\n  readonly _tag: \"Empty\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRefsPatch",
      "path": [
        "src",
        "FiberRefsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "Remove",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Remove {\n  readonly _tag: \"Remove\"\n  readonly fiberRef: FiberRef.FiberRef<unknown>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberRefsPatch",
      "path": [
        "src",
        "FiberRefsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "Update",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Update {\n  readonly _tag: \"Update\"\n  readonly fiberRef: FiberRef.FiberRef<unknown>\n  readonly patch: unknown\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberRefsPatch",
      "path": [
        "src",
        "FiberRefsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "FiberRefsPatch",
    "description": "A `FiberRefsPatch` captures the changes in `FiberRef` values made by a single\nfiber as a value. This allows fibers to apply the changes made by a workflow\nwithout inheriting all the `FiberRef` values of the fiber that executed the\nworkflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type FiberRefsPatch = Empty | Add | Remove | Update | AndThen"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeAdd",
    "description": "Add a fiber to the FiberSet. When the fiber completes, it will be removed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const unsafeAdd: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberSet<A, E>) => void; <A, E, XE extends E, XA extends A>(self: FiberSet<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "add",
    "description": "Add a fiber to the FiberSet. When the fiber completes, it will be removed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const add: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberSet<A, E>) => Effect.Effect<void>; <A, E, XE extends E, XA extends A>(self: FiberSet<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "run",
    "description": "Fork an Effect and add the forked fiber to the FiberSet.\nWhen the fiber completes, it will be removed from the FiberSet.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const run: { <A, E>(self: FiberSet<A, E>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <A, E, R, XE extends E, XA extends A>(self: FiberSet<A, E>, effect: Effect.Effect<XA, XE, R>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "isFiberSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "A FiberSet can be used to store a collection of fibers.\nWhen the associated Scope is closed, all fibers in the set will be interrupted.\n\nYou can add fibers to the set using `FiberSet.add` or `FiberSet.run`, and the fibers will\nbe automatically removed from the FiberSet when they complete.",
    "deprecated": false,
    "examples": [
      "import { Effect, FiberSet } from \"effect\"\n\nEffect.gen(function*() {\n  const set = yield* FiberSet.make()\n\n  // run some effects and add the fibers to the set\n  yield* FiberSet.run(set, Effect.never)\n  yield* FiberSet.run(set, Effect.never)\n\n  yield* Effect.sleep(1000)\n}).pipe(\n  Effect.scoped // The fibers will be interrupted when the scope is closed\n)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "makeRuntime",
    "description": "Create an Effect run function that is backed by a FiberSet.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "makeRuntimePromise",
    "description": "Create an Effect run function that is backed by a FiberSet.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "clear",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "runtime",
    "description": "Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberSet.",
    "deprecated": false,
    "examples": [
      "import { Context, Effect, FiberSet } from \"effect\"\n\ninterface Users {\n  readonly _: unique symbol\n}\nconst Users = Context.GenericTag<Users, {\n   getAll: Effect.Effect<Array<unknown>>\n}>(\"Users\")\n\nEffect.gen(function*() {\n  const set = yield* FiberSet.make()\n  const run = yield* FiberSet.runtime(set)<Users>()\n\n  // run some effects and add the fibers to the set\n  run(Effect.andThen(Users, _ => _.getAll))\n}).pipe(\n  Effect.scoped // The fibers will be interrupted when the scope is closed\n)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "runtimePromise",
    "description": "Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberSet.\n\nThe returned run function will return Promise's.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "join",
    "description": "Join all fibers in the FiberSet. If any of the Fiber's in the set terminate with a failure,\nthe returned Effect will terminate with the first failure that occurred.",
    "deprecated": false,
    "examples": [
      "import { Effect, FiberSet } from \"effect\";\n\nEffect.gen(function* (_) {\n  const set = yield* _(FiberSet.make());\n  yield* _(FiberSet.add(set, Effect.runFork(Effect.fail(\"error\"))));\n\n  // parent fiber will fail with \"error\"\n  yield* _(FiberSet.join(set));\n});"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "awaitEmpty",
    "description": "Wait until the fiber set is empty.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "FiberSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface FiberSet<out A = unknown, out E = unknown>\n  extends Pipeable, Inspectable.Inspectable, Iterable<Fiber.RuntimeFiber<A, E>>\n{\n  readonly [TypeId]: TypeId\n  readonly deferred: Deferred.Deferred<void, unknown>\n  /** @internal */\n  state: {\n    readonly _tag: \"Open\"\n    readonly backing: Set<Fiber.RuntimeFiber<A, E>>\n  } | {\n    readonly _tag: \"Closed\"\n  }\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberSet",
      "path": [
        "src",
        "FiberSet.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus",
      "path": [
        "src",
        "FiberStatus.ts"
      ]
    },
    "project": "effect",
    "name": "FiberStatusTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const FiberStatusTypeId: typeof FiberStatusTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus",
      "path": [
        "src",
        "FiberStatus.ts"
      ]
    },
    "project": "effect",
    "name": "done",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const done: FiberStatus"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus",
      "path": [
        "src",
        "FiberStatus.ts"
      ]
    },
    "project": "effect",
    "name": "running",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const running: (runtimeFlags: RuntimeFlags.RuntimeFlags) => FiberStatus"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus",
      "path": [
        "src",
        "FiberStatus.ts"
      ]
    },
    "project": "effect",
    "name": "suspended",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const suspended: (runtimeFlags: RuntimeFlags.RuntimeFlags, blockingOn: FiberId.FiberId) => FiberStatus"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus",
      "path": [
        "src",
        "FiberStatus.ts"
      ]
    },
    "project": "effect",
    "name": "isFiberStatus",
    "description": "Returns `true` if the specified value is a `FiberStatus`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isFiberStatus: (u: unknown) => u is FiberStatus"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus",
      "path": [
        "src",
        "FiberStatus.ts"
      ]
    },
    "project": "effect",
    "name": "isDone",
    "description": "Returns `true` if the specified `FiberStatus` is `Done`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isDone: (self: FiberStatus) => self is Done"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus",
      "path": [
        "src",
        "FiberStatus.ts"
      ]
    },
    "project": "effect",
    "name": "isRunning",
    "description": "Returns `true` if the specified `FiberStatus` is `Running`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isRunning: (self: FiberStatus) => self is Running"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "FiberStatus",
      "path": [
        "src",
        "FiberStatus.ts"
      ]
    },
    "project": "effect",
    "name": "isSuspended",
    "description": "Returns `true` if the specified `FiberStatus` is `Suspended`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isSuspended: (self: FiberStatus) => self is Suspended"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberStatus",
      "path": [
        "src",
        "FiberStatus.ts"
      ]
    },
    "project": "effect",
    "name": "Done",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Done extends Equal.Equal {\n  readonly _tag: \"Done\"\n  readonly [FiberStatusTypeId]: FiberStatusTypeId\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberStatus",
      "path": [
        "src",
        "FiberStatus.ts"
      ]
    },
    "project": "effect",
    "name": "Running",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Running extends Equal.Equal {\n  readonly _tag: \"Running\"\n  readonly [FiberStatusTypeId]: FiberStatusTypeId\n  readonly runtimeFlags: RuntimeFlags.RuntimeFlags\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "FiberStatus",
      "path": [
        "src",
        "FiberStatus.ts"
      ]
    },
    "project": "effect",
    "name": "Suspended",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Suspended extends Equal.Equal {\n  readonly _tag: \"Suspended\"\n  readonly [FiberStatusTypeId]: FiberStatusTypeId\n  readonly runtimeFlags: RuntimeFlags.RuntimeFlags\n  readonly blockingOn: FiberId.FiberId\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberStatus",
      "path": [
        "src",
        "FiberStatus.ts"
      ]
    },
    "project": "effect",
    "name": "FiberStatus",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type FiberStatus = Done | Running | Suspended"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "FiberStatus",
      "path": [
        "src",
        "FiberStatus.ts"
      ]
    },
    "project": "effect",
    "name": "FiberStatusTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type FiberStatusTypeId = typeof FiberStatusTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "dual",
    "description": "Creates a function that can be used in a data-last (aka `pipe`able) or\ndata-first style.\n\nThe first parameter to `dual` is either the arity of the uncurried function\nor a predicate that determines if the function is being used in a data-first\nor data-last style.\n\nUsing the arity is the most common use case, but there are some cases where\nyou may want to use a predicate. For example, if you have a function that\ntakes an optional argument, you can use a predicate to determine if the\nfunction is being used in a data-first or data-last style.",
    "deprecated": false,
    "examples": [
      "import { dual, pipe } from \"effect/Function\"\n\n// Exampe using arity to determine data-first or data-last style\nconst sum: {\n  (that: number): (self: number) => number\n  (self: number, that: number): number\n} = dual(2, (self: number, that: number): number => self + that)\n\nassert.deepStrictEqual(sum(2, 3), 5)\nassert.deepStrictEqual(pipe(2, sum(3)), 5)\n\n// Example using a predicate to determine data-first or data-last style\nconst sum2: {\n  (that: number): (self: number) => number\n  (self: number, that: number): number\n} = dual((args) => args.length === 1, (self: number, that: number): number => self + that)\n\nassert.deepStrictEqual(sum(2, 3), 5)\nassert.deepStrictEqual(pipe(2, sum(3)), 5)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const dual: { <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(arity: Parameters<DataFirst>[\"length\"], body: DataFirst): DataLast & DataFirst; <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(isDataFirst: (args: IArguments) => boolean, body: DataFirst): DataLast & DataFirst; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeCoerce",
    "description": "Casts the result to the specified type.",
    "deprecated": false,
    "examples": [
      "import { unsafeCoerce, identity } from \"effect/Function\"\n\nassert.deepStrictEqual(unsafeCoerce, identity)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const unsafeCoerce: <A, B>(a: A) => B"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "constTrue",
    "description": "A thunk that returns always `true`.",
    "deprecated": false,
    "examples": [
      "import { constTrue } from \"effect/Function\"\n\nassert.deepStrictEqual(constTrue(), true)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const constTrue: LazyArg<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "constFalse",
    "description": "A thunk that returns always `false`.",
    "deprecated": false,
    "examples": [
      "import { constFalse } from \"effect/Function\"\n\nassert.deepStrictEqual(constFalse(), false)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const constFalse: LazyArg<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "constNull",
    "description": "A thunk that returns always `null`.",
    "deprecated": false,
    "examples": [
      "import { constNull } from \"effect/Function\"\n\nassert.deepStrictEqual(constNull(), null)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const constNull: LazyArg<null>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "constUndefined",
    "description": "A thunk that returns always `undefined`.",
    "deprecated": false,
    "examples": [
      "import { constUndefined } from \"effect/Function\"\n\nassert.deepStrictEqual(constUndefined(), undefined)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const constUndefined: LazyArg<undefined>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "constVoid",
    "description": "A thunk that returns always `void`.",
    "deprecated": false,
    "examples": [
      "import { constVoid } from \"effect/Function\"\n\nassert.deepStrictEqual(constVoid(), undefined)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const constVoid: LazyArg<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "compose",
    "description": "Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\nThe result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.",
    "deprecated": false,
    "examples": [
      "import { compose } from \"effect/Function\"\n\nconst increment = (n: number) => n + 1;\nconst square = (n: number) => n * n;\n\nassert.strictEqual(compose(increment, square)(2), 9);"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const compose: { <B, C>(bc: (b: B) => C): <A>(self: (a: A) => B) => (a: A) => C; <A, B, C>(self: (a: A) => B, bc: (b: B) => C): (a: A) => C; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "hole",
    "description": "Type hole simulation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const hole: <T>() => T"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "pipe",
    "description": "Pipes the value of an expression into a pipeline of functions.\n\n**When to Use**\n\nThis is useful in combination with data-last functions as a simulation of\nmethods:\n\n```ts\nas.map(f).filter(g)\n```\n\nbecomes:\n\n```ts\nimport { pipe, Array } from \"effect\"\n\npipe(as, Array.map(f), Array.filter(g))\n```\n\n**Details**\n\nThe `pipe` function is a utility that allows us to compose functions in a\nreadable and sequential manner. It takes the output of one function and\npasses it as the input to the next function in the pipeline. This enables us\nto build complex transformations by chaining multiple functions together.\n\n```ts\nimport { pipe } from \"effect\"\n\nconst result = pipe(input, func1, func2, ..., funcN)\n```\n\nIn this syntax, `input` is the initial value, and `func1`, `func2`, ...,\n`funcN` are the functions to be applied in sequence. The result of each\nfunction becomes the input for the next function, and the final result is\nreturned.\n\nHere's an illustration of how `pipe` works:\n\n```text\n                    \n input  func1  func2   ...   funcN  result \n                    \n```\n\nIt's important to note that functions passed to `pipe` must have a **single\nargument** because they are only called with a single argument.",
    "deprecated": false,
    "examples": [
      "// Example: Chaining Arithmetic Operations\nimport { pipe } from \"effect\"\n\n// Define simple arithmetic operations\nconst increment = (x: number) => x + 1\nconst double = (x: number) => x * 2\nconst subtractTen = (x: number) => x - 10\n\n// Sequentially apply these operations using `pipe`\nconst result = pipe(5, increment, double, subtractTen)\n\nconsole.log(result)\n// Output: 2"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "flow",
    "description": "Performs left-to-right function composition. The first argument may have any arity, the remaining arguments must be unary.\n\nSee also [`pipe`](#pipe).",
    "deprecated": false,
    "examples": [
      "import { flow } from \"effect/Function\"\n\nconst len = (s: string): number => s.length\nconst double = (n: number): number => n * 2\n\nconst f = flow(len, double)\n\nassert.strictEqual(f('aaa'), 6)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "isFunction",
    "description": "Tests if a value is a `function`.",
    "deprecated": false,
    "examples": [
      "import { isFunction } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isFunction(isFunction), true)\nassert.deepStrictEqual(isFunction(\"function\"), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "apply",
    "description": "Apply a function to a given value.",
    "deprecated": false,
    "examples": [
      "import { pipe, apply } from \"effect/Function\"\nimport { length } from \"effect/String\"\n\nassert.deepStrictEqual(pipe(length, apply(\"hello\")), 5)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "identity",
    "description": "The identity function, i.e. A function that returns its input argument.",
    "deprecated": false,
    "examples": [
      "import { identity } from \"effect/Function\"\n\nassert.deepStrictEqual(identity(5), 5)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "satisfies",
    "description": "A function that ensures that the type of an expression matches some type,\nwithout changing the resulting type of that expression.",
    "deprecated": false,
    "examples": [
      "import { satisfies } from \"effect/Function\"\n\nconst test1 = satisfies<number>()(5 as const)\n    //^? const test: 5\n    // @ts-expect-error\nconst test2 = satisfies<string>()(5)\n    //^? Argument of type 'number' is not assignable to parameter of type 'string'\n\nassert.deepStrictEqual(satisfies<number>()(5), 5)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "constant",
    "description": "Creates a constant value that never changes.\n\nThis is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)\nand want that inner function to always use the same value, no matter how many times it is called.",
    "deprecated": false,
    "examples": [
      "import { constant } from \"effect/Function\"\n\nconst constNull = constant(null)\n\nassert.deepStrictEqual(constNull(), null)\nassert.deepStrictEqual(constNull(), null)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "flip",
    "description": "Reverses the order of arguments for a curried function.",
    "deprecated": false,
    "examples": [
      "import { flip } from \"effect/Function\"\n\nconst f = (a: number) => (b: string) => a - b.length\n\nassert.deepStrictEqual(flip(f)('aaa')(2), -1)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "absurd",
    "description": "The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,\nmeaning that it should be impossible for this code to be executed.\n\nThis function is particularly useful when it's necessary to specify that certain cases are impossible.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "tupled",
    "description": "Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.",
    "deprecated": false,
    "examples": [
      "import { tupled } from \"effect/Function\"\n\nconst sumTupled = tupled((x: number, y: number): number => x + y)\n\nassert.deepStrictEqual(sumTupled([1, 2]), 3)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "untupled",
    "description": "Inverse function of `tupled`",
    "deprecated": false,
    "examples": [
      "import { untupled } from \"effect/Function\"\n\nconst getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])\n\nassert.deepStrictEqual(getFirst(1, 2), 1)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "SK",
    "description": "The SK combinator, also known as the \"S-K combinator\" or \"S-combinator\", is a fundamental combinator in the\nlambda calculus and the SKI combinator calculus.\n\nThis function is useful for discarding the first argument passed to it and returning the second argument.",
    "deprecated": false,
    "examples": [
      "import { SK } from \"effect/Function\";\n\nassert.deepStrictEqual(SK(0, \"hello\"), \"hello\")"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "FunctionN",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { FunctionN } from \"effect/Function\"\n\nconst sum: FunctionN<[number, number], number> = (a, b) => a + b"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface FunctionN<A extends ReadonlyArray<unknown>, B> {\n  (...args: A): B\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "FunctionTypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface FunctionTypeLambda extends TypeLambda {\n  readonly type: (a: this[\"In\"]) => this[\"Target\"]\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Function",
      "path": [
        "src",
        "Function.ts"
      ]
    },
    "project": "effect",
    "name": "LazyArg",
    "description": "A lazy argument.",
    "deprecated": false,
    "examples": [
      "import { LazyArg, constant } from \"effect/Function\"\n\nconst constNull: LazyArg<null> = constant(null)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface LazyArg<A> {\n  (): A\n}"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "GlobalValue",
      "path": [
        "src",
        "GlobalValue.ts"
      ]
    },
    "project": "effect",
    "name": "globalValue",
    "description": "Retrieves or computes a global value associated with the given `id`. If the value for this `id`\nhas already been computed, it will be returned from the global store. If it does not exist yet,\nthe provided `compute` function will be executed to compute the value, store it, and then return it.\n\nThis ensures that even in cases where the module is imported multiple times (e.g., in mixed environments\nlike CommonJS and ESM, or during hot-reloading in development), the value is computed only once and reused\nthereafter.",
    "deprecated": false,
    "examples": [
      "import { globalValue } from \"effect/GlobalValue\"\n\n// This cache will persist as long as the module is running,\n// even if reloaded or imported elsewhere\nconst myCache = globalValue(\n  Symbol.for(\"myCache\"),\n  () => new WeakMap<object, number>()\n)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "GroupBy",
      "path": [
        "src",
        "GroupBy.ts"
      ]
    },
    "project": "effect",
    "name": "GroupByTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const GroupByTypeId: typeof GroupByTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "GroupBy",
      "path": [
        "src",
        "GroupBy.ts"
      ]
    },
    "project": "effect",
    "name": "evaluate",
    "description": "Run the function across all groups, collecting the results in an\narbitrary order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const evaluate: { <K, V, E, A, E2, R2>(f: (key: K, stream: Stream.Stream<V, E, never>) => Stream.Stream<A, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <R>(self: GroupBy<K, V, E, R>) => Stream.Stream<A, E | E2, R2 | R>; <K, V, E, R, A, E2, R2>(self: GroupBy<K, V, E, R>, f: (key: K, stream: Stream.Stream<V, E, never>) => Stream.Stream<A, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): Stream.Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "GroupBy",
      "path": [
        "src",
        "GroupBy.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": "Filter the groups to be processed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const filter: { <K>(predicate: Predicate<NoInfer<K>>): <V, E, R>(self: GroupBy<K, V, E, R>) => GroupBy<K, V, E, R>; <K, V, E, R>(self: GroupBy<K, V, E, R>, predicate: Predicate<K>): GroupBy<K, V, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "GroupBy",
      "path": [
        "src",
        "GroupBy.ts"
      ]
    },
    "project": "effect",
    "name": "first",
    "description": "Only consider the first `n` groups found in the `Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const first: { (n: number): <K, V, E, R>(self: GroupBy<K, V, E, R>) => GroupBy<K, V, E, R>; <K, V, E, R>(self: GroupBy<K, V, E, R>, n: number): GroupBy<K, V, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "GroupBy",
      "path": [
        "src",
        "GroupBy.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a `GroupBy` from a `Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <K, V, E, R>(grouped: Stream.Stream<readonly [K, Queue.Dequeue<Take.Take<V, E>>], E, R>) => GroupBy<K, V, E, R>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "GroupBy",
      "path": [
        "src",
        "GroupBy.ts"
      ]
    },
    "project": "effect",
    "name": "GroupBy",
    "description": "Representation of a grouped stream. This allows to filter which groups will\nbe processed. Once this is applied all groups will be processed in parallel\nand the results will be merged in arbitrary order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface GroupBy<out K, out V, out E = never, out R = never> extends GroupBy.Variance<K, V, E, R>, Pipeable {\n  readonly grouped: Stream.Stream<readonly [K, Queue.Dequeue<Take.Take<V, E>>], E, R>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "GroupBy",
      "path": [
        "src",
        "GroupBy.ts"
      ]
    },
    "project": "effect",
    "name": "GroupByTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type GroupByTypeId = typeof GroupByTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Hash",
      "path": [
        "src",
        "Hash.ts"
      ]
    },
    "project": "effect",
    "name": "symbol",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const symbol: typeof symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Hash",
      "path": [
        "src",
        "Hash.ts"
      ]
    },
    "project": "effect",
    "name": "cached",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": "export declare const cached: { (self: object): (hash: number) => number; (self: object, hash: number): number; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash",
      "path": [
        "src",
        "Hash.ts"
      ]
    },
    "project": "effect",
    "name": "hash",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash",
      "path": [
        "src",
        "Hash.ts"
      ]
    },
    "project": "effect",
    "name": "random",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash",
      "path": [
        "src",
        "Hash.ts"
      ]
    },
    "project": "effect",
    "name": "combine",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash",
      "path": [
        "src",
        "Hash.ts"
      ]
    },
    "project": "effect",
    "name": "optimize",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash",
      "path": [
        "src",
        "Hash.ts"
      ]
    },
    "project": "effect",
    "name": "isHash",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash",
      "path": [
        "src",
        "Hash.ts"
      ]
    },
    "project": "effect",
    "name": "number",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash",
      "path": [
        "src",
        "Hash.ts"
      ]
    },
    "project": "effect",
    "name": "string",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash",
      "path": [
        "src",
        "Hash.ts"
      ]
    },
    "project": "effect",
    "name": "structureKeys",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash",
      "path": [
        "src",
        "Hash.ts"
      ]
    },
    "project": "effect",
    "name": "structure",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Hash",
      "path": [
        "src",
        "Hash.ts"
      ]
    },
    "project": "effect",
    "name": "array",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "hashing",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Hash",
      "path": [
        "src",
        "Hash.ts"
      ]
    },
    "project": "effect",
    "name": "Hash",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Hash {\n  [symbol](): number\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "isHashMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isHashMap: { <K, V>(u: Iterable<readonly [K, V]>): u is HashMap<K, V>; (u: unknown): u is HashMap<unknown, unknown>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates a new `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: <K = never, V = never>() => HashMap<K, V>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new `HashMap` from an array of key/value pairs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <Entries extends ReadonlyArray<readonly [any, any]>>(...entries: Entries) => HashMap<Entries[number] extends readonly [infer K, any] ? K : never, Entries[number] extends readonly [any, infer V] ? V : never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `HashMap` from an iterable collection of key/value pairs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterable: <K, V>(entries: Iterable<readonly [K, V]>) => HashMap<K, V>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Checks if the `HashMap` contains any entries.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const isEmpty: <K, V>(self: HashMap<K, V>) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Safely lookup the value for the specified key in the `HashMap` using the\ninternal hashing function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const get: { <K1>(key: K1): <K, V>(self: HashMap<K, V>) => Option<V>; <K, V, K1>(self: HashMap<K, V>, key: K1): Option<V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "getHash",
    "description": "Lookup the value for the specified key in the `HashMap` using a custom hash.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const getHash: { <K1>(key: K1, hash: number): <K, V>(self: HashMap<K, V>) => Option<V>; <K, V, K1>(self: HashMap<K, V>, key: K1, hash: number): Option<V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeGet",
    "description": "Unsafely lookup the value for the specified key in the `HashMap` using the\ninternal hashing function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeGet: { <K1>(key: K1): <K, V>(self: HashMap<K, V>) => V; <K, V, K1>(self: HashMap<K, V>, key: K1): V; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "has",
    "description": "Checks if the specified key has an entry in the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const has: { <K1>(key: K1): <K, V>(self: HashMap<K, V>) => boolean; <K, V, K1>(self: HashMap<K, V>, key: K1): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "hasHash",
    "description": "Checks if the specified key has an entry in the `HashMap` using a custom\nhash.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const hasHash: { <K1>(key: K1, hash: number): <K, V>(self: HashMap<K, V>) => boolean; <K, V, K1>(self: HashMap<K, V>, key: K1, hash: number): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": "Sets the specified key to the specified value using the internal hashing\nfunction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const set: { <K, V>(key: K, value: V): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, value: V): HashMap<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "keys",
    "description": "Returns an `IterableIterator` of the keys within the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const keys: <K, V>(self: HashMap<K, V>) => IterableIterator<K>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "keySet",
    "description": "Returns a `HashSet` of keys within the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getter",
    "signature": "export declare const keySet: <K, V>(self: HashMap<K, V>) => HashSet<K>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "values",
    "description": "Returns an `IterableIterator` of the values within the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const values: <K, V>(self: HashMap<K, V>) => IterableIterator<V>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "entries",
    "description": "Returns an `IterableIterator` of the entries within the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const entries: <K, V>(self: HashMap<K, V>) => IterableIterator<[K, V]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the number of entries within the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const size: <K, V>(self: HashMap<K, V>) => number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "beginMutation",
    "description": "Marks the `HashMap` as mutable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const beginMutation: <K, V>(self: HashMap<K, V>) => HashMap<K, V>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "endMutation",
    "description": "Marks the `HashMap` as immutable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const endMutation: <K, V>(self: HashMap<K, V>) => HashMap<K, V>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "mutate",
    "description": "Mutates the `HashMap` within the context of the provided function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const mutate: { <K, V>(f: (self: HashMap<K, V>) => void): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, f: (self: HashMap<K, V>) => void): HashMap<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "modifyAt",
    "description": "Set or remove the specified key in the `HashMap` using the specified\nupdate function. The value of the specified key will be computed using the\nprovided hash.\n\nThe update function will be invoked with the current value of the key if it\nexists, or `None` if no such value exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const modifyAt: { <K, V>(key: K, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, f: HashMap.UpdateFn<V>): HashMap<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "modifyHash",
    "description": "Alter the value of the specified key in the `HashMap` using the specified\nupdate function. The value of the specified key will be computed using the\nprovided hash.\n\nThe update function will be invoked with the current value of the key if it\nexists, or `None` if no such value exists.\n\nThis function will always either update or insert a value into the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const modifyHash: { <K, V>(key: K, hash: number, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, hash: number, f: HashMap.UpdateFn<V>): HashMap<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "modify",
    "description": "Updates the value of the specified key within the `HashMap` if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const modify: { <K, V>(key: K, f: (v: V) => V): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, f: (v: V) => V): HashMap<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "union",
    "description": "Performs a union of this `HashMap` and that `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const union: { <K1, V1>(that: HashMap<K1, V1>): <K0, V0>(self: HashMap<K0, V0>) => HashMap<K1 | K0, V1 | V0>; <K0, V0, K1, V1>(self: HashMap<K0, V0>, that: HashMap<K1, V1>): HashMap<K0 | K1, V0 | V1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "remove",
    "description": "Remove the entry for the specified key in the `HashMap` using the internal\nhashing function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const remove: { <K>(key: K): <V>(self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K): HashMap<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "removeMany",
    "description": "Removes all entries in the `HashMap` which have the specified keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const removeMany: { <K>(keys: Iterable<K>): <V>(self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, keys: Iterable<K>): HashMap<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Maps over the entries of the `HashMap` using the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <A, V, K>(f: (value: V, key: K) => A): (self: HashMap<K, V>) => HashMap<K, A>; <K, V, A>(self: HashMap<K, V>, f: (value: V, key: K) => A): HashMap<K, A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Chains over the entries of the `HashMap` using the specified function.\n\n**NOTE**: the hash and equal of both maps have to be the same.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMap: { <A, K, B>(f: (value: A, key: K) => HashMap<K, B>): (self: HashMap<K, A>) => HashMap<K, B>; <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => HashMap<K, B>): HashMap<K, B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "Applies the specified function to the entries of the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const forEach: { <V, K>(f: (value: V, key: K) => void): (self: HashMap<K, V>) => void; <V, K>(self: HashMap<K, V>, f: (value: V, key: K) => void): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": "Reduces the specified state over the entries of the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduce: { <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: HashMap<K, V>) => Z; <K, V, Z>(self: HashMap<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters entries out of a `HashMap` using the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filter: { <K, A, B extends A>(f: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => HashMap<K, B>; <K, A>(f: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => HashMap<K, A>; <K, A, B extends A>(self: HashMap<K, A>, f: (a: A, k: K) => a is B): HashMap<K, B>; <K, A>(self: HashMap<K, A>, f: (a: A, k: K) => boolean): HashMap<K, A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "compact",
    "description": "Filters out `None` values from a `HashMap` of `Options`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const compact: <K, A>(self: HashMap<K, Option<A>>) => HashMap<K, A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Maps over the entries of the `HashMap` using the specified partial function\nand filters out `None` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterMap: { <A, K, B>(f: (value: A, key: K) => Option<B>): (self: HashMap<K, A>) => HashMap<K, B>; <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => Option<B>): HashMap<K, B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirst: { <K, A, B extends A>(predicate: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => Option<[K, B]>; <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => Option<[K, A]>; <K, A, B extends A>(self: HashMap<K, A>, predicate: (a: A, k: K) => a is B): Option<[K, B]>; <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): Option<[K, A]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": "Checks if any entry in a hashmap meets a specific condition.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "elements",
    "signature": "export declare const some: { <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => boolean; <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "toValues",
    "description": "Returns an `Array` of the values within the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "toEntries",
    "description": "Returns an `Array<[K, V]>` of the entries within the `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "HashMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface HashMap<out Key, out Value> extends Iterable<[Key, Value]>, Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "HashMap",
      "path": [
        "src",
        "HashMap.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "isHashSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isHashSet: { <A>(u: Iterable<A>): u is HashSet<A>; (u: unknown): u is HashSet<unknown>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates an empty `HashSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: <A = never>() => HashSet<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `HashSet` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterable: <A>(elements: Iterable<A>) => HashSet<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Construct a new `HashSet` from a variable number of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <As extends ReadonlyArray<any>>(...elements: As) => HashSet<As[number]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "has",
    "description": "Checks if the specified value exists in the `HashSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const has: { <A>(value: A): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, value: A): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": "Check if a predicate holds true for some `HashSet` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const some: { <A>(f: Predicate<A>): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, f: Predicate<A>): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "every",
    "description": "Check if a predicate holds true for every `HashSet` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const every: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => self is HashSet<B>; <A>(predicate: Predicate<A>): (self: HashSet<A>) => boolean; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): self is HashSet<B>; <A>(self: HashSet<A>, predicate: Predicate<A>): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "isSubset",
    "description": "Returns `true` if and only if every element in the this `HashSet` is an\nelement of the second set,\n\n**NOTE**: the hash and equal of both sets must be the same.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const isSubset: { <A>(that: HashSet<A>): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, that: HashSet<A>): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "values",
    "description": "Returns an `IterableIterator` of the values in the `HashSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const values: <A>(self: HashSet<A>) => IterableIterator<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Calculates the number of values in the `HashSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const size: <A>(self: HashSet<A>) => number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "beginMutation",
    "description": "Marks the `HashSet` as mutable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const beginMutation: <A>(self: HashSet<A>) => HashSet<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "endMutation",
    "description": "Marks the `HashSet` as immutable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const endMutation: <A>(self: HashSet<A>) => HashSet<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "mutate",
    "description": "Mutates the `HashSet` within the context of the provided function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const mutate: { <A>(f: (set: HashSet<A>) => void): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, f: (set: HashSet<A>) => void): HashSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "add",
    "description": "Adds a value to the `HashSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const add: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "remove",
    "description": "Removes a value from the `HashSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const remove: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "difference",
    "description": "Computes the set difference between this `HashSet` and the specified\n`Iterable<A>`.\n\n**NOTE**: the hash and equal of the values in both the set and the iterable\nmust be the same.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const difference: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "intersection",
    "description": "Returns a `HashSet` of values which are present in both this set and that\n`Iterable<A>`.\n\n**NOTE**: the hash and equal of the values in both the set and the iterable\nmust be the same.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const intersection: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "union",
    "description": "Computes the set union `(`self` + `that`)` between this `HashSet` and the\nspecified `Iterable<A>`.\n\n**NOTE**: the hash and equal of the values in both the set and the iterable\nmust be the same.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const union: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "toggle",
    "description": "Checks if a value is present in the `HashSet`. If it is present, the value\nwill be removed from the `HashSet`, otherwise the value will be added to the\n`HashSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const toggle: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Maps over the values of the `HashSet` using the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <A, B>(f: (a: A) => B): (self: HashSet<A>) => HashSet<B>; <A, B>(self: HashSet<A>, f: (a: A) => B): HashSet<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Chains over the values of the `HashSet` using the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMap: { <A, B>(f: (a: A) => Iterable<B>): (self: HashSet<A>) => HashSet<B>; <A, B>(self: HashSet<A>, f: (a: A) => Iterable<B>): HashSet<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "Applies the specified function to the values of the `HashSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const forEach: { <A>(f: (value: A) => void): (self: HashSet<A>) => void; <A>(self: HashSet<A>, f: (value: A) => void): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": "Reduces the specified state over the values of the `HashSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduce: { <A, Z>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: HashSet<A>) => Z; <A, Z>(self: HashSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters values out of a `HashSet` using the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => HashSet<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => HashSet<A>; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): HashSet<B>; <A>(self: HashSet<A>, predicate: Predicate<A>): HashSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "partition",
    "description": "Partition the values of a `HashSet` using the specified predicate.\n\nIf a value matches the predicate, it will be placed into the `HashSet` on the\nright side of the resulting `Tuple`, otherwise the value will be placed into\nthe left side.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "partitioning",
    "signature": "export declare const partition: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]; <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => [excluded: HashSet<A>, satisfying: HashSet<A>]; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]; <A>(self: HashSet<A>, predicate: Predicate<A>): [excluded: HashSet<A>, satisfying: HashSet<A>]; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "toValues",
    "description": "Returns an `Array` of the values within the `HashSet`.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "HashSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface HashSet<out A> extends Iterable<A>, Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "HashSet",
      "path": [
        "src",
        "HashSet.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "HKT",
      "path": [
        "src",
        "HKT.ts"
      ]
    },
    "project": "effect",
    "name": "TypeClass",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TypeClass<F extends TypeLambda> {\n  readonly [URI]?: F\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "HKT",
      "path": [
        "src",
        "HKT.ts"
      ]
    },
    "project": "effect",
    "name": "TypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TypeLambda {\n  readonly In: unknown\n  readonly Out2: unknown\n  readonly Out1: unknown\n  readonly Target: unknown\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "HKT",
      "path": [
        "src",
        "HKT.ts"
      ]
    },
    "project": "effect",
    "name": "Kind",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type Kind<F extends TypeLambda, In, Out2, Out1, Target> = F extends {\n  readonly type: unknown\n} ? (F & {\n    readonly In: In\n    readonly Out2: Out2\n    readonly Out1: Out1\n    readonly Target: Target\n  })[\"type\"]\n  : {\n    readonly F: F\n    readonly In: Types.Contravariant<In>\n    readonly Out2: Types.Covariant<Out2>\n    readonly Out1: Types.Covariant<Out1>\n    readonly Target: Types.Invariant<Target>\n  }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "absurd",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const absurd: <A>(_: never) => A"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "flow",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const flow: typeof flow"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "hole",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const hole: <T>() => T"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "identity",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const identity: <A>(a: A) => A"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "pipe",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const pipe: typeof pipe"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeCoerce",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const unsafeCoerce: <A, B>(a: A) => B"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Arbitrary.js\"",
    "description": "Re-exports all named exports from the \"./Arbitrary.js\" module as `Arbitrary`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "exports",
    "signature": "export * as Arbitrary from \"./Arbitrary.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Array.js\"",
    "description": "This module provides utility functions for working with arrays in TypeScript.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Array from \"./Array.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./BigDecimal.js\"",
    "description": "This module provides utility functions and type class instances for working with the `BigDecimal` type in TypeScript.\nIt includes functions for basic arithmetic operations, as well as type class instances for `Equivalence` and `Order`.\n\nA `BigDecimal` allows storing any real number to arbitrary precision; which avoids common floating point errors\n(such as 0.1 + 0.2  0.3) at the cost of complexity.\n\nInternally, `BigDecimal` uses a `BigInt` object, paired with a 64-bit integer which determines the position of the\ndecimal point. Therefore, the precision *is not* actually arbitrary, but limited to 2<sup>63</sup> decimal places.\n\nIt is not recommended to convert a floating point number to a decimal directly, as the floating point representation\nmay be unexpected.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as BigDecimal from \"./BigDecimal.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./BigInt.js\"",
    "description": "This module provides utility functions and type class instances for working with the `bigint` type in TypeScript.\nIt includes functions for basic arithmetic operations, as well as type class instances for\n`Equivalence` and `Order`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as BigInt from \"./BigInt.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Boolean.js\"",
    "description": "This module provides utility functions and type class instances for working with the `boolean` type in TypeScript.\nIt includes functions for basic boolean operations, as well as type class instances for\n`Equivalence` and `Order`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Boolean from \"./Boolean.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Brand.js\"",
    "description": "This module provides types and utility functions to create and work with branded types,\nwhich are TypeScript types with an added type tag to prevent accidental usage of a value in the wrong context.\n\nThe `refined` and `nominal` functions are both used to create branded types in TypeScript.\nThe main difference between them is that `refined` allows for validation of the data, while `nominal` does not.\n\nThe `nominal` function is used to create a new branded type that has the same underlying type as the input, but with a different name.\nThis is useful when you want to distinguish between two values of the same type that have different meanings.\nThe `nominal` function does not perform any validation of the input data.\n\nOn the other hand, the `refined` function is used to create a new branded type that has the same underlying type as the input,\nbut with a different name, and it also allows for validation of the input data.\nThe `refined` function takes a predicate that is used to validate the input data.\nIf the input data fails the validation, a `BrandErrors` is returned, which provides information about the specific validation failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Brand from \"./Brand.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Cache.js\"",
    "description": "Re-exports all named exports from the \"./Cache.js\" module as `Cache`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Cache from \"./Cache.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Cause.js\"",
    "description": "The `Effect<A, E, R>` type is polymorphic in values of type `E` and we can\nwork with any error type that we want. However, there is a lot of information\nthat is not inside an arbitrary `E` value. So as a result, an `Effect` needs\nsomewhere to store things like unexpected errors or defects, stack and\nexecution traces, causes of fiber interruptions, and so forth.\n\nEffect-TS is very strict about preserving the full information related to a\nfailure. It captures all type of errors into the `Cause` data type. `Effect`\nuses the `Cause<E>` data type to store the full story of failure. So its\nerror model is lossless. It doesn't throw information related to the failure\nresult. So we can figure out exactly what happened during the operation of\nour effects.\n\nIt is important to note that `Cause` is an underlying data type representing\nerrors occuring within an `Effect` workflow. Thus, we don't usually deal with\n`Cause`s directly. Even though it is not a data type that we deal with very\noften, the `Cause` of a failing `Effect` workflow can be accessed at any\ntime, which gives us total access to all parallel and sequential errors in\noccurring within our codebase.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Cause from \"./Cause.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Channel.js\"",
    "description": "Re-exports all named exports from the \"./Channel.js\" module as `Channel`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Channel from \"./Channel.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./ChildExecutorDecision.js\"",
    "description": "Re-exports all named exports from the \"./ChildExecutorDecision.js\" module as `ChildExecutorDecision`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as ChildExecutorDecision from \"./ChildExecutorDecision.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Chunk.js\"",
    "description": "Re-exports all named exports from the \"./Chunk.js\" module as `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Chunk from \"./Chunk.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Clock.js\"",
    "description": "Re-exports all named exports from the \"./Clock.js\" module as `Clock`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Clock from \"./Clock.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Config.js\"",
    "description": "Re-exports all named exports from the \"./Config.js\" module as `Config`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Config from \"./Config.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./ConfigError.js\"",
    "description": "Re-exports all named exports from the \"./ConfigError.js\" module as `ConfigError`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as ConfigError from \"./ConfigError.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./ConfigProvider.js\"",
    "description": "Re-exports all named exports from the \"./ConfigProvider.js\" module as `ConfigProvider`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as ConfigProvider from \"./ConfigProvider.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./ConfigProviderPathPatch.js\"",
    "description": "Re-exports all named exports from the \"./ConfigProviderPathPatch.js\" module as `ConfigProviderPathPatch`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as ConfigProviderPathPatch from \"./ConfigProviderPathPatch.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Console.js\"",
    "description": "Re-exports all named exports from the \"./Console.js\" module as `Console`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Console from \"./Console.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Context.js\"",
    "description": "This module provides a data structure called `Context` that can be used for dependency injection in effectful\nprograms. It is essentially a table mapping `Tag`s to their implementations (called `Service`s), and can be used to\nmanage dependencies in a type-safe way. The `Context` data structure is essentially a way of providing access to a set\nof related services that can be passed around as a single unit. This module provides functions to create, modify, and\nquery the contents of a `Context`, as well as a number of utility types for working with tags and services.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Context from \"./Context.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Cron.js\"",
    "description": "Re-exports all named exports from the \"./Cron.js\" module as `Cron`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Cron from \"./Cron.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Data.js\"",
    "description": "Re-exports all named exports from the \"./Data.js\" module as `Data`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Data from \"./Data.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./DateTime.js\"",
    "description": "Re-exports all named exports from the \"./DateTime.js\" module as `DateTime`.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "exports",
    "signature": "export * as DateTime from \"./DateTime.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./DefaultServices.js\"",
    "description": "Re-exports all named exports from the \"./DefaultServices.js\" module as `DefaultServices`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as DefaultServices from \"./DefaultServices.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Deferred.js\"",
    "description": "Re-exports all named exports from the \"./Deferred.js\" module as `Deferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Deferred from \"./Deferred.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Differ.js\"",
    "description": "Re-exports all named exports from the \"./Differ.js\" module as `Differ`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Differ from \"./Differ.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Duration.js\"",
    "description": "Re-exports all named exports from the \"./Duration.js\" module as `Duration`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Duration from \"./Duration.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Effect.js\"",
    "description": "Re-exports all named exports from the \"./Effect.js\" module as `Effect`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Effect from \"./Effect.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Effectable.js\"",
    "description": "Re-exports all named exports from the \"./Effectable.js\" module as `Effectable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Effectable from \"./Effectable.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Either.js\"",
    "description": "Re-exports all named exports from the \"./Either.js\" module as `Either`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Either from \"./Either.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Encoding.js\"",
    "description": "This module provides encoding & decoding functionality for:\n\n- base64 (RFC4648)\n- base64 (URL)\n- hex",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Encoding from \"./Encoding.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Equal.js\"",
    "description": "Re-exports all named exports from the \"./Equal.js\" module as `Equal`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Equal from \"./Equal.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Equivalence.js\"",
    "description": "This module provides an implementation of the `Equivalence` type class, which defines a binary relation\nthat is reflexive, symmetric, and transitive. In other words, it defines a notion of equivalence between values of a certain type.\nThese properties are also known in mathematics as an \"equivalence relation\".",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Equivalence from \"./Equivalence.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./ExecutionStrategy.js\"",
    "description": "Re-exports all named exports from the \"./ExecutionStrategy.js\" module as `ExecutionStrategy`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as ExecutionStrategy from \"./ExecutionStrategy.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Exit.js\"",
    "description": "Re-exports all named exports from the \"./Exit.js\" module as `Exit`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Exit from \"./Exit.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./FastCheck.js\"",
    "description": "Re-exports all named exports from the \"./FastCheck.js\" module as `FastCheck`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "exports",
    "signature": "export * as FastCheck from \"./FastCheck.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Fiber.js\"",
    "description": "Re-exports all named exports from the \"./Fiber.js\" module as `Fiber`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Fiber from \"./Fiber.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./FiberHandle.js\"",
    "description": "Re-exports all named exports from the \"./FiberHandle.js\" module as `FiberHandle`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as FiberHandle from \"./FiberHandle.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./FiberId.js\"",
    "description": "Re-exports all named exports from the \"./FiberId.js\" module as `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as FiberId from \"./FiberId.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./FiberMap.js\"",
    "description": "Re-exports all named exports from the \"./FiberMap.js\" module as `FiberMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as FiberMap from \"./FiberMap.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./FiberRef.js\"",
    "description": "Re-exports all named exports from the \"./FiberRef.js\" module as `FiberRef`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as FiberRef from \"./FiberRef.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./FiberRefs.js\"",
    "description": "Re-exports all named exports from the \"./FiberRefs.js\" module as `FiberRefs`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as FiberRefs from \"./FiberRefs.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./FiberRefsPatch.js\"",
    "description": "Re-exports all named exports from the \"./FiberRefsPatch.js\" module as `FiberRefsPatch`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as FiberRefsPatch from \"./FiberRefsPatch.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./FiberSet.js\"",
    "description": "Re-exports all named exports from the \"./FiberSet.js\" module as `FiberSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as FiberSet from \"./FiberSet.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./FiberStatus.js\"",
    "description": "Re-exports all named exports from the \"./FiberStatus.js\" module as `FiberStatus`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as FiberStatus from \"./FiberStatus.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Function.js\"",
    "description": "Re-exports all named exports from the \"./Function.js\" module as `Function`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Function from \"./Function.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./GlobalValue.js\"",
    "description": "The `GlobalValue` module ensures that a single instance of a value is created globally,\neven when modules are imported multiple times (e.g., due to mixing CommonJS and ESM builds)\nor during hot-reloading in development environments like Next.js or Remix.\n\nIt achieves this by using a versioned global store, identified by a unique `Symbol` tied to\nthe current version of the `effect` library. The store holds values that are keyed by an identifier,\nallowing the reuse of previously computed instances across imports or reloads.\n\nThis pattern is particularly useful in scenarios where frequent reloading can cause services or\nsingle-instance objects to be recreated unnecessarily, such as in development environments with hot-reloading.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as GlobalValue from \"./GlobalValue.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./GroupBy.js\"",
    "description": "Re-exports all named exports from the \"./GroupBy.js\" module as `GroupBy`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as GroupBy from \"./GroupBy.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./HKT.js\"",
    "description": "Re-exports all named exports from the \"./HKT.js\" module as `HKT`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as HKT from \"./HKT.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Hash.js\"",
    "description": "Re-exports all named exports from the \"./Hash.js\" module as `Hash`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Hash from \"./Hash.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./HashMap.js\"",
    "description": "Re-exports all named exports from the \"./HashMap.js\" module as `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as HashMap from \"./HashMap.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./HashSet.js\"",
    "description": "Re-exports all named exports from the \"./HashSet.js\" module as `HashSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as HashSet from \"./HashSet.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Inspectable.js\"",
    "description": "Re-exports all named exports from the \"./Inspectable.js\" module as `Inspectable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Inspectable from \"./Inspectable.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Iterable.js\"",
    "description": "This module provides utility functions for working with Iterables in TypeScript.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Iterable from \"./Iterable.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./JSONSchema.js\"",
    "description": "Re-exports all named exports from the \"./JSONSchema.js\" module as `JSONSchema`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "exports",
    "signature": "export * as JSONSchema from \"./JSONSchema.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./KeyedPool.js\"",
    "description": "Re-exports all named exports from the \"./KeyedPool.js\" module as `KeyedPool`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as KeyedPool from \"./KeyedPool.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Layer.js\"",
    "description": "A `Layer<ROut, E, RIn>` describes how to build one or more services in your\napplication. Services can be injected into effects via\n`Effect.provideService`. Effects can require services via `Effect.service`.\n\nLayer can be thought of as recipes for producing bundles of services, given\ntheir dependencies (other services).\n\nConstruction of services can be effectful and utilize resources that must be\nacquired and safely released when the services are done being utilized.\n\nBy default layers are shared, meaning that if the same layer is used twice\nthe layer will only be allocated a single time.\n\nBecause of their excellent composition properties, layers are the idiomatic\nway in Effect-TS to create services that depend on other services.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Layer from \"./Layer.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./List.js\"",
    "description": "A data type for immutable linked lists representing ordered collections of elements of type `A`.\n\nThis data type is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.\n\n**Performance**\n\n- Time: `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list. This includes the index-based lookup of elements, `length`, `append` and `reverse`.\n- Space: `List` implements structural sharing of the tail list. This means that many operations are either zero- or constant-memory cost.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as List from \"./List.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./LogLevel.js\"",
    "description": "Re-exports all named exports from the \"./LogLevel.js\" module as `LogLevel`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as LogLevel from \"./LogLevel.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./LogSpan.js\"",
    "description": "Re-exports all named exports from the \"./LogSpan.js\" module as `LogSpan`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as LogSpan from \"./LogSpan.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Logger.js\"",
    "description": "Re-exports all named exports from the \"./Logger.js\" module as `Logger`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Logger from \"./Logger.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Mailbox.js\"",
    "description": "Re-exports all named exports from the \"./Mailbox.js\" module as `Mailbox`.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "exports",
    "signature": "export * as Mailbox from \"./Mailbox.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./ManagedRuntime.js\"",
    "description": "Re-exports all named exports from the \"./ManagedRuntime.js\" module as `ManagedRuntime`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as ManagedRuntime from \"./ManagedRuntime.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Match.js\"",
    "description": "The `effect/match` module provides a type-safe pattern matching system for\nTypeScript. Inspired by functional programming, it simplifies conditional\nlogic by replacing verbose if/else or switch statements with a structured and\nexpressive API.\n\nThis module supports matching against types, values, and discriminated unions\nwhile enforcing exhaustiveness checking to ensure all cases are handled.\n\nAlthough pattern matching is not yet a native JavaScript feature,\n`effect/match` offers a reliable implementation that is available today.\n\n**How Pattern Matching Works**\n\nPattern matching follows a structured process:\n\n- **Creating a matcher**: Define a `Matcher` that operates on either a\n  specific `Match.type` or `Match.value`.\n\n- **Defining patterns**: Use combinators such as `Match.when`, `Match.not`,\n  and `Match.tag` to specify matching conditions.\n\n- **Completing the match**: Apply a finalizer such as `Match.exhaustive`,\n  `Match.orElse`, or `Match.option` to determine how unmatched cases should\n  be handled.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "exports",
    "signature": "export * as Match from \"./Match.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MergeDecision.js\"",
    "description": "Re-exports all named exports from the \"./MergeDecision.js\" module as `MergeDecision`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MergeDecision from \"./MergeDecision.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MergeState.js\"",
    "description": "Re-exports all named exports from the \"./MergeState.js\" module as `MergeState`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MergeState from \"./MergeState.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MergeStrategy.js\"",
    "description": "Re-exports all named exports from the \"./MergeStrategy.js\" module as `MergeStrategy`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MergeStrategy from \"./MergeStrategy.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Metric.js\"",
    "description": "Re-exports all named exports from the \"./Metric.js\" module as `Metric`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Metric from \"./Metric.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MetricBoundaries.js\"",
    "description": "Re-exports all named exports from the \"./MetricBoundaries.js\" module as `MetricBoundaries`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MetricBoundaries from \"./MetricBoundaries.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MetricHook.js\"",
    "description": "Re-exports all named exports from the \"./MetricHook.js\" module as `MetricHook`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MetricHook from \"./MetricHook.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MetricKey.js\"",
    "description": "Re-exports all named exports from the \"./MetricKey.js\" module as `MetricKey`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MetricKey from \"./MetricKey.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MetricKeyType.js\"",
    "description": "Re-exports all named exports from the \"./MetricKeyType.js\" module as `MetricKeyType`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MetricKeyType from \"./MetricKeyType.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MetricLabel.js\"",
    "description": "Re-exports all named exports from the \"./MetricLabel.js\" module as `MetricLabel`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MetricLabel from \"./MetricLabel.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MetricPair.js\"",
    "description": "Re-exports all named exports from the \"./MetricPair.js\" module as `MetricPair`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MetricPair from \"./MetricPair.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MetricPolling.js\"",
    "description": "Re-exports all named exports from the \"./MetricPolling.js\" module as `MetricPolling`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MetricPolling from \"./MetricPolling.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MetricRegistry.js\"",
    "description": "Re-exports all named exports from the \"./MetricRegistry.js\" module as `MetricRegistry`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MetricRegistry from \"./MetricRegistry.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MetricState.js\"",
    "description": "Re-exports all named exports from the \"./MetricState.js\" module as `MetricState`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MetricState from \"./MetricState.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Micro.js\"",
    "description": "A lightweight alternative to the `Effect` data type, with a subset of the functionality.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "exports",
    "signature": "export * as Micro from \"./Micro.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./ModuleVersion.js\"",
    "description": "Re-exports all named exports from the \"./ModuleVersion.js\" module as `ModuleVersion`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0\n\nEnables low level framework authors to run on their own isolated effect version",
    "category": "exports",
    "signature": "export * as ModuleVersion from \"./ModuleVersion.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MutableHashMap.js\"",
    "description": "Re-exports all named exports from the \"./MutableHashMap.js\" module as `MutableHashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MutableHashMap from \"./MutableHashMap.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MutableHashSet.js\"",
    "description": "Re-exports all named exports from the \"./MutableHashSet.js\" module as `MutableHashSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MutableHashSet from \"./MutableHashSet.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MutableList.js\"",
    "description": "Re-exports all named exports from the \"./MutableList.js\" module as `MutableList`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MutableList from \"./MutableList.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MutableQueue.js\"",
    "description": "Re-exports all named exports from the \"./MutableQueue.js\" module as `MutableQueue`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MutableQueue from \"./MutableQueue.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./MutableRef.js\"",
    "description": "Re-exports all named exports from the \"./MutableRef.js\" module as `MutableRef`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as MutableRef from \"./MutableRef.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./NonEmptyIterable.js\"",
    "description": "Re-exports all named exports from the \"./NonEmptyIterable.js\" module as `NonEmptyIterable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as NonEmptyIterable from \"./NonEmptyIterable.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Number.js\"",
    "description": "This module provides utility functions and type class instances for working with the `number` type in TypeScript.\nIt includes functions for basic arithmetic operations, as well as type class instances for\n`Equivalence` and `Order`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Number from \"./Number.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Option.js\"",
    "description": "Re-exports all named exports from the \"./Option.js\" module as `Option`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Option from \"./Option.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Order.js\"",
    "description": "This module provides an implementation of the `Order` type class which is used to define a total ordering on some type `A`.\nAn order is defined by a relation `<=`, which obeys the following laws:\n\n- either `x <= y` or `y <= x` (totality)\n- if `x <= y` and `y <= x`, then `x == y` (antisymmetry)\n- if `x <= y` and `y <= z`, then `x <= z` (transitivity)\n\nThe truth table for compare is defined as follows:\n\n| `x <= y` | `x >= y` | Ordering |                       |\n| -------- | -------- | -------- | --------------------- |\n| `true`   | `true`   | `0`      | corresponds to x == y |\n| `true`   | `false`  | `< 0`    | corresponds to x < y  |\n| `false`  | `true`   | `> 0`    | corresponds to x > y  |",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Order from \"./Order.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Ordering.js\"",
    "description": "Re-exports all named exports from the \"./Ordering.js\" module as `Ordering`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Ordering from \"./Ordering.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./ParseResult.js\"",
    "description": "Re-exports all named exports from the \"./ParseResult.js\" module as `ParseResult`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "exports",
    "signature": "export * as ParseResult from \"./ParseResult.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Pipeable.js\"",
    "description": "Re-exports all named exports from the \"./Pipeable.js\" module as `Pipeable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Pipeable from \"./Pipeable.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Pool.js\"",
    "description": "Re-exports all named exports from the \"./Pool.js\" module as `Pool`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Pool from \"./Pool.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Predicate.js\"",
    "description": "Re-exports all named exports from the \"./Predicate.js\" module as `Predicate`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Predicate from \"./Predicate.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Pretty.js\"",
    "description": "Re-exports all named exports from the \"./Pretty.js\" module as `Pretty`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "exports",
    "signature": "export * as Pretty from \"./Pretty.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./PrimaryKey.js\"",
    "description": "Re-exports all named exports from the \"./PrimaryKey.js\" module as `PrimaryKey`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as PrimaryKey from \"./PrimaryKey.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./PubSub.js\"",
    "description": "Re-exports all named exports from the \"./PubSub.js\" module as `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as PubSub from \"./PubSub.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Queue.js\"",
    "description": "Re-exports all named exports from the \"./Queue.js\" module as `Queue`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Queue from \"./Queue.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Random.js\"",
    "description": "Re-exports all named exports from the \"./Random.js\" module as `Random`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Random from \"./Random.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./RateLimiter.js\"",
    "description": "Limits the number of calls to a resource to a maximum amount in some interval.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as RateLimiter from \"./RateLimiter.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./RcMap.js\"",
    "description": "Re-exports all named exports from the \"./RcMap.js\" module as `RcMap`.",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "exports",
    "signature": "export * as RcMap from \"./RcMap.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./RcRef.js\"",
    "description": "Re-exports all named exports from the \"./RcRef.js\" module as `RcRef`.",
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "exports",
    "signature": "export * as RcRef from \"./RcRef.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Readable.js\"",
    "description": "Re-exports all named exports from the \"./Readable.js\" module as `Readable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Readable from \"./Readable.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Record.js\"",
    "description": "This module provides utility functions for working with records in TypeScript.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Record from \"./Record.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./RedBlackTree.js\"",
    "description": "Re-exports all named exports from the \"./RedBlackTree.js\" module as `RedBlackTree`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as RedBlackTree from \"./RedBlackTree.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Redacted.js\"",
    "description": "The Redacted module provides functionality for handling sensitive information\nsecurely within your application. By using the `Redacted` data type, you can\nensure that sensitive values are not accidentally exposed in logs or error\nmessages.",
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "exports",
    "signature": "export * as Redacted from \"./Redacted.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Ref.js\"",
    "description": "Re-exports all named exports from the \"./Ref.js\" module as `Ref`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Ref from \"./Ref.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./RegExp.js\"",
    "description": "This module provides utility functions for working with RegExp in TypeScript.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as RegExp from \"./RegExp.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Reloadable.js\"",
    "description": "Re-exports all named exports from the \"./Reloadable.js\" module as `Reloadable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Reloadable from \"./Reloadable.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Request.js\"",
    "description": "Re-exports all named exports from the \"./Request.js\" module as `Request`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Request from \"./Request.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./RequestBlock.js\"",
    "description": "Re-exports all named exports from the \"./RequestBlock.js\" module as `RequestBlock`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as RequestBlock from \"./RequestBlock.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./RequestResolver.js\"",
    "description": "Re-exports all named exports from the \"./RequestResolver.js\" module as `RequestResolver`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as RequestResolver from \"./RequestResolver.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Resource.js\"",
    "description": "Re-exports all named exports from the \"./Resource.js\" module as `Resource`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Resource from \"./Resource.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Runtime.js\"",
    "description": "Re-exports all named exports from the \"./Runtime.js\" module as `Runtime`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Runtime from \"./Runtime.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./RuntimeFlags.js\"",
    "description": "Re-exports all named exports from the \"./RuntimeFlags.js\" module as `RuntimeFlags`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as RuntimeFlags from \"./RuntimeFlags.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./RuntimeFlagsPatch.js\"",
    "description": "Re-exports all named exports from the \"./RuntimeFlagsPatch.js\" module as `RuntimeFlagsPatch`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as RuntimeFlagsPatch from \"./RuntimeFlagsPatch.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./STM.js\"",
    "description": "Re-exports all named exports from the \"./STM.js\" module as `STM`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as STM from \"./STM.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Schedule.js\"",
    "description": "Re-exports all named exports from the \"./Schedule.js\" module as `Schedule`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Schedule from \"./Schedule.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./ScheduleDecision.js\"",
    "description": "Re-exports all named exports from the \"./ScheduleDecision.js\" module as `ScheduleDecision`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as ScheduleDecision from \"./ScheduleDecision.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./ScheduleInterval.js\"",
    "description": "Re-exports all named exports from the \"./ScheduleInterval.js\" module as `ScheduleInterval`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as ScheduleInterval from \"./ScheduleInterval.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./ScheduleIntervals.js\"",
    "description": "Re-exports all named exports from the \"./ScheduleIntervals.js\" module as `ScheduleIntervals`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as ScheduleIntervals from \"./ScheduleIntervals.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Scheduler.js\"",
    "description": "Re-exports all named exports from the \"./Scheduler.js\" module as `Scheduler`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Scheduler from \"./Scheduler.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Schema.js\"",
    "description": "Re-exports all named exports from the \"./Schema.js\" module as `Schema`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "exports",
    "signature": "export * as Schema from \"./Schema.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./SchemaAST.js\"",
    "description": "Re-exports all named exports from the \"./SchemaAST.js\" module as `SchemaAST`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "exports",
    "signature": "export * as SchemaAST from \"./SchemaAST.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Scope.js\"",
    "description": "Re-exports all named exports from the \"./Scope.js\" module as `Scope`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Scope from \"./Scope.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./ScopedCache.js\"",
    "description": "Re-exports all named exports from the \"./ScopedCache.js\" module as `ScopedCache`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as ScopedCache from \"./ScopedCache.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./ScopedRef.js\"",
    "description": "Re-exports all named exports from the \"./ScopedRef.js\" module as `ScopedRef`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as ScopedRef from \"./ScopedRef.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Secret.js\"",
    "description": "Re-exports all named exports from the \"./Secret.js\" module as `Secret`.",
    "deprecated": true,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Secret from \"./Secret.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./SingleProducerAsyncInput.js\"",
    "description": "Re-exports all named exports from the \"./SingleProducerAsyncInput.js\" module as `SingleProducerAsyncInput`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as SingleProducerAsyncInput from \"./SingleProducerAsyncInput.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Sink.js\"",
    "description": "Re-exports all named exports from the \"./Sink.js\" module as `Sink`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Sink from \"./Sink.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./SortedMap.js\"",
    "description": "Re-exports all named exports from the \"./SortedMap.js\" module as `SortedMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as SortedMap from \"./SortedMap.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./SortedSet.js\"",
    "description": "Re-exports all named exports from the \"./SortedSet.js\" module as `SortedSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as SortedSet from \"./SortedSet.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Stream.js\"",
    "description": "Re-exports all named exports from the \"./Stream.js\" module as `Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Stream from \"./Stream.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./StreamEmit.js\"",
    "description": "Re-exports all named exports from the \"./StreamEmit.js\" module as `StreamEmit`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as StreamEmit from \"./StreamEmit.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./StreamHaltStrategy.js\"",
    "description": "Re-exports all named exports from the \"./StreamHaltStrategy.js\" module as `StreamHaltStrategy`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as StreamHaltStrategy from \"./StreamHaltStrategy.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Streamable.js\"",
    "description": "Re-exports all named exports from the \"./Streamable.js\" module as `Streamable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Streamable from \"./Streamable.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./String.js\"",
    "description": "This module provides utility functions and type class instances for working with the `string` type in TypeScript.\nIt includes functions for basic string manipulation, as well as type class instances for\n`Equivalence` and `Order`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as String from \"./String.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Struct.js\"",
    "description": "This module provides utility functions for working with structs in TypeScript.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Struct from \"./Struct.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Subscribable.js\"",
    "description": "Re-exports all named exports from the \"./Subscribable.js\" module as `Subscribable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Subscribable from \"./Subscribable.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./SubscriptionRef.js\"",
    "description": "Re-exports all named exports from the \"./SubscriptionRef.js\" module as `SubscriptionRef`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as SubscriptionRef from \"./SubscriptionRef.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Supervisor.js\"",
    "description": "A `Supervisor<T>` is allowed to supervise the launching and termination of\nfibers, producing some visible value of type `T` from the supervision.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Supervisor from \"./Supervisor.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Symbol.js\"",
    "description": "Re-exports all named exports from the \"./Symbol.js\" module as `Symbol`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Symbol from \"./Symbol.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./SynchronizedRef.js\"",
    "description": "Re-exports all named exports from the \"./SynchronizedRef.js\" module as `SynchronizedRef`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as SynchronizedRef from \"./SynchronizedRef.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TArray.js\"",
    "description": "Re-exports all named exports from the \"./TArray.js\" module as `TArray`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TArray from \"./TArray.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TDeferred.js\"",
    "description": "Re-exports all named exports from the \"./TDeferred.js\" module as `TDeferred`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TDeferred from \"./TDeferred.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TMap.js\"",
    "description": "Re-exports all named exports from the \"./TMap.js\" module as `TMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TMap from \"./TMap.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TPriorityQueue.js\"",
    "description": "Re-exports all named exports from the \"./TPriorityQueue.js\" module as `TPriorityQueue`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TPriorityQueue from \"./TPriorityQueue.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TPubSub.js\"",
    "description": "Re-exports all named exports from the \"./TPubSub.js\" module as `TPubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TPubSub from \"./TPubSub.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TQueue.js\"",
    "description": "Re-exports all named exports from the \"./TQueue.js\" module as `TQueue`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TQueue from \"./TQueue.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TRandom.js\"",
    "description": "Re-exports all named exports from the \"./TRandom.js\" module as `TRandom`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TRandom from \"./TRandom.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TReentrantLock.js\"",
    "description": "Re-exports all named exports from the \"./TReentrantLock.js\" module as `TReentrantLock`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TReentrantLock from \"./TReentrantLock.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TRef.js\"",
    "description": "Re-exports all named exports from the \"./TRef.js\" module as `TRef`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TRef from \"./TRef.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TSemaphore.js\"",
    "description": "Re-exports all named exports from the \"./TSemaphore.js\" module as `TSemaphore`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TSemaphore from \"./TSemaphore.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TSet.js\"",
    "description": "Re-exports all named exports from the \"./TSet.js\" module as `TSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TSet from \"./TSet.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TSubscriptionRef.js\"",
    "description": "Re-exports all named exports from the \"./TSubscriptionRef.js\" module as `TSubscriptionRef`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "exports",
    "signature": "export * as TSubscriptionRef from \"./TSubscriptionRef.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Take.js\"",
    "description": "Re-exports all named exports from the \"./Take.js\" module as `Take`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Take from \"./Take.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TestAnnotation.js\"",
    "description": "Re-exports all named exports from the \"./TestAnnotation.js\" module as `TestAnnotation`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TestAnnotation from \"./TestAnnotation.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TestAnnotationMap.js\"",
    "description": "Re-exports all named exports from the \"./TestAnnotationMap.js\" module as `TestAnnotationMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TestAnnotationMap from \"./TestAnnotationMap.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TestAnnotations.js\"",
    "description": "Re-exports all named exports from the \"./TestAnnotations.js\" module as `TestAnnotations`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TestAnnotations from \"./TestAnnotations.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TestClock.js\"",
    "description": "Re-exports all named exports from the \"./TestClock.js\" module as `TestClock`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TestClock from \"./TestClock.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TestConfig.js\"",
    "description": "Re-exports all named exports from the \"./TestConfig.js\" module as `TestConfig`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TestConfig from \"./TestConfig.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TestContext.js\"",
    "description": "Re-exports all named exports from the \"./TestContext.js\" module as `TestContext`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TestContext from \"./TestContext.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TestLive.js\"",
    "description": "Re-exports all named exports from the \"./TestLive.js\" module as `TestLive`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TestLive from \"./TestLive.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TestServices.js\"",
    "description": "Re-exports all named exports from the \"./TestServices.js\" module as `TestServices`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TestServices from \"./TestServices.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./TestSized.js\"",
    "description": "Re-exports all named exports from the \"./TestSized.js\" module as `TestSized`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as TestSized from \"./TestSized.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Tracer.js\"",
    "description": "Re-exports all named exports from the \"./Tracer.js\" module as `Tracer`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Tracer from \"./Tracer.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Trie.js\"",
    "description": "A `Trie` is used for locating specific `string` keys from within a set.\n\nIt works similar to `HashMap`, but with keys required to be `string`.\nThis constraint unlocks some performance optimizations and new methods to get string prefixes (e.g. `keysWithPrefix`, `longestPrefixOf`).\n\nPrefix search is also the main feature that makes a `Trie` more suited than `HashMap` for certain usecases.\n\nA `Trie` is often used to store a dictionary (list of words) that can be searched\nin a manner that allows for efficient generation of completion lists\n(e.g. predict the rest of a word a user is typing).\n\nA `Trie` has O(n) lookup time where `n` is the size of the key,\nor even less than `n` on search misses.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Trie from \"./Trie.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Tuple.js\"",
    "description": "This module provides utility functions for working with tuples in TypeScript.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Tuple from \"./Tuple.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Types.js\"",
    "description": "A collection of types that are commonly used types.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Types from \"./Types.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Unify.js\"",
    "description": "Re-exports all named exports from the \"./Unify.js\" module as `Unify`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Unify from \"./Unify.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./UpstreamPullRequest.js\"",
    "description": "Re-exports all named exports from the \"./UpstreamPullRequest.js\" module as `UpstreamPullRequest`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as UpstreamPullRequest from \"./UpstreamPullRequest.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./UpstreamPullStrategy.js\"",
    "description": "Re-exports all named exports from the \"./UpstreamPullStrategy.js\" module as `UpstreamPullStrategy`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as UpstreamPullStrategy from \"./UpstreamPullStrategy.js\""
  },
  {
    "_tag": "Export",
    "module": {
      "name": "index",
      "path": [
        "src",
        "index.ts"
      ]
    },
    "project": "effect",
    "name": "From \"./Utils.js\"",
    "description": "Re-exports all named exports from the \"./Utils.js\" module as `Utils`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export * as Utils from \"./Utils.js\""
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Inspectable",
      "path": [
        "src",
        "Inspectable.ts"
      ]
    },
    "project": "effect",
    "name": "Class",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare class Class"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Inspectable",
      "path": [
        "src",
        "Inspectable.ts"
      ]
    },
    "project": "effect",
    "name": "NodeInspectSymbol",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const NodeInspectSymbol: typeof NodeInspectSymbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Inspectable",
      "path": [
        "src",
        "Inspectable.ts"
      ]
    },
    "project": "effect",
    "name": "BaseProto",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const BaseProto: Inspectable"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Inspectable",
      "path": [
        "src",
        "Inspectable.ts"
      ]
    },
    "project": "effect",
    "name": "symbolRedactable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "redactable",
    "signature": "export declare const symbolRedactable: typeof symbolRedactable"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Inspectable",
      "path": [
        "src",
        "Inspectable.ts"
      ]
    },
    "project": "effect",
    "name": "toJSON",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Inspectable",
      "path": [
        "src",
        "Inspectable.ts"
      ]
    },
    "project": "effect",
    "name": "format",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Inspectable",
      "path": [
        "src",
        "Inspectable.ts"
      ]
    },
    "project": "effect",
    "name": "toStringUnknown",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Inspectable",
      "path": [
        "src",
        "Inspectable.ts"
      ]
    },
    "project": "effect",
    "name": "stringifyCircular",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Inspectable",
      "path": [
        "src",
        "Inspectable.ts"
      ]
    },
    "project": "effect",
    "name": "isRedactable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "redactable",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Inspectable",
      "path": [
        "src",
        "Inspectable.ts"
      ]
    },
    "project": "effect",
    "name": "withRedactableContext",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "redactable",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Inspectable",
      "path": [
        "src",
        "Inspectable.ts"
      ]
    },
    "project": "effect",
    "name": "redact",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "redactable",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Inspectable",
      "path": [
        "src",
        "Inspectable.ts"
      ]
    },
    "project": "effect",
    "name": "Inspectable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Inspectable {\n  toString(): string\n  toJSON(): unknown\n  [NodeInspectSymbol](): unknown\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Inspectable",
      "path": [
        "src",
        "Inspectable.ts"
      ]
    },
    "project": "effect",
    "name": "Redactable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "redactable",
    "signature": "export interface Redactable {\n  readonly [symbolRedactable]: (fiberRefs: FiberRefs.FiberRefs) => unknown\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Inspectable",
      "path": [
        "src",
        "Inspectable.ts"
      ]
    },
    "project": "effect",
    "name": "NodeInspectSymbol",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type NodeInspectSymbol = typeof NodeInspectSymbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "replicate",
    "description": "Return a `Iterable` containing a value repeated the specified number of times.\n\n**Note**. `n` is normalized to an integer >= 1.",
    "deprecated": false,
    "examples": [
      "import { replicate } from \"effect/Iterable\"\n\nassert.deepStrictEqual(Array.from(replicate(\"a\", 3)), [\"a\", \"a\", \"a\"])"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const replicate: { (n: number): <A>(a: A) => Iterable<A>; <A>(a: A, n: number): Iterable<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "prepend",
    "description": "Prepend an element to the front of an `Iterable`, creating a new `Iterable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const prepend: { <B>(head: B): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, head: B): Iterable<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "prependAll",
    "description": "Prepends the specified prefix iterable to the beginning of the specified iterable.",
    "deprecated": false,
    "examples": [
      "import { Iterable } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.from(Iterable.prependAll([1, 2], [\"a\", \"b\"])),\n  [\"a\", \"b\", 1, 2]\n)"
    ],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const prependAll: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "append",
    "description": "Append an element to the end of an `Iterable`, creating a new `Iterable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const append: { <B>(last: B): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, last: B): Iterable<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "appendAll",
    "description": "Concatenates two iterables, combining their elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const appendAll: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "scan",
    "description": "Reduce an `Iterable` from the left, keeping all intermediate results instead of only the final result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const scan: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): Iterable<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "take",
    "description": "Keep only a max number of elements from the start of an `Iterable`, creating a new `Iterable`.\n\n**Note**. `n` is normalized to a non negative integer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const take: { (n: number): <A>(self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, n: number): Iterable<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "takeWhile",
    "description": "Calculate the longest initial Iterable for which all element satisfy the specified predicate, creating a new `Iterable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const takeWhile: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Iterable<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Iterable<A>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Iterable<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Iterable<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "drop",
    "description": "Drop a max number of elements from the start of an `Iterable`\n\n**Note**. `n` is normalized to a non negative integer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const drop: { (n: number): <A>(self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, n: number): Iterable<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirst: { <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "findLast",
    "description": "Find the last element for which a predicate holds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findLast: { <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Takes two `Iterable`s and returns an `Iterable` of corresponding pairs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zip: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results. If one\ninput `Iterable` is short, excess elements of the longer `Iterable` are discarded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWith: { <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>; <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "intersperse",
    "description": "Places an element in between members of an `Iterable`.\nIf the input is a non-empty array, the result is also a non-empty array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const intersperse: { <B>(middle: B): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, middle: B): Iterable<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "contains",
    "description": "Returns a function that checks if a `Iterable` contains a given value using the default `Equivalence`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const contains: { <A>(a: A): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, a: A): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "chunksOf",
    "description": "Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\nthe `Iterable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "splitting",
    "signature": "export declare const chunksOf: { (n: number): <A>(self: Iterable<A>) => Iterable<Array<A>>; <A>(self: Iterable<A>, n: number): Iterable<Array<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "groupWith",
    "description": "Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s using the provided `isEquivalent` function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "export declare const groupWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<NonEmptyArray<A>>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<NonEmptyArray<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "group",
    "description": "Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "export declare const group: <A>(self: Iterable<A>) => Iterable<NonEmptyArray<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "groupBy",
    "description": "Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\nfunction on each element, and grouping the results according to values returned",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "export declare const groupBy: { <A, K extends string | symbol>(f: (a: A) => K): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; <A, K extends string | symbol>(self: Iterable<A>, f: (a: A) => K): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <A, B>(f: (a: NoInfer<A>, i: number) => B): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, f: (a: NoInfer<A>, i: number) => B): Iterable<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Applies a function to each element in an Iterable and returns a new Iterable containing the concatenated mapped elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMap: { <A, B>(f: (a: NoInfer<A>, i: number) => Iterable<B>): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, f: (a: NoInfer<A>, i: number) => Iterable<B>): Iterable<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "filterMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterMap: { <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Iterable<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "filterMapWhile",
    "description": "Transforms all elements of the `Iterable` for as long as the specified function returns some value",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterMapWhile: { <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Iterable<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "getSomes",
    "description": "Retrieves the `Some` values from an `Iterable` of `Option`s.",
    "deprecated": false,
    "examples": [
      "import { Iterable, Option } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.from(Iterable.getSomes([Option.some(1), Option.none(), Option.some(2)])),\n  [1, 2]\n)"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const getSomes: <A>(self: Iterable<Option<A>>) => Iterable<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filter: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Iterable<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Iterable<A>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Iterable<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Iterable<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "flatMapNullable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMapNullable: { <A, B>(f: (a: A) => B | null | undefined): (self: Iterable<A>) => Iterable<NonNullable<B>>; <A, B>(self: Iterable<A>, f: (a: A) => B | null | undefined): Iterable<NonNullable<B>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": "Check if a predicate holds true for some `Iterable` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const some: { <A>(predicate: (a: A, i: number) => boolean): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "Iterate over the `Iterable` applying `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const forEach: { <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void; <A>(self: Iterable<A>, f: (a: A, i: number) => void): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduce: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "dedupeAdjacentWith",
    "description": "Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const dedupeAdjacentWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "dedupeAdjacent",
    "description": "Deduplicates adjacent elements that are identical.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const dedupeAdjacent: <A>(self: Iterable<A>) => Iterable<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "cartesianWith",
    "description": "Zips this Iterable crosswise with the specified Iterable using the specified combiner.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const cartesianWith: { <A, B, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>; <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "cartesian",
    "description": "Zips this Iterable crosswise with the specified Iterable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const cartesian: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "makeBy",
    "description": "Return a `Iterable` with element `i` initialized with `f(i)`.\n\nIf the `length` is not specified, the `Iterable` will be infinite.\n\n**Note**. `length` is normalized to an integer >= 1.",
    "deprecated": false,
    "examples": [
      "import { makeBy } from \"effect/Iterable\"\n\nassert.deepStrictEqual(Array.from(makeBy(n => n * 2, { length: 5 })), [0, 2, 4, 6, 8])"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "range",
    "description": "Return a `Iterable` containing a range of integers, including both endpoints.\n\nIf `end` is omitted, the range will not have an upper bound.",
    "deprecated": false,
    "examples": [
      "import { range } from \"effect/Iterable\"\n\nassert.deepStrictEqual(Array.from(range(1, 3)), [1, 2, 3])"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "fromRecord",
    "description": "Takes a record and returns an Iterable of tuples containing its keys and values.",
    "deprecated": false,
    "examples": [
      "import { fromRecord } from \"effect/Iterable\"\n\nconst x = { a: 1, b: 2, c: 3 }\nassert.deepStrictEqual(Array.from(fromRecord(x)), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Determine if an `Iterable` is empty",
    "deprecated": false,
    "examples": [
      "import { isEmpty } from \"effect/Iterable\"\n\nassert.deepStrictEqual(isEmpty([]), true);\nassert.deepStrictEqual(isEmpty([1, 2, 3]), false);"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Return the number of elements in a `Iterable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "head",
    "description": "Get the first element of a `Iterable`, or `None` if the `Iterable` is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeHead",
    "description": "Get the first element of a `Iterable`, or throw an error if the `Iterable` is empty.",
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "containsWith",
    "description": "Returns a function that checks if an `Iterable` contains a given value using a provided `isEquivalent` function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "of",
    "description": "Constructs a new `Iterable<A>` from the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens an Iterable of Iterables into a single Iterable",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "getLefts",
    "description": "Retrieves the `Left` values from an `Iterable` of `Either`s.",
    "deprecated": false,
    "examples": [
      "import { Iterable, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.from(Iterable.getLefts([Either.right(1), Either.left(\"err\"), Either.right(2)])),\n  [\"err\"]\n)"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "getRights",
    "description": "Retrieves the `Right` values from an `Iterable` of `Either`s.",
    "deprecated": false,
    "examples": [
      "import { Iterable, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Array.from(Iterable.getRights([Either.right(1), Either.left(\"err\"), Either.right(2)])),\n  [1, 2]\n)"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Iterable",
      "path": [
        "src",
        "Iterable.ts"
      ]
    },
    "project": "effect",
    "name": "unfold",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "fromAST",
    "description": "Returns a JSON Schema with additional options and definitions.\n\n**Warning**\n\nThis function is experimental and subject to change.\n\n**Details**\n\n- `definitions`: A record of definitions that are included in the schema.\n- `definitionPath`: The path to the definitions within the schema (defaults\n  to \"#/$defs/\").\n- `target`: Which spec to target. Possible values are:\n  - `'jsonSchema7'`: JSON Schema draft-07 (default behavior).\n  - `'jsonSchema2019-09'`: JSON Schema draft-2019-09.\n  - `'openApi3.1'`: OpenAPI 3.1.\n- `topLevelReferenceStrategy`: Controls the handling of the top-level\n  reference. Possible values are:\n  - `\"keep\"`: Keep the top-level reference (default behavior).\n  - `\"skip\"`: Skip the top-level reference.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.5",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Any",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Any extends JsonSchemaAnnotations {\n  $id: \"/schemas/any\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7AnyOf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7AnyOf extends JsonSchemaAnnotations {\n  anyOf: Array<JsonSchema7>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Array",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Array extends JsonSchemaAnnotations {\n  type: \"array\"\n  items?: JsonSchema7 | Array<JsonSchema7>\n  minItems?: number\n  maxItems?: number\n  additionalItems?: JsonSchema7 | boolean\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Boolean",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Boolean extends JsonSchemaAnnotations {\n  type: \"boolean\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Enum",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Enum extends JsonSchemaAnnotations {\n  type?: \"string\" | \"number\" | \"boolean\"\n  enum: Array<string | number | boolean>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Enums",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Enums extends JsonSchemaAnnotations {\n  $comment: \"/schemas/enums\"\n  anyOf: Array<{\n    type: \"string\" | \"number\"\n    title: string\n    enum: [string | number]\n  }>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Integer",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Integer extends JsonSchema7Numeric {\n  type: \"integer\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Never",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.5",
    "category": "model",
    "signature": "export interface JsonSchema7Never extends JsonSchemaAnnotations {\n  $id: \"/schemas/never\"\n  not: {}\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Null",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.7",
    "category": "model",
    "signature": "export interface JsonSchema7Null extends JsonSchemaAnnotations {\n  type: \"null\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Number",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Number extends JsonSchema7Numeric {\n  type: \"number\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Numeric",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Numeric extends JsonSchemaAnnotations {\n  minimum?: number\n  exclusiveMinimum?: number\n  maximum?: number\n  exclusiveMaximum?: number\n  multipleOf?: number\n  allOf?: Array<{\n    minimum?: number\n    exclusiveMinimum?: number\n    maximum?: number\n    exclusiveMaximum?: number\n    multipleOf?: number\n  }>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Object",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Object extends JsonSchemaAnnotations {\n  type: \"object\"\n  required: Array<string>\n  properties: Record<string, JsonSchema7>\n  additionalProperties?: boolean | JsonSchema7\n  patternProperties?: Record<string, JsonSchema7>\n  propertyNames?: JsonSchema7\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Ref",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Ref extends JsonSchemaAnnotations {\n  $ref: string\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7String",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7String extends JsonSchemaAnnotations {\n  type: \"string\"\n  minLength?: number\n  maxLength?: number\n  pattern?: string\n  format?: string\n  contentMediaType?: string\n  allOf?: Array<{\n    minLength?: number\n    maxLength?: number\n    pattern?: string\n  }>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Unknown",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Unknown extends JsonSchemaAnnotations {\n  $id: \"/schemas/unknown\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Void",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7Void extends JsonSchemaAnnotations {\n  $id: \"/schemas/void\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7empty extends JsonSchemaAnnotations {\n  $id: \"/schemas/{}\"\n  anyOf: [\n    { type: \"object\" },\n    { type: \"array\" }\n  ]\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7object",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchema7object extends JsonSchemaAnnotations {\n  $id: \"/schemas/object\"\n  anyOf: [\n    { type: \"object\" },\n    { type: \"array\" }\n  ]\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchemaAnnotations",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface JsonSchemaAnnotations {\n  title?: string\n  description?: string\n  default?: unknown\n  examples?: Array<unknown>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export type JsonSchema7 =\n  | JsonSchema7Never\n  | JsonSchema7Any\n  | JsonSchema7Unknown\n  | JsonSchema7Void\n  | JsonSchema7object\n  | JsonSchema7empty\n  | JsonSchema7Ref\n  | JsonSchema7Null\n  | JsonSchema7String\n  | JsonSchema7Number\n  | JsonSchema7Integer\n  | JsonSchema7Boolean\n  | JsonSchema7Array\n  | JsonSchema7Enum\n  | JsonSchema7Enums\n  | JsonSchema7AnyOf\n  | JsonSchema7Object"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "JSONSchema",
      "path": [
        "src",
        "JSONSchema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonSchema7Root",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export type JsonSchema7Root = JsonSchema7 & {\n  $schema?: string\n  $defs?: Record<string, JsonSchema7>\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "KeyedPool",
      "path": [
        "src",
        "KeyedPool.ts"
      ]
    },
    "project": "effect",
    "name": "KeyedPoolTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const KeyedPoolTypeId: typeof KeyedPoolTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "KeyedPool",
      "path": [
        "src",
        "KeyedPool.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Makes a new pool of the specified fixed size. The pool is returned in a\n`Scope`, which governs the lifetime of the pool. When the pool is shutdown\nbecause the `Scope` is closed, the individual items allocated by the pool\nwill be released in some unspecified order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly size: number; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "KeyedPool",
      "path": [
        "src",
        "KeyedPool.ts"
      ]
    },
    "project": "effect",
    "name": "makeWith",
    "description": "Makes a new pool of the specified fixed size. The pool is returned in a\n`Scope`, which governs the lifetime of the pool. When the pool is shutdown\nbecause the `Scope` is closed, the individual items allocated by the pool\nwill be released in some unspecified order.\n\nThe size of the underlying pools can be configured per key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeWith: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly size: (key: K) => number; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "KeyedPool",
      "path": [
        "src",
        "KeyedPool.ts"
      ]
    },
    "project": "effect",
    "name": "makeWithTTL",
    "description": "Makes a new pool with the specified minimum and maximum sizes and time to\nlive before a pool whose excess items are not being used will be shrunk\ndown to the minimum size. The pool is returned in a `Scope`, which governs\nthe lifetime of the pool. When the pool is shutdown because the `Scope` is\nused, the individual items allocated by the pool will be released in some\nunspecified order.\n\nThe size of the underlying pools can be configured per key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeWithTTL: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly min: (key: K) => number; readonly max: (key: K) => number; readonly timeToLive: Duration.DurationInput; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "KeyedPool",
      "path": [
        "src",
        "KeyedPool.ts"
      ]
    },
    "project": "effect",
    "name": "makeWithTTLBy",
    "description": "Makes a new pool with the specified minimum and maximum sizes and time to\nlive before a pool whose excess items are not being used will be shrunk\ndown to the minimum size. The pool is returned in a `Scope`, which governs\nthe lifetime of the pool. When the pool is shutdown because the `Scope` is\nused, the individual items allocated by the pool will be released in some\nunspecified order.\n\nThe size of the underlying pools can be configured per key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeWithTTLBy: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly min: (key: K) => number; readonly max: (key: K) => number; readonly timeToLive: (key: K) => Duration.DurationInput; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "KeyedPool",
      "path": [
        "src",
        "KeyedPool.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves an item from the pool belonging to the given key in a scoped\neffect. Note that if acquisition fails, then the returned effect will fail\nfor that same reason. Retrying a failed acquisition attempt will repeat the\nacquisition attempt.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const get: { <K>(key: K): <A, E>(self: KeyedPool<K, A, E>) => Effect.Effect<A, E, Scope.Scope>; <K, A, E>(self: KeyedPool<K, A, E>, key: K): Effect.Effect<A, E, Scope.Scope>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "KeyedPool",
      "path": [
        "src",
        "KeyedPool.ts"
      ]
    },
    "project": "effect",
    "name": "invalidate",
    "description": "Invalidates the specified item. This will cause the pool to eventually\nreallocate the item, although this reallocation may occur lazily rather\nthan eagerly.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const invalidate: { <A>(item: A): <K, E>(self: KeyedPool<K, A, E>) => Effect.Effect<void>; <K, A, E>(self: KeyedPool<K, A, E>, item: A): Effect.Effect<void>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "KeyedPool",
      "path": [
        "src",
        "KeyedPool.ts"
      ]
    },
    "project": "effect",
    "name": "KeyedPool",
    "description": "A `KeyedPool<K, A, E>` is a pool of `Pool`s of items of type `A`. Each pool\nin the `KeyedPool` is associated with a key of type `K`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface KeyedPool<in K, in out A, out E = never> extends KeyedPool.Variance<K, A, E>, Pipeable {\n  /**\n   * Retrieves an item from the pool belonging to the given key in a scoped\n   * effect. Note that if acquisition fails, then the returned effect will fail\n   * for that same reason. Retrying a failed acquisition attempt will repeat the\n   * acquisition attempt.\n   */\n  get(key: K): Effect.Effect<A, E, Scope.Scope>\n\n  /**\n   * Invalidates the specified item. This will cause the pool to eventually\n   * reallocate the item, although this reallocation may occur lazily rather\n   * than eagerly.\n   */\n  invalidate(item: A): Effect.Effect<void>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "KeyedPool",
      "path": [
        "src",
        "KeyedPool.ts"
      ]
    },
    "project": "effect",
    "name": "KeyedPoolTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type KeyedPoolTypeId = typeof KeyedPoolTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "LayerTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const LayerTypeId: typeof LayerTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "MemoMapTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const MemoMapTypeId: typeof MemoMapTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "isLayer",
    "description": "Returns `true` if the specified value is a `Layer`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isLayer: (u: unknown) => u is Layer<unknown, unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "isFresh",
    "description": "Returns `true` if the specified `Layer` is a fresh version that will not be\nshared, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isFresh: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "annotateLogs",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "tracing",
    "signature": "export declare const annotateLogs: { (key: string, value: unknown): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; (values: Record<string, unknown>): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R>(self: Layer<A, E, R>, key: string, value: unknown): Layer<A, E, R>; <A, E, R>(self: Layer<A, E, R>, values: Record<string, unknown>): Layer<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "annotateSpans",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "tracing",
    "signature": "export declare const annotateSpans: { (key: string, value: unknown): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; (values: Record<string, unknown>): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R>(self: Layer<A, E, R>, key: string, value: unknown): Layer<A, E, R>; <A, E, R>(self: Layer<A, E, R>, values: Record<string, unknown>): Layer<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "build",
    "description": "Builds a layer into a scoped value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const build: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, Scope.Scope | RIn>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "buildWithScope",
    "description": "Builds a layer into an `Effect` value. Any resources associated with this\nlayer will be released when the specified scope is closed unless their scope\nhas been extended. This allows building layers where the lifetime of some of\nthe services output by the layer exceed the lifetime of the effect the\nlayer is provided to.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const buildWithScope: { (scope: Scope.Scope): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, scope: Scope.Scope): Effect.Effect<Context.Context<ROut>, E, RIn>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "catchAll",
    "description": "Recovers from all errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const catchAll: { <E, RIn2, E2, ROut2>(onError: (error: E) => Layer<ROut2, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut & ROut2, E2, RIn2 | RIn>; <RIn, E, ROut, RIn2, E2, ROut2>(self: Layer<ROut, E, RIn>, onError: (error: E) => Layer<ROut2, E2, RIn2>): Layer<ROut & ROut2, E2, RIn | RIn2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "catchAllCause",
    "description": "Recovers from all errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const catchAllCause: { <E, RIn2, E2, ROut2>(onError: (cause: Cause.Cause<E>) => Layer<ROut2, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut & ROut2, E2, RIn2 | RIn>; <RIn, E, ROut, RIn2, E2, ROut22>(self: Layer<ROut, E, RIn>, onError: (cause: Cause.Cause<E>) => Layer<ROut22, E2, RIn2>): Layer<ROut & ROut22, E2, RIn | RIn2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "context",
    "description": "Constructs a `Layer` that passes along the specified context as an\noutput.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const context: <R>() => Layer<R, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "die",
    "description": "Constructs a layer that dies with the specified defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const die: (defect: unknown) => Layer<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "dieSync",
    "description": "Constructs a layer that dies with the specified defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dieSync: (evaluate: LazyArg<unknown>) => Layer<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "discard",
    "description": "Replaces the layer's output with `void` and includes the layer only for its\nside-effects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const discard: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<never, E, RIn>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "effect",
    "description": "Constructs a layer from the specified effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const effect: { <I, S>(tag: Context.Tag<I, S>): <E, R>(effect: Effect.Effect<Types.NoInfer<S>, E, R>) => Layer<I, E, R>; <I, S, E, R>(tag: Context.Tag<I, S>, effect: Effect.Effect<Types.NoInfer<S>, E, R>): Layer<I, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "effectDiscard",
    "description": "Constructs a layer from the specified effect, discarding its output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const effectDiscard: <X, E, R>(effect: Effect.Effect<X, E, R>) => Layer<never, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "effectContext",
    "description": "Constructs a layer from the specified effect, which must return one or more\nservices.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const effectContext: <A, E, R>(effect: Effect.Effect<Context.Context<A>, E, R>) => Layer<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "A Layer that constructs an empty Context.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "extendScope",
    "description": "Extends the scope of this layer, returning a new layer that when provided\nto an effect will not immediately release its associated resources when\nthat effect completes execution but instead when the scope the resulting\neffect depends on is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const extendScope: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E, Scope.Scope | RIn>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": "Constructs a layer that fails with the specified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fail: <E>(error: E) => Layer<unknown, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "failSync",
    "description": "Constructs a layer that fails with the specified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failSync: <E>(evaluate: LazyArg<E>) => Layer<unknown, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "failCause",
    "description": "Constructs a layer that fails with the specified cause.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failCause: <E>(cause: Cause.Cause<E>) => Layer<unknown, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "failCauseSync",
    "description": "Constructs a layer that fails with the specified cause.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Layer<unknown, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Constructs a layer dynamically based on the output of this layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMap: { <A, A2, E2, R2>(f: (context: Context.Context<A>) => Layer<A2, E2, R2>): <E, R>(self: Layer<A, E, R>) => Layer<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Layer<A, E, R>, f: (context: Context.Context<A>) => Layer<A2, E2, R2>): Layer<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens layers nested in the context of an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatten: { <I, A, E2, R2>(tag: Context.Tag<I, Layer<A, E2, R2>>): <E, R>(self: Layer<I, E, R>) => Layer<A, E2 | E, R2 | R>; <I, E, R, A, E2, R2>(self: Layer<I, E, R>, tag: Context.Tag<I, Layer<A, E2, R2>>): Layer<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "fresh",
    "description": "Creates a fresh version of this layer that will not be shared.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const fresh: <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "launch",
    "description": "Builds this layer and uses it until it is interrupted. This is useful when\nyour entire application is a layer, such as an HTTP server.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "export declare const launch: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<never, E, RIn>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Returns a new layer whose output is mapped by the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <A, B>(f: (context: Context.Context<A>) => Context.Context<B>): <E, R>(self: Layer<A, E, R>) => Layer<B, E, R>; <A, E, R, B>(self: Layer<A, E, R>, f: (context: Context.Context<A>) => Context.Context<B>): Layer<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "mapError",
    "description": "Returns a layer with its error channel mapped using the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: Layer<A, E, R>) => Layer<A, E2, R>; <A, E, R, E2>(self: Layer<A, E, R>, f: (error: E) => E2): Layer<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Feeds the error or output services of this layer into the input of either\nthe specified `failure` or `success` layers, resulting in a new layer with\nthe inputs of this layer, and the error or outputs of the specified layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const match: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (error: E) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; }): <R>(self: Layer<A, E, R>) => Layer<A2 & A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Layer<A, E, R>, options: { readonly onFailure: (error: E) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; }): Layer<A2 & A3, E2 | E3, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "matchCause",
    "description": "Feeds the error or output services of this layer into the input of either\nthe specified `failure` or `success` layers, resulting in a new layer with\nthe inputs of this layer, and the error or outputs of the specified layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const matchCause: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; }): <R>(self: Layer<A, E, R>) => Layer<A2 & A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Layer<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; }): Layer<A2 & A3, E2 | E3, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "memoize",
    "description": "Returns a scoped effect that, if evaluated, will return the lazily computed\nresult of this layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const memoize: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Layer<ROut, E, RIn>, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "merge",
    "description": "Merges this layer with the specified layer concurrently, producing a new layer with combined input and output types.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const merge: { <RIn2, E2, ROut2>(that: Layer<ROut2, E2, RIn2>): <RIn, E1, ROut>(self: Layer<ROut, E1, RIn>) => Layer<ROut2 | ROut, E2 | E1, RIn2 | RIn>; <RIn, E1, ROut, RIn2, E2, ROut2>(self: Layer<ROut, E1, RIn>, that: Layer<ROut2, E2, RIn2>): Layer<ROut | ROut2, E1 | E2, RIn | RIn2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "mergeAll",
    "description": "Combines all the provided layers concurrently, creating a new layer with merged input, error, and output types.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const mergeAll: <Layers extends [Layer<never, any, any>, ...Array<Layer<never, any, any>>]>(...layers: Layers) => Layer<{ [k in keyof Layers]: Layer.Success<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "orDie",
    "description": "Translates effect failure into death of the fiber, making all failures\nunchecked and not a part of the type of the layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orDie: <A, E, R>(self: Layer<A, E, R>) => Layer<A, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "orElse",
    "description": "Executes this layer and returns its output, if it succeeds, but otherwise\nexecutes the specified layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElse: { <A2, E2, R2>(that: LazyArg<Layer<A2, E2, R2>>): <A, E, R>(self: Layer<A, E, R>) => Layer<A & A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Layer<A, E, R>, that: LazyArg<Layer<A2, E2, R2>>): Layer<A & A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "passthrough",
    "description": "Returns a new layer that produces the outputs of this layer but also\npasses through the inputs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const passthrough: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<RIn | ROut, E, RIn>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "project",
    "description": "Projects out part of one of the services output by this layer using the\nspecified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const project: { <I1, S1, I2, S2>(tagA: Context.Tag<I1, S1>, tagB: Context.Tag<I2, S2>, f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>): <RIn, E>(self: Layer<I1, E, RIn>) => Layer<I2, E, RIn>; <RIn, E, I1, S1, I2, S2>(self: Layer<I1, E, RIn>, tagA: Context.Tag<I1, S1>, tagB: Context.Tag<I2, S2>, f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>): Layer<I2, E, RIn>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "locallyEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const locallyEffect: { <RIn, E, ROut, RIn2, E2, ROut2>(f: (_: Effect.Effect<RIn, E, Context.Context<ROut>>) => Effect.Effect<RIn2, E2, Context.Context<ROut2>>): (self: Layer<ROut, E, RIn>) => Layer<ROut2, E2, RIn2>; <RIn, E, ROut, RIn2, E2, ROut2>(self: Layer<ROut, E, RIn>, f: (_: Effect.Effect<RIn, E, Context.Context<ROut>>) => Effect.Effect<RIn2, E2, Context.Context<ROut2>>): Layer<ROut2, E2, RIn2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "locally",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const locally: { <X>(ref: FiberRef<X>, value: X): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R, X>(self: Layer<A, E, R>, ref: FiberRef<X>, value: X): Layer<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "locallyWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const locallyWith: { <X>(ref: FiberRef<X>, value: (_: X) => X): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R, X>(self: Layer<A, E, R>, ref: FiberRef<X>, value: (_: X) => X): Layer<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "locallyScoped",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const locallyScoped: <A>(self: FiberRef<A>, value: A) => Layer<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "fiberRefLocallyScopedWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const fiberRefLocallyScopedWith: <A>(self: FiberRef<A>, value: (_: A) => A) => Layer<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "retry",
    "description": "Retries constructing this layer according to the specified schedule.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "retrying",
    "signature": "export declare const retry: { <X, E, RIn2>(schedule: Schedule.Schedule<X, NoInfer<E>, RIn2>): <ROut, RIn>(self: Layer<ROut, E, RIn>) => Layer<ROut, E, RIn2 | RIn>; <ROut, E, RIn, X, RIn2>(self: Layer<ROut, E, RIn>, schedule: Schedule.Schedule<X, E, RIn2>): Layer<ROut, E, RIn | RIn2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "scope",
    "description": "A layer that constructs a scope and closes it when the workflow the layer\nis provided to completes execution, whether by success, failure, or\ninterruption. This can be used to close a scope when providing a layer to a\nworkflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const scope: Layer<Scope.Scope, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "scoped",
    "description": "Constructs a layer from the specified scoped effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const scoped: { <I, S>(tag: Context.Tag<I, S>): <E, R>(effect: Effect.Effect<Types.NoInfer<S>, E, R>) => Layer<I, E, Exclude<R, Scope.Scope>>; <I, S, E, R>(tag: Context.Tag<I, S>, effect: Effect.Effect<Types.NoInfer<S>, E, R>): Layer<I, E, Exclude<R, Scope.Scope>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "scopedDiscard",
    "description": "Constructs a layer from the specified scoped effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const scopedDiscard: <X, E, R>(effect: Effect.Effect<X, E, R>) => Layer<never, E, Exclude<R, Scope.Scope>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "scopedContext",
    "description": "Constructs a layer from the specified scoped effect, which must return one\nor more services.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const scopedContext: <A, E, R>(effect: Effect.Effect<Context.Context<A>, E, R>) => Layer<A, E, Exclude<R, Scope.Scope>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "service",
    "description": "Constructs a layer that accesses and returns the specified service from the\ncontext.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const service: <I, S>(tag: Context.Tag<I, S>) => Layer<I, never, I>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": "Constructs a layer from the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const succeed: { <I, S>(tag: Context.Tag<I, S>): (resource: Types.NoInfer<S>) => Layer<I>; <I, S>(tag: Context.Tag<I, S>, resource: Types.NoInfer<S>): Layer<I>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "succeedContext",
    "description": "Constructs a layer from the specified value, which must return one or more\nservices.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const succeedContext: <A>(context: Context.Context<A>) => Layer<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "suspend",
    "description": "Lazily constructs a layer. This is useful to avoid infinite recursion when\ncreating layers that refer to themselves.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const suspend: <RIn, E, ROut>(evaluate: LazyArg<Layer<ROut, E, RIn>>) => Layer<ROut, E, RIn>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "sync",
    "description": "Lazily constructs a layer from the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sync: { <I, S>(tag: Context.Tag<I, S>): (evaluate: LazyArg<Types.NoInfer<S>>) => Layer<I>; <I, S>(tag: Context.Tag<I, S>, evaluate: LazyArg<Types.NoInfer<S>>): Layer<I>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "syncContext",
    "description": "Lazily constructs a layer from the specified value, which must return one or more\nservices.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const syncContext: <A>(evaluate: LazyArg<Context.Context<A>>) => Layer<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "tap",
    "description": "Performs the specified effect if this layer succeeds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const tap: { <ROut, XR extends ROut, RIn2, E2, X>(f: (context: Context.Context<XR>) => Effect.Effect<X, E2, RIn2>): <RIn, E>(self: Layer<ROut, E, RIn>) => Layer<ROut, E2 | E, RIn2 | RIn>; <RIn, E, ROut, XR extends ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (context: Context.Context<XR>) => Effect.Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "tapError",
    "description": "Performs the specified effect if this layer fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const tapError: { <E, XE extends E, RIn2, E2, X>(f: (e: XE) => Effect.Effect<X, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E | E2, RIn2 | RIn>; <RIn, E, XE extends E, ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (e: XE) => Effect.Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "tapErrorCause",
    "description": "Performs the specified effect if this layer fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const tapErrorCause: { <E, XE extends E, RIn2, E2, X>(f: (cause: Cause.Cause<XE>) => Effect.Effect<X, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E | E2, RIn2 | RIn>; <RIn, E, XE extends E, ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (cause: Cause.Cause<XE>) => Effect.Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "toRuntime",
    "description": "Converts a layer that requires no services into a scoped runtime, which can\nbe used to execute effects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "export declare const toRuntime: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "toRuntimeWithMemoMap",
    "description": "Converts a layer that requires no services into a scoped runtime, which can\nbe used to execute effects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "export declare const toRuntimeWithMemoMap: { (memoMap: MemoMap): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, memoMap: MemoMap): Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "provide",
    "description": "Feeds the output services of this builder into the input of the specified\nbuilder, resulting in a new builder with the inputs of this builder as\nwell as any leftover inputs, and the outputs of the specified builder.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const provide: { <RIn, E, ROut>(that: Layer<ROut, E, RIn>): <RIn2, E2, ROut2>(self: Layer<ROut2, E2, RIn2>) => Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <const Layers extends [Layer.Any, ...Array<Layer.Any>]>(that: Layers): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; <RIn2, E2, ROut2, RIn, E, ROut>(self: Layer<ROut2, E2, RIn2>, that: Layer<ROut, E, RIn>): Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <A, E, R, const Layers extends [Layer.Any, ...Array<Layer.Any>]>(self: Layer<A, E, R>, that: Layers): Layer<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "provideMerge",
    "description": "Feeds the output services of this layer into the input of the specified\nlayer, resulting in a new layer with the inputs of this layer, and the\noutputs of both layers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const provideMerge: { <RIn, E, ROut>(self: Layer<ROut, E, RIn>): <RIn2, E2, ROut2>(that: Layer<ROut2, E2, RIn2>) => Layer<ROut | ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <RIn2, E2, ROut2, RIn, E, ROut>(that: Layer<ROut2, E2, RIn2>, self: Layer<ROut, E, RIn>): Layer<ROut2 | ROut, E2 | E, RIn | Exclude<RIn2, ROut>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Combines this layer with the specified layer concurrently, creating a new layer with merged input types and\ncombined output types using the provided function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWith: { <B, E2, R2, A, C>(that: Layer<B, E2, R2>, f: (a: Context.Context<A>, b: Context.Context<B>) => Context.Context<C>): <E, R>(self: Layer<A, E, R>) => Layer<C, E2 | E, R2 | R>; <A, E, R, B, E2, R2, C>(self: Layer<A, E, R>, that: Layer<B, E2, R2>, f: (a: Context.Context<A>, b: Context.Context<B>) => Context.Context<C>): Layer<C, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "unwrapEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const unwrapEffect: <A, E1, R1, E, R>(self: Effect.Effect<Layer<A, E1, R1>, E, R>) => Layer<A, E | E1, R | R1>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "unwrapScoped",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const unwrapScoped: <A, E1, R1, E, R>(self: Effect.Effect<Layer<A, E1, R1>, E, R>) => Layer<A, E | E1, R1 | Exclude<R, Scope.Scope>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "setConfigProvider",
    "description": "Sets the current `ConfigProvider`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "config",
    "signature": "export declare const setConfigProvider: (configProvider: ConfigProvider) => Layer<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "parentSpan",
    "description": "Adds the provided span to the span stack.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "export declare const parentSpan: (span: Tracer.AnySpan) => Layer<Tracer.ParentSpan>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "setRequestCache",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "requests & batching",
    "signature": "export declare const setRequestCache: { <E, R>(cache: Effect.Effect<Request.Cache, E, R>): Layer<never, E, Exclude<R, Scope.Scope>>; (cache: Request.Cache): Layer<never>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "span",
    "description": "Create and add a span to the current span stack.\n\nThe span is ended when the Layer is released.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "export declare const span: (name: string, options?: Tracer.SpanOptions & { readonly onEnd?: ((span: Tracer.Span, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>) | undefined; }) => Layer<Tracer.ParentSpan>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "setTracer",
    "description": "Create a Layer that sets the current Tracer",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "export declare const setTracer: (tracer: Tracer.Tracer) => Layer<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "withSpan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "export declare const withSpan: { (name: string, options?: Tracer.SpanOptions & { readonly onEnd?: ((span: Tracer.Span, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>) | undefined; }): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Layer<A, E, R>, name: string, options?: Tracer.SpanOptions & { readonly onEnd?: ((span: Tracer.Span, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>) | undefined; }): Layer<A, E, Exclude<R, Tracer.ParentSpan>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "withParentSpan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "export declare const withParentSpan: { (span: Tracer.AnySpan): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Layer<A, E, R>, span: Tracer.AnySpan): Layer<A, E, Exclude<R, Tracer.ParentSpan>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "makeMemoMap",
    "description": "Constructs a `MemoMap` that can be used to build additional layers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "memo map",
    "signature": "export declare const makeMemoMap: Effect.Effect<MemoMap, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "buildWithMemoMap",
    "description": "Builds a layer into an `Effect` value, using the specified `MemoMap` to memoize\nthe layer construction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "memo map",
    "signature": "export declare const buildWithMemoMap: { (memoMap: MemoMap, scope: Scope.Scope): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, memoMap: MemoMap, scope: Scope.Scope): Effect.Effect<Context.Context<ROut>, E, RIn>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "updateService",
    "description": "Updates a service in the context with a new implementation.\n\n**Details**\n\nThis function modifies the existing implementation of a service in the\ncontext. It retrieves the current service, applies the provided\ntransformation function `f`, and replaces the old service with the\ntransformed one.\n\n**When to Use**\n\nThis is useful for adapting or extending a service's behavior during the\ncreation of a layer.",
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "utils",
    "signature": "export declare const updateService: (<I, A>(tag: Context.Tag<I, A>, f: (a: A) => A) => <A1, E1, R1>(layer: Layer<A1, E1, R1>) => Layer<A1, E1, I | R1>) & (<A1, E1, R1, I, A>(layer: Layer<A1, E1, R1>, tag: Context.Tag<I, A>, f: (a: A) => A) => Layer<A1, E1, I | R1>)"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "function",
    "description": "Constructs a layer from the context using the specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const function: <I1, S1, I2, S2>(tagA: Context.Tag<I1, S1>, tagB: Context.Tag<I2, S2>, f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>) => Layer<I2, never, I1>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "setClock",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "clock",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "setRequestBatching",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "requests & batching",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "setRequestCaching",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "requests & batching",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "setScheduler",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "scheduler",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "setTracerEnabled",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "setTracerTiming",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "setUnhandledErrorLogLevel",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "logging",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "Layer",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Layer<in ROut, out E = never, out RIn = never> extends Layer.Variance<ROut, E, RIn>, Pipeable {}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "MemoMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MemoMap {\n  readonly [MemoMapTypeId]: MemoMapTypeId\n\n  /** @internal */\n  readonly getOrElseMemoize: <RIn, E, ROut>(\n    layer: Layer<ROut, E, RIn>,\n    scope: Scope.Scope\n  ) => Effect.Effect<Context.Context<ROut>, E, RIn>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "LayerTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type LayerTypeId = typeof LayerTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Layer",
      "path": [
        "src",
        "Layer.ts"
      ]
    },
    "project": "effect",
    "name": "MemoMapTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type MemoMapTypeId = typeof MemoMapTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "Constructs a new empty `List<A>`.\n\nAlias of {@link nil}.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: <A = never>() => List<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "append",
    "description": "Appends the specified element to the end of the `List`, creating a new `Cons`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const append: { <B>(element: B): <A>(self: List<A>) => Cons<A | B>; <A, B>(self: List<A>, element: B): Cons<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "appendAll",
    "description": "Concatenates two lists, combining their elements.\nIf either list is non-empty, the result is also a non-empty list.",
    "deprecated": false,
    "examples": [
      "import { List } from \"effect\"\n\nassert.deepStrictEqual(\n  List.make(1, 2).pipe(List.appendAll(List.make(\"a\", \"b\")), List.toArray),\n  [1, 2, \"a\", \"b\"]\n)"
    ],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const appendAll: { <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>; <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>; <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>; <A, B>(self: List<A>, that: List<B>): List<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "prepend",
    "description": "Prepends the specified element to the beginning of the list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const prepend: { <B>(element: B): <A>(self: List<A>) => Cons<A | B>; <A, B>(self: List<A>, element: B): Cons<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "prependAll",
    "description": "Prepends the specified prefix list to the beginning of the specified list.\nIf either list is non-empty, the result is also a non-empty list.",
    "deprecated": false,
    "examples": [
      "import { List } from \"effect\"\n\nassert.deepStrictEqual(\n  List.make(1, 2).pipe(List.prependAll(List.make(\"a\", \"b\")), List.toArray),\n  [\"a\", \"b\", 1, 2]\n)"
    ],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const prependAll: { <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>; <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>; <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>; <A, B>(self: List<A>, that: List<B>): List<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "prependAllReversed",
    "description": "Prepends the specified prefix list (in reverse order) to the beginning of the\nspecified list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const prependAllReversed: { <B>(prefix: List<B>): <A>(self: List<A>) => List<A | B>; <A, B>(self: List<A>, prefix: List<B>): List<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "drop",
    "description": "Drops the first `n` elements from the specified list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const drop: { (n: number): <A>(self: List<A>) => List<A>; <A>(self: List<A>, n: number): List<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "every",
    "description": "Check if a predicate holds true for every `List` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const every: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => self is List<B>; <A>(predicate: Predicate<A>): (self: List<A>) => boolean; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): self is List<B>; <A>(self: List<A>, predicate: Predicate<A>): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": "Check if a predicate holds true for some `List` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const some: { <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => self is Cons<A>; <A>(self: List<A>, predicate: Predicate<A>): self is Cons<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters a list using the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => List<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => List<A>; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): List<B>; <A>(self: List<A>, predicate: Predicate<A>): List<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Filters and maps a list using the specified partial function. The resulting\nlist may be smaller than the input list due to the possibility of the partial\nfunction not being defined for some elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const filterMap: { <A, B>(f: (a: A) => Option.Option<B>): (self: List<A>) => List<B>; <A, B>(self: List<A>, f: (a: A) => Option.Option<B>): List<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirst: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => Option.Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => Option.Option<A>; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): Option.Option<B>; <A>(self: List<A>, predicate: Predicate<A>): Option.Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMap: { <S extends List<any>, T extends List<any>>(f: (a: List.Infer<S>, i: number) => T): (self: S) => List.AndNonEmpty<S, T, List.Infer<T>>; <A, B>(self: Cons<A>, f: (a: A, i: number) => Cons<B>): Cons<B>; <A, B>(self: List<A>, f: (a: A, i: number) => List<B>): List<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "Applies the specified function to each element of the `List`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const forEach: { <A, B>(f: (a: A) => B): (self: List<A>) => void; <A, B>(self: List<A>, f: (a: A) => B): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Applies the specified mapping function to each element of the list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <S extends List<any>, B>(f: (a: List.Infer<S>, i: number) => B): (self: S) => List.With<S, B>; <S extends List<any>, B>(self: S, f: (a: List.Infer<S>, i: number) => B): List.With<S, B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "partition",
    "description": "Partition a list into two lists, where the first list contains all elements\nthat did not satisfy the specified predicate, and the second list contains\nall elements that did satisfy the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const partition: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => [excluded: List<Exclude<A, B>>, satisfying: List<B>]; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => [excluded: List<A>, satisfying: List<A>]; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): [excluded: List<Exclude<A, B>>, satisfying: List<B>]; <A>(self: List<A>, predicate: Predicate<A>): [excluded: List<A>, satisfying: List<A>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "partitionMap",
    "description": "Partition a list into two lists, where the first list contains all elements\nfor which the specified function returned a `Left`, and the second list\ncontains all elements for which the specified function returned a `Right`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const partitionMap: { <A, B, C>(f: (a: A) => Either.Either<C, B>): (self: List<A>) => [left: List<B>, right: List<C>]; <A, B, C>(self: List<A>, f: (a: A) => Either.Either<C, B>): [left: List<B>, right: List<C>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": "Folds over the elements of the list using the specified function, using the\nspecified initial value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduce: { <Z, A>(zero: Z, f: (b: Z, a: A) => Z): (self: List<A>) => Z; <A, Z>(self: List<A>, zero: Z, f: (b: Z, a: A) => Z): Z; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "reduceRight",
    "description": "Folds over the elements of the list using the specified function, beginning\nwith the last element of the list, using the specified initial value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduceRight: { <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: List<A>) => Z; <Z, A>(self: List<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "splitAt",
    "description": "Splits the specified list into two lists at the specified index.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const splitAt: { (n: number): <A>(self: List<A>) => [beforeIndex: List<A>, fromIndex: List<A>]; <A>(self: List<A>, n: number): [beforeIndex: List<A>, fromIndex: List<A>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "take",
    "description": "Takes the specified number of elements from the beginning of the specified\nlist.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const take: { (n: number): <A>(self: List<A>) => List<A>; <A>(self: List<A>, n: number): List<A>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "toArray",
    "description": "Converts the specified `List` to an `Array`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "equivalence",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "isList",
    "description": "Returns `true` if the specified value is a `List`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "isNil",
    "description": "Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "isCons",
    "description": "Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the number of elements contained in the specified `List`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "nil",
    "description": "Constructs a new empty `List<A>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "cons",
    "description": "Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "of",
    "description": "Constructs a new `List<A>` from the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `List` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new `List<A>` from the specified values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "compact",
    "description": "Removes all `None` values from the specified list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "head",
    "description": "Returns the first element of the specified list, or `None` if the list is\nempty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "last",
    "description": "Returns the last element of the specified list, or `None` if the list is\nempty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "reverse",
    "description": "Returns a new list with the elements of the specified list in reverse order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "tail",
    "description": "Returns the tail of the specified list, or `None` if the list is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "toChunk",
    "description": "Converts the specified `List` to a `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeHead",
    "description": "Unsafely returns the first element of the specified `List`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeLast",
    "description": "Unsafely returns the last element of the specified `List`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeTail",
    "description": "Unsafely returns the tail of the specified `List`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "Cons",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Cons<out A> extends NonEmptyIterable<A>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly _tag: \"Cons\"\n  readonly head: A\n  readonly tail: List<A>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "Nil",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Nil<out A> extends Iterable<A>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly _tag: \"Nil\"\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "List",
    "description": "Represents an immutable linked list of elements of type `A`.\n\nA `List` is optimal for last-in-first-out (LIFO), stack-like access patterns.\nIf you need another access pattern, for example, random access or FIFO,\nconsider using a collection more suited for that other than `List`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type List<A> = Cons<A> | Nil<A>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "List",
      "path": [
        "src",
        "List.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "LoggerTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const LoggerTypeId: typeof LoggerTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a custom logger that formats log messages according to the provided\nfunction.",
    "deprecated": false,
    "examples": [
      "import { Effect, Logger, LogLevel } from \"effect\"\n\nconst logger = Logger.make(({ logLevel, message }) => {\n  globalThis.console.log(`[${logLevel.label}] ${message}`)\n})\n\nconst task1 = Effect.logDebug(\"task1 done\")\nconst task2 = Effect.logDebug(\"task2 done\")\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"start\")\n  yield* task1\n  yield* task2\n  yield* Effect.log(\"done\")\n}).pipe(\n  Logger.withMinimumLogLevel(LogLevel.Debug),\n  Effect.provide(Logger.replace(Logger.defaultLogger, logger))\n)\n\n// Effect.runFork(program)\n// [INFO] start\n// [DEBUG] task1 done\n// [DEBUG] task2 done\n// [INFO] done"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <Message, Output>(log: (options: Logger.Options<Message>) => Output) => Logger<Message, Output>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "add",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const add: <B>(logger: Logger<unknown, B>) => Layer.Layer<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "addEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const addEffect: <A, E, R>(effect: Effect<Logger<unknown, A>, E, R>) => Layer.Layer<never, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "addScoped",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const addScoped: <A, E, R>(effect: Effect<Logger<unknown, A>, E, R>) => Layer.Layer<never, E, Exclude<R, Scope>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "mapInput",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapInput: { <Message, Message2>(f: (message: Message2) => Message): <Output>(self: Logger<Message, Output>) => Logger<Message2, Output>; <Output, Message, Message2>(self: Logger<Message, Output>, f: (message: Message2) => Message): Logger<Message2, Output>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputOptions",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapInputOptions: { <Message, Message2>(f: (options: Logger.Options<Message2>) => Logger.Options<Message>): <Output>(self: Logger<Message, Output>) => Logger<Message2, Output>; <Output, Message, Message2>(self: Logger<Message, Output>, f: (options: Logger.Options<Message2>) => Logger.Options<Message>): Logger<Message2, Output>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "filterLogLevel",
    "description": "Returns a version of this logger that only logs messages when the log level\nsatisfies the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterLogLevel: { (f: (logLevel: LogLevel.LogLevel) => boolean): <Message, Output>(self: Logger<Message, Output>) => Logger<Message, Option.Option<Output>>; <Message, Output>(self: Logger<Message, Output>, f: (logLevel: LogLevel.LogLevel) => boolean): Logger<Message, Option.Option<Output>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <Output, Output2>(f: (output: Output) => Output2): <Message>(self: Logger<Message, Output>) => Logger<Message, Output2>; <Message, Output, Output2>(self: Logger<Message, Output>, f: (output: Output) => Output2): Logger<Message, Output2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "batched",
    "description": "Creates a batched logger that groups log messages together and processes them\nin intervals.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect, Logger } from \"effect\"\n\nconst LoggerLive = Logger.replaceScoped(\n  Logger.defaultLogger,\n  Logger.logfmtLogger.pipe(\n    Logger.batched(\"500 millis\", (messages) => Console.log(\"BATCH\", `[\\n${messages.join(\"\\n\")}\\n]`))\n  )\n)\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"one\")\n  yield* Effect.log(\"two\")\n  yield* Effect.log(\"three\")\n}).pipe(Effect.provide(LoggerLive))\n\n// Effect.runFork(program)\n// BATCH [\n// timestamp=... level=INFO fiber=#0 message=one\n// timestamp=... level=INFO fiber=#0 message=two\n// timestamp=... level=INFO fiber=#0 message=three\n// ]"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const batched: { <Output, R>(window: DurationInput, f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>): <Message>(self: Logger<Message, Output>) => Effect<Logger<Message, void>, never, R | Scope>; <Message, Output, R>(self: Logger<Message, Output>, window: DurationInput, f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>): Effect<Logger<Message, void>, never, Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "withConsoleLog",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "console",
    "signature": "export declare const withConsoleLog: <M, O>(self: Logger<M, O>) => Logger<M, void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "withLeveledConsole",
    "description": "Takes a `Logger<M, O>` and returns a logger that calls the respective `Console` method\nbased on the log level.",
    "deprecated": false,
    "examples": [
      "import { Logger, Effect } from \"effect\"\n\nconst loggerLayer = Logger.replace(\n  Logger.defaultLogger,\n  Logger.withLeveledConsole(Logger.stringLogger),\n)\n\nEffect.gen(function* () {\n  yield* Effect.logError(\"an error\")\n  yield* Effect.logInfo(\"an info\")\n}).pipe(Effect.provide(loggerLayer))"
    ],
    "since": "3.8.0",
    "category": "console",
    "signature": "export declare const withLeveledConsole: <M, O>(self: Logger<M, O>) => Logger<M, void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "withConsoleError",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "console",
    "signature": "export declare const withConsoleError: <M, O>(self: Logger<M, O>) => Logger<M, void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "none",
    "description": "A logger that does nothing in response to logging events.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const none: Logger<unknown, void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "remove",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const remove: <A>(logger: Logger<unknown, A>) => Layer.Layer<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "replace",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const replace: { <B>(that: Logger<unknown, B>): <A>(self: Logger<unknown, A>) => Layer.Layer<never>; <A, B>(self: Logger<unknown, A>, that: Logger<unknown, B>): Layer.Layer<never>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "replaceEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const replaceEffect: { <B, E, R>(that: Effect<Logger<unknown, B>, E, R>): <A>(self: Logger<unknown, A>) => Layer.Layer<never, E, R>; <A, B, E, R>(self: Logger<unknown, A>, that: Effect<Logger<unknown, B>, E, R>): Layer.Layer<never, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "replaceScoped",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const replaceScoped: { <B, E, R>(that: Effect<Logger<unknown, B>, E, R>): <A>(self: Logger<unknown, A>) => Layer.Layer<never, E, Exclude<R, Scope>>; <A, B, E, R>(self: Logger<unknown, A>, that: Effect<Logger<unknown, B>, E, R>): Layer.Layer<never, E, Exclude<R, Scope>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "simple",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const simple: <A, B>(log: (a: A) => B) => Logger<A, B>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const succeed: <A>(value: A) => Logger<unknown, A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "sync",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sync: <A>(evaluate: LazyArg<A>) => Logger<unknown, A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "test",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const test: { <Message>(input: Message): <Output>(self: Logger<Message, Output>) => Output; <Message, Output>(self: Logger<Message, Output>, input: Message): Output; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "withMinimumLogLevel",
    "description": "Sets the minimum log level for subsequent logging operations, allowing\ncontrol over which log messages are displayed based on their severity.",
    "deprecated": false,
    "examples": [
      "import { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.logDebug(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n\n// Effect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message1"
    ],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const withMinimumLogLevel: { (level: LogLevel.LogLevel): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, level: LogLevel.LogLevel): Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "withSpanAnnotations",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "export declare const withSpanAnnotations: <Message, Output>(self: Logger<Message, Output>) => Logger<Message, Output>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Combines this logger with the specified logger to produce a new logger that\nlogs to both this logger and that logger.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zip: { <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, [Output, Output2]>; <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, [Output, Output2]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "zipLeft",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipLeft: { <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, Output>; <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, Output>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "zipRight",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipRight: { <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, Output2>; <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, Output2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "defaultLogger",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const defaultLogger: Logger<unknown, void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "jsonLogger",
    "description": "The `jsonLogger` logger formats log entries as JSON objects, making them easy to\nintegrate with logging systems that consume JSON data.",
    "deprecated": false,
    "examples": [
      "import { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\n// Effect.runFork(program.pipe(Effect.provide(Logger.json)))\n// {\"message\":[\"message1\",\"message2\"],\"logLevel\":\"INFO\",\"timestamp\":\"...\",\"annotations\":{\"key2\":\"value2\",\"key1\":\"value1\"},\"spans\":{\"myspan\":0},\"fiberId\":\"#0\"}"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const jsonLogger: Logger<unknown, string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "logfmtLogger",
    "description": "This logger outputs logs in a human-readable format that is easy to read\nduring development or in a production console.",
    "deprecated": false,
    "examples": [
      "import { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\n// Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const logfmtLogger: Logger<unknown, string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "stringLogger",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const stringLogger: Logger<unknown, string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "prettyLogger",
    "description": "The pretty logger utilizes the capabilities of the console API to generate\nvisually engaging and color-enhanced log outputs. This feature is\nparticularly useful for improving the readability of log messages during\ndevelopment and debugging processes.",
    "deprecated": false,
    "examples": [
      "import { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\n// Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))\n//         green --v                      v-- bold and cyan\n// [07:51:54.434] INFO (#0) myspan=1ms: message1\n//   message2\n//    v-- bold\n//   key2: value2\n//   key1: value1"
    ],
    "since": "3.5.0",
    "category": "constructors",
    "signature": "export declare const prettyLogger: (options?: { readonly colors?: \"auto\" | boolean | undefined; readonly stderr?: boolean | undefined; readonly formatDate?: ((date: Date) => string) | undefined; readonly mode?: \"browser\" | \"tty\" | \"auto\" | undefined; }) => Logger<unknown, void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "prettyLoggerDefault",
    "description": "A default version of the pretty logger.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "constructors",
    "signature": "export declare const prettyLoggerDefault: Logger<unknown, void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "structuredLogger",
    "description": "The structured logger provides detailed log outputs, structured in a way that\nretains comprehensive traceability of the events, suitable for deeper\nanalysis and troubleshooting.",
    "deprecated": false,
    "examples": [
      "import { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\n// Effect.runFork(program.pipe(Effect.provide(Logger.structured)))\n// {\n//   message: [ 'message1', 'message2' ],\n//   logLevel: 'INFO',\n//   timestamp: '2024-07-09T14:05:41.623Z',\n//   cause: undefined,\n//   annotations: { key2: 'value2', key1: 'value1' },\n//   spans: { myspan: 0 },\n//   fiberId: '#0'\n// }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const structuredLogger: Logger<unknown, { readonly logLevel: string; readonly fiberId: string; readonly timestamp: string; readonly message: unknown; readonly cause: string | undefined; readonly annotations: Record<string, unknown>; readonly spans: Record<string, number>; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "tracerLogger",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const tracerLogger: Logger<unknown, void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "json",
    "description": "The `json` logger formats log entries as JSON objects, making them easy to\nintegrate with logging systems that consume JSON data.",
    "deprecated": false,
    "examples": [
      "import { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\n// Effect.runFork(program.pipe(Effect.provide(Logger.json)))\n// {\"message\":[\"message1\",\"message2\"],\"logLevel\":\"INFO\",\"timestamp\":\"...\",\"annotations\":{\"key2\":\"value2\",\"key1\":\"value1\"},\"spans\":{\"myspan\":0},\"fiberId\":\"#0\"}"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const json: Layer.Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "logFmt",
    "description": "This logger outputs logs in a human-readable format that is easy to read\nduring development or in a production console.",
    "deprecated": false,
    "examples": [
      "import { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\n// Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const logFmt: Layer.Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "pretty",
    "description": "The pretty logger utilizes the capabilities of the console API to generate\nvisually engaging and color-enhanced log outputs. This feature is\nparticularly useful for improving the readability of log messages during\ndevelopment and debugging processes.",
    "deprecated": false,
    "examples": [
      "import { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\n// Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))\n//         green --v                      v-- bold and cyan\n// [07:51:54.434] INFO (#0) myspan=1ms: message1\n//   message2\n//    v-- bold\n//   key2: value2\n//   key1: value1"
    ],
    "since": "3.5.0",
    "category": "constructors",
    "signature": "export declare const pretty: Layer.Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "structured",
    "description": "The structured logger provides detailed log outputs, structured in a way that\nretains comprehensive traceability of the events, suitable for deeper\nanalysis and troubleshooting.",
    "deprecated": false,
    "examples": [
      "import { Effect, Logger } from \"effect\"\n\nconst program = Effect.log(\"message1\", \"message2\").pipe(\n  Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n  Effect.withLogSpan(\"myspan\")\n)\n\n// Effect.runFork(program.pipe(Effect.provide(Logger.structured)))\n// {\n//   message: [ 'message1', 'message2' ],\n//   logLevel: 'INFO',\n//   timestamp: '2024-07-09T14:05:41.623Z',\n//   cause: undefined,\n//   annotations: { key2: 'value2', key1: 'value1' },\n//   spans: { myspan: 0 },\n//   fiberId: '#0'\n// }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const structured: Layer.Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "minimumLogLevel",
    "description": "Sets the minimum log level for logging operations, allowing control over\nwhich log messages are displayed based on their severity.",
    "deprecated": false,
    "examples": [
      "import { Effect, Logger, LogLevel } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"Executing task...\")\n  yield* Effect.sleep(\"100 millis\")\n  console.log(\"task done\")\n})\n\n// Logging disabled using a layer\n// Effect.runFork(program.pipe(Effect.provide(Logger.minimumLogLevel(LogLevel.None))))\n// task done"
    ],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const minimumLogLevel: (level: LogLevel.LogLevel) => Layer.Layer<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "isLogger",
    "description": "Returns `true` if the specified value is a `Logger`, otherwise returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "guards",
    "signature": "export declare const isLogger: (u: unknown) => u is Logger<unknown, unknown>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "Logger",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Logger<in Message, out Output> extends Logger.Variance<Message, Output>, Pipeable {\n  log(options: Logger.Options<Message>): Output\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Logger",
      "path": [
        "src",
        "Logger.ts"
      ]
    },
    "project": "effect",
    "name": "LoggerTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type LoggerTypeId = typeof LoggerTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "All",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const All: LogLevel"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "Fatal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Fatal: LogLevel"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "Error",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Error: LogLevel"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "Warning",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Warning: LogLevel"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "Info",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Info: LogLevel"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "Debug",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Debug: LogLevel"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "Trace",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Trace: LogLevel"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "None",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const None: LogLevel"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "allLevels",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const allLevels: readonly LogLevel[]"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "locally",
    "description": "Temporarily sets a `LogLevel` for an `Effect` workflow.\n\n**Details**\n\nThis function allows you to apply a specific `LogLevel` locally to an\n`Effect` workflow. Once the workflow completes, the `LogLevel` reverts to its\nprevious state.\n\n**When to Use**\n\nThis is particularly useful when you want to adjust the verbosity of logging\nfor specific parts of your program without affecting the global log level.",
    "deprecated": false,
    "examples": [
      "import { Effect, LogLevel } from \"effect\"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log(\"message1\")\n  yield* Effect.gen(function*() {\n    yield* Effect.log(\"message2\")\n    yield* Effect.log(\"message3\")\n  }).pipe(LogLevel.locally(LogLevel.Warning))\n})\n\n// Effect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=message1\n// timestamp=... level=WARN fiber=#0 message=message2\n// timestamp=... level=WARN fiber=#0 message=message3"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const locally: { (self: LogLevel): <A, E, R>(use: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(use: Effect.Effect<A, E, R>, self: LogLevel): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "Order",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Order: order.Order<LogLevel>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "lessThan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "export declare const lessThan: { (that: LogLevel): (self: LogLevel) => boolean; (self: LogLevel, that: LogLevel): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanEqual",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "export declare const lessThanEqual: { (that: LogLevel): (self: LogLevel) => boolean; (self: LogLevel, that: LogLevel): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "export declare const greaterThan: { (that: LogLevel): (self: LogLevel) => boolean; (self: LogLevel, that: LogLevel): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanEqual",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "export declare const greaterThanEqual: { (that: LogLevel): (self: LogLevel) => boolean; (self: LogLevel, that: LogLevel): boolean; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "fromLiteral",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "All",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface All extends Pipeable {\n  readonly _tag: \"All\"\n  readonly label: \"ALL\"\n  readonly syslog: 0\n  readonly ordinal: number\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "Debug",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface Debug extends Pipeable {\n  readonly _tag: \"Debug\"\n  readonly label: \"DEBUG\"\n  readonly syslog: 7\n  readonly ordinal: number\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "Error",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface Error extends Pipeable {\n  readonly _tag: \"Error\"\n  readonly label: \"ERROR\"\n  readonly syslog: 3\n  readonly ordinal: number\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "Fatal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface Fatal extends Pipeable {\n  readonly _tag: \"Fatal\"\n  readonly label: \"FATAL\"\n  readonly syslog: 2\n  readonly ordinal: number\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "Info",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface Info extends Pipeable {\n  readonly _tag: \"Info\"\n  readonly label: \"INFO\"\n  readonly syslog: 6\n  readonly ordinal: number\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "None",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface None extends Pipeable {\n  readonly _tag: \"None\"\n  readonly label: \"OFF\"\n  readonly syslog: 7\n  readonly ordinal: number\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "Trace",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface Trace extends Pipeable {\n  readonly _tag: \"Trace\"\n  readonly label: \"TRACE\"\n  readonly syslog: 7\n  readonly ordinal: number\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "Warning",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface Warning extends Pipeable {\n  readonly _tag: \"Warning\"\n  readonly label: \"WARN\"\n  readonly syslog: 4\n  readonly ordinal: number\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "Literal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export type Literal = LogLevel[\"_tag\"]"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "LogLevel",
      "path": [
        "src",
        "LogLevel.ts"
      ]
    },
    "project": "effect",
    "name": "LogLevel",
    "description": "A `LogLevel` represents the log level associated with an individual logging\noperation. Log levels are used both to describe the granularity (or\nimportance) of individual log statements, as well as to enable tuning\nverbosity of log output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export type LogLevel = All | Fatal | Error | Warning | Info | Debug | Trace | None"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogSpan",
      "path": [
        "src",
        "LogSpan.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: (label: string, startTime: number) => LogSpan"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "LogSpan",
      "path": [
        "src",
        "LogSpan.ts"
      ]
    },
    "project": "effect",
    "name": "render",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const render: (now: number) => (self: LogSpan) => string"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "LogSpan",
      "path": [
        "src",
        "LogSpan.ts"
      ]
    },
    "project": "effect",
    "name": "LogSpan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface LogSpan {\n  readonly label: string\n  readonly startTime: number\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Mailbox",
      "path": [
        "src",
        "Mailbox.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "type ids",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Mailbox",
      "path": [
        "src",
        "Mailbox.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlyTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "type ids",
    "signature": "export declare const ReadonlyTypeId: typeof ReadonlyTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Mailbox",
      "path": [
        "src",
        "Mailbox.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "A `Mailbox` is a queue that can be signaled to be done or failed.",
    "deprecated": false,
    "examples": [
      "import { Effect, Mailbox } from \"effect\"\n\nEffect.gen(function*() {\n  const mailbox = yield* Mailbox.make<number, string>()\n\n  // add messages to the mailbox\n  yield* mailbox.offer(1)\n  yield* mailbox.offer(2)\n  yield* mailbox.offerAll([3, 4, 5])\n\n  // take messages from the mailbox\n  const [messages, done] = yield* mailbox.takeAll\n  assert.deepStrictEqual(messages, [1, 2, 3, 4, 5])\n  assert.strictEqual(done, false)\n\n  // signal that the mailbox is done\n  yield* mailbox.end\n  const [messages2, done2] = yield* mailbox.takeAll\n  assert.deepStrictEqual(messages2, [])\n  assert.strictEqual(done2, true)\n\n  // signal that the mailbox has failed\n  yield* mailbox.fail(\"boom\")\n})"
    ],
    "since": "3.8.0",
    "category": "constructors",
    "signature": "export declare const make: <A, E = never>(capacity?: number | { readonly capacity?: number; readonly strategy?: \"suspend\" | \"dropping\" | \"sliding\"; } | undefined) => Effect<Mailbox<A, E>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Mailbox",
      "path": [
        "src",
        "Mailbox.ts"
      ]
    },
    "project": "effect",
    "name": "into",
    "description": "Run an `Effect` into a `Mailbox`, where success ends the mailbox and failure\nfails the mailbox.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "combinators",
    "signature": "export declare const into: { <A, E>(self: Mailbox<A, E>): <AX, EX extends E, RX>(effect: Effect<AX, EX, RX>) => Effect<boolean, never, RX>; <AX, E, EX extends E, RX, A>(effect: Effect<AX, EX, RX>, self: Mailbox<A, E>): Effect<boolean, never, RX>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Mailbox",
      "path": [
        "src",
        "Mailbox.ts"
      ]
    },
    "project": "effect",
    "name": "toChannel",
    "description": "Create a `Channel` from a `Mailbox`.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "conversions",
    "signature": "export declare const toChannel: <A, E>(self: ReadonlyMailbox<A, E>) => Channel<Chunk<A>, unknown, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Mailbox",
      "path": [
        "src",
        "Mailbox.ts"
      ]
    },
    "project": "effect",
    "name": "toStream",
    "description": "Create a `Stream` from a `Mailbox`.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "conversions",
    "signature": "export declare const toStream: <A, E>(self: ReadonlyMailbox<A, E>) => Stream<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Mailbox",
      "path": [
        "src",
        "Mailbox.ts"
      ]
    },
    "project": "effect",
    "name": "fromStream",
    "description": "Create a `ReadonlyMailbox` from a `Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "conversions",
    "signature": "export declare const fromStream: { (options?: { readonly capacity?: number | undefined; readonly strategy?: \"suspend\" | \"dropping\" | \"sliding\" | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect<ReadonlyMailbox<A, E>, never, R | Scope>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly capacity?: number | undefined; readonly strategy?: \"suspend\" | \"dropping\" | \"sliding\" | undefined; }): Effect<ReadonlyMailbox<A, E>, never, R | Scope>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Mailbox",
      "path": [
        "src",
        "Mailbox.ts"
      ]
    },
    "project": "effect",
    "name": "isMailbox",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Mailbox",
      "path": [
        "src",
        "Mailbox.ts"
      ]
    },
    "project": "effect",
    "name": "isReadonlyMailbox",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Mailbox",
      "path": [
        "src",
        "Mailbox.ts"
      ]
    },
    "project": "effect",
    "name": "Mailbox",
    "description": "A `Mailbox` is a queue that can be signaled to be done or failed.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface Mailbox<in out A, in out E = never> extends ReadonlyMailbox<A, E> {\n  readonly [TypeId]: TypeId\n  /**\n   * Add a message to the mailbox. Returns `false` if the mailbox is done.\n   */\n  readonly offer: (message: A) => Effect<boolean>\n  /**\n   * Add a message to the mailbox. Returns `false` if the mailbox is done.\n   */\n  readonly unsafeOffer: (message: A) => boolean\n  /**\n   * Add multiple messages to the mailbox. Returns the remaining messages that\n   * were not added.\n   */\n  readonly offerAll: (messages: Iterable<A>) => Effect<Chunk<A>>\n  /**\n   * Add multiple messages to the mailbox. Returns the remaining messages that\n   * were not added.\n   */\n  readonly unsafeOfferAll: (messages: Iterable<A>) => Chunk<A>\n  /**\n   * Fail the mailbox with an error. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly fail: (error: E) => Effect<boolean>\n  /**\n   * Fail the mailbox with a cause. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly failCause: (cause: Cause<E>) => Effect<boolean>\n  /**\n   * Signal that the mailbox is complete. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly end: Effect<boolean>\n  /**\n   * Signal that the mailbox is done. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly done: (exit: Exit<void, E>) => Effect<boolean>\n  /**\n   * Signal that the mailbox is done. If the mailbox is already done, `false` is\n   * returned.\n   */\n  readonly unsafeDone: (exit: Exit<void, E>) => boolean\n  /**\n   * Shutdown the mailbox, canceling any pending operations.\n   * If the mailbox is already done, `false` is returned.\n   */\n  readonly shutdown: Effect<boolean>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Mailbox",
      "path": [
        "src",
        "Mailbox.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlyMailbox",
    "description": "A `ReadonlyMailbox` represents a mailbox that can only be read from.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface ReadonlyMailbox<out A, out E = never>\n  extends Effect<readonly [messages: Chunk<A>, done: boolean], E>, Inspectable\n{\n  readonly [ReadonlyTypeId]: ReadonlyTypeId\n  /**\n   * Take all messages from the mailbox, returning an empty Chunk if the mailbox\n   * is empty or done.\n   */\n  readonly clear: Effect<Chunk<A>, E>\n  /**\n   * Take all messages from the mailbox, or wait for messages to be available.\n   *\n   * If the mailbox is done, the `done` flag will be `true`. If the mailbox\n   * fails, the Effect will fail with the error.\n   */\n  readonly takeAll: Effect<readonly [messages: Chunk<A>, done: boolean], E>\n  /**\n   * Take a specified number of messages from the mailbox. It will only take\n   * up to the capacity of the mailbox.\n   *\n   * If the mailbox is done, the `done` flag will be `true`. If the mailbox\n   * fails, the Effect will fail with the error.\n   */\n  readonly takeN: (n: number) => Effect<readonly [messages: Chunk<A>, done: boolean], E>\n  /**\n   * Take a single message from the mailbox, or wait for a message to be\n   * available.\n   *\n   * If the mailbox is done, it will fail with `NoSuchElementException`. If the\n   * mailbox fails, the Effect will fail with the error.\n   */\n  readonly take: Effect<A, E | NoSuchElementException>\n  /** Wait for the mailbox to be done. */\n  readonly await: Effect<void, E>\n  /**\n   * Check the size of the mailbox.\n   *\n   * If the mailbox is complete, it will return `None`.\n   */\n  readonly size: Effect<Option<number>>\n  /**\n   * Check the size of the mailbox.\n   *\n   * If the mailbox is complete, it will return `None`.\n   */\n  readonly unsafeSize: () => Option<number>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Mailbox",
      "path": [
        "src",
        "Mailbox.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlyTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "type ids",
    "signature": "export type ReadonlyTypeId = typeof ReadonlyTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Mailbox",
      "path": [
        "src",
        "Mailbox.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "type ids",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ManagedRuntime",
      "path": [
        "src",
        "ManagedRuntime.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "symbol",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ManagedRuntime",
      "path": [
        "src",
        "ManagedRuntime.ts"
      ]
    },
    "project": "effect",
    "name": "isManagedRuntime",
    "description": "Checks if the provided argument is a `ManagedRuntime`.",
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "guards",
    "signature": "export declare const isManagedRuntime: (input: unknown) => input is ManagedRuntime<unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ManagedRuntime",
      "path": [
        "src",
        "ManagedRuntime.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Convert a Layer into an ManagedRuntime, that can be used to run Effect's using\nyour services.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect, Layer, ManagedRuntime } from \"effect\"\n\nclass Notifications extends Effect.Tag(\"Notifications\")<\n  Notifications,\n  { readonly notify: (message: string) => Effect.Effect<void> }\n>() {\n  static Live = Layer.succeed(this, { notify: (message) => Console.log(message) })\n}\n\nasync function main() {\n  const runtime = ManagedRuntime.make(Notifications.Live)\n  await runtime.runPromise(Notifications.notify(\"Hello, world!\"))\n  await runtime.dispose()\n}\n\nmain()"
    ],
    "since": "2.0.0",
    "category": "runtime class",
    "signature": "export declare const make: <R, E>(layer: Layer.Layer<R, E, never>, memoMap?: Layer.MemoMap | undefined) => ManagedRuntime<R, E>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ManagedRuntime",
      "path": [
        "src",
        "ManagedRuntime.ts"
      ]
    },
    "project": "effect",
    "name": "ManagedRuntime",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ManagedRuntime<in R, out ER> extends Effect.Effect<Runtime.Runtime<R>, ER> {\n  readonly [TypeId]: TypeId\n  readonly memoMap: Layer.MemoMap\n  readonly runtimeEffect: Effect.Effect<Runtime.Runtime<R>, ER>\n  readonly runtime: () => Promise<Runtime.Runtime<R>>\n\n  /**\n   * Executes the effect using the provided Scheduler or using the global\n   * Scheduler if not provided\n   */\n  readonly runFork: <A, E>(\n    self: Effect.Effect<A, E, R>,\n    options?: Runtime.RunForkOptions\n  ) => Fiber.RuntimeFiber<A, E | ER>\n\n  /**\n   * Executes the effect synchronously returning the exit.\n   *\n   * This method is effectful and should only be invoked at the edges of your\n   * program.\n   */\n  readonly runSyncExit: <A, E>(effect: Effect.Effect<A, E, R>) => Exit.Exit<A, ER | E>\n\n  /**\n   * Executes the effect synchronously throwing in case of errors or async boundaries.\n   *\n   * This method is effectful and should only be invoked at the edges of your\n   * program.\n   */\n  readonly runSync: <A, E>(effect: Effect.Effect<A, E, R>) => A\n\n  /**\n   * Executes the effect asynchronously, eventually passing the exit value to\n   * the specified callback.\n   *\n   * This method is effectful and should only be invoked at the edges of your\n   * program.\n   */\n  readonly runCallback: <A, E>(\n    effect: Effect.Effect<A, E, R>,\n    options?: Runtime.RunCallbackOptions<A, E | ER> | undefined\n  ) => Runtime.Cancel<A, E | ER>\n\n  /**\n   * Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\n   * with the value of the effect once the effect has been executed, or will be\n   * rejected with the first error or exception throw by the effect.\n   *\n   * This method is effectful and should only be used at the edges of your\n   * program.\n   */\n  readonly runPromise: <A, E>(effect: Effect.Effect<A, E, R>, options?: {\n    readonly signal?: AbortSignal | undefined\n  }) => Promise<A>\n\n  /**\n   * Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\n   * with the `Exit` state of the effect once the effect has been executed.\n   *\n   * This method is effectful and should only be used at the edges of your\n   * program.\n   */\n  readonly runPromiseExit: <A, E>(effect: Effect.Effect<A, E, R>, options?: {\n    readonly signal?: AbortSignal | undefined\n  }) => Promise<Exit.Exit<A, ER | E>>\n\n  /**\n   * Dispose of the resources associated with the runtime.\n   */\n  readonly dispose: () => Promise<void>\n\n  /**\n   * Dispose of the resources associated with the runtime.\n   */\n  readonly disposeEffect: Effect.Effect<void, never, never>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: ManagedRuntimeUnify<this>\n  readonly [Unify.ignoreSymbol]?: ManagedRuntimeUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ManagedRuntime",
      "path": [
        "src",
        "ManagedRuntime.ts"
      ]
    },
    "project": "effect",
    "name": "ManagedRuntimeUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface ManagedRuntimeUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  ManagedRuntime?: () => Extract<A[Unify.typeSymbol], ManagedRuntime<any, any>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ManagedRuntime",
      "path": [
        "src",
        "ManagedRuntime.ts"
      ]
    },
    "project": "effect",
    "name": "ManagedRuntimeUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface ManagedRuntimeUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ManagedRuntime",
      "path": [
        "src",
        "ManagedRuntime.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "MatcherTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Symbols",
    "signature": "export declare const MatcherTypeId: typeof MatcherTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "type",
    "description": "Creates a matcher for a specific type.\n\n**Details**\n\nThis function defines a `Matcher` that operates on a given type, allowing you\nto specify conditions for handling different cases. Once the matcher is\ncreated, you can use pattern-matching functions like {@link when} to define\nhow different values should be processed.",
    "deprecated": false,
    "examples": [
      "// Title: Matching Numbers and Strings\nimport { Match } from \"effect\"\n\n// Create a matcher for values that are either strings or numbers\n//\n//       (u: string | number) => string\n//      \nconst match = Match.type<string | number>().pipe(\n  // Match when the value is a number\n  Match.when(Match.number, (n) => `number: ${n}`),\n  // Match when the value is a string\n  Match.when(Match.string, (s) => `string: ${s}`),\n  // Ensure all possible cases are handled\n  Match.exhaustive\n)\n\nconsole.log(match(0))\n// Output: \"number: 0\"\n\nconsole.log(match(\"hello\"))\n// Output: \"string: hello\""
    ],
    "since": "1.0.0",
    "category": "Creating a matcher",
    "signature": "export declare const type: <I>() => Matcher<I, Types.Without<never>, I, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "value",
    "description": "Creates a matcher from a specific value.\n\n**Details**\n\nThis function allows you to define a `Matcher` directly from a given value,\nrather than from a type. This is useful when working with known values,\nenabling structured pattern matching on objects, primitives, or any data\nstructure.\n\nOnce the matcher is created, you can use pattern-matching functions like\n{@link when} to define how different cases should be handled.",
    "deprecated": false,
    "examples": [
      "// Title: Matching an Object by Property\nimport { Match } from \"effect\"\n\nconst input = { name: \"John\", age: 30 }\n\n// Create a matcher for the specific object\nconst result = Match.value(input).pipe(\n  // Match when the 'name' property is \"John\"\n  Match.when(\n    { name: \"John\" },\n    (user) => `${user.name} is ${user.age} years old`\n  ),\n  // Provide a fallback if no match is found\n  Match.orElse(() => \"Oh, not John\")\n)\n\nconsole.log(result)\n// Output: \"John is 30 years old\""
    ],
    "since": "1.0.0",
    "category": "Creating a matcher",
    "signature": "export declare const value: <const I>(i: I) => Matcher<I, Types.Without<never>, I, never, I>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "valueTags",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Creating a matcher",
    "signature": "export declare const valueTags: <const I, P extends { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag; }>) => any; } & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never; }>(fields: P) => (input: I) => Unify<ReturnType<P[keyof P]>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "typeTags",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Creating a matcher",
    "signature": "export declare const typeTags: <I>() => <P extends { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag; }>) => any; } & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never; }>(fields: P) => (input: I) => Unify<ReturnType<P[keyof P]>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "withReturnType",
    "description": "Ensures that all branches of a matcher return a specific type.\n\n**Details**\n\nThis function enforces a consistent return type across all pattern-matching\nbranches. By specifying a return type, TypeScript will check that every\nmatching condition produces a value of the expected type.\n\n**Important:** This function must be the first step in the matcher pipeline.\nIf used later, TypeScript will not enforce type consistency correctly.",
    "deprecated": false,
    "examples": [
      "// Title: Validating Return Type Consistency\nimport { Match } from \"effect\"\n\nconst match = Match.type<{ a: number } | { b: string }>().pipe(\n  // Ensure all branches return a string\n  Match.withReturnType<string>(),\n  //  Type error: 'number' is not assignable to type 'string'\n  // @ts-expect-error\n  Match.when({ a: Match.number }, (_) => _.a),\n  //  Correct: returns a string\n  Match.when({ b: Match.string }, (_) => _.b),\n  Match.exhaustive\n)"
    ],
    "since": "1.0.0",
    "category": null,
    "signature": "export declare const withReturnType: <Ret>() => <I, F, R, A, Pr, _>(self: Matcher<I, F, R, A, Pr, _>) => [Ret] extends [[A] extends [never] ? any : A] ? Matcher<I, F, R, A, Pr, Ret> : \"withReturnType constraint does not extend Result type\""
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "when",
    "description": "Defines a condition for matching values.\n\n**Details**\n\nThis function enables pattern matching by checking whether a given value\nsatisfies a condition. It supports both direct value comparisons and\npredicate functions. If the condition is met, the associated function is\nexecuted.\n\nThis function is useful when defining matchers that need to check for\nspecific values or apply logical conditions to determine a match. It works\nwell with structured objects and primitive types.",
    "deprecated": false,
    "examples": [
      "// Title: Matching with Values and Predicates\nimport { Match } from \"effect\"\n\n// Create a matcher for objects with an \"age\" property\nconst match = Match.type<{ age: number }>().pipe(\n  // Match when age is greater than 18\n  Match.when({ age: (age) => age > 18 }, (user) => `Age: ${user.age}`),\n  // Match when age is exactly 18\n  Match.when({ age: 18 }, () => \"You can vote\"),\n  // Fallback case for all other ages\n  Match.orElse((user) => `${user.age} is too young`)\n)\n\nconsole.log(match({ age: 20 }))\n// Output: \"Age: 20\"\n\nconsole.log(match({ age: 18 }))\n// Output: \"You can vote\"\n\nconsole.log(match({ age: 4 }))\n// Output: \"4 is too young\""
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "export declare const when: <R, const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>, Ret, Fn extends (_: Types.WhenMatch<R, P>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Types.PForExclude<P>>, Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P>>>, A | ReturnType<Fn>, Pr, Ret>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "whenOr",
    "description": "Matches one of multiple patterns in a single condition.\n\n**Details**\n\nThis function allows defining a condition where a value matches any of the\nprovided patterns. If a match is found, the associated function is executed.\nIt simplifies cases where multiple patterns share the same handling logic.\n\nUnlike {@link when}, which requires separate conditions for each pattern,\nthis function enables combining them into a single statement, making the\nmatcher more concise.",
    "deprecated": false,
    "examples": [
      "import { Match } from \"effect\"\n\ntype ErrorType =\n  | { readonly _tag: \"NetworkError\"; readonly message: string }\n  | { readonly _tag: \"TimeoutError\"; readonly duration: number }\n  | { readonly _tag: \"ValidationError\"; readonly field: string }\n\nconst handleError = Match.type<ErrorType>().pipe(\n  Match.whenOr(\n    { _tag: \"NetworkError\" },\n    { _tag: \"TimeoutError\" },\n    () => \"Retry the request\"\n  ),\n  Match.when({ _tag: \"ValidationError\" }, (_) => `Invalid field: ${_.field}`),\n  Match.exhaustive\n)\n\nconsole.log(handleError({ _tag: \"NetworkError\", message: \"No connection\" }))\n// Output: \"Retry the request\"\n\nconsole.log(handleError({ _tag: \"ValidationError\", field: \"email\" }))\n// Output: \"Invalid field: email\""
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "export declare const whenOr: <R, const P extends ReadonlyArray<Types.PatternPrimitive<R> | Types.PatternBase<R>>, Ret, Fn extends (_: Types.WhenMatch<R, P[number]>) => Ret>(...args: [...patterns: P, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Types.PForExclude<P[number]>>, Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P[number]>>>, A | ReturnType<Fn>, Pr, Ret>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "whenAnd",
    "description": "Matches a value that satisfies all provided patterns.\n\n**Details**\n\nThis function allows defining a condition where a value must match all the\ngiven patterns simultaneously. If the value satisfies every pattern, the\nassociated function is executed.\n\nUnlike {@link when}, which matches a single pattern at a time, this function\nensures that multiple conditions are met before executing the callback. It is\nuseful when checking for values that need to fulfill multiple criteria at\nonce.",
    "deprecated": false,
    "examples": [
      "import { Match } from \"effect\"\n\ntype User = { readonly age: number; readonly role: \"admin\" | \"user\" }\n\nconst checkUser = Match.type<User>().pipe(\n  Match.whenAnd(\n    { age: (n) => n >= 18 },\n    { role: \"admin\" },\n    () => \"Admin access granted\"\n  ),\n  Match.orElse(() => \"Access denied\")\n)\n\nconsole.log(checkUser({ age: 20, role: \"admin\" }))\n// Output: \"Admin access granted\"\n\nconsole.log(checkUser({ age: 20, role: \"user\" }))\n// Output: \"Access denied\""
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "export declare const whenAnd: <R, const P extends ReadonlyArray<Types.PatternPrimitive<R> | Types.PatternBase<R>>, Ret, Fn extends (_: Types.WhenMatch<R, T.UnionToIntersection<P[number]>>) => Ret>(...args: [...patterns: P, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Types.PForExclude<T.UnionToIntersection<P[number]>>>, Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<T.UnionToIntersection<P[number]>>>>, A | ReturnType<Fn>, Pr>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "discriminator",
    "description": "Matches values based on a specified discriminant field.\n\n**Details**\n\nThis function is used to define pattern matching on objects that follow a\n**discriminated union** structure, where a specific field (e.g., `type`,\n`kind`, `_tag`) determines the variant of the object. It allows matching\nmultiple values of the discriminant and provides a function to handle the\nmatched cases.",
    "deprecated": false,
    "examples": [
      "import { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n  Match.discriminator(\"type\")(\"A\", \"B\", (_) => `A or B: ${_.type}`),\n  Match.discriminator(\"type\")(\"C\", (_) => `C(${_.c})`),\n  Match.exhaustive\n)"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "export declare const discriminator: <D extends string>(field: D) => <R, P extends Types.Tags<D, R> & string, Ret, B extends Ret>(...pattern: [first: P, ...values: Array<P>, f: (_: Extract<R, Record<D, P>>) => B]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, P>>>>, B | A, Pr, Ret>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "discriminatorStartsWith",
    "description": "Matches values where a specified field starts with a given prefix.\n\n**Details**\n\nThis function is useful for working with discriminated unions where the\ndiscriminant field follows a hierarchical or namespaced structure. It allows\nyou to match values based on whether the specified field starts with a given\nprefix, making it easier to handle grouped cases.\n\nInstead of checking for exact matches, this function lets you match values\nthat share a common prefix. For example, if your discriminant field contains\nhierarchical names like `\"A\"`, `\"A.A\"`, and `\"B\"`, you can match all values\nstarting with `\"A\"` using a single rule.",
    "deprecated": false,
    "examples": [
      "import { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ type: \"A\" } | { type: \"B\" } | { type: \"A.A\" } | {}>(),\n  Match.discriminatorStartsWith(\"type\")(\"A\", (_) => 1 as const),\n  Match.discriminatorStartsWith(\"type\")(\"B\", (_) => 2 as const),\n  Match.orElse((_) => 3 as const)\n)\n\nconsole.log(match({ type: \"A\" })) // 1\nconsole.log(match({ type: \"B\" })) // 2\nconsole.log(match({ type: \"A.A\" })) // 1"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "export declare const discriminatorStartsWith: <D extends string>(field: D) => <R, P extends string, Ret, B extends Ret>(pattern: P, f: (_: Extract<R, Record<D, `${P}${string}`>>) => B) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>>, B | A, Pr, Ret>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "discriminators",
    "description": "Matches values based on a field that serves as a discriminator, mapping each\npossible value to a corresponding handler.\n\n**Details**\n\nThis function simplifies working with discriminated unions by letting you\ndefine a set of handlers for each possible value of a given field. Instead of\nchaining multiple calls to {@link discriminator}, this function allows\ndefining all possible cases at once using an object where the keys are the\npossible values of the field, and the values are the corresponding handler\nfunctions.",
    "deprecated": false,
    "examples": [
      "import { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n  Match.discriminators(\"type\")({\n    A: (a) => a.a,\n    B: (b) => b.b,\n    C: (c) => c.c\n  }),\n  Match.exhaustive\n)"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "export declare const discriminators: <D extends string>(field: D) => <R, Ret, P extends { readonly [Tag in Types.Tags<D, R> & string]?: ((_: Extract<R, Record<D, Tag>>) => Ret) | undefined; } & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>>, A | ReturnType<P[keyof P] & {}>, Pr, Ret>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "discriminatorsExhaustive",
    "description": "Matches values based on a discriminator field and **ensures all cases are\nhandled**.\n\n**Details*+\n\nThis function is similar to {@link discriminators}, but **requires that all\npossible cases** are explicitly handled. It is useful when working with\ndiscriminated unions, where a specific field (e.g., `\"type\"`) determines the\nshape of an object. Each possible value of the field must have a\ncorresponding handler, ensuring **exhaustiveness checking** at compile time.\n\nThis function **does not require** `Match.exhaustive` at the end of the\npipeline because it enforces exhaustiveness by design.",
    "deprecated": false,
    "examples": [
      "import { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n  Match.discriminatorsExhaustive(\"type\")({\n    A: (a) => a.a,\n    B: (b) => b.b,\n    C: (c) => c.c\n  })\n)"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "export declare const discriminatorsExhaustive: <D extends string>(field: D) => <R, Ret, P extends { readonly [Tag in Types.Tags<D, R> & string]: (_: Extract<R, Record<D, Tag>>) => Ret; } & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "tag",
    "description": "The `Match.tag` function allows pattern matching based on the `_tag` field in\na [Discriminated Union](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions).\nYou can specify multiple tags to match within a single pattern.\n\n**Note**\n\nThe `Match.tag` function relies on the convention within the Effect ecosystem\nof naming the tag field as `\"_tag\"`. Ensure that your discriminated unions\nfollow this naming convention for proper functionality.",
    "deprecated": false,
    "examples": [
      "// Title: Matching a Discriminated Union by Tag\nimport { Match } from \"effect\"\n\ntype Event =\n  | { readonly _tag: \"fetch\" }\n  | { readonly _tag: \"success\"; readonly data: string }\n  | { readonly _tag: \"error\"; readonly error: Error }\n  | { readonly _tag: \"cancel\" }\n\n// Create a Matcher for Either<number, string>\nconst match = Match.type<Event>().pipe(\n  // Match either \"fetch\" or \"success\"\n  Match.tag(\"fetch\", \"success\", () => `Ok!`),\n  // Match \"error\" and extract the error message\n  Match.tag(\"error\", (event) => `Error: ${event.error.message}`),\n  // Match \"cancel\"\n  Match.tag(\"cancel\", () => \"Cancelled\"),\n  Match.exhaustive\n)\n\nconsole.log(match({ _tag: \"success\", data: \"Hello\" }))\n// Output: \"Ok!\"\n\nconsole.log(match({ _tag: \"error\", error: new Error(\"Oops!\") }))\n// Output: \"Error: Oops!\""
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "export declare const tag: <R, P extends Types.Tags<\"_tag\", R> & string, Ret, B extends Ret>(...pattern: [first: P, ...values: Array<P>, f: (_: Extract<T.NoInfer<R>, Record<\"_tag\", P>>) => B]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", P>>>>, B | A, Pr, Ret>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "tagStartsWith",
    "description": "Matches values where the `_tag` field starts with a given prefix.\n\n**Details**\n\nThis function allows you to match on values in a **discriminated union**\nbased on whether the `_tag` field starts with a specified prefix. It is\nuseful for handling hierarchical or namespaced tags, where multiple related\ncases share a common prefix.",
    "deprecated": false,
    "examples": [
      "import { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ _tag: \"A\" } | { _tag: \"B\" } | { _tag: \"A.A\" } | {}>(),\n  Match.tagStartsWith(\"A\", (_) => 1 as const),\n  Match.tagStartsWith(\"B\", (_) => 2 as const),\n  Match.orElse((_) => 3 as const)\n)\n\nconsole.log(match({ _tag: \"A\" })) // 1\nconsole.log(match({ _tag: \"B\" })) // 2\nconsole.log(match({ _tag: \"A.A\" })) // 1"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "export declare const tagStartsWith: <R, P extends string, Ret, B extends Ret>(pattern: P, f: (_: Extract<T.NoInfer<R>, Record<\"_tag\", `${P}${string}`>>) => B) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", `${P}${string}`>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", `${P}${string}`>>>>, B | A, Pr, Ret>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "tags",
    "description": "Matches values based on their `_tag` field, mapping each tag to a\ncorresponding handler.\n\n**Details**\n\nThis function provides a way to handle discriminated unions by mapping `_tag`\nvalues to specific functions. Each handler receives the matched value and\nreturns a transformed result. If all possible tags are handled, you can\nenforce exhaustiveness using `Match.exhaustive` to ensure no case is missed.",
    "deprecated": false,
    "examples": [
      "import { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ _tag: \"A\"; a: string } | { _tag: \"B\"; b: number } | { _tag: \"C\"; c: boolean }>(),\n  Match.tags({\n    A: (a) => a.a,\n    B: (b) => b.b,\n    C: (c) => c.c\n  }),\n  Match.exhaustive\n)"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "export declare const tags: <R, Ret, P extends { readonly [Tag in Types.Tags<\"_tag\", R> & string]?: ((_: Extract<R, Record<\"_tag\", Tag>>) => Ret) | undefined; } & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", keyof P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", keyof P>>>>, A | ReturnType<P[keyof P] & {}>, Pr, Ret>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "tagsExhaustive",
    "description": "Matches values based on their `_tag` field and requires handling of all\npossible cases.\n\n**Details**\n\nThis function is designed for **discriminated unions** where every possible\n`_tag` value must have a corresponding handler. Unlike {@link tags}, this\nfunction ensures **exhaustiveness**, meaning all cases must be explicitly\nhandled. If a `_tag` value is missing from the mapping, TypeScript will\nreport an error.",
    "deprecated": false,
    "examples": [
      "import { Match, pipe } from \"effect\"\n\nconst match = pipe(\n  Match.type<{ _tag: \"A\"; a: string } | { _tag: \"B\"; b: number } | { _tag: \"C\"; c: boolean }>(),\n  Match.tagsExhaustive({\n    A: (a) => a.a,\n    B: (b) => b.b,\n    C: (c) => c.c\n  })\n)"
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "export declare const tagsExhaustive: <R, Ret, P extends { readonly [Tag in Types.Tags<\"_tag\", R> & string]: (_: Extract<R, Record<\"_tag\", Tag>>) => Ret; } & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "not",
    "description": "Excludes a specific value from matching while allowing all others.\n\n**Details**\n\nThis function is useful when you need to **handle all values except one or\nmore specific cases**. Instead of listing all possible matches manually, this\nfunction simplifies the logic by allowing you to specify values to exclude.\nAny excluded value will bypass the provided function and continue matching\nthrough other cases.",
    "deprecated": false,
    "examples": [
      "// Title: Ignoring a Specific Value\nimport { Match } from \"effect\"\n\n// Create a matcher for string or number values\nconst match = Match.type<string | number>().pipe(\n  // Match any value except \"hi\", returning \"ok\"\n  Match.not(\"hi\", () => \"ok\"),\n  // Fallback case for when the value is \"hi\"\n  Match.orElse(() => \"fallback\")\n)\n\nconsole.log(match(\"hello\"))\n// Output: \"ok\"\n\nconsole.log(match(\"hi\"))\n// Output: \"fallback\""
    ],
    "since": "1.0.0",
    "category": "Defining patterns",
    "signature": "export declare const not: <R, const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>, Ret, Fn extends (_: Exclude<R, Types.ExtractMatch<R, Types.PForExclude<P>>>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddOnly<F, Types.WhenMatch<R, P>>, Types.ApplyFilters<I, Types.AddOnly<F, Types.WhenMatch<R, P>>>, A | ReturnType<Fn>, Pr, Ret>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "nonEmptyString",
    "description": "Matches non-empty strings.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const nonEmptyString: SafeRefinement<string, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "is",
    "description": "Matches a specific set of literal values (e.g., `Match.is(\"a\", 42, true)`).",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const is: <Literals extends ReadonlyArray<string | number | bigint | boolean | null>>(...literals: Literals) => Predicate.Refinement<unknown, Literals[number]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "string",
    "description": "Matches values of type `string`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const string: Predicate.Refinement<unknown, string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "number",
    "description": "Matches values of type `number`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const number: Predicate.Refinement<unknown, number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "any",
    "description": "Matches any value without restrictions.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const any: SafeRefinement<unknown, any>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "defined",
    "description": "Matches any defined (non-null and non-undefined) value.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const defined: <A>(u: A) => u is A & {}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "boolean",
    "description": "Matches values of type `boolean`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const boolean: Predicate.Refinement<unknown, boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "bigint",
    "description": "Matches values of type `bigint`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const bigint: Predicate.Refinement<unknown, bigint>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "symbol",
    "description": "Matches values of type `symbol`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const symbol: Predicate.Refinement<unknown, symbol>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "date",
    "description": "Matches values that are instances of `Date`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const date: Predicate.Refinement<unknown, Date>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "record",
    "description": "Matches objects where keys are `string` or `symbol` and values are `unknown`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const record: Predicate.Refinement<unknown, { [x: string]: unknown; [x: symbol]: unknown; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "instanceOf",
    "description": "Matches instances of a given class.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const instanceOf: <A extends abstract new (...args: any) => any>(constructor: A) => SafeRefinement<InstanceType<A>, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "instanceOfUnsafe",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const instanceOfUnsafe: <A extends abstract new (...args: any) => any>(constructor: A) => SafeRefinement<InstanceType<A>, InstanceType<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "orElse",
    "description": "Provides a fallback value when no patterns match.\n\n**Details**\n\nThis function ensures that a matcher always returns a valid result, even if\nno defined patterns match. It acts as a default case, similar to the\n`default` clause in a `switch` statement or the final `else` in an `if-else`\nchain.",
    "deprecated": false,
    "examples": [
      "// Title: Providing a Default Value When No Patterns Match\nimport { Match } from \"effect\"\n\n// Create a matcher for string or number values\nconst match = Match.type<string | number>().pipe(\n  // Match when the value is \"a\"\n  Match.when(\"a\", () => \"ok\"),\n  // Fallback when no patterns match\n  Match.orElse(() => \"fallback\")\n)\n\nconsole.log(match(\"a\"))\n// Output: \"ok\"\n\nconsole.log(match(\"b\"))\n// Output: \"fallback\""
    ],
    "since": "1.0.0",
    "category": "Completion",
    "signature": "export declare const orElse: <RA, Ret, F extends (_: RA) => Ret>(f: F) => <I, R, A, Pr>(self: Matcher<I, R, RA, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Unify<ReturnType<F> | A> : Unify<ReturnType<F> | A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "orElseAbsurd",
    "description": "Throws an error if no pattern matches.\n\n**Details**\n\nThis function finalizes a matcher by ensuring that if no patterns match, an\nerror is thrown. It is useful when all cases should be covered, and any\nunexpected input should trigger an error instead of returning a default\nvalue.\n\nWhen used, this function removes the need for an explicit fallback case and\nensures that an unmatched value is never silently ignored.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Completion",
    "signature": "export declare const orElseAbsurd: <I, R, RA, A, Pr, Ret>(self: Matcher<I, R, RA, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Unify<A> : Unify<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "either",
    "description": "Wraps the match result in an `Either`, distinguishing matched and unmatched\ncases.\n\n**Details**\n\nThis function ensures that the result of a matcher is always wrapped in an\n`Either`, allowing clear differentiation between successful matches\n(`Right(value)`) and cases where no pattern matched (`Left(unmatched\nvalue)`).\n\nThis approach is particularly useful when handling optional values or when an\nunmatched case should be explicitly handled rather than returning a default\nvalue or throwing an error.",
    "deprecated": false,
    "examples": [
      "// Title: Extracting a User Role with Either\nimport { Match } from \"effect\"\n\ntype User = { readonly role: \"admin\" | \"editor\" | \"viewer\" }\n\n// Create a matcher to extract user roles\nconst getRole = Match.type<User>().pipe(\n  Match.when({ role: \"admin\" }, () => \"Has full access\"),\n  Match.when({ role: \"editor\" }, () => \"Can edit content\"),\n  Match.either // Wrap the result in an Either\n)\n\nconsole.log(getRole({ role: \"admin\" }))\n// Output: { _id: 'Either', _tag: 'Right', right: 'Has full access' }\n\nconsole.log(getRole({ role: \"viewer\" }))\n// Output: { _id: 'Either', _tag: 'Left', left: { role: 'viewer' } }"
    ],
    "since": "1.0.0",
    "category": "Completion",
    "signature": "export declare const either: <I, F, R, A, Pr, Ret>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Either.Either<Unify<A>, R> : Either.Either<Unify<A>, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "option",
    "description": "Wraps the match result in an `Option`, representing an optional match.\n\n**Details**\n\nThis function ensures that the result of a matcher is wrapped in an `Option`,\nmaking it easy to handle cases where no pattern matches. If a match is found,\nit returns `Some(value)`, otherwise, it returns `None`.\n\nThis is useful in cases where a missing match is expected and should be\nhandled explicitly rather than throwing an error or returning a default\nvalue.",
    "deprecated": false,
    "examples": [
      "// Title: Extracting a User Role with Option\nimport { Match } from \"effect\"\n\ntype User = { readonly role: \"admin\" | \"editor\" | \"viewer\" }\n\n// Create a matcher to extract user roles\nconst getRole = Match.type<User>().pipe(\n  Match.when({ role: \"admin\" }, () => \"Has full access\"),\n  Match.when({ role: \"editor\" }, () => \"Can edit content\"),\n  Match.option // Wrap the result in an Option\n)\n\nconsole.log(getRole({ role: \"admin\" }))\n// Output: { _id: 'Option', _tag: 'Some', value: 'Has full access' }\n\nconsole.log(getRole({ role: \"viewer\" }))\n// Output: { _id: 'Option', _tag: 'None' }"
    ],
    "since": "1.0.0",
    "category": "Completion",
    "signature": "export declare const option: <I, F, R, A, Pr, Ret>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Option.Option<Unify<A>> : Option.Option<Unify<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "exhaustive",
    "description": "The `Match.exhaustive` method finalizes the pattern matching process by\nensuring that all possible cases are accounted for. If any case is missing,\nTypeScript will produce a type error. This is particularly useful when\nworking with unions, as it helps prevent unintended gaps in pattern matching.",
    "deprecated": false,
    "examples": [
      "// Title: Ensuring All Cases Are Covered\nimport { Match } from \"effect\"\n\n// Create a matcher for string or number values\nconst match = Match.type<string | number>().pipe(\n  // Match when the value is a number\n  Match.when(Match.number, (n) => `number: ${n}`),\n  // Mark the match as exhaustive, ensuring all cases are handled\n  // TypeScript will throw an error if any case is missing\n  // @ts-expect-error Type 'string' is not assignable to type 'never'\n  Match.exhaustive\n)"
    ],
    "since": "1.0.0",
    "category": "Completion",
    "signature": "export declare const exhaustive: <I, F, A, Pr, Ret>(self: Matcher<I, F, never, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A> : Unify<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "SafeRefinementId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Symbols",
    "signature": "export declare const SafeRefinementId: typeof SafeRefinementId"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "undefined",
    "description": "Matches the value `undefined`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const undefined: Predicate.Refinement<unknown, undefined>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "null",
    "description": "Matches the value `null`.",
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Predicates",
    "signature": "export declare const null: Predicate.Refinement<unknown, null>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "Not",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Model",
    "signature": "export interface Not {\n  readonly _tag: \"Not\"\n  guard(u: unknown): boolean\n  evaluate(input: unknown): any\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "SafeRefinement",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Model",
    "signature": "export interface SafeRefinement<in A, out R = A> {\n  readonly [SafeRefinementId]: (a: A) => R\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "TypeMatcher",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Model",
    "signature": "export interface TypeMatcher<in Input, out Filters, out Remaining, out Result, out Return = any> extends Pipeable {\n  readonly _tag: \"TypeMatcher\"\n  readonly [MatcherTypeId]: {\n    readonly _input: T.Contravariant<Input>\n    readonly _filters: T.Covariant<Filters>\n    readonly _remaining: T.Covariant<Remaining>\n    readonly _result: T.Covariant<Result>\n    readonly _return: T.Covariant<Return>\n  }\n  readonly cases: ReadonlyArray<Case>\n  add<I, R, RA, A>(_case: Case): TypeMatcher<I, R, RA, A>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "ValueMatcher",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Model",
    "signature": "export interface ValueMatcher<in Input, Filters, out Remaining, out Result, Provided, out Return = any>\n  extends Pipeable\n{\n  readonly _tag: \"ValueMatcher\"\n  readonly [MatcherTypeId]: {\n    readonly _input: T.Contravariant<Input>\n    readonly _filters: T.Covariant<Filters>\n    readonly _result: T.Covariant<Result>\n    readonly _return: T.Covariant<Return>\n  }\n  readonly provided: Provided\n  readonly value: Either.Either<Provided, Remaining>\n  add<I, R, RA, A, Pr>(_case: Case): ValueMatcher<I, R, RA, A, Pr>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "When",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Model",
    "signature": "export interface When {\n  readonly _tag: \"When\"\n  guard(u: unknown): boolean\n  evaluate(input: unknown): any\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "Case",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Model",
    "signature": "export type Case = When | Not"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "Matcher",
    "description": "Pattern matching follows a structured process:\n\n- **Creating a matcher**: Define a `Matcher` that operates on either a\n  specific `Match.type` or `Match.value`.\n\n- **Defining patterns**: Use combinators such as `Match.when`, `Match.not`,\n  and `Match.tag` to specify matching conditions.\n\n- **Completing the match**: Apply a finalizer such as `Match.exhaustive`,\n  `Match.orElse`, or `Match.option` to determine how unmatched cases should\n  be handled.",
    "deprecated": false,
    "examples": [
      "import { Match } from \"effect\"\n\n// Simulated dynamic input that can be a string or a number\nconst input: string | number = \"some input\"\n\n//       string\n//      \nconst result = Match.value(input).pipe(\n  // Match if the value is a number\n  Match.when(Match.number, (n) => `number: ${n}`),\n  // Match if the value is a string\n  Match.when(Match.string, (s) => `string: ${s}`),\n  // Ensure all possible cases are covered\n  Match.exhaustive\n)\n\nconsole.log(result)\n// Output: \"string: some input\""
    ],
    "since": "1.0.0",
    "category": "Model",
    "signature": "export type Matcher<Input, Filters, RemainingApplied, Result, Provided, Return = any> =\n  | TypeMatcher<Input, Filters, RemainingApplied, Result, Return>\n  | ValueMatcher<Input, Filters, RemainingApplied, Result, Provided, Return>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "MatcherTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Symbols",
    "signature": "export type MatcherTypeId = typeof MatcherTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Match",
      "path": [
        "src",
        "Match.ts"
      ]
    },
    "project": "effect",
    "name": "SafeRefinementId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "Symbols",
    "signature": "export type SafeRefinementId = typeof SafeRefinementId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeDecision",
      "path": [
        "src",
        "MergeDecision.ts"
      ]
    },
    "project": "effect",
    "name": "MergeDecisionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const MergeDecisionTypeId: typeof MergeDecisionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeDecision",
      "path": [
        "src",
        "MergeDecision.ts"
      ]
    },
    "project": "effect",
    "name": "Done",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Done: <Z, E, R>(effect: Effect.Effect<Z, E, R>) => MergeDecision<R, unknown, unknown, E, Z>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeDecision",
      "path": [
        "src",
        "MergeDecision.ts"
      ]
    },
    "project": "effect",
    "name": "Await",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Await: <R, E0, Z0, E, Z>(f: (exit: Exit.Exit<Z0, E0>) => Effect.Effect<Z, E, R>) => MergeDecision<R, E0, Z0, E, Z>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeDecision",
      "path": [
        "src",
        "MergeDecision.ts"
      ]
    },
    "project": "effect",
    "name": "AwaitConst",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const AwaitConst: <Z, E, R>(effect: Effect.Effect<Z, E, R>) => MergeDecision<R, unknown, unknown, E, Z>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeDecision",
      "path": [
        "src",
        "MergeDecision.ts"
      ]
    },
    "project": "effect",
    "name": "isMergeDecision",
    "description": "Returns `true` if the specified value is a `MergeDecision`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isMergeDecision: (u: unknown) => u is MergeDecision<unknown, unknown, unknown, unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeDecision",
      "path": [
        "src",
        "MergeDecision.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const match: { <R, E0, Z0, E, Z, Z2>(options: { readonly onDone: (effect: Effect.Effect<Z, E, R>) => Z2; readonly onAwait: (f: (exit: Exit.Exit<Z0, E0>) => Effect.Effect<Z, E, R>) => Z2; }): (self: MergeDecision<R, E0, Z0, E, Z>) => Z2; <R, E0, Z0, E, Z, Z2>(self: MergeDecision<R, E0, Z0, E, Z>, options: { readonly onDone: (effect: Effect.Effect<Z, E, R>) => Z2; readonly onAwait: (f: (exit: Exit.Exit<Z0, E0>) => Effect.Effect<Z, E, R>) => Z2; }): Z2; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeDecision",
      "path": [
        "src",
        "MergeDecision.ts"
      ]
    },
    "project": "effect",
    "name": "MergeDecision",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MergeDecision<out R, in E0, in Z0, out E, out Z> extends MergeDecision.Variance<R, E0, Z0, E, Z> {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MergeDecision",
      "path": [
        "src",
        "MergeDecision.ts"
      ]
    },
    "project": "effect",
    "name": "MergeDecisionTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type MergeDecisionTypeId = typeof MergeDecisionTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState",
      "path": [
        "src",
        "MergeState.ts"
      ]
    },
    "project": "effect",
    "name": "MergeStateTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const MergeStateTypeId: typeof MergeStateTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState",
      "path": [
        "src",
        "MergeState.ts"
      ]
    },
    "project": "effect",
    "name": "BothRunning",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const BothRunning: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(left: Fiber.Fiber<Either.Either<Elem, Done>, Err>, right: Fiber.Fiber<Either.Either<Elem, Done1>, Err1>) => MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState",
      "path": [
        "src",
        "MergeState.ts"
      ]
    },
    "project": "effect",
    "name": "LeftDone",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const LeftDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(f: (exit: Exit.Exit<Done1, Err1>) => Effect.Effect<Done2, Err2, Env>) => MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState",
      "path": [
        "src",
        "MergeState.ts"
      ]
    },
    "project": "effect",
    "name": "RightDone",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const RightDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(f: (exit: Exit.Exit<Done, Err>) => Effect.Effect<Done2, Err2, Env>) => MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState",
      "path": [
        "src",
        "MergeState.ts"
      ]
    },
    "project": "effect",
    "name": "isMergeState",
    "description": "Returns `true` if the specified value is a `MergeState`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isMergeState: (u: unknown) => u is MergeState<unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState",
      "path": [
        "src",
        "MergeState.ts"
      ]
    },
    "project": "effect",
    "name": "isBothRunning",
    "description": "Returns `true` if the specified `MergeState` is a `BothRunning`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isBothRunning: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is BothRunning<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState",
      "path": [
        "src",
        "MergeState.ts"
      ]
    },
    "project": "effect",
    "name": "isLeftDone",
    "description": "Returns `true` if the specified `MergeState` is a `LeftDone`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isLeftDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is LeftDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState",
      "path": [
        "src",
        "MergeState.ts"
      ]
    },
    "project": "effect",
    "name": "isRightDone",
    "description": "Returns `true` if the specified `MergeState` is a `RightDone`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isRightDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is RightDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeState",
      "path": [
        "src",
        "MergeState.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const match: { <Env, Err, Err1, Err2, Elem, Done, Done1, Done2, Z>(options: { readonly onBothRunning: (left: Fiber.Fiber<Either.Either<Elem, Done>, Err>, right: Fiber.Fiber<Either.Either<Elem, Done1>, Err1>) => Z; readonly onLeftDone: (f: (exit: Exit.Exit<Done1, Err1>) => Effect.Effect<Done2, Err2, Env>) => Z; readonly onRightDone: (f: (exit: Exit.Exit<Done, Err>) => Effect.Effect<Done2, Err2, Env>) => Z; }): (self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => Z; <Env, Err, Err1, Err2, Elem, Done, Done1, Done2, Z>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>, options: { readonly onBothRunning: (left: Fiber.Fiber<Either.Either<Elem, Done>, Err>, right: Fiber.Fiber<Either.Either<Elem, Done1>, Err1>) => Z; readonly onLeftDone: (f: (exit: Exit.Exit<Done1, Err1>) => Effect.Effect<Done2, Err2, Env>) => Z; readonly onRightDone: (f: (exit: Exit.Exit<Done, Err>) => Effect.Effect<Done2, Err2, Env>) => Z; }): Z; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeState",
      "path": [
        "src",
        "MergeState.ts"
      ]
    },
    "project": "effect",
    "name": "BothRunning",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BothRunning<_Env, out Err, out Err1, _Err2, out Elem, out Done, out Done1, _Done2>\n  extends MergeState.Proto\n{\n  readonly _tag: \"BothRunning\"\n  readonly left: Fiber.Fiber<Either.Either<Elem, Done>, Err>\n  readonly right: Fiber.Fiber<Either.Either<Elem, Done1>, Err1>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeState",
      "path": [
        "src",
        "MergeState.ts"
      ]
    },
    "project": "effect",
    "name": "LeftDone",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface LeftDone<out Env, _Err, in Err1, out Err2, _Elem, _Done, in Done1, out Done2>\n  extends MergeState.Proto\n{\n  readonly _tag: \"LeftDone\"\n  f(exit: Exit.Exit<Done1, Err1>): Effect.Effect<Done2, Err2, Env>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeState",
      "path": [
        "src",
        "MergeState.ts"
      ]
    },
    "project": "effect",
    "name": "RightDone",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RightDone<out Env, in Err, _Err1, out Err2, _Elem, in Done, _Done1, out Done2>\n  extends MergeState.Proto\n{\n  readonly _tag: \"RightDone\"\n  f(exit: Exit.Exit<Done, Err>): Effect.Effect<Done2, Err2, Env>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MergeState",
      "path": [
        "src",
        "MergeState.ts"
      ]
    },
    "project": "effect",
    "name": "MergeState",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2> =\n  | BothRunning<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>\n  | LeftDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>\n  | RightDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MergeState",
      "path": [
        "src",
        "MergeState.ts"
      ]
    },
    "project": "effect",
    "name": "MergeStateTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type MergeStateTypeId = typeof MergeStateTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeStrategy",
      "path": [
        "src",
        "MergeStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "MergeStrategyTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const MergeStrategyTypeId: typeof MergeStrategyTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeStrategy",
      "path": [
        "src",
        "MergeStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "BackPressure",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const BackPressure: (_: void) => MergeStrategy"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeStrategy",
      "path": [
        "src",
        "MergeStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "BufferSliding",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const BufferSliding: (_: void) => MergeStrategy"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeStrategy",
      "path": [
        "src",
        "MergeStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "isMergeStrategy",
    "description": "Returns `true` if the specified value is a `MergeStrategy`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isMergeStrategy: (u: unknown) => u is MergeStrategy"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeStrategy",
      "path": [
        "src",
        "MergeStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "isBackPressure",
    "description": "Returns `true` if the specified `MergeStrategy` is a `BackPressure`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isBackPressure: (self: MergeStrategy) => self is BackPressure"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeStrategy",
      "path": [
        "src",
        "MergeStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "isBufferSliding",
    "description": "Returns `true` if the specified `MergeStrategy` is a `BufferSliding`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isBufferSliding: (self: MergeStrategy) => self is BufferSliding"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MergeStrategy",
      "path": [
        "src",
        "MergeStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Folds an `MergeStrategy` into a value of type `A`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const match: { <A>(options: { readonly onBackPressure: () => A; readonly onBufferSliding: () => A; }): (self: MergeStrategy) => A; <A>(self: MergeStrategy, options: { readonly onBackPressure: () => A; readonly onBufferSliding: () => A; }): A; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeStrategy",
      "path": [
        "src",
        "MergeStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "BackPressure",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BackPressure extends MergeStrategy.Proto {\n  readonly _tag: \"BackPressure\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MergeStrategy",
      "path": [
        "src",
        "MergeStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "BufferSliding",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BufferSliding extends MergeStrategy.Proto {\n  readonly _tag: \"BufferSliding\"\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MergeStrategy",
      "path": [
        "src",
        "MergeStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "MergeStrategy",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type MergeStrategy = BackPressure | BufferSliding"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MergeStrategy",
      "path": [
        "src",
        "MergeStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "MergeStrategyTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type MergeStrategyTypeId = typeof MergeStrategyTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "MetricTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const MetricTypeId: typeof MetricTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "globalMetricRegistry",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "globals",
    "signature": "export declare const globalMetricRegistry: MetricRegistry.MetricRegistry"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: MetricApply"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "mapInput",
    "description": "Returns a new metric that is powered by this one, but which accepts updates\nof the specified new type, which must be transformable to the input type of\nthis metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapInput: { <In, In2>(f: (input: In2) => In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In2, Out>; <Type, In, Out, In2>(self: Metric<Type, In, Out>, f: (input: In2) => In): Metric<Type, In2, Out>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "counter",
    "description": "Represents a Counter metric that tracks cumulative numerical values over time.\nCounters can be incremented and decremented and provide a running total of changes.",
    "deprecated": false,
    "examples": [
      "import { Metric } from \"effect\"\n\nconst numberCounter = Metric.counter(\"count\", {\n  description: \"A number counter\"\n});\n\nconst bigintCounter = Metric.counter(\"count\", {\n  description: \"A bigint counter\",\n  bigint: true\n});"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const counter: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; readonly incremental?: boolean | undefined; }): Metric.Counter<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; readonly incremental?: boolean | undefined; }): Metric.Counter<bigint>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "frequency",
    "description": "Creates a Frequency metric to count occurrences of events.\nFrequency metrics are used to count the number of times specific events or incidents occur.",
    "deprecated": false,
    "examples": [
      "import { Metric } from \"effect\"\n\nconst errorFrequency = Metric.frequency(\"error_frequency\", {\n   description: \"Counts the occurrences of errors.\"\n});"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const frequency: (name: string, options?: { readonly description?: string | undefined; readonly preregisteredWords?: ReadonlyArray<string> | undefined; } | undefined) => Metric.Frequency<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "withConstantInput",
    "description": "Returns a new metric that is powered by this one, but which accepts updates\nof any type, and translates them to updates with the specified constant\nupdate value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const withConstantInput: { <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, unknown, Out>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Metric<Type, unknown, Out>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "fromMetricKey",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromMetricKey: <Type extends MetricKeyType.MetricKeyType<any, any>>(key: MetricKey.MetricKey<Type>) => Metric<Type, MetricKeyType.MetricKeyType.InType<Type>, MetricKeyType.MetricKeyType.OutType<Type>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "gauge",
    "description": "Represents a Gauge metric that tracks and reports a single numerical value at a specific moment.\nGauges are suitable for metrics that represent instantaneous values, such as memory usage or CPU load.",
    "deprecated": false,
    "examples": [
      "import { Metric } from \"effect\"\n\nconst numberGauge = Metric.gauge(\"memory_usage\", {\n  description: \"A gauge for memory usage\"\n});\n\nconst bigintGauge = Metric.gauge(\"cpu_load\", {\n  description: \"A gauge for CPU load\",\n  bigint: true\n});"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const gauge: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; }): Metric.Gauge<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; }): Metric.Gauge<bigint>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "histogram",
    "description": "Represents a Histogram metric that records observations in specified value boundaries.\nHistogram metrics are useful for measuring the distribution of values within a range.",
    "deprecated": false,
    "examples": [
      "import { Metric, MetricBoundaries } from \"effect\"\n\nconst latencyHistogram = Metric.histogram(\"latency_histogram\",\n  MetricBoundaries.linear({ start: 0, width: 10, count: 11 }),\n  \"Measures the distribution of request latency.\"\n);"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const histogram: (name: string, boundaries: MetricBoundaries.MetricBoundaries, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, number, MetricState.MetricState.Histogram>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "increment",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const increment: (self: Metric.Counter<number> | Metric.Counter<bigint> | Metric.Gauge<number> | Metric.Gauge<bigint>) => Effect.Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "incrementBy",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const incrementBy: { (amount: number): (self: Metric.Counter<number> | Metric.Counter<number>) => Effect.Effect<void>; (amount: bigint): (self: Metric.Counter<bigint> | Metric.Gauge<bigint>) => Effect.Effect<void>; (self: Metric.Counter<number> | Metric.Gauge<number>, amount: number): Effect.Effect<void>; (self: Metric.Counter<bigint> | Metric.Gauge<bigint>, amount: bigint): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Returns a new metric that is powered by this one, but which outputs a new\nstate type, determined by transforming the state type of this metric by the\nspecified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <Out, Out2>(f: (out: Out) => Out2): <Type, In>(self: Metric<Type, In, Out>) => Metric<Type, In, Out2>; <Type, In, Out, Out2>(self: Metric<Type, In, Out>, f: (out: Out) => Out2): Metric<Type, In, Out2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "mapType",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapType: { <Type, Type2>(f: (type: Type) => Type2): <In, Out>(self: Metric<Type, In, Out>) => Metric<Type2, In, Out>; <Type, In, Out, Type2>(self: Metric<Type, In, Out>, f: (type: Type) => Type2): Metric<Type2, In, Out>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "modify",
    "description": "Modifies the metric with the specified update message. For example, if the\nmetric were a gauge, the update would increment the method by the provided\namount.",
    "deprecated": false,
    "examples": [],
    "since": "3.6.5",
    "category": "utils",
    "signature": "export declare const modify: { <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "export declare const set: { (value: number): (self: Metric.Gauge<number>) => Effect.Effect<void>; (value: bigint): (self: Metric.Gauge<bigint>) => Effect.Effect<void>; (self: Metric.Gauge<number>, value: number): Effect.Effect<void>; (self: Metric.Gauge<bigint>, value: bigint): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "snapshot",
    "description": "Captures a snapshot of all metrics recorded by the application.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const snapshot: Effect.Effect<MetricPair.MetricPair.Untyped[], never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": "Creates a metric that ignores input and produces constant output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const succeed: <Out>(out: Out) => Metric<void, unknown, Out>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "sync",
    "description": "Creates a metric that ignores input and produces constant output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sync: <Out>(evaluate: LazyArg<Out>) => Metric<void, unknown, Out>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "summary",
    "description": "Creates a Summary metric that records observations and calculates quantiles.\nSummary metrics provide statistical information about a set of values, including quantiles.",
    "deprecated": false,
    "examples": [
      "import { Metric, Chunk } from \"effect\"\n\nconst responseTimesSummary = Metric.summary({\n  name: \"response_times_summary\",\n  maxAge: \"60 seconds\", // Retain observations for 60 seconds.\n  maxSize: 1000, // Keep a maximum of 1000 observations.\n  error: 0.01, // Allow a 1% error when calculating quantiles.\n  quantiles: [0.5, 0.9, 0.99], // Calculate 50th, 90th, and 99th percentiles.\n  description: \"Measures the distribution of response times.\"\n});"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const summary: (options: { readonly name: string; readonly maxAge: Duration.DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: ReadonlyArray<number>; readonly description?: string | undefined; }) => Metric.Summary<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "summaryTimestamp",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const summaryTimestamp: (options: { readonly name: string; readonly maxAge: Duration.DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: ReadonlyArray<number>; readonly description?: string | undefined; }) => Metric.Summary<readonly [value: number, timestamp: number]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "tagged",
    "description": "Returns a new metric, which is identical in every way to this one, except\nthe specified tags have been added to the tags of this metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const tagged: { <Type, In, Out>(key: string, value: string): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>; <Type, In, Out>(self: Metric<Type, In, Out>, key: string, value: string): Metric<Type, In, Out>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "taggedWithLabelsInput",
    "description": "Returns a new metric, which is identical in every way to this one, except\ndynamic tags are added based on the update values. Note that the metric\nreturned by this method does not return any useful information, due to the\ndynamic nature of the added tags.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const taggedWithLabelsInput: { <In>(f: (input: In) => Iterable<MetricLabel.MetricLabel>): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In, void>; <Type, In, Out>(self: Metric<Type, In, Out>, f: (input: In) => Iterable<MetricLabel.MetricLabel>): Metric<Type, In, void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "taggedWithLabels",
    "description": "Returns a new metric, which is identical in every way to this one, except\nthe specified tags have been added to the tags of this metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const taggedWithLabels: { <Type, In, Out>(extraTags: Iterable<MetricLabel.MetricLabel>): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>; <Type, In, Out>(self: Metric<Type, In, Out>, extraTags: Iterable<MetricLabel.MetricLabel>): Metric<Type, In, Out>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "timer",
    "description": "Creates a timer metric, based on a histogram, which keeps track of\ndurations in milliseconds. The unit of time will automatically be added to\nthe metric as a tag (i.e. `\"time_unit: milliseconds\"`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const timer: (name: string, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "timerWithBoundaries",
    "description": "Creates a timer metric, based on a histogram created from the provided\nboundaries, which keeps track of durations in milliseconds. The unit of time\nwill automatically be added to the metric as a tag (i.e.\n`\"time_unit: milliseconds\"`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const timerWithBoundaries: (name: string, boundaries: ReadonlyArray<number>, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "trackAll",
    "description": "Returns an aspect that will update this metric with the specified constant\nvalue every time the aspect is applied to an effect, regardless of whether\nthat effect fails or succeeds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "export declare const trackAll: { <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "trackDefect",
    "description": "Returns an aspect that will update this metric with the defects of the\neffects that it is applied to.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "export declare const trackDefect: { <Type, Out>(metric: Metric<Type, unknown, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, unknown, Out>): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "trackDefectWith",
    "description": "Returns an aspect that will update this metric with the result of applying\nthe specified function to the defect throwables of the effects that the\naspect is applied to.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "export declare const trackDefectWith: { <Type, In, Out>(metric: Metric<Type, In, Out>, f: (defect: unknown) => In): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (defect: unknown) => In): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "trackDuration",
    "description": "Returns an aspect that will update this metric with the duration that the\neffect takes to execute. To call this method, the input type of the metric\nmust be `Duration`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "export declare const trackDuration: { <Type, Out>(metric: Metric<Type, Duration.Duration, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, Duration.Duration, Out>): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "trackDurationWith",
    "description": "Returns an aspect that will update this metric with the duration that the\neffect takes to execute. To call this method, you must supply a function\nthat can convert the `Duration` to the input type of this metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "export declare const trackDurationWith: { <Type, In, Out>(metric: Metric<Type, In, Out>, f: (duration: Duration.Duration) => In): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (duration: Duration.Duration) => In): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "trackError",
    "description": "Returns an aspect that will update this metric with the failure value of\nthe effects that it is applied to.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "export declare const trackError: { <Type, In, Out>(metric: Metric<Type, In, Out>): <A, E extends In, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E extends In, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "trackErrorWith",
    "description": "Returns an aspect that will update this metric with the result of applying\nthe specified function to the error value of the effects that the aspect is\napplied to.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "export declare const trackErrorWith: { <Type, In, Out, In2>(metric: Metric<Type, In, Out>, f: (error: In2) => In): <A, E extends In2, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E extends In2, R, Type, In, Out, In2>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (error: In2) => In): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "trackSuccess",
    "description": "Returns an aspect that will update this metric with the success value of\nthe effects that it is applied to.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "export declare const trackSuccess: { <Type, In, Out>(metric: Metric<Type, In, Out>): <A extends In, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A extends In, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "trackSuccessWith",
    "description": "Returns an aspect that will update this metric with the result of applying\nthe specified function to the success value of the effects that the aspect is\napplied to.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "aspects",
    "signature": "export declare const trackSuccessWith: { <Type, In, Out, In2>(metric: Metric<Type, In, Out>, f: (value: In2) => In): <A extends In2, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A extends In2, E, R, Type, In, Out, In2>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (value: In2) => In): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "update",
    "description": "Updates the metric with the specified update message. For example, if the\nmetric were a counter, the update would increment the method by the\nprovided amount.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const update: { <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "value",
    "description": "Retrieves a snapshot of the value of the metric at this moment in time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const value: <Type, In, Out>(self: Metric<Type, In, Out>) => Effect.Effect<Out>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "withNow",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const withNow: <Type, In, Out>(self: Metric<Type, readonly [In, number], Out>) => Metric<Type, In, Out>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zip: { <Type2, In2, Out2>(that: Metric<Type2, In2, Out2>): <Type, In, Out>(self: Metric<Type, In, Out>) => Metric<readonly [Type, Type2], readonly [In, In2], [Out, Out2]>; <Type, In, Out, Type2, In2, Out2>(self: Metric<Type, In, Out>, that: Metric<Type2, In2, Out2>): Metric<readonly [Type, Type2], readonly [In, In2], [Out, Out2]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeSnapshot",
    "description": "Unsafely captures a snapshot of all metrics recorded by the application.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeSnapshot: (_: void) => ReadonlyArray<MetricPair.MetricPair.Untyped>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "fiberStarted",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "metrics",
    "signature": "export declare const fiberStarted: Metric.Counter<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "fiberSuccesses",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "metrics",
    "signature": "export declare const fiberSuccesses: Metric.Counter<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "fiberFailures",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "metrics",
    "signature": "export declare const fiberFailures: Metric.Counter<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "fiberLifetimes",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "metrics",
    "signature": "export declare const fiberLifetimes: Metric<MetricKeyType.MetricKeyType.Histogram, number, MetricState.MetricState.Histogram>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "fiberActive",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "metrics",
    "signature": "export declare const fiberActive: Metric.Counter<number>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "Metric",
    "description": "A `Metric<Type, In, Out>` represents a concurrent metric which accepts\nupdates of type `In` and are aggregated to a stateful value of type `Out`.\n\nFor example, a counter metric would have type `Metric<number, number>`,\nrepresenting the fact that the metric can be updated with numbers (the amount\nto increment or decrement the counter by), and the state of the counter is a\nnumber.\n\nThere are five primitive metric types supported by Effect:\n\n  - Counters\n  - Frequencies\n  - Gauges\n  - Histograms\n  - Summaries",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Metric<in out Type, in In, out Out> extends Metric.Variance<Type, In, Out>, Pipeable {\n  /**\n   * The type of the underlying primitive metric. For example, this could be\n   * `MetricKeyType.Counter` or `MetricKeyType.Gauge`.\n   */\n  readonly keyType: Type\n  unsafeUpdate(input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): void\n  unsafeValue(extraTags: ReadonlyArray<MetricLabel.MetricLabel>): Out\n  unsafeModify(input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): void\n  register(): this\n  <A extends In, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "MetricApply",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricApply {\n  <Type, In, Out>(\n    keyType: Type,\n    unsafeUpdate: (input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => void,\n    unsafeValue: (extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => Out,\n    unsafeModify: (input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => void\n  ): Metric<Type, In, Out>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Metric",
      "path": [
        "src",
        "Metric.ts"
      ]
    },
    "project": "effect",
    "name": "MetricTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type MetricTypeId = typeof MetricTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricBoundaries",
      "path": [
        "src",
        "MetricBoundaries.ts"
      ]
    },
    "project": "effect",
    "name": "MetricBoundariesTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const MetricBoundariesTypeId: typeof MetricBoundariesTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricBoundaries",
      "path": [
        "src",
        "MetricBoundaries.ts"
      ]
    },
    "project": "effect",
    "name": "isMetricBoundaries",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isMetricBoundaries: (u: unknown) => u is MetricBoundaries"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricBoundaries",
      "path": [
        "src",
        "MetricBoundaries.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterable: (iterable: Iterable<number>) => MetricBoundaries"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricBoundaries",
      "path": [
        "src",
        "MetricBoundaries.ts"
      ]
    },
    "project": "effect",
    "name": "linear",
    "description": "A helper method to create histogram bucket boundaries for a histogram\nwith linear increasing values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const linear: (options: { readonly start: number; readonly width: number; readonly count: number; }) => MetricBoundaries"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricBoundaries",
      "path": [
        "src",
        "MetricBoundaries.ts"
      ]
    },
    "project": "effect",
    "name": "exponential",
    "description": "A helper method to create histogram bucket boundaries for a histogram\nwith exponentially increasing values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const exponential: (options: { readonly start: number; readonly factor: number; readonly count: number; }) => MetricBoundaries"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricBoundaries",
      "path": [
        "src",
        "MetricBoundaries.ts"
      ]
    },
    "project": "effect",
    "name": "MetricBoundaries",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricBoundaries extends Equal.Equal, Pipeable {\n  readonly [MetricBoundariesTypeId]: MetricBoundariesTypeId\n  readonly values: ReadonlyArray<number>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricBoundaries",
      "path": [
        "src",
        "MetricBoundaries.ts"
      ]
    },
    "project": "effect",
    "name": "MetricBoundariesTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type MetricBoundariesTypeId = typeof MetricBoundariesTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook",
      "path": [
        "src",
        "MetricHook.ts"
      ]
    },
    "project": "effect",
    "name": "MetricHookTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const MetricHookTypeId: typeof MetricHookTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook",
      "path": [
        "src",
        "MetricHook.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <In, Out>(options: { readonly get: LazyArg<Out>; readonly update: (input: In) => void; readonly modify: (input: In) => void; }) => MetricHook<In, Out>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook",
      "path": [
        "src",
        "MetricHook.ts"
      ]
    },
    "project": "effect",
    "name": "counter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const counter: <A extends (number | bigint)>(key: MetricKey.MetricKey.Counter<A>) => MetricHook.Counter<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook",
      "path": [
        "src",
        "MetricHook.ts"
      ]
    },
    "project": "effect",
    "name": "frequency",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const frequency: (_key: MetricKey.MetricKey.Frequency) => MetricHook.Frequency"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook",
      "path": [
        "src",
        "MetricHook.ts"
      ]
    },
    "project": "effect",
    "name": "gauge",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const gauge: { (key: MetricKey.MetricKey.Gauge<number>, startAt: number): MetricHook.Gauge<number>; (key: MetricKey.MetricKey.Gauge<bigint>, startAt: bigint): MetricHook.Gauge<bigint>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook",
      "path": [
        "src",
        "MetricHook.ts"
      ]
    },
    "project": "effect",
    "name": "histogram",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const histogram: (key: MetricKey.MetricKey.Histogram) => MetricHook.Histogram"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook",
      "path": [
        "src",
        "MetricHook.ts"
      ]
    },
    "project": "effect",
    "name": "summary",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const summary: (key: MetricKey.MetricKey.Summary) => MetricHook.Summary"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook",
      "path": [
        "src",
        "MetricHook.ts"
      ]
    },
    "project": "effect",
    "name": "onUpdate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const onUpdate: { <In, Out>(f: (input: In) => void): (self: MetricHook<In, Out>) => MetricHook<In, Out>; <In, Out>(self: MetricHook<In, Out>, f: (input: In) => void): MetricHook<In, Out>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricHook",
      "path": [
        "src",
        "MetricHook.ts"
      ]
    },
    "project": "effect",
    "name": "onModify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.5",
    "category": "utils",
    "signature": "export declare const onModify: { <In, Out>(f: (input: In) => void): (self: MetricHook<In, Out>) => MetricHook<In, Out>; <In, Out>(self: MetricHook<In, Out>, f: (input: In) => void): MetricHook<In, Out>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricHook",
      "path": [
        "src",
        "MetricHook.ts"
      ]
    },
    "project": "effect",
    "name": "MetricHook",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricHook<in In, out Out> extends MetricHook.Variance<In, Out>, Pipeable {\n  get(): Out\n  update(input: In): void\n  modify(input: In): void\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricHook",
      "path": [
        "src",
        "MetricHook.ts"
      ]
    },
    "project": "effect",
    "name": "MetricHookTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type MetricHookTypeId = typeof MetricHookTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey",
      "path": [
        "src",
        "MetricKey.ts"
      ]
    },
    "project": "effect",
    "name": "MetricKeyTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const MetricKeyTypeId: typeof MetricKeyTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey",
      "path": [
        "src",
        "MetricKey.ts"
      ]
    },
    "project": "effect",
    "name": "isMetricKey",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isMetricKey: (u: unknown) => u is MetricKey<MetricKeyType.MetricKeyType<unknown, unknown>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey",
      "path": [
        "src",
        "MetricKey.ts"
      ]
    },
    "project": "effect",
    "name": "counter",
    "description": "Creates a metric key for a counter, with the specified name.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const counter: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; readonly incremental?: boolean | undefined; }): MetricKey.Counter<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; readonly incremental?: boolean | undefined; }): MetricKey.Counter<bigint>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey",
      "path": [
        "src",
        "MetricKey.ts"
      ]
    },
    "project": "effect",
    "name": "frequency",
    "description": "Creates a metric key for a categorical frequency table, with the specified\nname.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const frequency: (name: string, options?: { readonly description?: string | undefined; readonly preregisteredWords?: ReadonlyArray<string> | undefined; } | undefined) => MetricKey.Frequency"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey",
      "path": [
        "src",
        "MetricKey.ts"
      ]
    },
    "project": "effect",
    "name": "gauge",
    "description": "Creates a metric key for a gauge, with the specified name.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const gauge: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; }): MetricKey.Gauge<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; }): MetricKey.Gauge<bigint>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey",
      "path": [
        "src",
        "MetricKey.ts"
      ]
    },
    "project": "effect",
    "name": "histogram",
    "description": "Creates a metric key for a histogram, with the specified name and boundaries.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const histogram: (name: string, boundaries: MetricBoundaries.MetricBoundaries, description?: string) => MetricKey.Histogram"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey",
      "path": [
        "src",
        "MetricKey.ts"
      ]
    },
    "project": "effect",
    "name": "summary",
    "description": "Creates a metric key for a summary, with the specified name, maxAge,\nmaxSize, error, and quantiles.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const summary: (options: { readonly name: string; readonly maxAge: Duration.DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: ReadonlyArray<number>; readonly description?: string | undefined; }) => MetricKey.Summary"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey",
      "path": [
        "src",
        "MetricKey.ts"
      ]
    },
    "project": "effect",
    "name": "tagged",
    "description": "Returns a new `MetricKey` with the specified tag appended.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const tagged: { (key: string, value: string): <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>) => MetricKey<Type>; <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>, key: string, value: string): MetricKey<Type>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKey",
      "path": [
        "src",
        "MetricKey.ts"
      ]
    },
    "project": "effect",
    "name": "taggedWithLabels",
    "description": "Returns a new `MetricKey` with the specified tags appended.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const taggedWithLabels: { (extraTags: ReadonlyArray<MetricLabel.MetricLabel>): <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>) => MetricKey<Type>; <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): MetricKey<Type>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricKey",
      "path": [
        "src",
        "MetricKey.ts"
      ]
    },
    "project": "effect",
    "name": "MetricKey",
    "description": "A `MetricKey` is a unique key associated with each metric. The key is based\non a combination of the metric type, the name and tags associated with the\nmetric, an optional description of the key, and any other information to\ndescribe a metric, such as the boundaries of a histogram. In this way, it is\nimpossible to ever create different metrics with conflicting keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricKey<out Type extends MetricKeyType.MetricKeyType<any, any>>\n  extends MetricKey.Variance<Type>, Equal.Equal, Pipeable\n{\n  readonly name: string\n  readonly keyType: Type\n  readonly description: Option.Option<string>\n  readonly tags: ReadonlyArray<MetricLabel.MetricLabel>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKey",
      "path": [
        "src",
        "MetricKey.ts"
      ]
    },
    "project": "effect",
    "name": "MetricKeyTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type MetricKeyTypeId = typeof MetricKeyTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "MetricKeyTypeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const MetricKeyTypeTypeId: typeof MetricKeyTypeTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "CounterKeyTypeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const CounterKeyTypeTypeId: typeof CounterKeyTypeTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "FrequencyKeyTypeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const FrequencyKeyTypeTypeId: typeof FrequencyKeyTypeTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "GaugeKeyTypeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const GaugeKeyTypeTypeId: typeof GaugeKeyTypeTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "HistogramKeyTypeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const HistogramKeyTypeTypeId: typeof HistogramKeyTypeTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "SummaryKeyTypeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const SummaryKeyTypeTypeId: typeof SummaryKeyTypeTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "counter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const counter: <A extends number | bigint>() => MetricKeyType.Counter<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "frequency",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const frequency: (options?: { readonly preregisteredWords?: ReadonlyArray<string> | undefined; } | undefined) => MetricKeyType.Frequency"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "gauge",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const gauge: <A extends number | bigint>() => MetricKeyType.Gauge<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "histogram",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const histogram: (boundaries: MetricBoundaries.MetricBoundaries) => MetricKeyType.Histogram"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "summary",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const summary: (options: { readonly maxAge: Duration.DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: ReadonlyArray<number>; }) => MetricKeyType.Summary"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "isMetricKeyType",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isMetricKeyType: (u: unknown) => u is MetricKeyType<unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "isCounterKey",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isCounterKey: (u: unknown) => u is MetricKeyType.Counter<number | bigint>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "isFrequencyKey",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isFrequencyKey: (u: unknown) => u is MetricKeyType.Frequency"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "isGaugeKey",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isGaugeKey: (u: unknown) => u is MetricKeyType.Gauge<number | bigint>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "isHistogramKey",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isHistogramKey: (u: unknown) => u is MetricKeyType.Histogram"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "isSummaryKey",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isSummaryKey: (u: unknown) => u is MetricKeyType.Summary"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "MetricKeyType",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "modelz",
    "signature": "export interface MetricKeyType<in In, out Out> extends MetricKeyType.Variance<In, Out>, Equal.Equal, Pipeable {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "CounterKeyTypeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type CounterKeyTypeTypeId = typeof CounterKeyTypeTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "FrequencyKeyTypeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type FrequencyKeyTypeTypeId = typeof FrequencyKeyTypeTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "GaugeKeyTypeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type GaugeKeyTypeTypeId = typeof GaugeKeyTypeTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "HistogramKeyTypeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type HistogramKeyTypeTypeId = typeof HistogramKeyTypeTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "MetricKeyTypeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type MetricKeyTypeTypeId = typeof MetricKeyTypeTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricKeyType",
      "path": [
        "src",
        "MetricKeyType.ts"
      ]
    },
    "project": "effect",
    "name": "SummaryKeyTypeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type SummaryKeyTypeTypeId = typeof SummaryKeyTypeTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricLabel",
      "path": [
        "src",
        "MetricLabel.ts"
      ]
    },
    "project": "effect",
    "name": "MetricLabelTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const MetricLabelTypeId: typeof MetricLabelTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricLabel",
      "path": [
        "src",
        "MetricLabel.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: (key: string, value: string) => MetricLabel"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricLabel",
      "path": [
        "src",
        "MetricLabel.ts"
      ]
    },
    "project": "effect",
    "name": "isMetricLabel",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isMetricLabel: (u: unknown) => u is MetricLabel"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricLabel",
      "path": [
        "src",
        "MetricLabel.ts"
      ]
    },
    "project": "effect",
    "name": "MetricLabel",
    "description": "A `MetricLabel` represents a key value pair that allows analyzing metrics at\nan additional level of granularity.\n\nFor example if a metric tracks the response time of a service labels could\nbe used to create separate versions that track response times for different\nclients.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricLabel extends Equal.Equal, Pipeable {\n  readonly [MetricLabelTypeId]: MetricLabelTypeId\n  readonly key: string\n  readonly value: string\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricLabel",
      "path": [
        "src",
        "MetricLabel.ts"
      ]
    },
    "project": "effect",
    "name": "MetricLabelTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type MetricLabelTypeId = typeof MetricLabelTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPair",
      "path": [
        "src",
        "MetricPair.ts"
      ]
    },
    "project": "effect",
    "name": "MetricPairTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const MetricPairTypeId: typeof MetricPairTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPair",
      "path": [
        "src",
        "MetricPair.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <Type extends MetricKeyType.MetricKeyType<any, any>>(metricKey: MetricKey.MetricKey<Type>, metricState: MetricState.MetricState<MetricKeyType.MetricKeyType.OutType<Type>>) => MetricPair.Untyped"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPair",
      "path": [
        "src",
        "MetricPair.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMake",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeMake: <Type extends MetricKeyType.MetricKeyType<any, any>>(metricKey: MetricKey.MetricKey<Type>, metricState: MetricState.MetricState.Untyped) => MetricPair.Untyped"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricPair",
      "path": [
        "src",
        "MetricPair.ts"
      ]
    },
    "project": "effect",
    "name": "MetricPair",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface MetricPair<out Type extends MetricKeyType.MetricKeyType<any, any>>\n  extends MetricPair.Variance<Type>, Pipeable\n{\n  readonly metricKey: MetricKey.MetricKey<Type>\n  readonly metricState: MetricState.MetricState<MetricKeyType.MetricKeyType.OutType<Type>>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricPair",
      "path": [
        "src",
        "MetricPair.ts"
      ]
    },
    "project": "effect",
    "name": "MetricPairTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type MetricPairTypeId = typeof MetricPairTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling",
      "path": [
        "src",
        "MetricPolling.ts"
      ]
    },
    "project": "effect",
    "name": "MetricPollingTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const MetricPollingTypeId: typeof MetricPollingTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling",
      "path": [
        "src",
        "MetricPolling.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new polling metric from a metric and poll effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <Type, In, Out, R, E>(metric: Metric.Metric<Type, In, Out>, poll: Effect.Effect<In, E, R>) => MetricPolling<Type, In, R, E, Out>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling",
      "path": [
        "src",
        "MetricPolling.ts"
      ]
    },
    "project": "effect",
    "name": "collectAll",
    "description": "Collects all of the polling metrics into a single polling metric, which\npolls for, updates, and produces the outputs of all individual metrics.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const collectAll: <R, E, Out>(iterable: Iterable<MetricPolling<any, any, R, E, Out>>) => MetricPolling<Array<any>, Array<any>, R, E, Array<Out>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling",
      "path": [
        "src",
        "MetricPolling.ts"
      ]
    },
    "project": "effect",
    "name": "launch",
    "description": "Returns an effect that will launch the polling metric in a background\nfiber, using the specified schedule.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const launch: { <A2, R2>(schedule: Schedule.Schedule<A2, unknown, R2>): <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<Fiber.Fiber<A2, E>, never, R2 | R | Scope.Scope>; <Type, In, R, E, Out, A2, R2>(self: MetricPolling<Type, In, R, E, Out>, schedule: Schedule.Schedule<A2, unknown, R2>): Effect.Effect<Fiber.Fiber<A2, E>, never, Scope.Scope | R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling",
      "path": [
        "src",
        "MetricPolling.ts"
      ]
    },
    "project": "effect",
    "name": "poll",
    "description": "An effect that polls a value that may be fed to the metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const poll: <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<In, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling",
      "path": [
        "src",
        "MetricPolling.ts"
      ]
    },
    "project": "effect",
    "name": "pollAndUpdate",
    "description": "An effect that polls for a value and uses the value to update the metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const pollAndUpdate: <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<void, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling",
      "path": [
        "src",
        "MetricPolling.ts"
      ]
    },
    "project": "effect",
    "name": "retry",
    "description": "Returns a new polling metric whose poll function will be retried with the\nspecified retry policy.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const retry: { <X, E, R2>(policy: Schedule.Schedule<X, NoInfer<E>, R2>): <Type, In, R, Out>(self: MetricPolling<Type, In, R, E, Out>) => MetricPolling<Type, In, R2 | R, E, Out>; <Type, In, R, E, Out, X, R2>(self: MetricPolling<Type, In, R, E, Out>, policy: Schedule.Schedule<X, E, R2>): MetricPolling<Type, In, R | R2, E, Out>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricPolling",
      "path": [
        "src",
        "MetricPolling.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Zips this polling metric with the specified polling metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const zip: { <Type2, In2, R2, E2, Out2>(that: MetricPolling<Type2, In2, R2, E2, Out2>): <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => MetricPolling<readonly [Type, Type2], readonly [In, In2], R2 | R, E2 | E, [Out, Out2]>; <Type, In, R, E, Out, Type2, In2, R2, E2, Out2>(self: MetricPolling<Type, In, R, E, Out>, that: MetricPolling<Type2, In2, R2, E2, Out2>): MetricPolling<readonly [Type, Type2], readonly [In, In2], R | R2, E | E2, [Out, Out2]>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricPolling",
      "path": [
        "src",
        "MetricPolling.ts"
      ]
    },
    "project": "effect",
    "name": "MetricPolling",
    "description": "A `MetricPolling` is a combination of a metric and an effect that polls for\nupdates to the metric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricPolling<in out Type, in out In, out R, out E, out Out> extends Pipeable {\n  readonly [MetricPollingTypeId]: MetricPollingTypeId\n  /**\n   * The metric that this `MetricPolling` polls to update.\n   */\n  readonly metric: Metric.Metric<Type, In, Out>\n  /**\n   * An effect that polls a value that may be fed to the metric.\n   */\n  readonly poll: Effect.Effect<In, E, R>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricPolling",
      "path": [
        "src",
        "MetricPolling.ts"
      ]
    },
    "project": "effect",
    "name": "MetricPollingTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type MetricPollingTypeId = typeof MetricPollingTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricRegistry",
      "path": [
        "src",
        "MetricRegistry.ts"
      ]
    },
    "project": "effect",
    "name": "MetricRegistryTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const MetricRegistryTypeId: typeof MetricRegistryTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricRegistry",
      "path": [
        "src",
        "MetricRegistry.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: (_: void) => MetricRegistry"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricRegistry",
      "path": [
        "src",
        "MetricRegistry.ts"
      ]
    },
    "project": "effect",
    "name": "MetricRegistry",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricRegistry {\n  readonly [MetricRegistryTypeId]: MetricRegistryTypeId\n  snapshot(): Array<MetricPair.MetricPair.Untyped>\n  get<Type extends MetricKeyType.MetricKeyType<any, any>>(\n    key: MetricKey.MetricKey<Type>\n  ): MetricHook.MetricHook<\n    MetricKeyType.MetricKeyType.InType<typeof key[\"keyType\"]>,\n    MetricKeyType.MetricKeyType.OutType<typeof key[\"keyType\"]>\n  >\n  getCounter<A extends (number | bigint)>(\n    key: MetricKey.MetricKey.Counter<A>\n  ): MetricHook.MetricHook.Counter<A>\n  getFrequency(key: MetricKey.MetricKey.Frequency): MetricHook.MetricHook.Frequency\n  getGauge<A extends (number | bigint)>(key: MetricKey.MetricKey.Gauge<A>): MetricHook.MetricHook.Gauge<A>\n  getHistogram(key: MetricKey.MetricKey.Histogram): MetricHook.MetricHook.Histogram\n  getSummary(key: MetricKey.MetricKey.Summary): MetricHook.MetricHook.Summary\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricRegistry",
      "path": [
        "src",
        "MetricRegistry.ts"
      ]
    },
    "project": "effect",
    "name": "MetricRegistryTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type MetricRegistryTypeId = typeof MetricRegistryTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "MetricStateTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const MetricStateTypeId: typeof MetricStateTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "CounterStateTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const CounterStateTypeId: typeof CounterStateTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "FrequencyStateTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const FrequencyStateTypeId: typeof FrequencyStateTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "GaugeStateTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const GaugeStateTypeId: typeof GaugeStateTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "HistogramStateTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const HistogramStateTypeId: typeof HistogramStateTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "SummaryStateTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const SummaryStateTypeId: typeof SummaryStateTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "counter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const counter: { (count: number): MetricState.Counter<number>; (count: bigint): MetricState.Counter<bigint>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "frequency",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const frequency: (occurrences: ReadonlyMap<string, number>) => MetricState.Frequency"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "gauge",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const gauge: { (count: number): MetricState.Gauge<number>; (count: bigint): MetricState.Gauge<bigint>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "histogram",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const histogram: (options: { readonly buckets: ReadonlyArray<readonly [number, number]>; readonly count: number; readonly min: number; readonly max: number; readonly sum: number; }) => MetricState.Histogram"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "summary",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const summary: (options: { readonly error: number; readonly quantiles: ReadonlyArray<readonly [number, Option.Option<number>]>; readonly count: number; readonly min: number; readonly max: number; readonly sum: number; }) => MetricState.Summary"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "isMetricState",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isMetricState: (u: unknown) => u is MetricState.Counter<number | bigint>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "isCounterState",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isCounterState: (u: unknown) => u is MetricState.Counter<number | bigint>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "isFrequencyState",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isFrequencyState: (u: unknown) => u is MetricState.Frequency"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "isGaugeState",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isGaugeState: (u: unknown) => u is MetricState.Gauge<number | bigint>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "isHistogramState",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isHistogramState: (u: unknown) => u is MetricState.Histogram"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "isSummaryState",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isSummaryState: (u: unknown) => u is MetricState.Summary"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "MetricState",
    "description": "A `MetricState` describes the state of a metric. The type parameter of a\nmetric state corresponds to the type of the metric key (`MetricStateType`).\nThis phantom type parameter is used to tie keys to their expected states.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MetricState<in A> extends MetricState.Variance<A>, Equal.Equal, Pipeable {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "CounterStateTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type CounterStateTypeId = typeof CounterStateTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "FrequencyStateTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type FrequencyStateTypeId = typeof FrequencyStateTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "GaugeStateTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type GaugeStateTypeId = typeof GaugeStateTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "HistogramStateTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type HistogramStateTypeId = typeof HistogramStateTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "MetricStateTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type MetricStateTypeId = typeof MetricStateTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MetricState",
      "path": [
        "src",
        "MetricState.ts"
      ]
    },
    "project": "effect",
    "name": "SummaryStateTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type SummaryStateTypeId = typeof SummaryStateTypeId"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "CurrentConcurrency",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "environment refs",
    "signature": "export declare class CurrentConcurrency"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "CurrentScheduler",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "environment refs",
    "signature": "export declare class CurrentScheduler"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MaxOpsBeforeYield",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "references",
    "signature": "export declare class MaxOpsBeforeYield"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroSchedulerDefault",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.5.9",
    "category": "scheduler",
    "signature": "export declare class MicroSchedulerDefault"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "NoSuchElementException",
    "description": "Represents a checked exception which occurs when an expected element was\nunable to be found.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.4",
    "category": "errors",
    "signature": "export declare class NoSuchElementException"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "TimeoutException",
    "description": "Represents a checked exception which occurs when a timeout occurs.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.4",
    "category": "errors",
    "signature": "export declare class TimeoutException"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "type ids",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroExitTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "MicroExit",
    "signature": "export declare const MicroExitTypeId: typeof MicroExitTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroCauseTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "export declare const MicroCauseTypeId: typeof MicroCauseTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "causeWithTrace",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "export declare const causeWithTrace: { (trace: string): <E>(self: MicroCause<E>) => MicroCause<E>; <E>(self: MicroCause<E>, trace: string): MicroCause<E>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroFiberTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroFiber",
    "signature": "export declare const MicroFiberTypeId: typeof MicroFiberTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": "Creates a `Micro` effect that will succeed with the specified constant value.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "export declare const succeed: <A>(value: A) => Micro<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "failCause",
    "description": "Creates a `Micro` effect that will fail with the specified `MicroCause`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "constructors",
    "signature": "export declare const failCause: <E>(cause: MicroCause<E>) => Micro<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "sync",
    "description": "Creates a `Micro` effect that succeeds with a lazily evaluated value.\n\nIf the evaluation of the value throws an error, the effect will fail with a\n`Die` variant of the `MicroCause` type.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "export declare const sync: <A>(evaluate: LazyArg<A>) => Micro<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "suspend",
    "description": "Lazily creates a `Micro` effect from the given side-effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "export declare const suspend: <A, E, R>(evaluate: LazyArg<Micro<A, E, R>>) => Micro<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "yieldNowWith",
    "description": "Pause the execution of the current `Micro` effect, and resume it on the next\nscheduler tick.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "export declare const yieldNowWith: (priority?: number) => Micro<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "yieldNow",
    "description": "Pause the execution of the current `Micro` effect, and resume it on the next\nscheduler tick.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "export declare const yieldNow: Micro<void, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "succeedNone",
    "description": "Creates a `Micro` effect that succeeds with `None`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "export declare const succeedNone: Micro<Option.Option<never>, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "withMicroFiber",
    "description": "Create a `Micro` effect using the current `MicroFiber`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "export declare const withMicroFiber: <A, E = never, R = never>(evaluate: (fiber: MicroFiberImpl<A, E>) => Micro<A, E, R>) => Micro<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "yieldFlush",
    "description": "Flush any yielded effects that are waiting to be executed.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "export declare const yieldFlush: Micro<void, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "never",
    "description": "A `Micro` that will never succeed or fail. It wraps `setInterval` to prevent\nthe Javascript runtime from exiting.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "export declare const never: Micro<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "as",
    "description": "Create a `Micro` effect that will replace the success value of the given\neffect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "export declare const as: { <A, B>(value: B): <E, R>(self: Micro<A, E, R>) => Micro<B, E, R>; <A, E, R, B>(self: Micro<A, E, R>, value: B): Micro<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "andThen",
    "description": "A more flexible version of `flatMap` that combines `map` and `flatMap` into a\nsingle API.\n\nIt also lets you directly pass a `Micro` effect, which will be executed after\nthe current effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "export declare const andThen: { <A, X>(f: (a: A) => X): <E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: (a: A) => X): [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: NotFunction<X>): [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "tap",
    "description": "Execute a side effect from the success value of the `Micro` effect.\n\nIt is similar to the `andThen` api, but the success value is ignored.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "export declare const tap: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: NotFunction<X>): [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "race",
    "description": "Returns an effect that races two effects, yielding the value of the first\neffect to succeed. Losers of the race will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "sequencing",
    "signature": "export declare const race: { <A2, E2, R2>(that: Micro<A2, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "raceFirst",
    "description": "Returns an effect that races two effects, yielding the value of the first\neffect to succeed *or* fail. Losers of the race will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "sequencing",
    "signature": "export declare const raceFirst: { <A2, E2, R2>(that: Micro<A2, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Map the success value of this `Micro` effect to another `Micro` effect, then\nflatten the result.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "export declare const flatMap: { <A, B, E2, R2>(f: (a: A) => Micro<B, E2, R2>): <E, R>(self: Micro<A, E, R>) => Micro<B, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (a: A) => Micro<B, E2, R2>): Micro<B, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms the success value of the `Micro` effect with the specified\nfunction.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": "export declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Micro<A, E, R>) => Micro<B, E, R>; <A, E, R, B>(self: Micro<A, E, R>, f: (a: A) => B): Micro<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "exitSucceed",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "export declare const exitSucceed: <A>(a: A) => MicroExit<A, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "exitFailCause",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "export declare const exitFailCause: <E>(cause: MicroCause<E>) => MicroExit<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "exitInterrupt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "export declare const exitInterrupt: MicroExit<never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "exitVoid",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "export declare const exitVoid: MicroExit<void, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "service",
    "description": "Access the given `Context.Tag` from the environment.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "environment",
    "signature": "export declare const service: { <I, S>(tag: Context.Reference<I, S>): Micro<S>; <I, S>(tag: Context.Tag<I, S>): Micro<S, never, I>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "updateContext",
    "description": "Update the Context with the given mapping function.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "environment",
    "signature": "export declare const updateContext: { <R2, R>(f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>): <A, E>(self: Micro<A, E, R>) => Micro<A, E, R2>; <A, E, R, R2>(self: Micro<A, E, R>, f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>): Micro<A, E, R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "updateService",
    "description": "Update the service for the given `Context.Tag` in the environment.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "environment",
    "signature": "export declare const updateService: { <I, A>(tag: Context.Reference<I, A>, f: (value: A) => A): <XA, E, R>(self: Micro<XA, E, R>) => Micro<XA, E, R>; <I, A>(tag: Context.Tag<I, A>, f: (value: A) => A): <XA, E, R>(self: Micro<XA, E, R>) => Micro<XA, E, R | I>; <XA, E, R, I, A>(self: Micro<XA, E, R>, tag: Context.Reference<I, A>, f: (value: A) => A): Micro<XA, E, R>; <XA, E, R, I, A>(self: Micro<XA, E, R>, tag: Context.Tag<I, A>, f: (value: A) => A): Micro<XA, E, R | I>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "provideContext",
    "description": "Merge the given `Context` with the current context.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "environment",
    "signature": "export declare const provideContext: { <XR>(context: Context.Context<XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, XR>>; <A, E, R, XR>(self: Micro<A, E, R>, context: Context.Context<XR>): Micro<A, E, Exclude<R, XR>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "provideService",
    "description": "Add the provided service to the current context.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "environment",
    "signature": "export declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: S): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Micro<A, E, R>, tag: Context.Tag<I, S>, service: S): Micro<A, E, Exclude<R, I>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "provideServiceEffect",
    "description": "Create a service using the provided `Micro` effect, and add it to the\ncurrent context.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "environment",
    "signature": "export declare const provideServiceEffect: { <I, S, E2, R2>(tag: Context.Tag<I, S>, acquire: Micro<S, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | E2, Exclude<R, I> | R2>; <A, E, R, I, S, E2, R2>(self: Micro<A, E, R>, tag: Context.Tag<I, S>, acquire: Micro<S, E2, R2>): Micro<A, E | E2, Exclude<R, I> | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "withConcurrency",
    "description": "If you have a `Micro` that uses `concurrency: \"inherit\"`, you can use this\napi to control the concurrency of that `Micro` when it is run.",
    "deprecated": false,
    "examples": [
      "import * as Micro from \"effect/Micro\"\n\nMicro.forEach([1, 2, 3], (n) => Micro.succeed(n), {\n  concurrency: \"inherit\"\n}).pipe(\n  Micro.withConcurrency(2) // use a concurrency of 2\n)"
    ],
    "since": "3.4.0",
    "category": "environment refs",
    "signature": "export declare const withConcurrency: { (concurrency: \"unbounded\" | number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, concurrency: \"unbounded\" | number): Micro<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Combine two `Micro` effects into a single effect that produces a tuple of\ntheir results.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "zipping",
    "signature": "export declare const zip: { <A2, E2, R2>(that: Micro<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, E, R>(self: Micro<A, E, R>) => Micro<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; }): Micro<[A, A2], E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": "The `Micro.zipWith` function combines two `Micro` effects and allows you to\napply a function to the results of the combined effects, transforming them\ninto a single value.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.3",
    "category": "zipping",
    "signature": "export declare const zipWith: { <A2, E2, R2, A, B>(that: Micro<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; }): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, B>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; }): Micro<B, E2 | E, R2 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "filterOrFailCause",
    "description": "Filter the specified effect with the provided function, failing with specified\n`MicroCause` if the predicate fails.\n\nIn addition to the filtering capabilities discussed earlier, you have the option to further\nrefine and narrow down the type of the success channel by providing a",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "filtering & conditionals",
    "signature": "export declare const filterOrFailCause: { <A, B extends A, E2>(refinement: Refinement<A, B>, orFailWith: (a: NoInfer<A>) => MicroCause<E2>): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => MicroCause<E2>): <E, R>(self: Micro<A, E, R>) => Micro<A, E2 | E, R>; <A, E, R, B extends A, E2>(self: Micro<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => MicroCause<E2>): Micro<B, E | E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => MicroCause<E2>): Micro<A, E | E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "filterOrFail",
    "description": "Filter the specified effect with the provided function, failing with specified\nerror if the predicate fails.\n\nIn addition to the filtering capabilities discussed earlier, you have the option to further\nrefine and narrow down the type of the success channel by providing a",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "filtering & conditionals",
    "signature": "export declare const filterOrFail: { <A, B extends A, E2>(refinement: Refinement<A, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Micro<A, E, R>) => Micro<A, E2 | E, R>; <A, E, R, B extends A, E2>(self: Micro<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): Micro<B, E | E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Micro<A, E | E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "when",
    "description": "The moral equivalent of `if (p) exp`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "filtering & conditionals",
    "signature": "export declare const when: { <E2 = never, R2 = never>(condition: LazyArg<boolean> | Micro<boolean, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E | E2, R | R2>; <A, E, R, E2 = never, R2 = never>(self: Micro<A, E, R>, condition: LazyArg<boolean> | Micro<boolean, E2, R2>): Micro<Option.Option<A>, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "repeatExit",
    "description": "Repeat the given `Micro` using the provided options.\n\nThe `while` predicate will be checked after each iteration, and can use the\nfall `MicroExit` of the effect to determine if the repetition should continue.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "repetition",
    "signature": "export declare const repeatExit: { <A, E>(options: { while: Predicate<MicroExit<A, E>>; times?: number | undefined; schedule?: MicroSchedule | undefined; }): <R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, options: { while: Predicate<MicroExit<A, E>>; times?: number | undefined; schedule?: MicroSchedule | undefined; }): Micro<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "repeat",
    "description": "Repeat the given `Micro` effect using the provided options. Only successful\nresults will be repeated.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "repetition",
    "signature": "export declare const repeat: { <A, E>(options?: { while?: Predicate<A> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined; } | undefined): <R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, options?: { while?: Predicate<A> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined; } | undefined): Micro<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "replicate",
    "description": "Replicates the given effect `n` times.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "repetition",
    "signature": "export declare const replicate: { (n: number): <A, E, R>(self: Micro<A, E, R>) => Array<Micro<A, E, R>>; <A, E, R>(self: Micro<A, E, R>, n: number): Array<Micro<A, E, R>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "replicateEffect",
    "description": "Performs this effect the specified number of times and collects the\nresults.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "repetition",
    "signature": "export declare const replicateEffect: { (n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined; }): <A, E, R>(self: Micro<A, E, R>) => Micro<Array<A>, E, R>; (n: number, options: { readonly concurrency?: Concurrency | undefined; readonly discard: true; }): <A, E, R>(self: Micro<A, E, R>) => Micro<void, E, R>; <A, E, R>(self: Micro<A, E, R>, n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined; }): Micro<Array<A>, E, R>; <A, E, R>(self: Micro<A, E, R>, n: number, options: { readonly concurrency?: Concurrency | undefined; readonly discard: true; }): Micro<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "scheduleAddDelay",
    "description": "Returns a new `MicroSchedule` with an added calculated delay to each delay\nreturned by this schedule.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "export declare const scheduleAddDelay: { (f: () => number): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, f: () => number): MicroSchedule; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "scheduleWithMaxDelay",
    "description": "Transform a `MicroSchedule` to one that will have a delay that will never exceed\nthe specified maximum.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "export declare const scheduleWithMaxDelay: { (max: number): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, max: number): MicroSchedule; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "scheduleWithMaxElapsed",
    "description": "Transform a `MicroSchedule` to one that will stop repeating after the specified\namount of time.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "export declare const scheduleWithMaxElapsed: { (max: number): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, max: number): MicroSchedule; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "scheduleUnion",
    "description": "Combines two `MicroSchedule`s, by recurring if either schedule wants to\nrecur, using the minimum of the two durations between recurrences.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "export declare const scheduleUnion: { (that: MicroSchedule): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, that: MicroSchedule): MicroSchedule; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "scheduleIntersect",
    "description": "Combines two `MicroSchedule`s, by recurring only if both schedules want to\nrecur, using the maximum of the two durations between recurrences.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "export declare const scheduleIntersect: { (that: MicroSchedule): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, that: MicroSchedule): MicroSchedule; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "catchAllCause",
    "description": "Catch the full `MicroCause` object of the given `Micro` effect, allowing you to\nrecover from any kind of cause.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "export declare const catchAllCause: { <E, B, E2, R2>(f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A | B, E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "catchCauseIf",
    "description": "Selectively catch a `MicroCause` object of the given `Micro` effect,\nusing the provided predicate to determine if the failure should be caught.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "export declare const catchCauseIf: { <E, B, E2, R2, EB extends MicroCause<E>>(refinement: Refinement<MicroCause<E>, EB>, f: (cause: EB) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, Exclude<E, MicroCause.Error<EB>> | E2, R | R2>; <E, B, E2, R2>(predicate: Predicate<MicroCause<NoInfer<E>>>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E | E2, R | R2>; <A, E, R, B, E2, R2, EB extends MicroCause<E>>(self: Micro<A, E, R>, refinement: Refinement<MicroCause<E>, EB>, f: (cause: EB) => Micro<B, E2, R2>): Micro<A | B, Exclude<E, MicroCause.Error<EB>> | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, predicate: Predicate<MicroCause<NoInfer<E>>>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A | B, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "catchAll",
    "description": "Catch the error of the given `Micro` effect, allowing you to recover from it.\n\nIt only catches expected errors.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "export declare const catchAll: { <E, B, E2, R2>(f: (e: NoInfer<E>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (e: NoInfer<E>) => Micro<B, E2, R2>): Micro<A | B, E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "catchAllDefect",
    "description": "Catch any unexpected errors of the given `Micro` effect, allowing you to recover from them.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "export declare const catchAllDefect: { <E, B, E2, R2>(f: (defect: unknown) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A | B, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "tapErrorCause",
    "description": "Perform a side effect using the full `MicroCause` object of the given `Micro`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "export declare const tapErrorCause: { <E, B, E2, R2>(f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "tapErrorCauseIf",
    "description": "Perform a side effect using if a `MicroCause` object matches the specified\npredicate.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "export declare const tapErrorCauseIf: { <E, B, E2, R2, EB extends MicroCause<E>>(refinement: Refinement<MicroCause<E>, EB>, f: (a: EB) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <E, B, E2, R2>(predicate: (cause: NoInfer<MicroCause<E>>) => boolean, f: (a: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2, EB extends MicroCause<E>>(self: Micro<A, E, R>, refinement: Refinement<MicroCause<E>, EB>, f: (a: EB) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, predicate: (cause: NoInfer<MicroCause<E>>) => boolean, f: (a: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "tapError",
    "description": "Perform a side effect from expected errors of the given `Micro`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "export declare const tapError: { <E, B, E2, R2>(f: (e: NoInfer<E>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (e: NoInfer<E>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "tapDefect",
    "description": "Perform a side effect from unexpected errors of the given `Micro`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "export declare const tapDefect: { <E, B, E2, R2>(f: (defect: unknown) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "catchIf",
    "description": "Catch any expected errors that match the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "export declare const catchIf: { <E, EB extends E, A2, E2, R2>(refinement: Refinement<NoInfer<E>, EB>, f: (e: EB) => Micro<A2, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A2 | A, E2 | Exclude<E, EB>, R2 | R>; <E, A2, E2, R2>(predicate: Predicate<NoInfer<E>>, f: (e: NoInfer<E>) => Micro<A2, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A2 | A, E | E2, R2 | R>; <A, E, R, EB extends E, A2, E2, R2>(self: Micro<A, E, R>, refinement: Refinement<E, EB>, f: (e: EB) => Micro<A2, E2, R2>): Micro<A | A2, E2 | Exclude<E, EB>, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, predicate: Predicate<E>, f: (e: E) => Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "catchTag",
    "description": "Recovers from the specified tagged error.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "export declare const catchTag: { <K extends E extends { _tag: string; } ? E[\"_tag\"] : never, E, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => Micro<A1, E1, R1>): <A, R>(self: Micro<A, E, R>) => Micro<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E[\"_tag\"] : never, R1, E1, A1>(self: Micro<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Micro<A1, E1, R1>): Micro<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "mapErrorCause",
    "description": "Transform the full `MicroCause` object of the given `Micro` effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "error handling",
    "signature": "export declare const mapErrorCause: { <E, E2>(f: (e: MicroCause<E>) => MicroCause<E2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, f: (e: MicroCause<E>) => MicroCause<E2>): Micro<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "mapError",
    "description": "Transform any expected errors of the given `Micro` effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "export declare const mapError: { <E, E2>(f: (e: E) => E2): <A, R>(self: Micro<A, E, R>) => Micro<A, E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, f: (e: E) => E2): Micro<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "orElseSucceed",
    "description": "Recover from all errors by succeeding with the given value.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "export declare const orElseSucceed: { <B>(f: LazyArg<B>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | B, never, R>; <A, E, R, B>(self: Micro<A, E, R>, f: LazyArg<B>): Micro<A | B, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "retry",
    "description": "Retry the given `Micro` effect using the provided options.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "export declare const retry: { <A, E>(options?: { while?: Predicate<E> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined; } | undefined): <R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, options?: { while?: Predicate<E> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined; } | undefined): Micro<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "withTrace",
    "description": "Add a stack trace to any failures that occur in the effect. The trace will be\nadded to the `traces` field of the `MicroCause` object.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": "export declare const withTrace: { (name: string): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, name: string): Micro<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "matchCauseEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "pattern matching",
    "signature": "export declare const matchCauseEffect: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: MicroCause<E>) => Micro<A2, E2, R2>; readonly onSuccess: (a: A) => Micro<A3, E3, R3>; }): <R>(self: Micro<A, E, R>) => Micro<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Micro<A, E, R>, options: { readonly onFailure: (cause: MicroCause<E>) => Micro<A2, E2, R2>; readonly onSuccess: (a: A) => Micro<A3, E3, R3>; }): Micro<A2 | A3, E2 | E3, R2 | R3 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "matchCause",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "pattern matching",
    "signature": "export declare const matchCause: { <E, A2, A, A3>(options: { readonly onFailure: (cause: MicroCause<E>) => A2; readonly onSuccess: (a: A) => A3; }): <R>(self: Micro<A, E, R>) => Micro<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Micro<A, E, R>, options: { readonly onFailure: (cause: MicroCause<E>) => A2; readonly onSuccess: (a: A) => A3; }): Micro<A2 | A3, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "matchEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "pattern matching",
    "signature": "export declare const matchEffect: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (e: E) => Micro<A2, E2, R2>; readonly onSuccess: (a: A) => Micro<A3, E3, R3>; }): <R>(self: Micro<A, E, R>) => Micro<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Micro<A, E, R>, options: { readonly onFailure: (e: E) => Micro<A2, E2, R2>; readonly onSuccess: (a: A) => Micro<A3, E3, R3>; }): Micro<A2 | A3, E2 | E3, R2 | R3 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "pattern matching",
    "signature": "export declare const match: { <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: Micro<A, E, R>) => Micro<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Micro<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): Micro<A2 | A3, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "delay",
    "description": "Returns an effect that will delay the execution of this effect by the\nspecified duration.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "delays & timeouts",
    "signature": "export declare const delay: { (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "timeoutOrElse",
    "description": "Returns an effect that will timeout this effect, that will execute the\nfallback effect if the timeout elapses before the effect has produced a value.\n\nIf the timeout elapses, the running effect will be safely interrupted.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "delays & timeouts",
    "signature": "export declare const timeoutOrElse: { <A2, E2, R2>(options: { readonly duration: number; readonly onTimeout: LazyArg<Micro<A2, E2, R2>>; }): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, options: { readonly duration: number; readonly onTimeout: LazyArg<Micro<A2, E2, R2>>; }): Micro<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "timeout",
    "description": "Returns an effect that will timeout this effect, that will fail with a\n`TimeoutException` if the timeout elapses before the effect has produced a\nvalue.\n\nIf the timeout elapses, the running effect will be safely interrupted.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "delays & timeouts",
    "signature": "export declare const timeout: { (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | TimeoutException, R>; <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E | TimeoutException, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "timeoutOption",
    "description": "Returns an effect that will timeout this effect, succeeding with a `None`\nif the timeout elapses before the effect has produced a value; and `Some` of\nthe produced value otherwise.\n\nIf the timeout elapses, the running effect will be safely interrupted.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "delays & timeouts",
    "signature": "export declare const timeoutOption: { (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E, R>; <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<Option.Option<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroScopeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "export declare const MicroScopeTypeId: typeof MicroScopeTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroScope",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "export declare const MicroScope: Context.Tag<MicroScope, MicroScope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "scopeMake",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "export declare const scopeMake: Micro<MicroScope.Closeable, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "scope",
    "description": "Access the current `MicroScope`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "export declare const scope: Micro<MicroScope, never, MicroScope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "provideScope",
    "description": "Provide a `MicroScope` to an effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "export declare const provideScope: { (scope: MicroScope): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, MicroScope>>; <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<A, E, Exclude<R, MicroScope>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "onExit",
    "description": "When the `Micro` effect is completed, run the given finalizer effect with the\n`MicroExit` of the executed effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "resources & finalization",
    "signature": "export declare const onExit: { <A, E, XE, XR>(f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "ensuring",
    "description": "Regardless of the result of the this `Micro` effect, run the finalizer effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "export declare const ensuring: { <XE, XR>(finalizer: Micro<void, XE, XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "onExitIf",
    "description": "When the `Micro` effect is completed, run the given finalizer effect if it\nmatches the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "resources & finalization",
    "signature": "export declare const onExitIf: { <A, E, XE, XR, B extends MicroExit<A, E>>(refinement: Refinement<MicroExit<A, E>, B>, f: (exit: B) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, XE, XR>(predicate: Predicate<MicroExit<NoInfer<A>, NoInfer<E>>>, f: (exit: MicroExit<NoInfer<A>, NoInfer<E>>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR, B extends MicroExit<A, E>>(self: Micro<A, E, R>, refinement: Refinement<MicroExit<A, E>, B>, f: (exit: B) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, predicate: Predicate<MicroExit<NoInfer<A>, NoInfer<E>>>, f: (exit: MicroExit<NoInfer<A>, NoInfer<E>>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "onError",
    "description": "When the `Micro` effect fails, run the given finalizer effect with the\n`MicroCause` of the executed effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "resources & finalization",
    "signature": "export declare const onError: { <A, E, XE, XR>(f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "onInterrupt",
    "description": "If this `Micro` effect is aborted, run the finalizer effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "resources & finalization",
    "signature": "export declare const onInterrupt: { <XE, XR>(finalizer: Micro<void, XE, XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "interrupt",
    "description": "Abort the current `Micro` effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "interruption",
    "signature": "export declare const interrupt: Micro<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "whileLoop",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "collecting & elements",
    "signature": "export declare const whileLoop: <A, E, R>(options: { readonly while: LazyArg<boolean>; readonly body: LazyArg<Micro<A, E, R>>; readonly step: (a: A) => void; }) => Micro<void, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "Do",
    "description": "Start a do notation block.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "do notation",
    "signature": "export declare const Do: Micro<{}, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "bindTo",
    "description": "Bind the success value of this `Micro` effect to the provided name.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "do notation",
    "signature": "export declare const bindTo: { <N extends string>(name: N): <A, E, R>(self: Micro<A, E, R>) => Micro<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Micro<A, E, R>, name: N): Micro<{ [K in N]: A; }, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "bind",
    "description": "Bind the success value of this `Micro` effect to the provided name.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "do notation",
    "signature": "export declare const bind: { <N extends string, A extends Record<string, any>, B, E2, R2>(name: N, f: (a: NoInfer<A>) => Micro<B, E2, R2>): <E, R>(self: Micro<A, E, R>) => Micro<Simplify<Omit<A, N> & { [K in N]: B; }>, E | E2, R | R2>; <A extends Record<string, any>, E, R, B, E2, R2, N extends string>(self: Micro<A, E, R>, name: N, f: (a: NoInfer<A>) => Micro<B, E2, R2>): Micro<Simplify<Omit<A, N> & { [K in N]: B; }>, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "forkIn",
    "description": "Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\naborted.\n\nThe lifetime of the handle will be attached to the provided `MicroScope`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "fiber & forking",
    "signature": "export declare const forkIn: { (scope: MicroScope): <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>; <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<MicroFiber<A, E>, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "Error",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "errors",
    "signature": "export declare const Error: new <A extends Record<string, any> = {}>(args: Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P]; }) => YieldableError & Readonly<A>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "void",
    "description": "A `Micro` effect that will succeed with `void` (`undefined`).",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "export declare const void: Micro<void, never, never>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "try",
    "description": "The `Micro` equivalent of a try / catch block, which allows you to map\nthrown errors to a specific error type.",
    "deprecated": false,
    "examples": [
      "import { Micro } from \"effect\"\n\nMicro.try({\n  try: () => throw new Error(\"boom\"),\n  catch: (cause) => new Error(\"caught\", { cause })\n})"
    ],
    "since": "3.4.0",
    "category": "constructors",
    "signature": "export declare const try: <A, E>(options: { try: LazyArg<A>; catch: (error: unknown) => E; }) => Micro<A, E>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "let",
    "description": "Bind the result of a synchronous computation to the given name.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "do notation",
    "signature": "export declare const let: { <N extends string, A extends Record<string, any>, B>(name: N, f: (a: NoInfer<A>) => B): <E, R>(self: Micro<A, E, R>) => Micro<Simplify<Omit<A, N> & { [K in N]: B; }>, E, R>; <A extends Record<string, any>, E, R, B, N extends string>(self: Micro<A, E, R>, name: N, f: (a: NoInfer<A>) => B): Micro<Simplify<Omit<A, N> & { [K in N]: B; }>, E, R>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "isMicro",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "isMicroCause",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.6",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "causeFail",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "causeDie",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "causeInterrupt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "causeIsFail",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "causeIsDie",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "causeIsInterrupt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "causeSquash",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "fiberAwait",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroFiber",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "fiberJoin",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.2",
    "category": "MicroFiber",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "fiberInterrupt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroFiber",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "fiberInterruptAll",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroFiber",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": "Creates a `Micro` effect that fails with the given error.\n\nThis results in a `Fail` variant of the `MicroCause` type, where the error is\ntracked at the type level.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "succeedSome",
    "description": "Creates a `Micro` effect that will succeed with the value wrapped in `Some`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "failCauseSync",
    "description": "Creates a `Micro` effect that will fail with the lazily evaluated `MicroCause`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "die",
    "description": "Creates a `Micro` effect that will die with the specified error.\n\nThis results in a `Die` variant of the `MicroCause` type, where the error is\nnot tracked at the type level.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "failSync",
    "description": "Creates a `Micro` effect that will fail with the lazily evaluated error.\n\nThis results in a `Fail` variant of the `MicroCause` type, where the error is\ntracked at the type level.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "fromOption",
    "description": "Converts an `Option` into a `Micro` effect, that will fail with\n`NoSuchElementException` if the option is `None`. Otherwise, it will succeed with the\nvalue of the option.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "fromEither",
    "description": "Converts an `Either` into a `Micro` effect, that will fail with the left side\nof the either if it is a `Left`. Otherwise, it will succeed with the right\nside of the either.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "promise",
    "description": "Wrap a `Promise` into a `Micro` effect.\n\nAny errors will result in a `Die` variant of the `MicroCause` type, where the\nerror is not tracked at the type level.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "tryPromise",
    "description": "Wrap a `Promise` into a `Micro` effect. Any errors will be caught and\nconverted into a specific error type.",
    "deprecated": false,
    "examples": [
      "import { Micro } from \"effect\"\n\nMicro.tryPromise({\n  try: () => Promise.resolve(\"success\"),\n  catch: (cause) => new Error(\"caught\", { cause })\n})"
    ],
    "since": "3.4.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "async",
    "description": "Create a `Micro` effect from an asynchronous computation.\n\nYou can return a cleanup effect that will be run when the effect is aborted.\nIt is also passed an `AbortSignal` that is triggered when the effect is\naborted.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "gen",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "asSome",
    "description": "Wrap the success value of this `Micro` effect in a `Some`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "flip",
    "description": "Swap the error and success types of the `Micro` effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "asVoid",
    "description": "Replace the success value of the `Micro` effect with `void`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "exit",
    "description": "Access the `MicroExit` of the given `Micro` effect.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "mapping & sequencing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "sandbox",
    "description": "Replace the error type of the given `Micro` with the full `MicroCause` object.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "raceAll",
    "description": "Returns an effect that races all the specified effects,\nyielding the value of the first effect to succeed with a value. Losers of\nthe race will be interrupted immediately",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "sequencing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "raceAllFirst",
    "description": "Returns an effect that races all the specified effects,\nyielding the value of the first effect to succeed or fail. Losers of\nthe race will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "sequencing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens any nested `Micro` effects, merging the error and requirement types.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "mapping & sequencing",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "isMicroExit",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "exitFail",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "exitDie",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "exitIsSuccess",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "exitIsFailure",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "exitIsInterrupt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "exitIsFail",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "exitIsDie",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "exitVoidAll",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroExit",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "serviceOption",
    "description": "Access the given `Context.Tag` from the environment, without tracking the\ndependency at the type level.\n\nIt will return an `Option` of the service, depending on whether it is\navailable in the environment or not.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "environment",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "context",
    "description": "Access the current `Context` from the environment.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "environment",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "forever",
    "description": "Repeat the given `Micro` effect forever, only stopping if the effect fails.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "repetition",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "scheduleRecurs",
    "description": "Create a `MicroSchedule` that will stop repeating after the specified number\nof attempts.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "scheduleSpaced",
    "description": "Create a `MicroSchedule` that will generate a constant delay.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "scheduleExponential",
    "description": "Create a `MicroSchedule` that will generate a delay with an exponential backoff.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "orDie",
    "description": "Elevate any expected errors of the given `Micro` effect to unexpected errors,\nresulting in an error type of `never`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "ignore",
    "description": "Ignore any expected errors of the given `Micro` effect, returning `void`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "ignoreLogged",
    "description": "Ignore any expected errors of the given `Micro` effect, returning `void`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "option",
    "description": "Replace the success value of the given `Micro` effect with an `Option`,\nwrapping the success value in `Some` and returning `None` if the effect fails\nwith an expected error.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "either",
    "description": "Replace the success value of the given `Micro` effect with an `Either`,\nwrapping the success value in `Right` and wrapping any expected errors with\na `Left`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "error handling",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "sleep",
    "description": "Create a `Micro` effect that will sleep for the specified duration.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "delays & timeouts",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "scopeUnsafeMake",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "scoped",
    "description": "Provide a `MicroScope` to the given effect, closing it after the effect has\nfinished executing.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "acquireRelease",
    "description": "Create a resource with a cleanup `Micro` effect, ensuring the cleanup is\nexecuted when the `MicroScope` is closed.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "addFinalizer",
    "description": "Add a finalizer to the current `MicroScope`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "acquireUseRelease",
    "description": "Acquire a resource, use it, and then release the resource when the `use`\neffect has completed.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "uninterruptible",
    "description": "Flag the effect as uninterruptible, which means that when the effect is\ninterrupted, it will be allowed to continue running until completion.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "flags",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "interruptible",
    "description": "Flag the effect as interruptible, which means that when the effect is\ninterrupted, it will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "flags",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "uninterruptibleMask",
    "description": "Wrap the given `Micro` effect in an uninterruptible region, preventing the\neffect from being aborted.\n\nYou can use the `restore` function to restore a `Micro` effect to the\ninterruptibility state before the `uninterruptibleMask` was applied.",
    "deprecated": false,
    "examples": [
      "import * as Micro from \"effect/Micro\"\n\nMicro.uninterruptibleMask((restore) =>\n  Micro.sleep(1000).pipe( // uninterruptible\n    Micro.andThen(restore(Micro.sleep(1000))) // interruptible\n  )\n)"
    ],
    "since": "3.4.0",
    "category": "interruption",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "all",
    "description": "Runs all the provided effects in sequence respecting the structure provided in input.\n\nSupports multiple arguments, a single argument tuple / array or record / struct.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "collecting & elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "For each element of the provided iterable, run the effect and collect the\nresults.\n\nIf the `discard` option is set to `true`, the results will be discarded and\nthe effect will return `void`.\n\nThe `concurrency` option can be set to control how many effects are run\nconcurrently. By default, the effects are run sequentially.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "collecting & elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": "Effectfully filter the elements of the provided iterable.\n\nUse the `concurrency` option to control how many elements are processed\nconcurrently.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "collecting & elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Effectfully filter the elements of the provided iterable.\n\nUse the `concurrency` option to control how many elements are processed\nconcurrently.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "collecting & elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "fork",
    "description": "Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\naborted.\n\nWhen the parent `Micro` finishes, this `Micro` will be aborted.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "fiber & forking",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "forkDaemon",
    "description": "Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\naborted.\n\nIt will not be aborted when the parent `Micro` finishes.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "fiber & forking",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "forkScoped",
    "description": "Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\naborted.\n\nThe lifetime of the handle will be attached to the current `MicroScope`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "fiber & forking",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "runFork",
    "description": "Execute the `Micro` effect and return a `MicroFiber` that can be awaited, joined,\nor aborted.\n\nYou can listen for the result by adding an observer using the handle's\n`addObserver` method.",
    "deprecated": false,
    "examples": [
      "import * as Micro from \"effect/Micro\"\n\nconst handle = Micro.succeed(42).pipe(\n  Micro.delay(1000),\n  Micro.runFork\n)\n\nhandle.addObserver((exit) => {\n  console.log(exit)\n})"
    ],
    "since": "3.4.0",
    "category": "execution",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "runPromiseExit",
    "description": "Execute the `Micro` effect and return a `Promise` that resolves with the\n`MicroExit` of the computation.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "execution",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "runPromise",
    "description": "Execute the `Micro` effect and return a `Promise` that resolves with the\nsuccessful value of the computation.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "execution",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "runSyncExit",
    "description": "Attempt to execute the `Micro` effect synchronously and return the `MicroExit`.\n\nIf any asynchronous effects are encountered, the function will return a\n`CauseDie` containing the `MicroFiber`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "execution",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "runSync",
    "description": "Attempt to execute the `Micro` effect synchronously and return the success\nvalue.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "execution",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "TaggedError",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "errors",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "Micro",
    "description": "A lightweight alternative to the `Effect` data type, with a subset of the functionality.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "models",
    "signature": "export interface Micro<out A, out E = never, out R = never> extends Effect<A, E, R> {\n  readonly [TypeId]: Micro.Variance<A, E, R>\n  [Symbol.iterator](): MicroIterator<Micro<A, E, R>>\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: MicroUnify<this>\n  [Unify.ignoreSymbol]?: MicroUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroFiber",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroFiber",
    "signature": "export interface MicroFiber<out A, out E = never> {\n  readonly [MicroFiberTypeId]: MicroFiber.Variance<A, E>\n\n  readonly currentOpCount: number\n  readonly getRef: <I, A>(ref: Context.Reference<I, A>) => A\n  readonly context: Context.Context<never>\n  readonly addObserver: (cb: (exit: MicroExit<A, E>) => void) => () => void\n  readonly unsafeInterrupt: () => void\n  readonly unsafePoll: () => MicroExit<A, E> | undefined\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroIterator",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "models",
    "signature": "export interface MicroIterator<T extends Micro<any, any, any>> {\n  next(...args: ReadonlyArray<any>): IteratorResult<YieldWrap<T>, Micro.Success<T>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroScheduler",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.5.9",
    "category": "scheduler",
    "signature": "export interface MicroScheduler {\n  readonly scheduleTask: (task: () => void, priority: number) => void\n  readonly shouldYield: (fiber: MicroFiber<unknown, unknown>) => boolean\n  readonly flush: () => void\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroScope",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "export interface MicroScope {\n  readonly [MicroScopeTypeId]: MicroScopeTypeId\n  readonly addFinalizer: (finalizer: (exit: MicroExit<unknown, unknown>) => Micro<void>) => Micro<void>\n  readonly fork: Micro<MicroScope.Closeable>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroTypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.1",
    "category": "type lambdas",
    "signature": "export interface MicroTypeLambda extends TypeLambda {\n  readonly type: Micro<this[\"Target\"], this[\"Out1\"], this[\"Out2\"]>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.3",
    "category": "models",
    "signature": "export interface MicroUnify<A extends { [Unify.typeSymbol]?: any }> extends EffectUnify<A> {\n  Micro?: () => A[Unify.typeSymbol] extends Micro<infer A0, infer E0, infer R0> | infer _ ? Micro<A0, E0, R0> : never\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.3",
    "category": "models",
    "signature": "export interface MicroUnifyIgnore extends EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "YieldableError",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "errors",
    "signature": "export interface YieldableError extends Pipeable, Inspectable, Readonly<Error> {\n  readonly [Effectable.EffectTypeId]: Effect.VarianceStruct<never, this, never>\n  readonly [Effectable.StreamTypeId]: Stream.VarianceStruct<never, this, never>\n  readonly [Effectable.SinkTypeId]: Sink.VarianceStruct<never, unknown, never, this, never>\n  readonly [Effectable.ChannelTypeId]: Channel.VarianceStruct<never, unknown, this, unknown, never, unknown, never>\n  readonly [TypeId]: Micro.Variance<never, this, never>\n  [Symbol.iterator](): MicroIterator<Micro<never, this, never>>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroCause",
    "description": "A `MicroCause` is a data type that represents the different ways a `Micro` can fail.\n\n**Details**\n\n`MicroCause` comes in three forms:\n\n- `Die`: Indicates an unforeseen defect that wasn't planned for in the system's logic.\n- `Fail`: Covers anticipated errors that are recognized and typically handled within the application.\n- `Interrupt`: Signifies an operation that has been purposefully stopped.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "export type MicroCause<E> =\n  | MicroCause.Die\n  | MicroCause.Fail<E>\n  | MicroCause.Interrupt"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroCauseTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroCause",
    "signature": "export type MicroCauseTypeId = typeof MicroCauseTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroExit",
    "description": "The `MicroExit` type is used to represent the result of a `Micro` computation. It\ncan either be successful, containing a value of type `A`, or it can fail,\ncontaining an error of type `E` wrapped in a `MicroCause`.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "MicroExit",
    "signature": "export type MicroExit<A, E = never> =\n  | MicroExit.Success<A, E>\n  | MicroExit.Failure<A, E>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroExitTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "MicroExit",
    "signature": "export type MicroExitTypeId = typeof TypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroFiberTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "MicroFiber",
    "signature": "export type MicroFiberTypeId = typeof MicroFiberTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroSchedule",
    "description": "The `MicroSchedule` type represents a function that can be used to calculate\nthe delay between repeats.\n\nThe function takes the current attempt number and the elapsed time since the\nfirst attempt, and returns the delay for the next attempt. If the function\nreturns `None`, the repetition will stop.",
    "deprecated": false,
    "examples": [],
    "since": "3.4.6",
    "category": "scheduling",
    "signature": "export type MicroSchedule = (attempt: number, elapsed: number) => Option.Option<number>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "MicroScopeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "resources & finalization",
    "signature": "export type MicroScopeTypeId = typeof MicroScopeTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Micro",
      "path": [
        "src",
        "Micro.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "type ids",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ModuleVersion",
      "path": [
        "src",
        "ModuleVersion.ts"
      ]
    },
    "project": "effect",
    "name": "getCurrentVersion",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "version",
    "signature": "export declare const getCurrentVersion: () => string"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ModuleVersion",
      "path": [
        "src",
        "ModuleVersion.ts"
      ]
    },
    "project": "effect",
    "name": "setCurrentVersion",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "version",
    "signature": "export declare const setCurrentVersion: (version: string) => void"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashMap",
      "path": [
        "src",
        "MutableHashMap.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const get: { <K>(key: K): <V>(self: MutableHashMap<K, V>) => Option.Option<V>; <K, V>(self: MutableHashMap<K, V>, key: K): Option.Option<V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashMap",
      "path": [
        "src",
        "MutableHashMap.ts"
      ]
    },
    "project": "effect",
    "name": "has",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const has: { <K>(key: K): <V>(self: MutableHashMap<K, V>) => boolean; <K, V>(self: MutableHashMap<K, V>, key: K): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashMap",
      "path": [
        "src",
        "MutableHashMap.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const set: { <K, V>(key: K, value: V): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>; <K, V>(self: MutableHashMap<K, V>, key: K, value: V): MutableHashMap<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashMap",
      "path": [
        "src",
        "MutableHashMap.ts"
      ]
    },
    "project": "effect",
    "name": "modify",
    "description": "Updates the value of the specified key within the `MutableHashMap` if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const modify: { <K, V>(key: K, f: (v: V) => V): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>; <K, V>(self: MutableHashMap<K, V>, key: K, f: (v: V) => V): MutableHashMap<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashMap",
      "path": [
        "src",
        "MutableHashMap.ts"
      ]
    },
    "project": "effect",
    "name": "modifyAt",
    "description": "Set or remove the specified key in the `MutableHashMap` using the specified\nupdate function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const modifyAt: { <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>; <K, V>(self: MutableHashMap<K, V>, key: K, f: (value: Option.Option<V>) => Option.Option<V>): MutableHashMap<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashMap",
      "path": [
        "src",
        "MutableHashMap.ts"
      ]
    },
    "project": "effect",
    "name": "remove",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const remove: { <K>(key: K): <V>(self: MutableHashMap<K, V>) => MutableHashMap<K, V>; <K, V>(self: MutableHashMap<K, V>, key: K): MutableHashMap<K, V>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashMap",
      "path": [
        "src",
        "MutableHashMap.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashMap",
      "path": [
        "src",
        "MutableHashMap.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashMap",
      "path": [
        "src",
        "MutableHashMap.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `MutableHashMap` from an iterable collection of key/value pairs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashMap",
      "path": [
        "src",
        "MutableHashMap.ts"
      ]
    },
    "project": "effect",
    "name": "keys",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashMap",
      "path": [
        "src",
        "MutableHashMap.ts"
      ]
    },
    "project": "effect",
    "name": "clear",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashMap",
      "path": [
        "src",
        "MutableHashMap.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MutableHashMap",
      "path": [
        "src",
        "MutableHashMap.ts"
      ]
    },
    "project": "effect",
    "name": "MutableHashMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MutableHashMap<out K, out V> extends Iterable<[K, V]>, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  /** @internal */\n  readonly referential: Map<K, V>\n  /** @internal */\n  readonly buckets: Map<number, NonEmptyArray<readonly [K & Equal.Equal, V]>>\n  /** @internal */\n  bucketsSize: number\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MutableHashMap",
      "path": [
        "src",
        "MutableHashMap.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashSet",
      "path": [
        "src",
        "MutableHashSet.ts"
      ]
    },
    "project": "effect",
    "name": "add",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const add: { <V>(key: V): (self: MutableHashSet<V>) => MutableHashSet<V>; <V>(self: MutableHashSet<V>, key: V): MutableHashSet<V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashSet",
      "path": [
        "src",
        "MutableHashSet.ts"
      ]
    },
    "project": "effect",
    "name": "has",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const has: { <V>(key: V): (self: MutableHashSet<V>) => boolean; <V>(self: MutableHashSet<V>, key: V): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableHashSet",
      "path": [
        "src",
        "MutableHashSet.ts"
      ]
    },
    "project": "effect",
    "name": "remove",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const remove: { <V>(key: V): (self: MutableHashSet<V>) => MutableHashSet<V>; <V>(self: MutableHashSet<V>, key: V): MutableHashSet<V>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashSet",
      "path": [
        "src",
        "MutableHashSet.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashSet",
      "path": [
        "src",
        "MutableHashSet.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `MutableHashSet` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashSet",
      "path": [
        "src",
        "MutableHashSet.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashSet",
      "path": [
        "src",
        "MutableHashSet.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableHashSet",
      "path": [
        "src",
        "MutableHashSet.ts"
      ]
    },
    "project": "effect",
    "name": "clear",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MutableHashSet",
      "path": [
        "src",
        "MutableHashSet.ts"
      ]
    },
    "project": "effect",
    "name": "MutableHashSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MutableHashSet<out V> extends Iterable<V>, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n\n  /** @internal */\n  readonly keyMap: MutableHashMap.MutableHashMap<V, boolean>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MutableHashSet",
      "path": [
        "src",
        "MutableHashSet.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "Executes the specified function `f` for each element in the list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const forEach: { <A>(f: (element: A) => void): (self: MutableList<A>) => void; <A>(self: MutableList<A>, f: (element: A) => void): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "append",
    "description": "Appends the specified element to the end of the `MutableList`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const append: { <A>(value: A): (self: MutableList<A>) => MutableList<A>; <A>(self: MutableList<A>, value: A): MutableList<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "prepend",
    "description": "Prepends the specified value to the beginning of the list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const prepend: { <A>(value: A): (self: MutableList<A>) => MutableList<A>; <A>(self: MutableList<A>, value: A): MutableList<A>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates an empty `MutableList`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `MutableList` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new `MutableList` from the specified elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the list contains zero elements, `false`, otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "length",
    "description": "Returns the length of the list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "tail",
    "description": "Returns the last element of the list, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "head",
    "description": "Returns the first element of the list, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "reset",
    "description": "Removes all elements from the doubly-linked list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "shift",
    "description": "Removes the first value from the list and returns it, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "0.0.1",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "pop",
    "description": "Removes the last value from the list and returns it, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "0.0.1",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "MutableList",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface MutableList<out A> extends Iterable<A>, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n\n  /** @internal */\n  head: LinkedListNode<A> | undefined\n  /** @internal */\n  tail: LinkedListNode<A> | undefined\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MutableList",
      "path": [
        "src",
        "MutableList.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableQueue",
      "path": [
        "src",
        "MutableQueue.ts"
      ]
    },
    "project": "effect",
    "name": "EmptyMutableQueue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export declare const EmptyMutableQueue: typeof EmptyMutableQueue"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableQueue",
      "path": [
        "src",
        "MutableQueue.ts"
      ]
    },
    "project": "effect",
    "name": "offer",
    "description": "Offers an element to the queue.\n\nReturns whether the enqueue was successful or not.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const offer: { <A>(self: MutableQueue<A>, value: A): boolean; <A>(value: A): (self: MutableQueue<A>) => boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableQueue",
      "path": [
        "src",
        "MutableQueue.ts"
      ]
    },
    "project": "effect",
    "name": "offerAll",
    "description": "Enqueues a collection of values into the queue.\n\nReturns a `Chunk` of the values that were **not** able to be enqueued.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const offerAll: { <A>(values: Iterable<A>): (self: MutableQueue<A>) => Chunk.Chunk<A>; <A>(self: MutableQueue<A>, values: Iterable<A>): Chunk.Chunk<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableQueue",
      "path": [
        "src",
        "MutableQueue.ts"
      ]
    },
    "project": "effect",
    "name": "poll",
    "description": "Dequeues an element from the queue.\n\nReturns either an element from the queue, or the `def` param.\n\n**Note**: if there is no meaningful default for your type, you can always\nuse `poll(MutableQueue.EmptyMutableQueue)`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const poll: { <D>(def: D): <A>(self: MutableQueue<A>) => D | A; <A, D>(self: MutableQueue<A>, def: D): A | D; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableQueue",
      "path": [
        "src",
        "MutableQueue.ts"
      ]
    },
    "project": "effect",
    "name": "pollUpTo",
    "description": "Dequeues up to `n` elements from the queue.\n\nReturns a `List` of up to `n` elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const pollUpTo: { (n: number): <A>(self: MutableQueue<A>) => Chunk.Chunk<A>; <A>(self: MutableQueue<A>, n: number): Chunk.Chunk<A>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableQueue",
      "path": [
        "src",
        "MutableQueue.ts"
      ]
    },
    "project": "effect",
    "name": "bounded",
    "description": "Creates a new bounded `MutableQueue`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableQueue",
      "path": [
        "src",
        "MutableQueue.ts"
      ]
    },
    "project": "effect",
    "name": "unbounded",
    "description": "Creates a new unbounded `MutableQueue`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableQueue",
      "path": [
        "src",
        "MutableQueue.ts"
      ]
    },
    "project": "effect",
    "name": "length",
    "description": "Returns the current number of elements in the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableQueue",
      "path": [
        "src",
        "MutableQueue.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the queue is empty, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableQueue",
      "path": [
        "src",
        "MutableQueue.ts"
      ]
    },
    "project": "effect",
    "name": "isFull",
    "description": "Returns `true` if the queue is full, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableQueue",
      "path": [
        "src",
        "MutableQueue.ts"
      ]
    },
    "project": "effect",
    "name": "capacity",
    "description": "The **maximum** number of elements that a queue can hold.\n\n**Note**: unbounded queues can still implement this interface with\n`capacity = Infinity`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MutableQueue",
      "path": [
        "src",
        "MutableQueue.ts"
      ]
    },
    "project": "effect",
    "name": "MutableQueue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface MutableQueue<out A> extends Iterable<A>, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n\n  /** @internal */\n  queue: MutableList.MutableList<A>\n  /** @internal */\n  capacity: number | undefined\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MutableQueue",
      "path": [
        "src",
        "MutableQueue.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "compareAndSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "export declare const compareAndSet: { <T>(oldValue: T, newValue: T): (self: MutableRef<T>) => boolean; <T>(self: MutableRef<T>, oldValue: T, newValue: T): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "export declare const getAndSet: { <T>(value: T): (self: MutableRef<T>) => T; <T>(self: MutableRef<T>, value: T): T; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "export declare const getAndUpdate: { <T>(f: (value: T) => T): (self: MutableRef<T>) => T; <T>(self: MutableRef<T>, f: (value: T) => T): T; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "export declare const set: { <T>(value: T): (self: MutableRef<T>) => MutableRef<T>; <T>(self: MutableRef<T>, value: T): MutableRef<T>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "setAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "export declare const setAndGet: { <T>(value: T): (self: MutableRef<T>) => T; <T>(self: MutableRef<T>, value: T): T; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "update",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "export declare const update: { <T>(f: (value: T) => T): (self: MutableRef<T>) => MutableRef<T>; <T>(self: MutableRef<T>, f: (value: T) => T): MutableRef<T>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": "export declare const updateAndGet: { <T>(f: (value: T) => T): (self: MutableRef<T>) => T; <T>(self: MutableRef<T>, f: (value: T) => T): T; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "decrement",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "numeric",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "decrementAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "numeric",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "general",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndDecrement",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "numeric",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndIncrement",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "numeric",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "increment",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "numeric",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "incrementAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "numeric",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "toggle",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "boolean",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "MutableRef",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface MutableRef<out T> extends Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n\n  /** @internal */\n  current: T\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "MutableRef",
      "path": [
        "src",
        "MutableRef.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "NonEmptyIterable",
      "path": [
        "src",
        "NonEmptyIterable.ts"
      ]
    },
    "project": "effect",
    "name": "unprepend",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "NonEmptyIterable",
      "path": [
        "src",
        "NonEmptyIterable.ts"
      ]
    },
    "project": "effect",
    "name": "NonEmptyIterable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export interface NonEmptyIterable<out A> extends Iterable<A> {\n  readonly [nonEmpty]: A\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "isNumber",
    "description": "Tests if a value is a `number`.",
    "deprecated": false,
    "examples": [
      "import { isNumber } from \"effect/Number\"\n\nassert.deepStrictEqual(isNumber(2), true)\nassert.deepStrictEqual(isNumber(\"2\"), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isNumber: (input: unknown) => input is number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "sum",
    "description": "Provides an addition operation on `number`s.",
    "deprecated": false,
    "examples": [
      "import { sum } from \"effect/Number\"\n\nassert.deepStrictEqual(sum(2, 3), 5)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const sum: { (that: number): (self: number) => number; (self: number, that: number): number; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "multiply",
    "description": "Provides a multiplication operation on `number`s.",
    "deprecated": false,
    "examples": [
      "import { multiply } from \"effect/Number\"\n\nassert.deepStrictEqual(multiply(2, 3), 6)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const multiply: { (that: number): (self: number) => number; (self: number, that: number): number; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "subtract",
    "description": "Provides a subtraction operation on `number`s.",
    "deprecated": false,
    "examples": [
      "import { subtract } from \"effect/Number\"\n\nassert.deepStrictEqual(subtract(2, 3), -1)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const subtract: { (that: number): (self: number) => number; (self: number, that: number): number; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "divide",
    "description": "Provides a division operation on `number`s.",
    "deprecated": false,
    "examples": [
      "import { Number, Option } from \"effect\"\n\nassert.deepStrictEqual(Number.divide(6, 3), Option.some(2))\nassert.deepStrictEqual(Number.divide(6, 0), Option.none())"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const divide: { (that: number): (self: number) => Option<number>; (self: number, that: number): Option<number>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeDivide",
    "description": "Provides a division operation on `number`s.\n\nThrows a `RangeError` if the divisor is `0`.",
    "deprecated": false,
    "examples": [
      "import { unsafeDivide } from \"effect/Number\"\n\nassert.deepStrictEqual(unsafeDivide(6, 3), 2)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const unsafeDivide: { (that: number): (self: number) => number; (self: number, that: number): number; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "Equivalence",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Equivalence: equivalence.Equivalence<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "Order",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Order: order.Order<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "lessThan",
    "description": "Returns `true` if the first argument is less than the second, otherwise `false`.",
    "deprecated": false,
    "examples": [
      "import { lessThan } from \"effect/Number\"\n\nassert.deepStrictEqual(lessThan(2, 3), true)\nassert.deepStrictEqual(lessThan(3, 3), false)\nassert.deepStrictEqual(lessThan(4, 3), false)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const lessThan: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanOrEqualTo",
    "description": "Returns a function that checks if a given `number` is less than or equal to the provided one.",
    "deprecated": false,
    "examples": [
      "import { lessThanOrEqualTo } from \"effect/Number\"\n\nassert.deepStrictEqual(lessThanOrEqualTo(2, 3), true)\nassert.deepStrictEqual(lessThanOrEqualTo(3, 3), true)\nassert.deepStrictEqual(lessThanOrEqualTo(4, 3), false)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const lessThanOrEqualTo: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThan",
    "description": "Returns `true` if the first argument is greater than the second, otherwise `false`.",
    "deprecated": false,
    "examples": [
      "import { greaterThan } from \"effect/Number\"\n\nassert.deepStrictEqual(greaterThan(2, 3), false)\nassert.deepStrictEqual(greaterThan(3, 3), false)\nassert.deepStrictEqual(greaterThan(4, 3), true)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const greaterThan: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanOrEqualTo",
    "description": "Returns a function that checks if a given `number` is greater than or equal to the provided one.",
    "deprecated": false,
    "examples": [
      "import { greaterThanOrEqualTo } from \"effect/Number\"\n\nassert.deepStrictEqual(greaterThanOrEqualTo(2, 3), false)\nassert.deepStrictEqual(greaterThanOrEqualTo(3, 3), true)\nassert.deepStrictEqual(greaterThanOrEqualTo(4, 3), true)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const greaterThanOrEqualTo: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "between",
    "description": "Checks if a `number` is between a `minimum` and `maximum` value (inclusive).",
    "deprecated": false,
    "examples": [
      "import { Number } from \"effect\"\n\nconst between = Number.between({ minimum: 0, maximum: 5 })\n\nassert.deepStrictEqual(between(3), true)\nassert.deepStrictEqual(between(-1), false)\nassert.deepStrictEqual(between(6), false)"
    ],
    "since": "2.0.0",
    "category": "predicates",
    "signature": "export declare const between: { (options: { minimum: number; maximum: number; }): (self: number) => boolean; (self: number, options: { minimum: number; maximum: number; }): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "clamp",
    "description": "Restricts the given `number` to be within the range specified by the `minimum` and `maximum` values.\n\n- If the `number` is less than the `minimum` value, the function returns the `minimum` value.\n- If the `number` is greater than the `maximum` value, the function returns the `maximum` value.\n- Otherwise, it returns the original `number`.",
    "deprecated": false,
    "examples": [
      "import { Number } from \"effect\"\n\nconst clamp = Number.clamp({ minimum: 1, maximum: 5 })\n\nassert.equal(clamp(3), 3)\nassert.equal(clamp(0), 1)\nassert.equal(clamp(6), 5)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const clamp: { (options: { minimum: number; maximum: number; }): (self: number) => number; (self: number, options: { minimum: number; maximum: number; }): number; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "min",
    "description": "Returns the minimum between two `number`s.",
    "deprecated": false,
    "examples": [
      "import { min } from \"effect/Number\"\n\nassert.deepStrictEqual(min(2, 3), 2)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const min: { (that: number): (self: number) => number; (self: number, that: number): number; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "max",
    "description": "Returns the maximum between two `number`s.",
    "deprecated": false,
    "examples": [
      "import { max } from \"effect/Number\"\n\nassert.deepStrictEqual(max(2, 3), 3)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const max: { (that: number): (self: number) => number; (self: number, that: number): number; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "remainder",
    "description": "Returns the remainder left over when one operand is divided by a second operand.\n\nIt always takes the sign of the dividend.",
    "deprecated": false,
    "examples": [
      "import { remainder } from \"effect/Number\"\n\nassert.deepStrictEqual(remainder(2, 2), 0)\nassert.deepStrictEqual(remainder(3, 2), 1)\nassert.deepStrictEqual(remainder(-4, 2), -0)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": "export declare const remainder: { (divisor: number): (self: number) => number; (self: number, divisor: number): number; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "round",
    "description": "Returns the number rounded with the given precision.",
    "deprecated": false,
    "examples": [
      "import { round } from \"effect/Number\"\n\nassert.deepStrictEqual(round(1.1234, 2), 1.12)\nassert.deepStrictEqual(round(1.567, 2), 1.57)"
    ],
    "since": "3.8.0",
    "category": "math",
    "signature": "export declare const round: { (precision: number): (self: number) => number; (self: number, precision: number): number; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "increment",
    "description": "Returns the result of adding `1` to a given number.",
    "deprecated": false,
    "examples": [
      "import { increment } from \"effect/Number\"\n\nassert.deepStrictEqual(increment(2), 3)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "decrement",
    "description": "Decrements a number by `1`.",
    "deprecated": false,
    "examples": [
      "import { decrement } from \"effect/Number\"\n\nassert.deepStrictEqual(decrement(3), 2)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "sign",
    "description": "Determines the sign of a given `number`.",
    "deprecated": false,
    "examples": [
      "import { sign } from \"effect/Number\"\n\nassert.deepStrictEqual(sign(-5), -1)\nassert.deepStrictEqual(sign(0), 0)\nassert.deepStrictEqual(sign(5), 1)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "sumAll",
    "description": "Takes an `Iterable` of `number`s and returns their sum as a single `number`.",
    "deprecated": false,
    "examples": [
      "import { sumAll } from \"effect/Number\"\n\nassert.deepStrictEqual(sumAll([2, 3, 4]), 9)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "multiplyAll",
    "description": "Takes an `Iterable` of `number`s and returns their multiplication as a single `number`.",
    "deprecated": false,
    "examples": [
      "import { multiplyAll } from \"effect/Number\"\n\nassert.deepStrictEqual(multiplyAll([2, 3, 4]), 24)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "nextPow2",
    "description": "Returns the next power of 2 from the given number.",
    "deprecated": false,
    "examples": [
      "import { nextPow2 } from \"effect/Number\"\n\nassert.deepStrictEqual(nextPow2(5), 8)\nassert.deepStrictEqual(nextPow2(17), 32)"
    ],
    "since": "2.0.0",
    "category": "math",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Number",
      "path": [
        "src",
        "Number.ts"
      ]
    },
    "project": "effect",
    "name": "parse",
    "description": "Tries to parse a `number` from a `string` using the `Number()` function.\nThe following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": "Wraps the given value into an `Option` to represent its presence.",
    "deprecated": false,
    "examples": [
      "// Title: Creating an Option with a Value\nimport { Option } from \"effect\"\n\n// An Option holding the number 1\n//\n//       Option<number>\n//      \nconst value = Option.some(1)\n\nconsole.log(value)\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }"
    ],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const some: <A>(value: A) => Option<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "isOption",
    "description": "Determines whether the given value is an `Option`.\n\n**Details**\n\nThis function checks if a value is an instance of `Option`. It returns `true`\nif the value is either `Option.some` or `Option.none`, and `false` otherwise.\nThis is particularly useful when working with unknown values or when you need\nto ensure type safety in your code.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconsole.log(Option.isOption(Option.some(1)))\n// Output: true\n\nconsole.log(Option.isOption(Option.none()))\n// Output: true\n\nconsole.log(Option.isOption({}))\n// Output: false"
    ],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isOption: (input: unknown) => input is Option<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "isNone",
    "description": "Checks whether an `Option` represents the absence of a value (`None`).",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconsole.log(Option.isNone(Option.some(1)))\n// Output: false\n\nconsole.log(Option.isNone(Option.none()))\n// Output: true"
    ],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isNone: <A>(self: Option<A>) => self is None<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "isSome",
    "description": "Checks whether an `Option` contains a value (`Some`).",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconsole.log(Option.isSome(Option.some(1)))\n// Output: true\n\nconsole.log(Option.isSome(Option.none()))\n// Output: false"
    ],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isSome: <A>(self: Option<A>) => self is Some<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Performs pattern matching on an `Option` to handle both `Some` and `None`\ncases.\n\n**Details**\n\nThis function allows you to match against an `Option` and handle both\nscenarios: when the `Option` is `None` (i.e., contains no value), and when\nthe `Option` is `Some` (i.e., contains a value). It executes one of the\nprovided functions based on the case:\n\n- If the `Option` is `None`, the `onNone` function is executed and its result\n  is returned.\n- If the `Option` is `Some`, the `onSome` function is executed with the\n  contained value, and its result is returned.\n\nThis function provides a concise and functional way to handle optional values\nwithout resorting to `if` or manual checks, making your code more declarative\nand readable.",
    "deprecated": false,
    "examples": [
      "// Title: Pattern Matching with Option\nimport { Option } from \"effect\"\n\nconst foo = Option.some(1)\n\nconst message = Option.match(foo, {\n  onNone: () => \"Option is empty\",\n  onSome: (value) => `Option has a value: ${value}`\n})\n\nconsole.log(message)\n// Output: \"Option has a value: 1\""
    ],
    "since": "2.0.0",
    "category": "Pattern matching",
    "signature": "export declare const match: { <B, A, C = B>(options: { readonly onNone: LazyArg<B>; readonly onSome: (a: A) => C; }): (self: Option<A>) => B | C; <A, B, C = B>(self: Option<A>, options: { readonly onNone: LazyArg<B>; readonly onSome: (a: A) => C; }): B | C; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "getRight",
    "description": "Converts an `Either` into an `Option` by discarding the error and extracting\nthe right value.\n\n**Details**\n\nThis function takes an `Either` and returns an `Option` based on its value:\n\n- If the `Either` is a `Right`, its value is wrapped in a `Some` and\n  returned.\n- If the `Either` is a `Left`, the error is discarded, and `None` is\n  returned.\n\nThis is particularly useful when you only care about the success case\n(`Right`) of an `Either` and want to handle the result using `Option`. By\nusing this function, you can convert `Either` into a simpler structure for\ncases where error handling is not required.",
    "deprecated": false,
    "examples": [
      "import { Either, Option } from \"effect\"\n\nconsole.log(Option.getRight(Either.right(\"ok\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'ok' }\n\nconsole.log(Option.getRight(Either.left(\"err\")))\n// Output: { _id: 'Option', _tag: 'None' }"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": "export declare const getRight: <R, L>(self: Either<R, L>) => Option<R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "getLeft",
    "description": "Converts an `Either` into an `Option` by discarding the right value and\nextracting the left value.\n\n**Details**\n\nThis function transforms an `Either` into an `Option` as follows:\n\n- If the `Either` is a `Left`, its value is wrapped in a `Some` and returned.\n- If the `Either` is a `Right`, the value is discarded, and `None` is\n  returned.\n\nThis utility is useful when you only care about the error case (`Left`) of an\n`Either` and want to handle it as an `Option`. By discarding the right value,\nit simplifies error-focused workflows.",
    "deprecated": false,
    "examples": [
      "import { Either, Option } from \"effect\"\n\nconsole.log(Option.getLeft(Either.right(\"ok\")))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.getLeft(Either.left(\"err\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'err' }"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": "export declare const getLeft: <R, L>(self: Either<R, L>) => Option<L>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "getOrElse",
    "description": "Returns the value contained in the `Option` if it is `Some`, otherwise\nevaluates and returns the result of `onNone`.\n\n**Details**\n\nThis function allows you to provide a fallback value or computation for when\nan `Option` is `None`. If the `Option` contains a value (`Some`), that value\nis returned. If it is empty (`None`), the `onNone` function is executed, and\nits result is returned instead.\n\nThis utility is helpful for safely handling `Option` values by ensuring you\nalways receive a meaningful result, whether or not the `Option` contains a\nvalue. It is particularly useful for providing default values or alternative\nlogic when working with optional values.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconsole.log(Option.some(1).pipe(Option.getOrElse(() => 0)))\n// Output: 1\n\nconsole.log(Option.none().pipe(Option.getOrElse(() => 0)))\n// Output: 0"
    ],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const getOrElse: { <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => B | A; <A, B>(self: Option<A>, onNone: LazyArg<B>): A | B; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "orElse",
    "description": "Returns the provided `Option` `that` if the current `Option` (`self`) is\n`None`; otherwise, it returns `self`.\n\n**Details**\n\nThis function provides a fallback mechanism for `Option` values. If the\ncurrent `Option` is `None` (i.e., it contains no value), the `that` function\nis evaluated, and its resulting `Option` is returned. If the current `Option`\nis `Some` (i.e., it contains a value), the original `Option` is returned\nunchanged.\n\nThis is particularly useful for chaining fallback values or computations,\nallowing you to provide alternative `Option` values when the first one is\nempty.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconsole.log(Option.none().pipe(Option.orElse(() => Option.none())))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.some(\"a\").pipe(Option.orElse(() => Option.none())))\n// Output: { _id: 'Option', _tag: 'Some', value: 'a' }\n\nconsole.log(Option.none().pipe(Option.orElse(() => Option.some(\"b\"))))\n// Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n\nconsole.log(Option.some(\"a\").pipe(Option.orElse(() => Option.some(\"b\"))))\n// Output: { _id: 'Option', _tag: 'Some', value: 'a' }"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const orElse: { <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<B | A>; <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "orElseSome",
    "description": "Returns the provided default value wrapped in `Some` if the current `Option`\n(`self`) is `None`; otherwise, returns `self`.\n\n**Details**\n\nThis function provides a way to supply a default value for cases where an\n`Option` is `None`. If the current `Option` is empty (`None`), the `onNone`\nfunction is executed to compute the default value, which is then wrapped in a\n`Some`. If the current `Option` contains a value (`Some`), it is returned as\nis.\n\nThis is particularly useful for handling optional values where a fallback\ndefault needs to be provided explicitly in case of absence.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconsole.log(Option.none().pipe(Option.orElseSome(() => \"b\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'b' }\n\nconsole.log(Option.some(\"a\").pipe(Option.orElseSome(() => \"b\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'a' }"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const orElseSome: { <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => Option<B | A>; <A, B>(self: Option<A>, onNone: LazyArg<B>): Option<A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "orElseEither",
    "description": "Similar to {@link orElse}, but returns an `Either` wrapped in an `Option` to\nindicate the source of the value.\n\n**Details**\n\nThis function allows you to provide a fallback `Option` in case the current\n`Option` (`self`) is `None`. However, unlike `orElse`, it returns the value\nwrapped in an `Either` object, providing additional information about where\nthe value came from:\n\n- If the value is from the fallback `Option` (`that`), it is wrapped in an\n  `Either.right`.\n- If the value is from the original `Option` (`self`), it is wrapped in an\n  `Either.left`.\n\nThis is especially useful when you need to differentiate between values\noriginating from the primary `Option` and those coming from the fallback,\nwhile still maintaining the `Option`-style handling.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": "export declare const orElseEither: { <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<Either<B, A>>; <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<Either<B, A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "getOrNull",
    "description": "Returns the value contained in the `Option` if it is `Some`; otherwise,\nreturns `null`.\n\n**Details**\n\nThis function provides a way to extract the value of an `Option` while\nfalling back to `null` if the `Option` is `None`.\n\nIt is particularly useful in scenarios where `null` is an acceptable\nplaceholder for the absence of a value, such as when interacting with APIs or\nsystems that use `null` as a default for missing values.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconsole.log(Option.getOrNull(Option.some(1)))\n// Output: 1\n\nconsole.log(Option.getOrNull(Option.none()))\n// Output: null"
    ],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const getOrNull: <A>(self: Option<A>) => A | null"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "getOrUndefined",
    "description": "Returns the value contained in the `Option` if it is `Some`; otherwise,\nreturns `undefined`.\n\n**Details**\n\nThis function provides a way to extract the value of an `Option` while\nfalling back to `undefined` if the `Option` is `None`.\n\nIt is particularly useful in scenarios where `undefined` is an acceptable\nplaceholder for the absence of a value, such as when interacting with APIs or\nsystems that use `undefined` as a default for missing values.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconsole.log(Option.getOrUndefined(Option.some(1)))\n// Output: 1\n\nconsole.log(Option.getOrUndefined(Option.none()))\n// Output: undefined"
    ],
    "since": "2.0.0",
    "category": "Getters",
    "signature": "export declare const getOrUndefined: <A>(self: Option<A>) => A | undefined"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "getOrThrowWith",
    "description": "Extracts the value of an `Option` or throws an error if the `Option` is\n`None`, using a custom error factory.\n\n**Details**\n\nThis function allows you to extract the value of an `Option` when it is\n`Some`. If the `Option` is `None`, it throws an error generated by the\nprovided `onNone` function. This utility is particularly useful when you need\na fail-fast behavior for empty `Option` values and want to provide a custom\nerror message or object.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nassert.deepStrictEqual(\n  Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),\n  1\n)\nassert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": "export declare const getOrThrowWith: { (onNone: () => unknown): <A>(self: Option<A>) => A; <A>(self: Option<A>, onNone: () => unknown): A; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "getOrThrow",
    "description": "Extracts the value of an `Option` or throws a default error if the `Option`\nis `None`.\n\n**Details**\n\nThis function extracts the value from an `Option` if it is `Some`. If the\n`Option` is `None`, it throws a default error. It is useful for fail-fast\nscenarios where the absence of a value is treated as an exceptional case and\na default error is sufficient.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nassert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)\nassert.throws(() => Option.getOrThrow(Option.none()))"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": "export declare const getOrThrow: <A>(self: Option<A>) => A"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms the value inside a `Some` to a new value using the provided\nfunction, while leaving `None` unchanged.\n\n**Details**\n\nThis function applies a mapping function `f` to the value inside an `Option`\nif it is a `Some`. If the `Option` is `None`, it remains unchanged. The\nresult is a new `Option` with the transformed value (if it was a `Some`) or\nstill `None`.\n\nThis utility is particularly useful for chaining transformations in a\nfunctional way without needing to manually handle `None` cases.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\n// Mapping over a `Some`\nconst someValue = Option.some(2)\n\nconsole.log(Option.map(someValue, (n) => n * 2))\n// Output: { _id: 'Option', _tag: 'Some', value: 4 }\n\n// Mapping over a `None`\nconst noneValue = Option.none<number>()\n\nconsole.log(Option.map(noneValue, (n) => n * 2))\n// Output: { _id: 'Option', _tag: 'None' }"
    ],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const map: { <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => B): Option<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "as",
    "description": "Replaces the value inside a `Some` with the specified constant value, leaving\n`None` unchanged.\n\n**Details**\n\nThis function transforms an `Option` by replacing the value inside a `Some`\nwith the given constant value `b`. If the `Option` is `None`, it remains\nunchanged.\n\nThis is useful when you want to preserve the presence of a value (`Some`) but\nreplace its content with a fixed value.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\n// Replacing the value of a `Some`\nconst someValue = Option.some(42)\n\nconsole.log(Option.as(someValue, \"new value\"))\n// Output: { _id: 'Option', _tag: 'Some', value: 'new value' }\n\n// Replacing a `None` (no effect)\nconst noneValue = Option.none<number>()\n\nconsole.log(Option.as(noneValue, \"new value\"))\n// Output: { _id: 'Option', _tag: 'None' }"
    ],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const as: { <B>(b: B): <X>(self: Option<X>) => Option<B>; <X, B>(self: Option<X>, b: B): Option<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "asVoid",
    "description": "Replaces the value inside a `Some` with the constant value `void`, leaving\n`None` unchanged.\n\n**Details**\n\nThis function transforms an `Option` by replacing the value inside a `Some`\nwith `void`. If the `Option` is `None`, it remains unchanged.\n\nThis is particularly useful in scenarios where the presence or absence of a\nvalue is significant, but the actual content of the value is irrelevant.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const asVoid: <_>(self: Option<_>) => Option<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Applies a function to the value of a `Some` and flattens the resulting\n`Option`. If the input is `None`, it remains `None`.\n\n**Details**\n\nThis function allows you to chain computations that return `Option` values.\nIf the input `Option` is `Some`, the provided function `f` is applied to the\ncontained value, and the resulting `Option` is returned. If the input is\n`None`, the function is not applied, and the result remains `None`.\n\nThis utility is particularly useful for sequencing operations that may fail\nor produce optional results, enabling clean and concise workflows for\nhandling such cases.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\ninterface Address {\n  readonly city: string\n  readonly street: Option.Option<string>\n}\n\ninterface User {\n  readonly id: number\n  readonly username: string\n  readonly email: Option.Option<string>\n  readonly address: Option.Option<Address>\n}\n\nconst user: User = {\n  id: 1,\n  username: \"john_doe\",\n  email: Option.some(\"john.doe@example.com\"),\n  address: Option.some({\n    city: \"New York\",\n    street: Option.some(\"123 Main St\")\n  })\n}\n\n// Use flatMap to extract the street value\nconst street = user.address.pipe(\n  Option.flatMap((address) => address.street)\n)\n\nconsole.log(street)\n// Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }"
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const flatMap: { <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "andThen",
    "description": "Chains two `Option`s together. The second `Option` can either be a static\nvalue or depend on the result of the first `Option`.\n\n**Details**\n\nThis function enables sequencing of two `Option` computations. If the first\n`Option` is `Some`, the second `Option` is evaluated. The second `Option` can\neither:\n\n- Be a static `Option` value.\n- Be a function that produces an `Option`, optionally based on the value of\n  the first `Option`.\n\nIf the first `Option` is `None`, the function skips the evaluation of the\nsecond `Option` and directly returns `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const andThen: { <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <B>(f: Option<B>): <A>(self: Option<A>) => Option<B>; <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>; <B>(f: NotFunction<B>): <A>(self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; <A, B>(self: Option<A>, f: Option<B>): Option<B>; <A, B>(self: Option<A>, f: (a: A) => B): Option<B>; <A, B>(self: Option<A>, f: NotFunction<B>): Option<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "flatMapNullable",
    "description": "Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`\nusing a function that may return `null` or `undefined`.\n\n**Details**\n\nThis function applies a transformation function `f` to the value inside a\n`Some`. The function `f` may return a value, `null`, or `undefined`. If `f`\nreturns a value, it is wrapped in a `Some`. If `f` returns `null` or\n`undefined`, the result is `None`. If the input `Option` is `None`, the\nfunction is not applied, and `None` is returned.\n\nThis utility is particularly useful when working with deeply nested optional\nvalues or chaining computations that may result in `null` or `undefined` at\nsome point.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\ninterface Employee {\n  company?: {\n    address?: {\n      street?: {\n        name?: string\n      }\n    }\n  }\n}\n\nconst employee1: Employee = { company: { address: { street: { name: \"high street\" } } } }\n\n// Extracting a deeply nested property\nconsole.log(\n  Option.some(employee1)\n    .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n)\n// Output: { _id: 'Option', _tag: 'Some', value: 'high street' }\n\nconst employee2: Employee = { company: { address: { street: {} } } }\n\n// Property does not exist\nconsole.log(\n  Option.some(employee2)\n    .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))\n)\n// Output: { _id: 'Option', _tag: 'None' }"
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const flatMapNullable: { <A, B>(f: (a: A) => B | null | undefined): (self: Option<A>) => Option<NonNullable<B>>; <A, B>(self: Option<A>, f: (a: A) => B | null | undefined): Option<NonNullable<B>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens an `Option` of `Option` into a single `Option`.\n\n**Details**\n\nThis function takes an `Option` that wraps another `Option` and flattens it\ninto a single `Option`. If the outer `Option` is `Some`, the function\nextracts the inner `Option`. If the outer `Option` is `None`, the result\nremains `None`.\n\nThis is useful for simplifying nested `Option` structures that may arise\nduring functional operations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const flatten: <A>(self: Option<Option<A>>) => Option<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Combines two `Option`s, keeping the value from the second `Option` if both\nare `Some`.\n\n**Details**\n\nThis function takes two `Option`s and returns the second one if the first is\n`Some`. If the first `Option` is `None`, the result will also be `None`,\nregardless of the second `Option`. It effectively \"zips\" the two `Option`s\nwhile discarding the value from the first `Option`.\n\nThis is particularly useful when sequencing computations where the result of\nthe first computation is not needed, and you only care about the result of\nthe second computation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "export declare const zipRight: { <B>(that: Option<B>): <_>(self: Option<_>) => Option<B>; <X, B>(self: Option<X>, that: Option<B>): Option<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Combines two `Option`s, keeping the value from the first `Option` if both are\n`Some`.\n\n**Details**\n\nThis function takes two `Option`s and returns the first one if it is `Some`.\nIf either the first `Option` or the second `Option` is `None`, the result\nwill be `None`. This operation \"zips\" the two `Option`s while discarding the\nvalue from the second `Option`.\n\nThis is useful when sequencing computations where the second `Option`\nrepresents a dependency or condition that must hold, but its value is\nirrelevant.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "export declare const zipLeft: { <_>(that: Option<_>): <A>(self: Option<A>) => Option<A>; <A, X>(self: Option<A>, that: Option<X>): Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "composeK",
    "description": "Composes two functions that return `Option` values, creating a new function\nthat chains them together.\n\n**Details**\n\nThis function allows you to compose two computations, each represented by a\nfunction that returns an `Option`. The result of the first function is passed\nto the second function if it is `Some`. If the first function returns `None`,\nthe composed function short-circuits and returns `None` without invoking the\nsecond function.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconst parse = (s: string): Option.Option<number> => isNaN(Number(s)) ? Option.none() : Option.some(Number(s))\n\nconst double = (n: number): Option.Option<number> => n > 0 ? Option.some(n * 2) : Option.none()\n\nconst parseAndDouble = Option.composeK(parse, double)\n\nconsole.log(parseAndDouble(\"42\"))\n// Output: { _id: 'Option', _tag: 'Some', value: 84 }\n\nconsole.log(parseAndDouble(\"not a number\"))\n// Output: { _id: 'Option', _tag: 'None' }"
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const composeK: { <B, C>(bfc: (b: B) => Option<C>): <A>(afb: (a: A) => Option<B>) => (a: A) => Option<C>; <A, B, C>(afb: (a: A) => Option<B>, bfc: (b: B) => Option<C>): (a: A) => Option<C>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "tap",
    "description": "Applies the provided function `f` to the value of the `Option` if it is\n`Some` and returns the original `Option`, unless `f` returns `None`, in which\ncase it returns `None`.\n\n**Details**\n\nThis function allows you to perform additional computations on the value of\nan `Option` without modifying its original value. If the `Option` is `Some`,\nthe provided function `f` is executed with the value, and its result\ndetermines whether the original `Option` is returned (`Some`) or the result\nis `None` if `f` returns `None`. If the input `Option` is `None`, the\nfunction is not executed, and `None` is returned.\n\nThis is particularly useful for applying side conditions or performing\nvalidation checks while retaining the original `Option`'s value.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconst getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()\n\nconsole.log(Option.tap(Option.none(), getInteger))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.tap(Option.some(1), getInteger))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(Option.tap(Option.some(1.14), getInteger))\n// Output: { _id: 'Option', _tag: 'None' }"
    ],
    "since": "2.0.0",
    "category": "Sequencing",
    "signature": "export declare const tap: { <A, X>(f: (a: A) => Option<X>): (self: Option<A>) => Option<A>; <A, X>(self: Option<A>, f: (a: A) => Option<X>): Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Combines two `Option` values into a new `Option` by applying a provided\nfunction to their values.\n\n**Details**\n\nThis function takes two `Option` values (`self` and `that`) and a combining\nfunction `f`. If both `Option` values are `Some`, the function `f` is applied\nto their values, and the result is wrapped in a new `Some`. If either\n`Option` is `None`, the result is `None`.\n\nThis utility is useful for combining two optional computations into a single\nresult while maintaining type safety and avoiding explicit checks for `None`.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconst maybeName: Option.Option<string> = Option.some(\"John\")\nconst maybeAge: Option.Option<number> = Option.some(25)\n\n// Combine the name and age into a person object\nconst person = Option.zipWith(maybeName, maybeAge, (name, age) => ({\n  name: name.toUpperCase(),\n  age\n}))\n\nconsole.log(person)\n// Output:\n// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }"
    ],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "export declare const zipWith: { <B, A, C>(that: Option<B>, f: (a: A, b: B) => C): (self: Option<A>) => Option<C>; <A, B, C>(self: Option<A>, that: Option<B>, f: (a: A, b: B) => C): Option<C>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "ap",
    "description": "Applies a function inside a `Some` to a value inside another `Some`,\ncombining them into a new `Option`.\n\n**Details**\n\nThis function allows you to apply a function wrapped in an `Option` (`self`)\nto a value wrapped in another `Option` (`that`). If both `Option`s are\n`Some`, the function is applied to the value, and the result is wrapped in a\nnew `Some`. If either `Option` is `None`, the result is `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Combining",
    "signature": "export declare const ap: { <A>(that: Option<A>): <B>(self: Option<(a: A) => B>) => Option<B>; <A, B>(self: Option<(a: A) => B>, that: Option<A>): Option<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "reduceCompact",
    "description": "Reduces an `Iterable` of `Option<A>` to a single value of type `B`, ignoring\nelements that are `None`.\n\n**Details**\n\nThis function takes an initial value of type `B` and a reducing function `f`\nthat combines the accumulator with values of type `A`. It processes an\niterable of `Option<A>`, applying `f` only to the `Some` values while\nignoring the `None` values. The result is a single value of type `B`.\n\nThis utility is particularly useful for aggregating values from an iterable\nof `Option`s while skipping the absent (`None`) values.",
    "deprecated": false,
    "examples": [
      "import { Option, pipe } from \"effect\"\n\nconst iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]\n\nconsole.log(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)))\n// Output: 3"
    ],
    "since": "2.0.0",
    "category": "Reducing",
    "signature": "export declare const reduceCompact: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<Option<A>>) => B; <A, B>(self: Iterable<Option<A>>, b: B, f: (b: B, a: A) => B): B; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "partitionMap",
    "description": "Splits an `Option` into two `Option`s based on the result of a mapping\nfunction that produces an `Either`.\n\n**Details**\n\nThis function takes an `Option` and a mapping function `f` that converts its\nvalue into an `Either`. It returns a tuple of two `Option`s:\n\n- The first `Option` (`left`) contains the value from the `Left` side of the\n  `Either` if it exists, otherwise `None`.\n- The second `Option` (`right`) contains the value from the `Right` side of\n  the `Either` if it exists, otherwise `None`.\n\nIf the input `Option` is `None`, both returned `Option`s are `None`.\n\nThis utility is useful for filtering and categorizing the contents of an\n`Option` based on a bifurcating computation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "export declare const partitionMap: { <A, B, C>(f: (a: A) => Either<C, B>): (self: Option<A>) => [left: Option<B>, right: Option<C>]; <A, B, C>(self: Option<A>, f: (a: A) => Either<C, B>): [left: Option<B>, right: Option<C>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Alias of {@link flatMap}.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\n// Transform and filter numbers\nconst transformEven = (n: Option.Option<number>): Option.Option<string> =>\n  Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))\n\nconsole.log(transformEven(Option.none()))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(transformEven(Option.some(1)))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(transformEven(Option.some(2)))\n// Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }"
    ],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "export declare const filterMap: { <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n\nIf you need to change the type of the `Option` in addition to filtering, see `filterMap`.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconst removeEmptyString = (input: Option.Option<string>) =>\n  Option.filter(input, (value) => value !== \"\")\n\nconsole.log(removeEmptyString(Option.none()))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(removeEmptyString(Option.some(\"\")))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(removeEmptyString(Option.some(\"a\")))\n// Output: { _id: 'Option', _tag: 'Some', value: 'a' }"
    ],
    "since": "2.0.0",
    "category": "Filtering",
    "signature": "export declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => Option<A>; <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Option<A>, predicate: Predicate<A>): Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "liftPredicate",
    "description": "Lifts a `Predicate` or `Refinement` into the `Option` context, returning a\n`Some` of the input value if the predicate is satisfied, or `None` otherwise.\n\n**Details**\n\nThis function transforms a `Predicate` (or a more specific `Refinement`) into\na function that produces an `Option`. If the predicate evaluates to `true`,\nthe input value is wrapped in a `Some`. If the predicate evaluates to\n`false`, the result is `None`.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\n// Check if a number is positive\nconst isPositive = (n: number) => n > 0\n\n//       (b: number) => Option<number>\n//      \nconst parsePositive = Option.liftPredicate(isPositive)\n\nconsole.log(parsePositive(1))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(parsePositive(-1))\n// OUtput: { _id: 'Option', _tag: 'None' }"
    ],
    "since": "2.0.0",
    "category": "Lifting",
    "signature": "export declare const liftPredicate: { <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Option<B>; <B extends A, A = B>(predicate: Predicate<A>): (b: B) => Option<B>; <A, B extends A>(self: A, refinement: Refinement<A, B>): Option<B>; <B extends A, A = B>(self: B, predicate: Predicate<A>): Option<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "contains",
    "description": "Returns a function that checks if an `Option` contains a specified value\nusing the default `Equivalence`.\n\n**Details**\n\nThis function allows you to check whether an `Option` contains a specific\nvalue. It uses the default `Equivalence` for equality comparison. If the\n`Option` is `Some` and its value is equivalent to the provided value, the\nresult is `true`. If the `Option` is `None` or the values are not equivalent,\nthe result is `false`.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconsole.log(Option.some(2).pipe(Option.contains(2)))\n// Output: true\n\nconsole.log(Option.some(1).pipe(Option.contains(2)))\n// Output: false\n\nconsole.log(Option.none().pipe(Option.contains(2)))\n// Output: false"
    ],
    "since": "2.0.0",
    "category": "Elements",
    "signature": "export declare const contains: { <A>(a: A): (self: Option<A>) => boolean; <A>(self: Option<A>, a: A): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "exists",
    "description": "Checks if a value in an `Option` satisfies a given predicate or refinement.\n\n**Details**\n\nThis function allows you to check if a value inside a `Some` meets a\nspecified condition. If the `Option` is `None`, the result is `false`. If the\n`Option` is `Some`, the provided predicate or refinement is applied to the\nvalue:\n\n- If the condition is met, the result is `true`.\n- If the condition is not met, the result is `false`.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconst isEven = (n: number) => n % 2 === 0\n\nconsole.log(Option.some(2).pipe(Option.exists(isEven)))\n// Output: true\n\nconsole.log(Option.some(1).pipe(Option.exists(isEven)))\n// Output: false\n\nconsole.log(Option.none().pipe(Option.exists(isEven)))\n// Output: false"
    ],
    "since": "2.0.0",
    "category": "Elements",
    "signature": "export declare const exists: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => self is Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => boolean; <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): self is Option<B>; <A>(self: Option<A>, predicate: Predicate<A>): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "bindTo",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope",
    "deprecated": false,
    "examples": [
      "import { Option, pipe } from \"effect\"\n\nconst result = pipe(\n  Option.Do,\n  Option.bind(\"x\", () => Option.some(2)),\n  Option.bind(\"y\", () => Option.some(3)),\n  Option.let(\"sum\", ({ x, y }) => x + y),\n  Option.filter(({ x, y }) => x * y > 5)\n)\nassert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))"
    ],
    "since": "2.0.0",
    "category": "Do notation",
    "signature": "export declare const bindTo: { <N extends string>(name: N): <A>(self: Option<A>) => Option<{ [K in N]: A; }>; <A, N extends string>(self: Option<A>, name: N): Option<{ [K in N]: A; }>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "bind",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope",
    "deprecated": false,
    "examples": [
      "import { Option, pipe } from \"effect\"\n\nconst result = pipe(\n  Option.Do,\n  Option.bind(\"x\", () => Option.some(2)),\n  Option.bind(\"y\", () => Option.some(3)),\n  Option.let(\"sum\", ({ x, y }) => x + y),\n  Option.filter(({ x, y }) => x * y > 5)\n)\nassert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))"
    ],
    "since": "2.0.0",
    "category": "Do notation",
    "signature": "export declare const bind: { <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Option<B>): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <A extends object, N extends string, B>(self: Option<A>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Option<B>): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "Do",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope",
    "deprecated": false,
    "examples": [
      "import { Option, pipe } from \"effect\"\n\nconst result = pipe(\n  Option.Do,\n  Option.bind(\"x\", () => Option.some(2)),\n  Option.bind(\"y\", () => Option.some(3)),\n  Option.let(\"sum\", ({ x, y }) => x + y),\n  Option.filter(({ x, y }) => x * y > 5)\n)\nassert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))"
    ],
    "since": "2.0.0",
    "category": "Do notation",
    "signature": "export declare const Do: Option<{}>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "void",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const void: Option<void>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "let",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope",
    "deprecated": false,
    "examples": [
      "import { Option, pipe } from \"effect\"\n\nconst result = pipe(\n  Option.Do,\n  Option.bind(\"x\", () => Option.some(2)),\n  Option.bind(\"y\", () => Option.some(3)),\n  Option.let(\"sum\", ({ x, y }) => x + y),\n  Option.filter(({ x, y }) => x * y > 5)\n)\nassert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))\n"
    ],
    "since": "2.0.0",
    "category": "Do notation",
    "signature": "export declare const let: { <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <A extends object, N extends string, B>(self: Option<A>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "none",
    "description": "Represents the absence of a value by creating an empty `Option`.\n\n`Option.none` returns an `Option<never>`, which is a subtype of `Option<A>`.\nThis means you can use it in place of any `Option<A>` regardless of the type\n`A`.",
    "deprecated": false,
    "examples": [
      "// Title: Creating an Option with No Value\nimport { Option } from \"effect\"\n\n// An Option holding no value\n//\n//       Option<never>\n//      \nconst noValue = Option.none()\n\nconsole.log(noValue)\n// Output: { _id: 'Option', _tag: 'None' }"
    ],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "toRefinement",
    "description": "Converts an `Option`-returning function into a type guard.\n\n**Details**\n\nThis function transforms a function that returns an `Option` into a type\nguard, ensuring type safety when validating or narrowing types. The returned\ntype guard function checks whether the input satisfies the condition defined\nin the original `Option`-returning function.\n\nIf the original function returns `Option.some`, the type guard evaluates to\n`true`, confirming the input is of the desired type. If the function returns\n`Option.none`, the type guard evaluates to `false`.\n\nThis utility is especially useful for validating types in union types,\nfiltering arrays, or ensuring safe handling of specific subtypes.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\ntype MyData = string | number\n\nconst parseString = (data: MyData): Option.Option<string> =>\n  typeof data === \"string\" ? Option.some(data) : Option.none()\n\n//       (a: MyData) => a is string\n//      \nconst isString = Option.toRefinement(parseString)\n\nconsole.log(isString(\"a\"))\n// Output: true\n\nconsole.log(isString(1))\n// Output: false"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Converts an `Iterable` into an `Option`, wrapping the first element if it\nexists.\n\n**Details**\n\nThis function takes an `Iterable` (e.g., an array, a generator, or any object\nimplementing the `Iterable` interface) and returns an `Option` based on its\ncontent:\n\n- If the `Iterable` contains at least one element, the first element is\n  wrapped in a `Some` and returned.\n- If the `Iterable` is empty, `None` is returned, representing the absence of\n  a value.\n\nThis utility is useful for safely handling collections that might be empty,\nensuring you explicitly handle both cases where a value exists or doesn't.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconsole.log(Option.fromIterable([1, 2, 3]))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(Option.fromIterable([]))\n// Output: { _id: 'Option', _tag: 'None' }"
    ],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "firstSomeOf",
    "description": "Returns the first `Some` value found in an `Iterable` collection of\n`Option`s, or `None` if no `Some` is found.\n\n**Details**\n\nThis function iterates over a collection of `Option` values and returns the\nfirst `Some` it encounters. If the collection contains only `None` values,\nthe result will also be `None`. This utility is useful for efficiently\nfinding the first valid value in a sequence of potentially empty or invalid\noptions.\n\nThe iteration stops as soon as a `Some` is found, making this function\nefficient for large collections.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconsole.log(Option.firstSomeOf([\n  Option.none(),\n  Option.some(1),\n  Option.some(2)\n]))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }"
    ],
    "since": "2.0.0",
    "category": "Error handling",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "fromNullable",
    "description": "Converts a nullable value into an `Option`. Returns `None` if the value is\n`null` or `undefined`, otherwise wraps the value in a `Some`.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconsole.log(Option.fromNullable(undefined))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.fromNullable(null))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(Option.fromNullable(1))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "liftNullable",
    "description": "Lifts a function that returns `null` or `undefined` into the `Option`\ncontext.\n\n**Details**\n\nThis function takes a function `f` that might return `null` or `undefined`\nand transforms it into a function that returns an `Option`. The resulting\nfunction will return:\n- `Some` if the original function produces a non-null, non-undefined value.\n- `None` if the original function produces `null` or `undefined`.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconst parse = (s: string): number | undefined => {\n  const n = parseFloat(s)\n  return isNaN(n) ? undefined : n\n}\n\nconst parseOption = Option.liftNullable(parse)\n\nconsole.log(parseOption(\"1\"))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(parseOption(\"not a number\"))\n// Output: { _id: 'Option', _tag: 'None' }"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "liftThrowable",
    "description": "Lifts a function that throws exceptions into a function that returns an\n`Option`.\n\n**Details**\n\nThis utility function takes a function `f` that might throw an exception and\ntransforms it into a safer function that returns an `Option`. If the original\nfunction executes successfully, the result is wrapped in a `Some`. If an\nexception is thrown, the result is `None`, allowing the developer to handle\nerrors in a functional, type-safe way.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconst parse = Option.liftThrowable(JSON.parse)\n\nconsole.log(parse(\"1\"))\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\nconsole.log(parse(\"\"))\n// Output: { _id: 'Option', _tag: 'None' }"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "product",
    "description": "Combines two `Option` values into a single `Option` containing a tuple of\ntheir values if both are `Some`.\n\n**Details**\n\nThis function takes two `Option`s and combines their values into a tuple `[A,\nB]` if both are `Some`. If either of the `Option`s is `None`, the result is\n`None`. This is particularly useful for combining multiple `Option` values\ninto a single one, ensuring both contain valid values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Combining",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "productMany",
    "description": "Combines an `Option` with a collection of `Option`s into a single `Option`\ncontaining a tuple of their values if all are `Some`.\n\n**Details**\n\nThis function takes a primary `Option` and a collection of `Option`s and\ncombines their values into a tuple `[A, ...Array<A>]` if all are `Some`. If\nthe primary `Option` or any `Option` in the collection is `None`, the result\nis `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Combining",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "all",
    "description": "Combines a structure of `Option`s into a single `Option` containing the\nvalues with the same structure.\n\n**Details**\n\nThis function takes a structure of `Option`s (a tuple, struct, or iterable)\nand produces a single `Option` that contains the values from the input\nstructure if all `Option`s are `Some`. If any `Option` in the input is\n`None`, the result is `None`. The structure of the input is preserved in the\noutput.\n\n- If the input is a tuple (e.g., an array), the result will be an `Option`\n  containing a tuple with the same length.\n- If the input is a struct (e.g., an object), the result will be an `Option`\n  containing a struct with the same keys.\n- If the input is an iterable, the result will be an `Option` containing an\n  array.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconst maybeName: Option.Option<string> = Option.some(\"John\")\nconst maybeAge: Option.Option<number> = Option.some(25)\n\n//       Option<[string, number]>\n//      \nconst tuple = Option.all([maybeName, maybeAge])\nconsole.log(tuple)\n// Output:\n// { _id: 'Option', _tag: 'Some', value: [ 'John', 25 ] }\n\n//       Option<{ name: string; age: number; }>\n//      \nconst struct = Option.all({ name: maybeName, age: maybeAge })\nconsole.log(struct)\n// Output:\n// { _id: 'Option', _tag: 'Some', value: { name: 'John', age: 25 } }"
    ],
    "since": "2.0.0",
    "category": "Combining",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "toArray",
    "description": "Converts an `Option` into an `Array`.\nIf the input is `None`, an empty array is returned.\nIf the input is `Some`, its value is wrapped in a single-element array.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\nconsole.log(Option.toArray(Option.some(1)))\n// Output: [1]\n\nconsole.log(Option.toArray(Option.none()))\n// Output: []"
    ],
    "since": "2.0.0",
    "category": "Conversions",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": "Creates an `Equivalence` instance for comparing `Option` values, using a\nprovided `Equivalence` for the inner type.\n\n**Details**\n\nThis function takes an `Equivalence` instance for a specific type `A` and\nproduces an `Equivalence` instance for `Option<A>`. The resulting\n`Equivalence` determines whether two `Option` values are equivalent:\n\n- Two `None`s are considered equivalent.\n- A `Some` and a `None` are not equivalent.\n- Two `Some` values are equivalent if their inner values are equivalent\n  according to the provided `Equivalence`.",
    "deprecated": false,
    "examples": [
      "// Title: Comparing Optional Numbers for Equivalence\nimport { Number, Option } from \"effect\"\n\nconst isEquivalent = Option.getEquivalence(Number.Equivalence)\n\nconsole.log(isEquivalent(Option.none(), Option.none()))\n// Output: true\n\nconsole.log(isEquivalent(Option.none(), Option.some(1)))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.none()))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.some(2)))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.some(1)))\n// Output: true"
    ],
    "since": "2.0.0",
    "category": "Equivalence",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "getOrder",
    "description": "Creates an `Order` instance for comparing `Option` values, using a provided\n`Order` for the inner type.\n\n**Details**\n\nThis function produces an `Order` instance for `Option<A>`, allowing `Option`\nvalues to be compared:\n\n- `None` is always considered less than any `Some` value.\n- If both are `Some`, their inner values are compared using the provided\n  `Order` instance.",
    "deprecated": false,
    "examples": [
      "import { Number, Option } from \"effect\"\n\nconst order = Option.getOrder(Number.Order)\n\nconsole.log(order(Option.none(), Option.none()))\n// Output: 0\n\nconsole.log(order(Option.none(), Option.some(1)))\n// Output: -1\n\nconsole.log(order(Option.some(1), Option.none()))\n// Output: 1\n\nconsole.log(order(Option.some(1), Option.some(2)))\n// Output: -1\n\nconsole.log(order(Option.some(1), Option.some(1)))\n// Output: 0"
    ],
    "since": "2.0.0",
    "category": "Sorting",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "lift2",
    "description": "Lifts a binary function to work with `Option` values, allowing the function\nto operate on two `Option`s.\n\n**Details**\n\nThis function takes a binary function `f` and returns a new function that\napplies `f` to the values of two `Option`s (`self` and `that`). If both\n`Option`s are `Some`, the binary function `f` is applied to their values, and\nthe result is wrapped in a new `Some`. If either `Option` is `None`, the\nresult is `None`.",
    "deprecated": false,
    "examples": [
      "import { Option } from \"effect\"\n\n// A binary function to add two numbers\nconst add = (a: number, b: number): number => a + b\n\n// Lift the `add` function to work with `Option` values\nconst addOptions = Option.lift2(add)\n\n// Both `Option`s are `Some`\nconsole.log(addOptions(Option.some(2), Option.some(3)))\n// Output: { _id: 'Option', _tag: 'Some', value: 5 }\n\n// One `Option` is `None`\nconsole.log(addOptions(Option.some(2), Option.none()))\n// Output: { _id: 'Option', _tag: 'None' }"
    ],
    "since": "2.0.0",
    "category": "Lifting",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "containsWith",
    "description": "Returns a function that checks if an `Option` contains a specified value,\nusing a provided equivalence function.\n\n**Details**\n\nThis function allows you to check whether an `Option` contains a specific\nvalue. It uses an equivalence function `isEquivalent` to compare the value\ninside the `Option` to the provided value. If the `Option` is `Some` and the\nequivalence function returns `true`, the result is `true`. If the `Option` is\n`None` or the values are not equivalent, the result is `false`.",
    "deprecated": false,
    "examples": [
      "import { Number, Option } from \"effect\"\n\nconst contains = Option.containsWith(Number.Equivalence)\n\nconsole.log(Option.some(2).pipe(contains(2)))\n// Output: true\n\nconsole.log(Option.some(1).pipe(contains(2)))\n// Output: false\n\nconsole.log(Option.none().pipe(contains(2)))\n// Output: false"
    ],
    "since": "2.0.0",
    "category": "Elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "gen",
    "description": "Similar to `Effect.gen`, `Option.gen` provides a more readable,\ngenerator-based syntax for working with `Option` values, making code that\ninvolves `Option` easier to write and understand. This approach is similar to\nusing `async/await` but tailored for `Option`.",
    "deprecated": false,
    "examples": [
      "// Title: Using Option.gen to Create a Combined Value\nimport { Option } from \"effect\"\n\nconst maybeName: Option.Option<string> = Option.some(\"John\")\nconst maybeAge: Option.Option<number> = Option.some(25)\n\nconst person = Option.gen(function* () {\n  const name = (yield* maybeName).toUpperCase()\n  const age = yield* maybeAge\n  return { name, age }\n})\n\nconsole.log(person)\n// Output:\n// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }"
    ],
    "since": "2.0.0",
    "category": "Generators",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "None",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface None<out A> extends Pipeable, Inspectable {\n  readonly _tag: \"None\"\n  readonly _op: \"None\"\n  readonly [TypeId]: {\n    readonly _A: Covariant<A>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: OptionUnify<this>\n  [Unify.ignoreSymbol]?: OptionUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "OptionTypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Type Lambdas",
    "signature": "export interface OptionTypeLambda extends TypeLambda {\n  readonly type: Option<this[\"Target\"]>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "OptionUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface OptionUnify<A extends { [Unify.typeSymbol]?: any }> {\n  Option?: () => A[Unify.typeSymbol] extends Option<infer A0> | infer _ ? Option<A0> : never\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "OptionUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface OptionUnifyIgnore {}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "Some",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface Some<out A> extends Pipeable, Inspectable {\n  readonly _tag: \"Some\"\n  readonly _op: \"Some\"\n  readonly value: A\n  readonly [TypeId]: {\n    readonly _A: Covariant<A>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: OptionUnify<this>\n  [Unify.ignoreSymbol]?: OptionUnifyIgnore\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "Option",
    "description": "The `Option` data type represents optional values. An `Option<A>` can either\nbe `Some<A>`, containing a value of type `A`, or `None`, representing the\nabsence of a value.\n\n**When to Use**\n\nYou can use `Option` in scenarios like:\n\n- Using it for initial values\n- Returning values from functions that are not defined for all possible\n  inputs (referred to as partial functions)\n- Managing optional fields in data structures\n- Handling optional function arguments",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export type Option<A> = None<A> | Some<A>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Option",
      "path": [
        "src",
        "Option.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "string",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const string: Order<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "number",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const number: Order<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "boolean",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const boolean: Order<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "bigint",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const bigint: Order<bigint>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "combine",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "export declare const combine: { <A>(that: Order<A>): (self: Order<A>) => Order<A>; <A>(self: Order<A>, that: Order<A>): Order<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "combineMany",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "export declare const combineMany: { <A>(collection: Iterable<Order<A>>): (self: Order<A>) => Order<A>; <A>(self: Order<A>, collection: Iterable<Order<A>>): Order<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "mapInput",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapInput: { <B, A>(f: (b: B) => A): (self: Order<A>) => Order<B>; <A, B>(self: Order<A>, f: (b: B) => A): Order<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "Date",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Date: Order<Date>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "product",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "export declare const product: { <B>(that: Order<B>): <A>(self: Order<A>) => Order<readonly [A, B]>; <A, B>(self: Order<A>, that: Order<B>): Order<readonly [A, B]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "productMany",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "export declare const productMany: { <A>(collection: Iterable<Order<A>>): (self: Order<A>) => Order<readonly [A, ...Array<A>]>; <A>(self: Order<A>, collection: Iterable<Order<A>>): Order<readonly [A, ...Array<A>]>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "reverse",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "combineAll",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "all",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "tuple",
    "description": "Similar to `Promise.all` but operates on `Order`s.\n\n```\n[Order<A>, Order<B>, ...] -> Order<[A, B, ...]>\n```\n\nThis function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\nThe returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\nIt is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\nof the tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "array",
    "description": "This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\nThe returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\nIf all elements are equal, the arrays are then compared based on their length.\nIt is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "struct",
    "description": "This function creates and returns a new `Order` for a struct of values based on the given `Order`s\nfor each property in the struct.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "lessThan",
    "description": "Test whether one value is _strictly less than_ another.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThan",
    "description": "Test whether one value is _strictly greater than_ another.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanOrEqualTo",
    "description": "Test whether one value is _non-strictly less than_ another.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanOrEqualTo",
    "description": "Test whether one value is _non-strictly greater than_ another.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "min",
    "description": "Take the minimum of two values. If they are considered equal, the first argument is chosen.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "max",
    "description": "Take the maximum of two values. If they are considered equal, the first argument is chosen.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "clamp",
    "description": "Clamp a value between a minimum and a maximum.",
    "deprecated": false,
    "examples": [
      "import { Order, Number } from \"effect\"\n\nconst clamp = Order.clamp(Number.Order)({ minimum: 1, maximum: 5 })\n\nassert.equal(clamp(3), 3)\nassert.equal(clamp(0), 1)\nassert.equal(clamp(6), 5)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "between",
    "description": "Test whether a value is between a minimum and a maximum (inclusive).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "Order",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type class",
    "signature": "export interface Order<in A> {\n  (self: A, that: A): -1 | 0 | 1\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Order",
      "path": [
        "src",
        "Order.ts"
      ]
    },
    "project": "effect",
    "name": "OrderTypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface OrderTypeLambda extends TypeLambda {\n  readonly type: Order<this[\"Target\"]>\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ordering",
      "path": [
        "src",
        "Ordering.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Depending on the `Ordering` parameter given to it, returns a value produced by one of the 3 functions provided as parameters.",
    "deprecated": false,
    "examples": [
      "import { Ordering } from \"effect\"\nimport { constant } from \"effect/Function\"\n\nconst toMessage = Ordering.match({\n  onLessThan: constant('less than'),\n  onEqual: constant('equal'),\n  onGreaterThan: constant('greater than')\n})\n\nassert.deepStrictEqual(toMessage(-1), \"less than\")\nassert.deepStrictEqual(toMessage(0), \"equal\")\nassert.deepStrictEqual(toMessage(1), \"greater than\")"
    ],
    "since": "2.0.0",
    "category": "pattern matching",
    "signature": "export declare const match: { <A, B, C = B>(options: { readonly onLessThan: LazyArg<A>; readonly onEqual: LazyArg<B>; readonly onGreaterThan: LazyArg<C>; }): (self: Ordering) => A | B | C; <A, B, C = B>(o: Ordering, options: { readonly onLessThan: LazyArg<A>; readonly onEqual: LazyArg<B>; readonly onGreaterThan: LazyArg<C>; }): A | B | C; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ordering",
      "path": [
        "src",
        "Ordering.ts"
      ]
    },
    "project": "effect",
    "name": "combine",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "export declare const combine: { (that: Ordering): (self: Ordering) => Ordering; (self: Ordering, that: Ordering): Ordering; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ordering",
      "path": [
        "src",
        "Ordering.ts"
      ]
    },
    "project": "effect",
    "name": "combineMany",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": "export declare const combineMany: { (collection: Iterable<Ordering>): (self: Ordering) => Ordering; (self: Ordering, collection: Iterable<Ordering>): Ordering; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Ordering",
      "path": [
        "src",
        "Ordering.ts"
      ]
    },
    "project": "effect",
    "name": "reverse",
    "description": "Inverts the ordering of the input `Ordering`.",
    "deprecated": false,
    "examples": [
      "import { reverse } from \"effect/Ordering\"\n\nassert.deepStrictEqual(reverse(1), -1)\nassert.deepStrictEqual(reverse(-1), 1)\nassert.deepStrictEqual(reverse(0), 0)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Ordering",
      "path": [
        "src",
        "Ordering.ts"
      ]
    },
    "project": "effect",
    "name": "combineAll",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": null
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Ordering",
      "path": [
        "src",
        "Ordering.ts"
      ]
    },
    "project": "effect",
    "name": "Ordering",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export type Ordering = -1 | 0 | 1"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "Composite",
    "description": "Error that contains multiple issues.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Composite { constructor(\n    readonly ast: AST.AST,\n    readonly actual: unknown,\n    readonly issues: SingleOrNonEmpty<ParseIssue>,\n    readonly output?: unknown\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "Forbidden",
    "description": "The `Forbidden` variant of the `ParseIssue` type represents a forbidden operation, such as when encountering an Effect that is not allowed to execute (e.g., using `runSync`).",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Forbidden { constructor(\n    readonly ast: AST.AST,\n    readonly actual: unknown,\n    readonly message?: string\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "Missing",
    "description": "Error that occurs when a required key or index is missing.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Missing { constructor(\n    /**\n     * @since 3.10.0\n     */\n    readonly ast: AST.Type,\n    /**\n     * @since 3.10.0\n     */\n    readonly message?: string\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "ParseError",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export declare class ParseError"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "Pointer",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Pointer { constructor(\n    readonly path: Path,\n    readonly actual: unknown,\n    readonly issue: ParseIssue\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "Refinement",
    "description": "Error that occurs when a refinement has an error.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Refinement { constructor(\n    readonly ast: AST.Refinement,\n    readonly actual: unknown,\n    readonly kind: \"From\" | \"Predicate\",\n    readonly issue: ParseIssue\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "Transformation",
    "description": "Error that occurs when a transformation has an error.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Transformation { constructor(\n    readonly ast: AST.Transformation,\n    readonly actual: unknown,\n    readonly kind: \"Encoded\" | \"Transformation\" | \"Type\",\n    readonly issue: ParseIssue\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "Type",
    "description": "The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.\nThe `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Type { constructor(\n    readonly ast: AST.AST,\n    readonly actual: unknown,\n    readonly message?: string\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "Unexpected",
    "description": "Error that occurs when an unexpected key or index is present.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Unexpected { constructor(\n    readonly actual: unknown,\n    /**\n     * @since 3.10.0\n     */\n    readonly message?: string\n  ) }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "ParseErrorTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "type id",
    "signature": "export declare const ParseErrorTypeId: typeof ParseErrorTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const succeed: <A>(a: A) => Either.Either<A, ParseIssue>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const fail: (issue: ParseIssue) => Either.Either<never, ParseIssue>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "fromOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const fromOption: { (onNone: () => ParseIssue): <A>(self: Option.Option<A>) => Either.Either<A, ParseIssue>; <A>(self: Option.Option<A>, onNone: () => ParseIssue): Either.Either<A, ParseIssue>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "optimisation",
    "signature": "export declare const flatMap: { <A, B, E1, R1>(f: (a: A) => Effect.Effect<B, E1, R1>): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect.Effect<A, E, R>, f: (a: A) => Effect.Effect<B, E1, R1>): Effect.Effect<B, E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "optimisation",
    "signature": "export declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>; <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "mapError",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "optimisation",
    "signature": "export declare const mapError: { <E, E2>(f: (e: E) => E2): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>; <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "mapBoth",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "optimisation",
    "signature": "export declare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R>; <A, E, R, E2, A2>(self: Effect.Effect<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Effect.Effect<A2, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "orElse",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "optimisation",
    "signature": "export declare const orElse: { <E, A2, E2, R2>(f: (e: E) => Effect.Effect<A2, E2, R2>): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect.Effect<A, E, R>, f: (e: E) => Effect.Effect<A2, E2, R2>): Effect.Effect<A2 | A, E2, R2 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "decodeSync",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const decodeSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => A"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "decodeOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const decodeOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Option.Option<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "decodeEither",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const decodeEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "decodePromise",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const decodePromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Promise<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "decode",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const decode: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "encodeSync",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const encodeSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => I"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "encodeOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const encodeOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (input: A, overrideOptions?: AST.ParseOptions) => Option.Option<I>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "encodeEither",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const encodeEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => Either.Either<I, ParseIssue>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "encodePromise",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const encodePromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => Promise<I>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "encode",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const encode: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => Effect.Effect<I, ParseIssue, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "TreeFormatter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "formatting",
    "signature": "export declare const TreeFormatter: ParseResultFormatter<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "isComposite",
    "description": "Returns `true` if the value is a `Composite`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isComposite: (issue: ParseIssue) => issue is Extract<ParseIssue, { _tag: \"Composite\"; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "ArrayFormatter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "formatting",
    "signature": "export declare const ArrayFormatter: ParseResultFormatter<ArrayFormatterIssue[]>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "try",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const try: <A>(options: { try: LazyArg<A>; catch: (e: unknown) => ParseIssue; }) => Either.Either<A, ParseIssue>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "isParseError",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "parseError",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "eitherOrUndefined",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "optimisation",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "decodeUnknownSync",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "decodeUnknownOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "decodeUnknownEither",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "decodeUnknownPromise",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "decodeUnknown",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "encodeUnknownSync",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "encodeUnknownOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "encodeUnknownEither",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "encodeUnknownPromise",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "encodeUnknown",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "validateSync",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "validateOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "validateEither",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "validatePromise",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "validate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "is",
    "description": "By default the option `exact` is set to `true`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "asserts",
    "description": "By default the option `exact` is set to `true`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "ArrayFormatterIssue",
    "description": "Represents an issue returned by the {@link ArrayFormatter} formatter.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface ArrayFormatterIssue {\n  /**\n   * The tag identifying the type of parse issue.\n   */\n  readonly _tag: ParseIssue[\"_tag\"]\n\n  /**\n   * The path to the property where the issue occurred.\n   */\n  readonly path: ReadonlyArray<PropertyKey>\n\n  /**\n   * A descriptive message explaining the issue.\n   */\n  readonly message: string\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "ParseResultFormatter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "formatting",
    "signature": "export interface ParseResultFormatter<A> {\n  readonly formatIssue: (issue: ParseIssue) => Effect.Effect<A>\n  readonly formatIssueSync: (issue: ParseIssue) => A\n  readonly formatError: (error: ParseError) => Effect.Effect<A>\n  readonly formatErrorSync: (error: ParseError) => A\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "DeclarationDecodeUnknown",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export type DeclarationDecodeUnknown<Out, R> = (\n  u: unknown,\n  options: AST.ParseOptions,\n  ast: AST.Declaration\n) => Effect.Effect<Out, ParseIssue, R>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "DecodeUnknown",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export type DecodeUnknown<Out, R> = (u: unknown, options?: AST.ParseOptions) => Effect.Effect<Out, ParseIssue, R>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "ParseErrorTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "type id",
    "signature": "export type ParseErrorTypeId = typeof ParseErrorTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "ParseIssue",
    "description": "`ParseIssue` is a type that represents the different types of errors that can occur when decoding/encoding a value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export type ParseIssue =\n  // leaf\n  | Type\n  | Missing\n  | Unexpected\n  | Forbidden\n  // composite\n  | Pointer\n  | Refinement\n  | Transformation\n  | Composite"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "Path",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export type Path = SingleOrNonEmpty<PropertyKey>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ParseResult",
      "path": [
        "src",
        "ParseResult.ts"
      ]
    },
    "project": "effect",
    "name": "SingleOrNonEmpty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export type SingleOrNonEmpty<A> = A | Arr.NonEmptyReadonlyArray<A>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Pipeable",
      "path": [
        "src",
        "Pipeable.ts"
      ]
    },
    "project": "effect",
    "name": "pipeArguments",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Pipeable",
      "path": [
        "src",
        "Pipeable.ts"
      ]
    },
    "project": "effect",
    "name": "Pipeable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Pipeable {\n  pipe<A>(this: A): A\n  pipe<A, B = never>(this: A, ab: (_: A) => B): B\n  pipe<A, B = never, C = never>(this: A, ab: (_: A) => B, bc: (_: B) => C): C\n  pipe<A, B = never, C = never, D = never>(this: A, ab: (_: A) => B, bc: (_: B) => C, cd: (_: C) => D): D\n  pipe<A, B = never, C = never, D = never, E = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E\n  ): E\n  pipe<A, B = never, C = never, D = never, E = never, F = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F\n  ): F\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G\n  ): G\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H\n  ): H\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I\n  ): I\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J\n  ): J\n  pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never>(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K\n  ): K\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L\n  ): L\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M\n  ): M\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N\n  ): N\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O\n  ): O\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P\n  ): P\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q\n  ): Q\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R\n  ): R\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S\n  ): S\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never,\n    T = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S,\n    st: (_: S) => T\n  ): T\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never,\n    T = never,\n    U = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S,\n    st: (_: S) => T,\n    tu: (_: T) => U\n  ): U\n  pipe<\n    A,\n    B = never,\n    C = never,\n    D = never,\n    E = never,\n    F = never,\n    G = never,\n    H = never,\n    I = never,\n    J = never,\n    K = never,\n    L = never,\n    M = never,\n    N = never,\n    O = never,\n    P = never,\n    Q = never,\n    R = never,\n    S = never,\n    T = never,\n    U = never\n  >(\n    this: A,\n    ab: (_: A) => B,\n    bc: (_: B) => C,\n    cd: (_: C) => D,\n    de: (_: D) => E,\n    ef: (_: E) => F,\n    fg: (_: F) => G,\n    gh: (_: G) => H,\n    hi: (_: H) => I,\n    ij: (_: I) => J,\n    jk: (_: J) => K,\n    kl: (_: K) => L,\n    lm: (_: L) => M,\n    mn: (_: M) => N,\n    no: (_: N) => O,\n    op: (_: O) => P,\n    pq: (_: P) => Q,\n    qr: (_: Q) => R,\n    rs: (_: R) => S,\n    st: (_: S) => T,\n    tu: (_: T) => U\n  ): U\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pool",
      "path": [
        "src",
        "Pool.ts"
      ]
    },
    "project": "effect",
    "name": "PoolTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const PoolTypeId: typeof PoolTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pool",
      "path": [
        "src",
        "Pool.ts"
      ]
    },
    "project": "effect",
    "name": "isPool",
    "description": "Returns `true` if the specified value is a `Pool`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isPool: (u: unknown) => u is Pool<unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pool",
      "path": [
        "src",
        "Pool.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Makes a new pool of the specified fixed size. The pool is returned in a\n`Scope`, which governs the lifetime of the pool. When the pool is shutdown\nbecause the `Scope` is closed, the individual items allocated by the pool\nwill be released in some unspecified order.\n\nBy setting the `concurrency` parameter, you can control the level of concurrent\naccess per pool item. By default, the number of permits is set to `1`.\n\n`targetUtilization` determines when to create new pool items. It is a value\nbetween 0 and 1, where 1 means only create new pool items when all the existing\nitems are fully utilized.\n\nA `targetUtilization` of 0.5 will create new pool items when the existing items are\n50% utilized.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <A, E, R>(options: { readonly acquire: Effect.Effect<A, E, R>; readonly size: number; readonly concurrency?: number | undefined; readonly targetUtilization?: number | undefined; }) => Effect.Effect<Pool<A, E>, never, Scope.Scope | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pool",
      "path": [
        "src",
        "Pool.ts"
      ]
    },
    "project": "effect",
    "name": "makeWithTTL",
    "description": "Makes a new pool with the specified minimum and maximum sizes and time to\nlive before a pool whose excess items are not being used will be shrunk\ndown to the minimum size. The pool is returned in a `Scope`, which governs\nthe lifetime of the pool. When the pool is shutdown because the `Scope` is\nused, the individual items allocated by the pool will be released in some\nunspecified order.\n\nBy setting the `concurrency` parameter, you can control the level of concurrent\naccess per pool item. By default, the number of permits is set to `1`.\n\n`targetUtilization` determines when to create new pool items. It is a value\nbetween 0 and 1, where 1 means only create new pool items when all the existing\nitems are fully utilized.\n\nA `targetUtilization` of 0.5 will create new pool items when the existing items are\n50% utilized.\n\nThe `timeToLiveStrategy` determines how items are invalidated. If set to\n\"creation\", then items are invalidated based on their creation time. If set\nto \"usage\", then items are invalidated based on pool usage.\n\nBy default, the `timeToLiveStrategy` is set to \"usage\".\n\n```ts\nimport { createConnection } from \"mysql2\";\nimport { Duration, Effect, Pool } from \"effect\"\n\nconst acquireDBConnection = Effect.acquireRelease(\n  Effect.sync(() => createConnection('mysql://...')),\n  (connection) => Effect.sync(() => connection.end(() => {})),\n)\n\nconst connectionPool = Effect.flatMap(\n Pool.makeWithTTL({\n    acquire: acquireDBConnection,\n    min: 10,\n    max: 20,\n    timeToLive: Duration.seconds(60)\n  }),\n  (pool) => pool.get\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeWithTTL: <A, E, R>(options: { readonly acquire: Effect.Effect<A, E, R>; readonly min: number; readonly max: number; readonly concurrency?: number | undefined; readonly targetUtilization?: number | undefined; readonly timeToLive: Duration.DurationInput; readonly timeToLiveStrategy?: \"creation\" | \"usage\" | undefined; }) => Effect.Effect<Pool<A, E>, never, Scope.Scope | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pool",
      "path": [
        "src",
        "Pool.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves an item from the pool in a scoped effect. Note that if\nacquisition fails, then the returned effect will fail for that same reason.\nRetrying a failed acquisition attempt will repeat the acquisition attempt.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const get: <A, E>(self: Pool<A, E>) => Effect.Effect<A, E, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pool",
      "path": [
        "src",
        "Pool.ts"
      ]
    },
    "project": "effect",
    "name": "invalidate",
    "description": "Invalidates the specified item. This will cause the pool to eventually\nreallocate the item, although this reallocation may occur lazily rather\nthan eagerly.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const invalidate: { <A>(value: A): <E>(self: Pool<A, E>) => Effect.Effect<void, never, Scope.Scope>; <A, E>(self: Pool<A, E>, value: A): Effect.Effect<void, never, Scope.Scope>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Pool",
      "path": [
        "src",
        "Pool.ts"
      ]
    },
    "project": "effect",
    "name": "Pool",
    "description": "A `Pool<A, E>` is a pool of items of type `A`, each of which may be\nassociated with the acquisition and release of resources. An attempt to get\nan item `A` from a pool may fail with an error of type `E`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Pool<in out A, out E = never> extends Pool.Variance<A, E>, Effect.Effect<A, E, Scope.Scope>, Pipeable {\n  /**\n   * Retrieves an item from the pool in a scoped effect. Note that if\n   * acquisition fails, then the returned effect will fail for that same reason.\n   * Retrying a failed acquisition attempt will repeat the acquisition attempt.\n   */\n  readonly get: Effect.Effect<A, E, Scope.Scope>\n\n  /**\n   * Invalidates the specified item. This will cause the pool to eventually\n   * reallocate the item, although this reallocation may occur lazily rather\n   * than eagerly.\n   */\n  invalidate(item: A): Effect.Effect<void>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: PoolUnify<this>\n  readonly [Unify.ignoreSymbol]?: PoolUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Pool",
      "path": [
        "src",
        "Pool.ts"
      ]
    },
    "project": "effect",
    "name": "PoolUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface PoolUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Pool?: () => Extract<A[Unify.typeSymbol], Pool<any, any>> extends Pool<infer A0, infer _E0> | infer _ ?\n    A0 extends any ? Extract<A[Unify.typeSymbol], Pool<A0, any>> extends Pool<A0, infer E1> ? Pool<A0, E1>\n      : never\n    : never :\n    never\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Pool",
      "path": [
        "src",
        "Pool.ts"
      ]
    },
    "project": "effect",
    "name": "PoolUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface PoolUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Pool",
      "path": [
        "src",
        "Pool.ts"
      ]
    },
    "project": "effect",
    "name": "PoolTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type PoolTypeId = typeof PoolTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "mapInput",
    "description": "Given a `Predicate<A>` returns a `Predicate<B>`",
    "deprecated": false,
    "examples": [
      "import { Predicate, Number } from \"effect\"\n\nconst minLength3 = Predicate.mapInput(Number.greaterThan(2), (s: string) => s.length)\n\nassert.deepStrictEqual(minLength3(\"a\"), false)\nassert.deepStrictEqual(minLength3(\"aa\"), false)\nassert.deepStrictEqual(minLength3(\"aaa\"), true)\nassert.deepStrictEqual(minLength3(\"aaaa\"), true)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const mapInput: { <B, A>(f: (b: B) => A): (self: Predicate<A>) => Predicate<B>; <A, B>(self: Predicate<A>, f: (b: B) => A): Predicate<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isTupleOf",
    "description": "Determine if an `Array` is a tuple with exactly `N` elements, narrowing down the type to `TupleOf`.\n\nAn `Array` is considered to be a `TupleOf` if its length is exactly `N`.",
    "deprecated": false,
    "examples": [
      "import { isTupleOf } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isTupleOf([1, 2, 3], 3), true);\nassert.deepStrictEqual(isTupleOf([1, 2, 3], 2), false);\nassert.deepStrictEqual(isTupleOf([1, 2, 3], 4), false);\n\nconst arr: number[] = [1, 2, 3];\nif (isTupleOf(arr, 3)) {\n  console.log(arr);\n  // ^? [number, number, number]\n}"
    ],
    "since": "3.3.0",
    "category": "guards",
    "signature": "export declare const isTupleOf: { <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOf<N, T>; <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOf<N, T>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isTupleOfAtLeast",
    "description": "Determine if an `Array` is a tuple with at least `N` elements, narrowing down the type to `TupleOfAtLeast`.\n\nAn `Array` is considered to be a `TupleOfAtLeast` if its length is at least `N`.",
    "deprecated": false,
    "examples": [
      "import { isTupleOfAtLeast } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 3), true);\nassert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 2), true);\nassert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 4), false);\n\nconst arr: number[] = [1, 2, 3, 4];\nif (isTupleOfAtLeast(arr, 3)) {\n  console.log(arr);\n  // ^? [number, number, number, ...number[]]\n}"
    ],
    "since": "3.3.0",
    "category": "guards",
    "signature": "export declare const isTupleOfAtLeast: { <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOfAtLeast<N, T>; <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOfAtLeast<N, T>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isFunction",
    "description": "Tests if a value is a `function`.",
    "deprecated": false,
    "examples": [
      "import { isFunction } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isFunction(isFunction), true)\n\nassert.deepStrictEqual(isFunction(\"function\"), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isFunction: (input: unknown) => input is Function"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "hasProperty",
    "description": "Checks whether a value is an `object` containing a specified property key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const hasProperty: { <P extends PropertyKey>(property: P): (self: unknown) => self is { [K in P]: unknown; }; <P extends PropertyKey>(self: unknown, property: P): self is { [K in P]: unknown; }; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isTagged",
    "description": "Tests if a value is an `object` with a property `_tag` that matches the given tag.",
    "deprecated": false,
    "examples": [
      "import { isTagged } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isTagged(1, \"a\"), false)\nassert.deepStrictEqual(isTagged(null, \"a\"), false)\nassert.deepStrictEqual(isTagged({}, \"a\"), false)\nassert.deepStrictEqual(isTagged({ a: \"a\" }, \"a\"), false)\nassert.deepStrictEqual(isTagged({ _tag: \"a\" }, \"a\"), true)\nassert.deepStrictEqual(isTagged(\"a\")({ _tag: \"a\" }), true)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isTagged: { <K extends string>(tag: K): (self: unknown) => self is { _tag: K; }; <K extends string>(self: unknown, tag: K): self is { _tag: K; }; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isReadonlyRecord",
    "description": "A guard that succeeds when the input is a readonly record.",
    "deprecated": false,
    "examples": [
      "import { isReadonlyRecord } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isReadonlyRecord({}), true)\nassert.deepStrictEqual(isReadonlyRecord({ a: 1 }), true)\n\nassert.deepStrictEqual(isReadonlyRecord([]), false)\nassert.deepStrictEqual(isReadonlyRecord([1, 2, 3]), false)\nassert.deepStrictEqual(isReadonlyRecord(null), false)\nassert.deepStrictEqual(isReadonlyRecord(undefined), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isReadonlyRecord: (input: unknown) => input is { readonly [x: string | symbol]: unknown; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "compose",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const compose: { <A, B extends A, C extends B>(bc: Refinement<B, C>): (ab: Refinement<A, B>) => Refinement<A, C>; <A, B extends A>(bc: Predicate<NoInfer<B>>): (ab: Refinement<A, B>) => Refinement<A, B>; <A, B extends A, C extends B>(ab: Refinement<A, B>, bc: Refinement<B, C>): Refinement<A, C>; <A, B extends A>(ab: Refinement<A, B>, bc: Predicate<NoInfer<B>>): Refinement<A, B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "struct",
    "description": "```\n{ ab: Refinement<A, B>; cd: Refinement<C, D>, ... } -> Refinement<{ ab: A; cd: C; ... }, { ab: B; cd: D; ... }>\n{ a: Predicate<A, B>; b: Predicate<B>, ... } -> Predicate<{ a: A; b: B; ... }>\n{ ab: Refinement<A, B>; c: Predicate<C>, ... } -> Refinement<{ ab: A; c: C; ... }, { ab: B; c: ; ... }>\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const struct: <R extends Record<string, Predicate.Any>>(fields: R) => [Extract<R[keyof R], Refinement.Any>] extends [never] ? Predicate<{ readonly [K in keyof R]: Predicate.In<R[K]>; }> : Refinement<{ readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.In<R[K]> : Predicate.In<R[K]>; }, { readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.Out<R[K]> : Predicate.In<R[K]>; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "or",
    "description": "Combines two predicates into a new predicate that returns `true` if at least one of the predicates returns `true`.",
    "deprecated": false,
    "examples": [
      "import { Predicate, Number } from \"effect\"\n\nconst nonZero = Predicate.or(Number.lessThan(0), Number.greaterThan(0))\n\nassert.deepStrictEqual(nonZero(-1), true)\nassert.deepStrictEqual(nonZero(0), false)\nassert.deepStrictEqual(nonZero(1), true)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const or: { <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B | C>; <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B | C>; <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "and",
    "description": "Combines two predicates into a new predicate that returns `true` if both of the predicates returns `true`.",
    "deprecated": false,
    "examples": [
      "import { Predicate } from \"effect\"\n\nconst minLength = (n: number) => (s: string) => s.length >= n\nconst maxLength = (n: number) => (s: string) => s.length <= n\n\nconst length = (n: number) => Predicate.and(minLength(n), maxLength(n))\n\nassert.deepStrictEqual(length(2)(\"aa\"), true)\nassert.deepStrictEqual(length(2)(\"a\"), false)\nassert.deepStrictEqual(length(2)(\"aaa\"), false)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const and: { <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B & C>; <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B & C>; <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "xor",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const xor: { <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "eqv",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const eqv: { <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "implies",
    "description": "Represents the logical implication combinator for predicates. In formal\nlogic, the implication operator `->` denotes that if the first proposition\n(antecedent) is true, then the second proposition (consequent) must also be\ntrue. In simpler terms, `p implies q` can be interpreted as \"if p then q\". If\nthe first predicate holds, then the second predicate must hold\nfor the given context.\n\nIn practical terms within TypeScript, `p implies q` is equivalent to `!p || (p && q)`.\n\nNote that if the antecedent is `false`, the result is `true` by default\nbecause the outcome of the consequent cannot be determined.\n\nThis function is useful in situations where you need to enforce rules or\nconstraints that are contingent on certain conditions.\nIt proves especially helpful in defining property tests.\n\nThe example below illustrates the transitive property of order using the\n`implies` function. In simple terms, if `a <= b` and `b <= c`, then `a <= c`\nmust be true.",
    "deprecated": false,
    "examples": [
      "import { Predicate } from \"effect\"\n\ntype Triple = {\n  readonly a: number\n  readonly b: number\n  readonly c: number\n}\n\nconst transitivity = Predicate.implies(\n  // antecedent\n  (input: Triple) => input.a <= input.b && input.b <= input.c,\n  // consequent\n  (input: Triple) => input.a <= input.c\n)\n\nassert.equal(transitivity({ a: 1, b: 2, c: 3 }), true)\n// antecedent is `false`, so the result is `true`\nassert.equal(transitivity({ a: 1, b: 0, c: 0 }), true)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const implies: { <A>(consequent: Predicate<A>): (antecedent: Predicate<A>) => Predicate<A>; <A>(antecedent: Predicate<A>, consequent: Predicate<A>): Predicate<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "nor",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const nor: { <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "nand",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const nand: { <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isTruthy",
    "description": "Tests if a value is `truthy`.",
    "deprecated": false,
    "examples": [
      "import { isTruthy } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isTruthy(1), true)\nassert.deepStrictEqual(isTruthy(0), false)\nassert.deepStrictEqual(isTruthy(\"\"), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isSet",
    "description": "Tests if a value is a `Set`.",
    "deprecated": false,
    "examples": [
      "import { isSet } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isSet(new Set([1, 2])), true)\nassert.deepStrictEqual(isSet(new Set()), true)\nassert.deepStrictEqual(isSet({}), false)\nassert.deepStrictEqual(isSet(null), false)\nassert.deepStrictEqual(isSet(undefined), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isMap",
    "description": "Tests if a value is a `Map`.",
    "deprecated": false,
    "examples": [
      "import { isMap } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isMap(new Map()), true)\nassert.deepStrictEqual(isMap({}), false)\nassert.deepStrictEqual(isMap(null), false)\nassert.deepStrictEqual(isMap(undefined), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isString",
    "description": "Tests if a value is a `string`.",
    "deprecated": false,
    "examples": [
      "import { isString } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isString(\"a\"), true)\n\nassert.deepStrictEqual(isString(1), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isNumber",
    "description": "Tests if a value is a `number`.",
    "deprecated": false,
    "examples": [
      "import { isNumber } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNumber(2), true)\n\nassert.deepStrictEqual(isNumber(\"2\"), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isBoolean",
    "description": "Tests if a value is a `boolean`.",
    "deprecated": false,
    "examples": [
      "import { isBoolean } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isBoolean(true), true)\n\nassert.deepStrictEqual(isBoolean(\"true\"), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isBigInt",
    "description": "Tests if a value is a `bigint`.",
    "deprecated": false,
    "examples": [
      "import { isBigInt } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isBigInt(1n), true)\n\nassert.deepStrictEqual(isBigInt(1), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isSymbol",
    "description": "Tests if a value is a `symbol`.",
    "deprecated": false,
    "examples": [
      "import { isSymbol } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isSymbol(Symbol.for(\"a\")), true)\n\nassert.deepStrictEqual(isSymbol(\"a\"), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isUndefined",
    "description": "Tests if a value is `undefined`.",
    "deprecated": false,
    "examples": [
      "import { isUndefined } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isUndefined(undefined), true)\n\nassert.deepStrictEqual(isUndefined(null), false)\nassert.deepStrictEqual(isUndefined(\"undefined\"), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isNotUndefined",
    "description": "Tests if a value is not `undefined`.",
    "deprecated": false,
    "examples": [
      "import { isNotUndefined } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNotUndefined(null), true)\nassert.deepStrictEqual(isNotUndefined(\"undefined\"), true)\n\nassert.deepStrictEqual(isNotUndefined(undefined), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isNull",
    "description": "Tests if a value is `null`.",
    "deprecated": false,
    "examples": [
      "import { isNull } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNull(null), true)\n\nassert.deepStrictEqual(isNull(undefined), false)\nassert.deepStrictEqual(isNull(\"null\"), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isNotNull",
    "description": "Tests if a value is not `null`.",
    "deprecated": false,
    "examples": [
      "import { isNotNull } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNotNull(undefined), true)\nassert.deepStrictEqual(isNotNull(\"null\"), true)\n\nassert.deepStrictEqual(isNotNull(null), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isNever",
    "description": "A guard that always fails.",
    "deprecated": false,
    "examples": [
      "import { isNever } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNever(null), false)\nassert.deepStrictEqual(isNever(undefined), false)\nassert.deepStrictEqual(isNever({}), false)\nassert.deepStrictEqual(isNever([]), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isUnknown",
    "description": "A guard that always succeeds.",
    "deprecated": false,
    "examples": [
      "import { isUnknown } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isUnknown(null), true)\nassert.deepStrictEqual(isUnknown(undefined), true)\n\nassert.deepStrictEqual(isUnknown({}), true)\nassert.deepStrictEqual(isUnknown([]), true)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isObject",
    "description": "Tests if a value is an `object`.",
    "deprecated": false,
    "examples": [
      "import { isObject } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isObject({}), true)\nassert.deepStrictEqual(isObject([]), true)\n\nassert.deepStrictEqual(isObject(null), false)\nassert.deepStrictEqual(isObject(undefined), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isNullable",
    "description": "A guard that succeeds when the input is `null` or `undefined`.",
    "deprecated": false,
    "examples": [
      "import { isNullable } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNullable(null), true)\nassert.deepStrictEqual(isNullable(undefined), true)\n\nassert.deepStrictEqual(isNullable({}), false)\nassert.deepStrictEqual(isNullable([]), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isNotNullable",
    "description": "A guard that succeeds when the input is not `null` or `undefined`.",
    "deprecated": false,
    "examples": [
      "import { isNotNullable } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isNotNullable({}), true)\nassert.deepStrictEqual(isNotNullable([]), true)\n\nassert.deepStrictEqual(isNotNullable(null), false)\nassert.deepStrictEqual(isNotNullable(undefined), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isError",
    "description": "A guard that succeeds when the input is an `Error`.",
    "deprecated": false,
    "examples": [
      "import { isError } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isError(new Error()), true)\n\nassert.deepStrictEqual(isError(null), false)\nassert.deepStrictEqual(isError({}), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isUint8Array",
    "description": "A guard that succeeds when the input is a `Uint8Array`.",
    "deprecated": false,
    "examples": [
      "import { isUint8Array } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isUint8Array(new Uint8Array()), true)\n\nassert.deepStrictEqual(isUint8Array(null), false)\nassert.deepStrictEqual(isUint8Array({}), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isDate",
    "description": "A guard that succeeds when the input is a `Date`.",
    "deprecated": false,
    "examples": [
      "import { isDate } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isDate(new Date()), true)\n\nassert.deepStrictEqual(isDate(null), false)\nassert.deepStrictEqual(isDate({}), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isIterable",
    "description": "A guard that succeeds when the input is an `Iterable`.",
    "deprecated": false,
    "examples": [
      "import { isIterable } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isIterable([]), true)\nassert.deepStrictEqual(isIterable(new Set()), true)\n\nassert.deepStrictEqual(isIterable(null), false)\nassert.deepStrictEqual(isIterable({}), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isRecord",
    "description": "A guard that succeeds when the input is a record.",
    "deprecated": false,
    "examples": [
      "import { isRecord } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isRecord({}), true)\nassert.deepStrictEqual(isRecord({ a: 1 }), true)\n\nassert.deepStrictEqual(isRecord([]), false)\nassert.deepStrictEqual(isRecord([1, 2, 3]), false)\nassert.deepStrictEqual(isRecord(null), false)\nassert.deepStrictEqual(isRecord(undefined), false)\nassert.deepStrictEqual(isRecord(() => null), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isPromise",
    "description": "A guard that succeeds when the input is a Promise.",
    "deprecated": false,
    "examples": [
      "import { isPromise } from \"effect/Predicate\"\n\nassert.deepStrictEqual(isPromise({}), false)\nassert.deepStrictEqual(isPromise(Promise.resolve(\"hello\")), true)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isPromiseLike",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "isRegExp",
    "description": "Tests if a value is a `RegExp`.",
    "deprecated": false,
    "examples": [
      "import { Predicate } from \"effect\"\n\nassert.deepStrictEqual(Predicate.isRegExp(/a/), true)\nassert.deepStrictEqual(Predicate.isRegExp(\"a\"), false)"
    ],
    "since": "3.9.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "product",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "all",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "productMany",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combining",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "tuple",
    "description": "Similar to `Promise.all` but operates on `Predicate`s.\n\n```\n[Refinement<A, B>, Refinement<C, D>, ...] -> Refinement<[A, C, ...], [B, D, ...]>\n[Predicate<A>, Predicate<B>, ...] -> Predicate<[A, B, ...]>\n[Refinement<A, B>, Predicate<C>, ...] -> Refinement<[A, C, ...], [B, C, ...]>\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "not",
    "description": "Negates the result of a given predicate.",
    "deprecated": false,
    "examples": [
      "import { Predicate, Number } from \"effect\"\n\nconst isPositive = Predicate.not(Number.lessThan(0))\n\nassert.deepStrictEqual(isPositive(-1), false)\nassert.deepStrictEqual(isPositive(0), true)\nassert.deepStrictEqual(isPositive(1), true)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "every",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "Predicate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Predicate<in A> {\n  (a: A): boolean\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "PredicateTypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface PredicateTypeLambda extends TypeLambda {\n  readonly type: Predicate<this[\"Target\"]>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Predicate",
      "path": [
        "src",
        "Predicate.ts"
      ]
    },
    "project": "effect",
    "name": "Refinement",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Refinement<in A, out B extends A> {\n  (a: A): a is B\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Pretty",
      "path": [
        "src",
        "Pretty.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export declare const match: AST.Match<Pretty<any>>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Pretty",
      "path": [
        "src",
        "Pretty.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "prettify",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Pretty",
      "path": [
        "src",
        "Pretty.ts"
      ]
    },
    "project": "effect",
    "name": "Pretty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface Pretty<To> {\n  (a: To): string\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Pretty",
      "path": [
        "src",
        "Pretty.ts"
      ]
    },
    "project": "effect",
    "name": "PrettyAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type PrettyAnnotation<A, TypeParameters extends ReadonlyArray<any> = readonly []> = (\n  ...pretties: { readonly [K in keyof TypeParameters]: Pretty<TypeParameters[K]> }\n) => Pretty<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PrimaryKey",
      "path": [
        "src",
        "PrimaryKey.ts"
      ]
    },
    "project": "effect",
    "name": "symbol",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const symbol: typeof symbol"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "PrimaryKey",
      "path": [
        "src",
        "PrimaryKey.ts"
      ]
    },
    "project": "effect",
    "name": "value",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "accessors",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "PrimaryKey",
      "path": [
        "src",
        "PrimaryKey.ts"
      ]
    },
    "project": "effect",
    "name": "PrimaryKey",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface PrimaryKey {\n  [symbol](): string\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "bounded",
    "description": "Creates a bounded `PubSub` with the back pressure strategy. The `PubSub` will retain\nmessages until they have been taken by all subscribers, applying back\npressure to publishers if the `PubSub` is at capacity.\n\nFor best performance use capacities that are powers of two.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const bounded: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "dropping",
    "description": "Creates a bounded `PubSub` with the dropping strategy. The `PubSub` will drop new\nmessages if the `PubSub` is at capacity.\n\nFor best performance use capacities that are powers of two.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dropping: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "sliding",
    "description": "Creates a bounded `PubSub` with the sliding strategy. The `PubSub` will add new\nmessages and drop old messages if the `PubSub` is at capacity.\n\nFor best performance use capacities that are powers of two.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sliding: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "unbounded",
    "description": "Creates an unbounded `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unbounded: <A>(options?: { readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "capacity",
    "description": "Returns the number of elements the queue can hold.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const capacity: <A>(self: PubSub<A>) => number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Retrieves the size of the queue, which is equal to the number of elements\nin the queue. This may be negative if fibers are suspended waiting for\nelements to be added to the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const size: <A>(self: PubSub<A>) => Effect.Effect<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "isFull",
    "description": "Returns `true` if the `Queue` contains at least one element, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isFull: <A>(self: PubSub<A>) => Effect.Effect<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the `Queue` contains zero elements, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isEmpty: <A>(self: PubSub<A>) => Effect.Effect<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "shutdown",
    "description": "Interrupts any fibers that are suspended on `offer` or `take`. Future calls\nto `offer*` and `take*` will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const shutdown: <A>(self: PubSub<A>) => Effect.Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "isShutdown",
    "description": "Returns `true` if `shutdown` has been called, otherwise returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isShutdown: <A>(self: PubSub<A>) => Effect.Effect<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "awaitShutdown",
    "description": "Waits until the queue is shutdown. The `Effect` returned by this method will\nnot resume until the queue has been shutdown. If the queue is already\nshutdown, the `Effect` will resume right away.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const awaitShutdown: <A>(self: PubSub<A>) => Effect.Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "publish",
    "description": "Publishes a message to the `PubSub`, returning whether the message was published\nto the `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const publish: { <A>(value: A): (self: PubSub<A>) => Effect.Effect<boolean>; <A>(self: PubSub<A>, value: A): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "publishAll",
    "description": "Publishes all of the specified messages to the `PubSub`, returning whether they\nwere published to the `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const publishAll: { <A>(elements: Iterable<A>): (self: PubSub<A>) => Effect.Effect<boolean>; <A>(self: PubSub<A>, elements: Iterable<A>): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "subscribe",
    "description": "Subscribes to receive messages from the `PubSub`. The resulting subscription can\nbe evaluated multiple times within the scope to take a message from the `PubSub`\neach time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const subscribe: <A>(self: PubSub<A>) => Effect.Effect<Queue.Dequeue<A>, never, Scope.Scope>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "PubSub",
      "path": [
        "src",
        "PubSub.ts"
      ]
    },
    "project": "effect",
    "name": "PubSub",
    "description": "A `PubSub<A>` is an asynchronous message hub into which publishers can publish\nmessages of type `A` and subscribers can subscribe to take messages of type\n`A`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface PubSub<in out A> extends Queue.Enqueue<A>, Pipeable {\n  /**\n   * Publishes a message to the `PubSub`, returning whether the message was published\n   * to the `PubSub`.\n   */\n  publish(value: A): Effect.Effect<boolean>\n\n  /**\n   * Publishes all of the specified messages to the `PubSub`, returning whether they\n   * were published to the `PubSub`.\n   */\n  publishAll(elements: Iterable<A>): Effect.Effect<boolean>\n\n  /**\n   * Subscribes to receive messages from the `PubSub`. The resulting subscription can\n   * be evaluated multiple times within the scope to take a message from the `PubSub`\n   * each time.\n   */\n  readonly subscribe: Effect.Effect<Queue.Dequeue<A>, never, Scope.Scope>\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "EnqueueTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const EnqueueTypeId: typeof EnqueueTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "DequeueTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const DequeueTypeId: typeof DequeueTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "QueueStrategyTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const QueueStrategyTypeId: typeof QueueStrategyTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "BackingQueueTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const BackingQueueTypeId: typeof BackingQueueTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "isQueue",
    "description": "Returns `true` if the specified value is a `Queue`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isQueue: (u: unknown) => u is Queue<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "isDequeue",
    "description": "Returns `true` if the specified value is a `Dequeue`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isDequeue: (u: unknown) => u is Dequeue<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "isEnqueue",
    "description": "Returns `true` if the specified value is a `Enqueue`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isEnqueue: (u: unknown) => u is Enqueue<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "backPressureStrategy",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "strategies",
    "signature": "export declare const backPressureStrategy: <A>() => Strategy<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "droppingStrategy",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "strategies",
    "signature": "export declare const droppingStrategy: <A>() => Strategy<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "slidingStrategy",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "strategies",
    "signature": "export declare const slidingStrategy: <A>() => Strategy<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <A>(queue: BackingQueue<A>, strategy: Strategy<A>) => Effect.Effect<Queue<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "bounded",
    "description": "Makes a new bounded `Queue`. When the capacity of the queue is reached, any\nadditional calls to `offer` will be suspended until there is more room in\nthe queue.\n\n**Note**: When possible use only power of 2 capacities; this will provide\nbetter performance by utilising an optimised version of the underlying\n`RingBuffer`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const bounded: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "dropping",
    "description": "Makes a new bounded `Queue` with the dropping strategy.\n\nWhen the capacity of the queue is reached, new elements will be dropped and the\nold elements will remain.\n\n**Note**: When possible use only power of 2 capacities; this will provide\nbetter performance by utilising an optimised version of the underlying\n`RingBuffer`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dropping: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "sliding",
    "description": "Makes a new bounded `Queue` with the sliding strategy.\n\nWhen the capacity of the queue is reached, new elements will be added and the\nold elements will be dropped.\n\n**Note**: When possible use only power of 2 capacities; this will provide\nbetter performance by utilising an optimised version of the underlying\n`RingBuffer`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sliding: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "unbounded",
    "description": "Creates a new unbounded `Queue`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unbounded: <A>() => Effect.Effect<Queue<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "capacity",
    "description": "Returns the number of elements the queue can hold.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const capacity: <A>(self: Dequeue<A> | Enqueue<A>) => number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Retrieves the size of the queue, which is equal to the number of elements\nin the queue. This may be negative if fibers are suspended waiting for\nelements to be added to the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const size: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the `Queue` contains zero elements, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isEmpty: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "isFull",
    "description": "Returns `true` if the `Queue` contains at least one element, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isFull: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "isShutdown",
    "description": "Returns `true` if `shutdown` has been called, otherwise returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isShutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "awaitShutdown",
    "description": "Waits until the queue is shutdown. The `Effect` returned by this method will\nnot resume until the queue has been shutdown. If the queue is already\nshutdown, the `Effect` will resume right away.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const awaitShutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "shutdown",
    "description": "Interrupts any fibers that are suspended on `offer` or `take`. Future calls\nto `offer*` and `take*` will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const shutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "offer",
    "description": "Places one value in the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const offer: { <A>(value: A): (self: Enqueue<A>) => Effect.Effect<boolean>; <A>(self: Enqueue<A>, value: A): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeOffer",
    "description": "Places one value in the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const unsafeOffer: { <A>(value: A): (self: Enqueue<A>) => boolean; <A>(self: Enqueue<A>, value: A): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "offerAll",
    "description": "For Bounded Queue: uses the `BackPressure` Strategy, places the values in\nthe queue and always returns true. If the queue has reached capacity, then\nthe fiber performing the `offerAll` will be suspended until there is room\nin the queue.\n\nFor Unbounded Queue: Places all values in the queue and returns true.\n\nFor Sliding Queue: uses `Sliding` Strategy If there is room in the queue,\nit places the values otherwise it removes the old elements and enqueues the\nnew ones. Always returns true.\n\nFor Dropping Queue: uses `Dropping` Strategy, It places the values in the\nqueue but if there is no room it will not enqueue them and return false.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const offerAll: { <A>(iterable: Iterable<A>): (self: Enqueue<A>) => Effect.Effect<boolean>; <A>(self: Enqueue<A>, iterable: Iterable<A>): Effect.Effect<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "poll",
    "description": "Returns the first value in the `Queue` as a `Some<A>`, or `None` if the queue\nis empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const poll: <A>(self: Dequeue<A>) => Effect.Effect<Option.Option<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "take",
    "description": "Takes the oldest value in the queue. If the queue is empty, this will return\na computation that resumes when an item has been added to the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const take: <A>(self: Dequeue<A>) => Effect.Effect<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "takeAll",
    "description": "Takes all the values in the queue and returns the values. If the queue is\nempty returns an empty collection.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const takeAll: <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "takeUpTo",
    "description": "Takes up to max number of values from the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const takeUpTo: { (max: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>; <A>(self: Dequeue<A>, max: number): Effect.Effect<Chunk.Chunk<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "takeBetween",
    "description": "Takes a number of elements from the queue between the specified minimum and\nmaximum. If there are fewer than the minimum number of elements available,\nsuspends until at least the minimum number of elements have been collected.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const takeBetween: { (min: number, max: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>; <A>(self: Dequeue<A>, min: number, max: number): Effect.Effect<Chunk.Chunk<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "takeN",
    "description": "Takes the specified number of elements from the queue. If there are fewer\nthan the specified number of elements available, it suspends until they\nbecome available.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const takeN: { (n: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>; <A>(self: Dequeue<A>, n: number): Effect.Effect<Chunk.Chunk<A>>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "BackingQueue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BackingQueue<in out A> extends Queue.BackingQueueVariance<A> {\n  /**\n   * Dequeues an element from the queue.\n   * Returns either an element from the queue, or the `def` param.\n   */\n  poll<Def>(def: Def): A | Def\n  /**\n   * Dequeues up to `limit` elements from the queue.\n   */\n  pollUpTo(limit: number): Chunk.Chunk<A>\n  /**\n   * Enqueues a collection of values into the queue.\n   *\n   * Returns a `Chunk` of the values that were **not** able to be enqueued.\n   */\n  offerAll(elements: Iterable<A>): Chunk.Chunk<A>\n  /**\n   * Offers an element to the queue.\n   *\n   * Returns whether the enqueue was successful or not.\n   */\n  offer(element: A): boolean\n  /**\n   * The **maximum** number of elements that a queue can hold.\n   *\n   * **Note**: unbounded queues can still implement this interface with\n   * `capacity = Infinity`.\n   */\n  capacity(): number\n  /**\n   * Returns the number of elements currently in the queue\n   */\n  length(): number\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "BaseQueue",
    "description": "The base interface that all `Queue`s must implement.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BaseQueue {\n  /**\n   * Returns the number of elements the queue can hold.\n   */\n  capacity(): number\n\n  /**\n   * Returns false if shutdown has been called.\n   */\n  isActive(): boolean\n\n  /**\n   * Retrieves the size of the queue, which is equal to the number of elements\n   * in the queue. This may be negative if fibers are suspended waiting for\n   * elements to be added to the queue.\n   */\n  readonly size: Effect.Effect<number>\n\n  /**\n   * Retrieves the size of the queue, which is equal to the number of elements\n   * in the queue. This may be negative if fibers are suspended waiting for\n   * elements to be added to the queue. Returns None if shutdown has been called\n   */\n  unsafeSize(): Option.Option<number>\n\n  /**\n   * Returns `true` if the `Queue` contains at least one element, `false`\n   * otherwise.\n   */\n  readonly isFull: Effect.Effect<boolean>\n\n  /**\n   * Returns `true` if the `Queue` contains zero elements, `false` otherwise.\n   */\n  readonly isEmpty: Effect.Effect<boolean>\n\n  /**\n   * Interrupts any fibers that are suspended on `offer` or `take`. Future calls\n   * to `offer*` and `take*` will be interrupted immediately.\n   */\n  readonly shutdown: Effect.Effect<void>\n\n  /**\n   * Returns `true` if `shutdown` has been called, otherwise returns `false`.\n   */\n  readonly isShutdown: Effect.Effect<boolean>\n\n  /**\n   * Waits until the queue is shutdown. The `Effect` returned by this method will\n   * not resume until the queue has been shutdown. If the queue is already\n   * shutdown, the `Effect` will resume right away.\n   */\n  readonly awaitShutdown: Effect.Effect<void>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "Dequeue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Dequeue<out A> extends Effect.Effect<A>, Queue.DequeueVariance<A>, BaseQueue {\n  /**\n   * Takes the oldest value in the queue. If the queue is empty, this will return\n   * a computation that resumes when an item has been added to the queue.\n   */\n  readonly take: Effect.Effect<A>\n\n  /**\n   * Takes all the values in the queue and returns the values. If the queue is\n   * empty returns an empty collection.\n   */\n  readonly takeAll: Effect.Effect<Chunk.Chunk<A>>\n\n  /**\n   * Takes up to max number of values from the queue.\n   */\n  takeUpTo(max: number): Effect.Effect<Chunk.Chunk<A>>\n\n  /**\n   * Takes a number of elements from the queue between the specified minimum and\n   * maximum. If there are fewer than the minimum number of elements available,\n   * suspends until at least the minimum number of elements have been collected.\n   */\n  takeBetween(min: number, max: number): Effect.Effect<Chunk.Chunk<A>>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: DequeueUnify<this>\n  readonly [Unify.ignoreSymbol]?: DequeueUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "DequeueUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface DequeueUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Dequeue?: () => A[Unify.typeSymbol] extends Dequeue<infer A0> | infer _ ? Dequeue<A0> : never\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "DequeueUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface DequeueUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "Enqueue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Enqueue<in A> extends Queue.EnqueueVariance<A>, BaseQueue, Pipeable {\n  /**\n   * Places one value in the queue.\n   */\n  offer(value: A): Effect.Effect<boolean>\n\n  /**\n   * Places one value in the queue when possible without needing the fiber runtime.\n   */\n  unsafeOffer(value: A): boolean\n\n  /**\n   * For Bounded Queue: uses the `BackPressure` Strategy, places the values in\n   * the queue and always returns true. If the queue has reached capacity, then\n   * the fiber performing the `offerAll` will be suspended until there is room\n   * in the queue.\n   *\n   * For Unbounded Queue: Places all values in the queue and returns true.\n   *\n   * For Sliding Queue: uses `Sliding` Strategy If there is room in the queue,\n   * it places the values otherwise it removes the old elements and enqueues the\n   * new ones. Always returns true.\n   *\n   * For Dropping Queue: uses `Dropping` Strategy, It places the values in the\n   * queue but if there is no room it will not enqueue them and return false.\n   */\n  offerAll(iterable: Iterable<A>): Effect.Effect<boolean>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "Queue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Queue<in out A> extends Enqueue<A>, Dequeue<A> {\n  /** @internal */\n  readonly queue: BackingQueue<A>\n  /** @internal */\n  readonly takers: MutableQueue.MutableQueue<Deferred.Deferred<A>>\n  /** @internal */\n  readonly shutdownHook: Deferred.Deferred<void>\n  /** @internal */\n  readonly shutdownFlag: MutableRef.MutableRef<boolean>\n  /** @internal */\n  readonly strategy: Strategy<A>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: QueueUnify<this>\n  readonly [Unify.ignoreSymbol]?: QueueUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "QueueUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface QueueUnify<A extends { [Unify.typeSymbol]?: any }> extends DequeueUnify<A> {\n  Queue?: () => Extract<A[Unify.typeSymbol], Queue<any>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "QueueUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface QueueUnifyIgnore extends DequeueUnifyIgnore {\n  Dequeue?: true\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "Strategy",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Strategy<in out A> extends Queue.StrategyVariance<A> {\n  /**\n   * Returns the number of surplus values that were unable to be added to the\n   * `Queue`\n   */\n  surplusSize(): number\n\n  /**\n   * Determines how the `Queue.Strategy` should shut down when the `Queue` is\n   * shut down.\n   */\n  readonly shutdown: Effect.Effect<void>\n\n  /**\n   * Determines the behavior of the `Queue.Strategy` when there are surplus\n   * values that could not be added to the `Queue` following an `offer`\n   * operation.\n   */\n  handleSurplus(\n    iterable: Iterable<A>,\n    queue: BackingQueue<A>,\n    takers: MutableQueue.MutableQueue<Deferred.Deferred<A>>,\n    isShutdown: MutableRef.MutableRef<boolean>\n  ): Effect.Effect<boolean>\n\n  /**\n   * It is called when the backing queue is empty but there are some\n   * takers that can be completed\n   */\n  onCompleteTakersWithEmptyQueue(\n    takers: MutableQueue.MutableQueue<Deferred.Deferred<A>>\n  ): void\n\n  /**\n   * Determines the behavior of the `Queue.Strategy` when the `Queue` has empty\n   * slots following a `take` operation.\n   */\n  unsafeOnQueueEmptySpace(\n    queue: BackingQueue<A>,\n    takers: MutableQueue.MutableQueue<Deferred.Deferred<A>>\n  ): void\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "BackingQueueTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type BackingQueueTypeId = typeof BackingQueueTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "DequeueTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type DequeueTypeId = typeof DequeueTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "EnqueueTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type EnqueueTypeId = typeof EnqueueTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Queue",
      "path": [
        "src",
        "Queue.ts"
      ]
    },
    "project": "effect",
    "name": "QueueStrategyTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type QueueStrategyTypeId = typeof QueueStrategyTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random",
      "path": [
        "src",
        "Random.ts"
      ]
    },
    "project": "effect",
    "name": "RandomTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const RandomTypeId: typeof RandomTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random",
      "path": [
        "src",
        "Random.ts"
      ]
    },
    "project": "effect",
    "name": "next",
    "description": "Returns the next numeric value from the pseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const next: Effect.Effect<number, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random",
      "path": [
        "src",
        "Random.ts"
      ]
    },
    "project": "effect",
    "name": "nextInt",
    "description": "Returns the next integer value from the pseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const nextInt: Effect.Effect<number, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random",
      "path": [
        "src",
        "Random.ts"
      ]
    },
    "project": "effect",
    "name": "nextBoolean",
    "description": "Returns the next boolean value from the pseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const nextBoolean: Effect.Effect<boolean, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random",
      "path": [
        "src",
        "Random.ts"
      ]
    },
    "project": "effect",
    "name": "nextRange",
    "description": "Returns the next numeric value in the specified range from the\npseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const nextRange: (min: number, max: number) => Effect.Effect<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random",
      "path": [
        "src",
        "Random.ts"
      ]
    },
    "project": "effect",
    "name": "nextIntBetween",
    "description": "Returns the next integer value in the specified range from the\npseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const nextIntBetween: (min: number, max: number) => Effect.Effect<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random",
      "path": [
        "src",
        "Random.ts"
      ]
    },
    "project": "effect",
    "name": "shuffle",
    "description": "Uses the pseudo-random number generator to shuffle the specified iterable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const shuffle: <A>(elements: Iterable<A>) => Effect.Effect<Chunk.Chunk<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random",
      "path": [
        "src",
        "Random.ts"
      ]
    },
    "project": "effect",
    "name": "choice",
    "description": "Get a random element from an iterable.",
    "deprecated": false,
    "examples": [
      "import { Effect, Random } from \"effect\"\n\nEffect.gen(function* () {\n  const randomItem = yield* Random.choice([1, 2, 3])\n  console.log(randomItem)\n})"
    ],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "export declare const choice: <Self extends Iterable<unknown>>(elements: Self) => Self extends NonEmptyIterable.NonEmptyIterable<infer A> ? Effect.Effect<A> : Self extends Array.NonEmptyReadonlyArray<infer A> ? Effect.Effect<A> : Self extends Iterable<infer A> ? Effect.Effect<A, Cause.NoSuchElementException> : never"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random",
      "path": [
        "src",
        "Random.ts"
      ]
    },
    "project": "effect",
    "name": "randomWith",
    "description": "Retreives the `Random` service from the context and uses it to run the\nspecified workflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const randomWith: <A, E, R>(f: (random: Random) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random",
      "path": [
        "src",
        "Random.ts"
      ]
    },
    "project": "effect",
    "name": "Random",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const Random: Context.Tag<Random, Random>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Random",
      "path": [
        "src",
        "Random.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs the `Random` service, seeding the pseudo-random number generator\nwith an hash of the specified seed.\nThis constructor is useful for generating predictable sequences of random values for specific use cases.\n\nExample uses:\n- Generating random UI data for visual tests.\n- Creating data that needs to change daily but remain the same throughout a single day, such as using a date as the seed.",
    "deprecated": false,
    "examples": [
      "import { Effect, Random } from \"effect\"\n\nconst random1 = Random.make(\"myseed\")\nconst random2 = Random.make(\"myseed\")\n\nassert.equal(Effect.runSync(random1.next), Effect.runSync(random2.next))"
    ],
    "since": "3.5.0",
    "category": "constructors",
    "signature": "export declare const make: <A>(seed: A) => Random"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Random",
      "path": [
        "src",
        "Random.ts"
      ]
    },
    "project": "effect",
    "name": "Random",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Random {\n  readonly [RandomTypeId]: RandomTypeId\n  /**\n   * Returns the next numeric value from the pseudo-random number generator.\n   */\n  readonly next: Effect.Effect<number>\n  /**\n   * Returns the next boolean value from the pseudo-random number generator.\n   */\n  readonly nextBoolean: Effect.Effect<boolean>\n  /**\n   * Returns the next integer value from the pseudo-random number generator.\n   */\n  readonly nextInt: Effect.Effect<number>\n  /**\n   * Returns the next numeric value in the specified range from the\n   * pseudo-random number generator.\n   */\n  nextRange(min: number, max: number): Effect.Effect<number>\n  /**\n   * Returns the next integer value in the specified range from the\n   * pseudo-random number generator.\n   */\n  nextIntBetween(min: number, max: number): Effect.Effect<number>\n  /**\n   * Uses the pseudo-random number generator to shuffle the specified iterable.\n   */\n  shuffle<A>(elements: Iterable<A>): Effect.Effect<Chunk.Chunk<A>>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Random",
      "path": [
        "src",
        "Random.ts"
      ]
    },
    "project": "effect",
    "name": "RandomTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type RandomTypeId = typeof RandomTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RateLimiter",
      "path": [
        "src",
        "RateLimiter.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new `RateLimiter` which will utilize the specified algorithm\nto limit requests (defaults to `token-bucket`).\n\nNotes\n- Only the moment of starting the effect is rate limited. The number of concurrent executions is not bounded.\n- Instances of `RateLimiter` can be composed.\n- The \"cost\" per effect can be changed. See {@link withCost}",
    "deprecated": false,
    "examples": [
      "import { Effect, RateLimiter } from \"effect\";\nimport { compose } from \"effect/Function\"\n\nconst program = Effect.scoped(\n  Effect.gen(function* ($) {\n    const perMinuteRL = yield* $(RateLimiter.make({ limit: 30, interval: \"1 minutes\" }))\n    const perSecondRL = yield* $(RateLimiter.make({ limit: 2, interval: \"1 seconds\" }))\n\n    // This rate limiter respects both the 30 calls per minute\n    // and the 2 calls per second constraints.\n     const rateLimit = compose(perMinuteRL, perSecondRL)\n\n    // simulate repeated calls\n    for (let n = 0; n < 100; n++) {\n      // wrap the effect we want to limit with rateLimit\n      yield* $(rateLimit(Effect.log(\"Calling RateLimited Effect\")));\n    }\n  })\n);"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: (options: RateLimiter.Options) => Effect<RateLimiter, never, Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RateLimiter",
      "path": [
        "src",
        "RateLimiter.ts"
      ]
    },
    "project": "effect",
    "name": "withCost",
    "description": "Alters the per-effect cost of the rate-limiter.\n\nThis can be used for \"credit\" based rate-limiting where different API endpoints\ncost a different number of credits within a time window.\nEg: 1000 credits / hour, where a query costs 1 credit and a mutation costs 5 credits.",
    "deprecated": false,
    "examples": [
      "import { Effect, RateLimiter } from \"effect\";\nimport { compose } from \"effect/Function\";\n\nconst program = Effect.scoped(\n  Effect.gen(function* ($) {\n    // Create a rate limiter that has an hourly limit of 1000 credits\n    const rateLimiter = yield* $(RateLimiter.make({ limit: 1000, interval: \"1 hours\" }));\n    // Query API costs 1 credit per call ( 1 is the default cost )\n    const queryAPIRL = compose(rateLimiter, RateLimiter.withCost(1));\n    // Mutation API costs 5 credits per call\n    const mutationAPIRL = compose(rateLimiter, RateLimiter.withCost(5));\n\n    // Use the pre-defined rate limiters\n    yield* $(queryAPIRL(Effect.log(\"Sample Query\")));\n    yield* $(mutationAPIRL(Effect.log(\"Sample Mutation\")));\n\n    // Or set a cost on-the-fly\n    yield* $(\n      rateLimiter(Effect.log(\"Another query with a different cost\")).pipe(\n        RateLimiter.withCost(3)\n      )\n    );\n  })\n);"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const withCost: (cost: number) => <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RateLimiter",
      "path": [
        "src",
        "RateLimiter.ts"
      ]
    },
    "project": "effect",
    "name": "RateLimiter",
    "description": "Limits the number of calls to a resource to a maximum amount in some interval.\n\nNote that only the moment of starting the effect is rate limited: the number\nof concurrent executions is not bounded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RateLimiter {\n  <A, E, R>(task: Effect<A, E, R>): Effect<A, E, R>\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcMap",
      "path": [
        "src",
        "RcMap.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "type ids",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcMap",
      "path": [
        "src",
        "RcMap.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "An `RcMap` can contain multiple reference counted resources that can be indexed\nby a key. The resources are lazily acquired on the first call to `get` and\nreleased when the last reference is released.\n\nComplex keys can extend `Equal` and `Hash` to allow lookups by value.",
    "deprecated": false,
    "examples": [
      "import { Effect, RcMap } from \"effect\"\n\nEffect.gen(function*() {\n  const map = yield* RcMap.make({\n    lookup: (key: string) =>\n      Effect.acquireRelease(\n        Effect.succeed(`acquired ${key}`),\n        () => Effect.log(`releasing ${key}`)\n      )\n  })\n\n  // Get \"foo\" from the map twice, which will only acquire it once.\n  // It will then be released once the scope closes.\n  yield* RcMap.get(map, \"foo\").pipe(\n    Effect.andThen(RcMap.get(map, \"foo\")),\n    Effect.scoped\n  )\n})"
    ],
    "since": "3.5.0",
    "category": "models",
    "signature": "export declare const make: { <K, A, E, R>(options: { readonly lookup: (key: K) => Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; readonly capacity?: undefined; }): Effect.Effect<RcMap<K, A, E>, never, Scope.Scope | R>; <K, A, E, R>(options: { readonly lookup: (key: K) => Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; readonly capacity: number; }): Effect.Effect<RcMap<K, A, E | Cause.ExceededCapacityException>, never, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcMap",
      "path": [
        "src",
        "RcMap.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "combinators",
    "signature": "export declare const get: { <K>(key: K): <A, E>(self: RcMap<K, A, E>) => Effect.Effect<A, E, Scope.Scope>; <K, A, E>(self: RcMap<K, A, E>, key: K): Effect.Effect<A, E, Scope.Scope>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcMap",
      "path": [
        "src",
        "RcMap.ts"
      ]
    },
    "project": "effect",
    "name": "keys",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "combinators",
    "signature": "export declare const keys: <K, A, E>(self: RcMap<K, A, E>) => Effect.Effect<Array<K>, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcMap",
      "path": [
        "src",
        "RcMap.ts"
      ]
    },
    "project": "effect",
    "name": "invalidate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "combinators",
    "signature": "export declare const invalidate: { <K>(key: K): <A, E>(self: RcMap<K, A, E>) => Effect.Effect<void>; <K, A, E>(self: RcMap<K, A, E>, key: K): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcMap",
      "path": [
        "src",
        "RcMap.ts"
      ]
    },
    "project": "effect",
    "name": "touch",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.13.0",
    "category": "combinators",
    "signature": "export declare const touch: { <K>(key: K): <A, E>(self: RcMap<K, A, E>) => Effect.Effect<void>; <K, A, E>(self: RcMap<K, A, E>, key: K): Effect.Effect<void>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RcMap",
      "path": [
        "src",
        "RcMap.ts"
      ]
    },
    "project": "effect",
    "name": "RcMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "models",
    "signature": "export interface RcMap<in K, out A, out E = never> extends Pipeable {\n  readonly [TypeId]: RcMap.Variance<K, A, E>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RcMap",
      "path": [
        "src",
        "RcMap.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "type ids",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcRef",
      "path": [
        "src",
        "RcRef.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "type ids",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcRef",
      "path": [
        "src",
        "RcRef.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Create an `RcRef` from an acquire `Effect`.\n\nAn RcRef wraps a reference counted resource that can be acquired and released\nmultiple times.\n\nThe resource is lazily acquired on the first call to `get` and released when\nthe last reference is released.",
    "deprecated": false,
    "examples": [
      "import { Effect, RcRef } from \"effect\"\n\nEffect.gen(function*() {\n  const ref = yield* RcRef.make({\n    acquire: Effect.acquireRelease(\n      Effect.succeed(\"foo\"),\n      () => Effect.log(\"release foo\")\n    )\n  })\n\n  // will only acquire the resource once, and release it\n  // when the scope is closed\n  yield* RcRef.get(ref).pipe(\n    Effect.andThen(RcRef.get(ref)),\n    Effect.scoped\n  )\n})"
    ],
    "since": "3.5.0",
    "category": "constructors",
    "signature": "export declare const make: <A, E, R>(options: { readonly acquire: Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; }) => Effect.Effect<RcRef<A, E>, never, R | Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RcRef",
      "path": [
        "src",
        "RcRef.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "combinators",
    "signature": "export declare const get: <A, E>(self: RcRef<A, E>) => Effect.Effect<A, E, Scope.Scope>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RcRef",
      "path": [
        "src",
        "RcRef.ts"
      ]
    },
    "project": "effect",
    "name": "RcRef",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "models",
    "signature": "export interface RcRef<out A, out E = never>\n  extends Effect.Effect<A, E, Scope.Scope>, Readable.Readable<A, E, Scope.Scope>\n{\n  readonly [TypeId]: RcRef.Variance<A, E>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: RcRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: RcRefUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RcRef",
      "path": [
        "src",
        "RcRef.ts"
      ]
    },
    "project": "effect",
    "name": "RcRefUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface RcRefUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  RcRef?: () => A[Unify.typeSymbol] extends RcRef<infer A0, infer E0> | infer _ ? RcRef<A0, E0>\n    : never\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RcRef",
      "path": [
        "src",
        "RcRef.ts"
      ]
    },
    "project": "effect",
    "name": "RcRefUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface RcRefUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RcRef",
      "path": [
        "src",
        "RcRef.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.5.0",
    "category": "type ids",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Readable",
      "path": [
        "src",
        "Readable.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Readable",
      "path": [
        "src",
        "Readable.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const map: { <A, B>(f: (a: NoInfer<A>) => B): <E, R>(fa: Readable<A, E, R>) => Readable<B, E, R>; <A, E, R, B>(self: Readable<A, E, R>, f: (a: NoInfer<A>) => B): Readable<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Readable",
      "path": [
        "src",
        "Readable.ts"
      ]
    },
    "project": "effect",
    "name": "mapEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const mapEffect: { <A, B, E2, R2>(f: (a: NoInfer<A>) => Effect<B, E2, R2>): <E, R>(fa: Readable<A, E, R>) => Readable<B, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Readable<A, E, R>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): Readable<B, E | E2, R | R2>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Readable",
      "path": [
        "src",
        "Readable.ts"
      ]
    },
    "project": "effect",
    "name": "isReadable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Readable",
      "path": [
        "src",
        "Readable.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Readable",
      "path": [
        "src",
        "Readable.ts"
      ]
    },
    "project": "effect",
    "name": "unwrap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Readable",
      "path": [
        "src",
        "Readable.ts"
      ]
    },
    "project": "effect",
    "name": "Readable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Readable<A, E = never, R = never> extends Pipeable {\n  readonly [TypeId]: TypeId\n  readonly get: Effect<A, E, R>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Readable",
      "path": [
        "src",
        "Readable.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "isEmptyReadonlyRecord",
    "description": "Determine if a record is empty.",
    "deprecated": false,
    "examples": [
      "import { isEmptyReadonlyRecord } from \"effect/Record\"\n\nassert.deepStrictEqual(isEmptyReadonlyRecord({}), true);\nassert.deepStrictEqual(isEmptyReadonlyRecord({ a: 3 }), false);"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isEmptyReadonlyRecord: <K extends string, A>(self: ReadonlyRecord<K, A>) => self is ReadonlyRecord<K, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterableWith",
    "description": "Takes an iterable and a projection function and returns a record.\nThe projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.",
    "deprecated": false,
    "examples": [
      "import { fromIterableWith } from \"effect/Record\"\n\nconst input = [1, 2, 3, 4]\n\nassert.deepStrictEqual(\n  fromIterableWith(input, a => [String(a), a * 2]),\n  { '1': 2, '2': 4, '3': 6, '4': 8 }\n)"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterableWith: { <A, K extends string | symbol, B>(f: (a: A) => readonly [K, B]): (self: Iterable<A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <A, K extends string | symbol, B>(self: Iterable<A>, f: (a: A) => readonly [K, B]): Record<ReadonlyRecord.NonLiteralKey<K>, B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "fromEntries",
    "description": "Builds a record from an iterable of key-value pairs.\n\nIf there are conflicting keys when using `fromEntries`, the last occurrence of the key/value pair will overwrite the\nprevious ones. So the resulting record will only have the value of the last occurrence of each key.",
    "deprecated": false,
    "examples": [
      "import { fromEntries } from \"effect/Record\"\n\nconst input: Array<[string, number]> = [[\"a\", 1], [\"b\", 2]]\n\nassert.deepStrictEqual(fromEntries(input), { a: 1, b: 2 })"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromEntries: <Entry extends readonly [string | symbol, any]>(entries: Iterable<Entry>) => Record<ReadonlyRecord.NonLiteralKey<Entry[0]>, Entry[1]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "collect",
    "description": "Transforms the values of a record into an `Array` with a custom mapping function.",
    "deprecated": false,
    "examples": [
      "import { collect } from \"effect/Record\"\n\nconst x = { a: 1, b: 2, c: 3 }\nassert.deepStrictEqual(collect(x, (key, n) => [key, n]), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "export declare const collect: { <K extends string, A, B>(f: (key: K, a: A) => B): (self: ReadonlyRecord<K, A>) => Array<B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => B): Array<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "toEntries",
    "description": "Takes a record and returns an array of tuples containing its keys and values.",
    "deprecated": false,
    "examples": [
      "import { toEntries } from \"effect/Record\"\n\nconst x = { a: 1, b: 2, c: 3 }\nassert.deepStrictEqual(toEntries(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])"
    ],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "export declare const toEntries: <K extends string, A>(self: ReadonlyRecord<K, A>) => Array<[K, A]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "has",
    "description": "Check if a given `key` exists in a record.",
    "deprecated": false,
    "examples": [
      "import { empty, has } from \"effect/Record\"\n\nassert.deepStrictEqual(has({ a: 1, b: 2 }, \"a\"), true);\nassert.deepStrictEqual(has(empty<string>(), \"c\"), false);"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const has: { <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => boolean; <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieve a value at a particular key from a record, returning it wrapped in an `Option`.",
    "deprecated": false,
    "examples": [
      "import { Record as R, Option } from \"effect\"\n\nconst person: Record<string, unknown> = { name: \"John Doe\", age: 35 }\n\nassert.deepStrictEqual(R.get(person, \"name\"), Option.some(\"John Doe\"))\nassert.deepStrictEqual(R.get(person, \"email\"), Option.none())"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const get: { <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => Option.Option<A>; <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): Option.Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "modify",
    "description": "Apply a function to the element at the specified key, creating a new record.\nIf the key does not exist, the record is returned unchanged.",
    "deprecated": false,
    "examples": [
      "import { Record as R } from \"effect\"\n\nconst f = (x: number) => x * 2\n\nassert.deepStrictEqual(\n R.modify({ a: 3 }, 'a', f),\n { a: 6 }\n)\nassert.deepStrictEqual(\n R.modify({ a: 3 } as Record<string, number>, 'b', f),\n { a: 3 }\n)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const modify: { <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Record<K, A | B>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Record<K, A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "modifyOption",
    "description": "Apply a function to the element at the specified key, creating a new record,\nor return `None` if the key doesn't exist.",
    "deprecated": false,
    "examples": [
      "import { Record as R, Option } from \"effect\"\n\nconst f = (x: number) => x * 2\n\nassert.deepStrictEqual(\n R.modifyOption({ a: 3 }, 'a', f),\n Option.some({ a: 6 })\n)\nassert.deepStrictEqual(\n R.modifyOption({ a: 3 } as Record<string, number>, 'b', f),\n Option.none()\n)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const modifyOption: { <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Option.Option<Record<K, A | B>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "replaceOption",
    "description": "Replaces a value in the record with the new value passed as parameter.",
    "deprecated": false,
    "examples": [
      "import { Record, Option } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),\n  Option.some({ a: 10, b: 2, c: 3 })\n)\nassert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), 'a', 10), Option.none())"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const replaceOption: { <K extends string | symbol, B>(key: NoInfer<K>, b: B): <A>(self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, b: B): Option.Option<Record<K, A | B>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "remove",
    "description": "If the given key exists in the record, returns a new record with the key removed,\notherwise returns a copy of the original record.",
    "deprecated": false,
    "examples": [
      "import { remove } from \"effect/Record\"\n\nassert.deepStrictEqual(remove({ a: 1, b: 2 }, \"a\"), { b: 2 })"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const remove: { <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Record<Exclude<K, X>, A>; <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Record<Exclude<K, X>, A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "pop",
    "description": "Retrieves the value of the property with the given `key` from a record and returns an `Option`\nof a tuple with the value and the record with the removed property.\nIf the key is not present, returns `O.none`.",
    "deprecated": false,
    "examples": [
      "import { Record as R, Option } from \"effect\"\n\nassert.deepStrictEqual(R.pop({ a: 1, b: 2 }, \"a\"), Option.some([1, { b: 2 }]))\nassert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, \"c\"), Option.none())"
    ],
    "since": "2.0.0",
    "category": "record",
    "signature": "export declare const pop: { <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Option.Option<[A, Record<Exclude<K, X>, A>]>; <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Option.Option<[A, Record<Exclude<K, X>, A>]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Maps a record into another record by applying a transformation function to each of its values.",
    "deprecated": false,
    "examples": [
      "import { map } from \"effect/Record\"\n\nconst f = (n: number) => `-${n}`\n\nassert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: \"-3\", b: \"-5\" })\n\nconst g = (n: number, key: string) => `${key.toUpperCase()}-${n}`\n\nassert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: \"A-3\", b: \"B-5\" })"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <K extends string, A, B>(f: (a: A, key: NoInfer<K>) => B): (self: ReadonlyRecord<K, A>) => Record<K, B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: NoInfer<K>) => B): Record<K, B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "mapKeys",
    "description": "Maps the keys of a `ReadonlyRecord` while preserving the corresponding values.",
    "deprecated": false,
    "examples": [
      "import { mapKeys } from \"effect/Record\"\n\nassert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapKeys: { <K extends string, A, K2 extends string>(f: (key: K, a: A) => K2): (self: ReadonlyRecord<K, A>) => Record<K2, A>; <K extends string, A, K2 extends string>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => K2): Record<K2, A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "mapEntries",
    "description": "Maps entries of a `ReadonlyRecord` using the provided function, allowing modification of both keys and corresponding values.",
    "deprecated": false,
    "examples": [
      "import { mapEntries } from \"effect/Record\"\n\nassert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapEntries: { <K extends string, A, K2 extends string, B>(f: (a: A, key: K) => readonly [K2, B]): (self: ReadonlyRecord<K, A>) => Record<K2, B>; <K extends string, A, K2 extends string, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => [K2, B]): Record<K2, B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Transforms a record into a record by applying the function `f` to each key and value in the original record.\nIf the function returns `Some`, the key-value pair is included in the output record.",
    "deprecated": false,
    "examples": [
      "import { Record, Option } from \"effect\"\n\nconst x = { a: 1, b: 2, c: 3 }\nconst f = (a: number, key: string) => a > 2 ? Option.some(a * 2) : Option.none()\nassert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const filterMap: { <K extends string, A, B>(f: (a: A, key: K) => Option.Option<B>): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => Option.Option<B>): Record<ReadonlyRecord.NonLiteralKey<K>, B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": "Selects properties from a record whose values match the given predicate.",
    "deprecated": false,
    "examples": [
      "import { filter } from \"effect/Record\"\n\nconst x = { a: 1, b: 2, c: 3, d: 4 }\nassert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filter: { <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A>(predicate: (A: NoInfer<A>, key: K) => boolean): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, A>; <K extends string, A, B extends A>(self: ReadonlyRecord<K, A>, refinement: (a: A, key: K) => a is B): Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (a: A, key: K) => boolean): Record<ReadonlyRecord.NonLiteralKey<K>, A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "getSomes",
    "description": "Given a record with `Option` values, returns a new record containing only the `Some` values, preserving the original keys.",
    "deprecated": false,
    "examples": [
      "import { Record, Option } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.getSomes({ a: Option.some(1), b: Option.none(), c: Option.some(2) }),\n  { a: 1, c: 2 }\n)"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const getSomes: <K extends string, A>(self: ReadonlyRecord<K, Option.Option<A>>) => Record<ReadonlyRecord.NonLiteralKey<K>, A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "partitionMap",
    "description": "Partitions the elements of a record into two groups: those that match a predicate, and those that don't.",
    "deprecated": false,
    "examples": [
      "import { Record, Either } from \"effect\"\n\nconst x = { a: 1, b: 2, c: 3 }\nconst f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))\nassert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const partitionMap: { <K extends string, A, B, C>(f: (a: A, key: K) => Either<C, B>): (self: ReadonlyRecord<K, A>) => [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]; <K extends string, A, B, C>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => Either<C, B>): [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "separate",
    "description": "Partitions a record of `Either` values into two separate records,\none with the `Left` values and one with the `Right` values.",
    "deprecated": false,
    "examples": [
      "import { Record, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.separate({ a: Either.left(\"e\"), b: Either.right(1) }),\n  [{ a: \"e\" }, { b: 1 }]\n)"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const separate: <K extends string, A, B>(self: ReadonlyRecord<K, Either<B, A>>) => [Record<ReadonlyRecord.NonLiteralKey<K>, A>, Record<ReadonlyRecord.NonLiteralKey<K>, B>]"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "partition",
    "description": "Partitions a record into two separate records based on the result of a predicate function.",
    "deprecated": false,
    "examples": [
      "import { partition } from \"effect/Record\"\n\nassert.deepStrictEqual(\n  partition({ a: 1, b: 3 }, (n) => n > 2),\n  [{ a: 1 }, { b: 3 }]\n)"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const partition: { <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (self: ReadonlyRecord<K, A>) => [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>]; <K extends string, A>(predicate: (a: NoInfer<A>, key: K) => boolean): (self: ReadonlyRecord<K, A>) => [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]; <K extends string, A, B extends A>(self: ReadonlyRecord<K, A>, refinement: (a: A, key: K) => a is B): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>]; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (a: A, key: K) => boolean): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": "Add a new key-value pair or update an existing key's value in a record.",
    "deprecated": false,
    "examples": [
      "import { set } from \"effect/Record\"\n\nassert.deepStrictEqual(set(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\nassert.deepStrictEqual(set(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const set: { <K extends string | symbol, K1 extends K | ((string | symbol) & {}), B>(key: K1, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K | K1, A | B>; <K extends string | symbol, A, K1 extends K | ((string | symbol) & {}), B>(self: ReadonlyRecord<K, A>, key: K1, value: B): Record<K | K1, A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "replace",
    "description": "Replace a key's value in a record and return the updated record.\nIf the key does not exist in the record, a copy of the original record is returned.",
    "deprecated": false,
    "examples": [
      "import { Record } from \"effect\"\n\nassert.deepStrictEqual(Record.replace(\"a\", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });\nassert.deepStrictEqual(Record.replace(\"c\", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const replace: { <K extends string | symbol, B>(key: NoInfer<K>, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K, A | B>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, value: B): Record<K, A | B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "isSubrecord",
    "description": "Check if one record is a subrecord of another, meaning it contains all the keys and values found in the second record.\nThis comparison uses default equality checks (`Equal.equivalence()`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const isSubrecord: { <K extends string, A>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean; <K extends string, A>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": "Reduce a record to a single value by combining its entries with a specified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduce: { <Z, V, K extends string>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: ReadonlyRecord<K, V>) => Z; <K extends string, V, Z>(self: ReadonlyRecord<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "every",
    "description": "Check if all entries in a record meet a specific condition.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const every: { <A, K extends string, B extends A>(refinement: (value: A, key: K) => value is B): (self: ReadonlyRecord<K, A>) => self is ReadonlyRecord<K, B>; <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean; <A, K extends string, B extends A>(self: ReadonlyRecord<K, A>, refinement: (value: A, key: K) => value is B): self is ReadonlyRecord<K, B>; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": "Check if any entry in a record meets a specific condition.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const some: { <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "union",
    "description": "Merge two records, preserving entries that exist in either of the records.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const union: { <K1 extends string, A, B, C>(that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B | C>; <K0 extends string, A, K1 extends string, B, C>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): Record<K0 | K1, A | B | C>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "intersection",
    "description": "Merge two records, retaining only the entries that exist in both records.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const intersection: { <K1 extends string, A, B, C>(that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>; <K0 extends string, A, K1 extends string, B, C>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "difference",
    "description": "Merge two records, preserving only the entries that are unique to each record.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const difference: { <K1 extends string, B>(that: ReadonlyRecord<K1, B>): <K0 extends string, A>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B>; <K0 extends string, A, K1 extends string, B>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>): Record<K0 | K1, A | B>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates a new, empty record.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "isEmptyRecord",
    "description": "Determine if a record is empty.",
    "deprecated": false,
    "examples": [
      "import { isEmptyRecord } from \"effect/Record\"\n\nassert.deepStrictEqual(isEmptyRecord({}), true);\nassert.deepStrictEqual(isEmptyRecord({ a: 3 }), false);"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterableBy",
    "description": "Creates a new record from an iterable, utilizing the provided function to determine the key for each element.",
    "deprecated": false,
    "examples": [
      "import { fromIterableBy } from \"effect/Record\"\n\nconst users = [\n  { id: \"2\", name: \"name2\" },\n  { id: \"1\", name: \"name1\" }\n]\n\nassert.deepStrictEqual(\n  fromIterableBy(users, user => user.id),\n  {\n    \"2\": { id: \"2\", name: \"name2\" },\n    \"1\": { id: \"1\", name: \"name1\" }\n  }\n)"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the number of key/value pairs in a record.",
    "deprecated": false,
    "examples": [
      "import { size } from \"effect/Record\";\n\nassert.deepStrictEqual(size({ a: \"a\", b: 1, c: true }), 3);"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "getLefts",
    "description": "Given a record with `Either` values, returns a new record containing only the `Left` values, preserving the original keys.",
    "deprecated": false,
    "examples": [
      "import { Record, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.getLefts({ a: Either.right(1), b: Either.left(\"err\"), c: Either.right(2) }),\n  { b: \"err\" }\n)"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "getRights",
    "description": "Given a record with `Either` values, returns a new record containing only the `Right` values, preserving the original keys.",
    "deprecated": false,
    "examples": [
      "import { Record, Either } from \"effect\"\n\nassert.deepStrictEqual(\n  Record.getRights({ a: Either.right(1), b: Either.left(\"err\"), c: Either.right(2) }),\n  { a: 1, c: 2 }\n)"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "keys",
    "description": "Retrieve the keys of a given record as an array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "values",
    "description": "Retrieve the values of a given record as an array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "isSubrecordBy",
    "description": "Check if all the keys and values in one record are also found in another record.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": "Create an `Equivalence` for records using the provided `Equivalence` for values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "singleton",
    "description": "Create a non-empty record from a single element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlyRecordTypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface ReadonlyRecordTypeLambda<K extends string = string> extends TypeLambda {\n  readonly type: ReadonlyRecord<K, this[\"Target\"]>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Record",
      "path": [
        "src",
        "Record.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlyRecord",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type ReadonlyRecord<in out K extends string | symbol, out A> = {\n  readonly [P in K]: A\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Redacted",
      "path": [
        "src",
        "Redacted.ts"
      ]
    },
    "project": "effect",
    "name": "RedactedTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "symbols",
    "signature": "export declare const RedactedTypeId: typeof RedactedTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Redacted",
      "path": [
        "src",
        "Redacted.ts"
      ]
    },
    "project": "effect",
    "name": "isRedacted",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "refinements",
    "signature": "export declare const isRedacted: (u: unknown) => u is Redacted<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Redacted",
      "path": [
        "src",
        "Redacted.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "This function creates a `Redacted<A>` instance from a given value `A`,\nsecurely hiding its content.",
    "deprecated": false,
    "examples": [
      "import { Redacted } from \"effect\"\n\nconst API_KEY = Redacted.make(\"1234567890\")"
    ],
    "since": "3.3.0",
    "category": "constructors",
    "signature": "export declare const make: <A>(value: A) => Redacted<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Redacted",
      "path": [
        "src",
        "Redacted.ts"
      ]
    },
    "project": "effect",
    "name": "value",
    "description": "Retrieves the original value from a `Redacted` instance. Use this function\nwith caution, as it exposes the sensitive data.",
    "deprecated": false,
    "examples": [
      "import { Redacted } from \"effect\"\n\nconst API_KEY = Redacted.make(\"1234567890\")\n\nassert.equal(Redacted.value(API_KEY), \"1234567890\")"
    ],
    "since": "3.3.0",
    "category": "getters",
    "signature": "export declare const value: <A>(self: Redacted<A>) => A"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Redacted",
      "path": [
        "src",
        "Redacted.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeWipe",
    "description": "Erases the underlying value of a `Redacted` instance, rendering it unusable.\nThis function is intended to ensure that sensitive data does not remain in\nmemory longer than necessary.",
    "deprecated": false,
    "examples": [
      "import { Redacted } from \"effect\"\n\nconst API_KEY = Redacted.make(\"1234567890\")\n\nassert.equal(Redacted.value(API_KEY), \"1234567890\")\n\nRedacted.unsafeWipe(API_KEY)\n\nassert.throws(() => Redacted.value(API_KEY), new Error(\"Unable to get redacted value\"))"
    ],
    "since": "3.3.0",
    "category": "unsafe",
    "signature": "export declare const unsafeWipe: <A>(self: Redacted<A>) => boolean"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Redacted",
      "path": [
        "src",
        "Redacted.ts"
      ]
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": "Generates an equivalence relation for `Redacted<A>` values based on an\nequivalence relation for the underlying values `A`. This function is useful\nfor comparing `Redacted` instances without exposing their contents.",
    "deprecated": false,
    "examples": [
      "import { Redacted, Equivalence } from \"effect\"\n\nconst API_KEY1 = Redacted.make(\"1234567890\")\nconst API_KEY2 = Redacted.make(\"1-34567890\")\nconst API_KEY3 = Redacted.make(\"1234567890\")\n\nconst equivalence = Redacted.getEquivalence(Equivalence.string)\n\nassert.equal(equivalence(API_KEY1, API_KEY2), false)\nassert.equal(equivalence(API_KEY1, API_KEY3), true)"
    ],
    "since": "3.3.0",
    "category": "equivalence",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Redacted",
      "path": [
        "src",
        "Redacted.ts"
      ]
    },
    "project": "effect",
    "name": "Redacted",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "models",
    "signature": "export interface Redacted<out A = string> extends Redacted.Variance<A>, Equal.Equal, Pipeable {\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Redacted",
      "path": [
        "src",
        "Redacted.ts"
      ]
    },
    "project": "effect",
    "name": "RedactedTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.3.0",
    "category": "symbols",
    "signature": "export type RedactedTypeId = typeof RedactedTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "Direction",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constants",
    "signature": "export declare const Direction: { readonly Forward: RedBlackTree.Direction; readonly Backward: RedBlackTree.Direction; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "isRedBlackTree",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isRedBlackTree: { <K, V>(u: Iterable<readonly [K, V]>): u is RedBlackTree<K, V>; (u: unknown): u is RedBlackTree<unknown, unknown>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates an empty `RedBlackTree`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: <K, V = never>(ord: Order<K>) => RedBlackTree<K, V>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `RedBlackTree` from an iterable collection of key/value pairs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterable: { <B>(ord: Order<B>): <K extends B, V>(entries: Iterable<readonly [K, V]>) => RedBlackTree<K, V>; <K extends B, V, B>(entries: Iterable<readonly [K, V]>, ord: Order<B>): RedBlackTree<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new `RedBlackTree` from the specified entries.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <K>(ord: Order<K>) => <Entries extends Array<readonly [K, any]>>(...entries: Entries) => RedBlackTree<K, Entries[number] extends readonly [any, infer V] ? V : never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "at",
    "description": "Returns an iterator that points to the element at the specified index of the\ntree.\n\n**Note**: The iterator will run through elements in order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const at: { (index: number): <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, index: number): Iterable<[K, V]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "atReversed",
    "description": "Returns an iterator that points to the element at the specified index of the\ntree.\n\n**Note**: The iterator will run through elements in reverse order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const atReversed: { (index: number): <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, index: number): Iterable<[K, V]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "findAll",
    "description": "Finds all values in the tree associated with the specified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findAll: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Chunk<V>; <K, V>(self: RedBlackTree<K, V>, key: K): Chunk<V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Finds the first value in the tree associated with the specified key, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirst: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Option<V>; <K, V>(self: RedBlackTree<K, V>, key: K): Option<V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "first",
    "description": "Returns the first entry in the tree, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const first: <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "getAt",
    "description": "Returns the element at the specified index within the tree or `None` if the\nspecified index does not exist.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const getAt: { (index: number): <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>; <K, V>(self: RedBlackTree<K, V>, index: number): Option<[K, V]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "getOrder",
    "description": "Gets the `Order<K>` that the `RedBlackTree<K, V>` is using.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const getOrder: <K, V>(self: RedBlackTree<K, V>) => Order<K>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThan",
    "description": "Returns an iterator that traverse entries in order with keys greater than the\nspecified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const greaterThan: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanReversed",
    "description": "Returns an iterator that traverse entries in reverse order with keys greater\nthan the specified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const greaterThanReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanEqual",
    "description": "Returns an iterator that traverse entries in order with keys greater than or\nequal to the specified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const greaterThanEqual: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanEqualReversed",
    "description": "Returns an iterator that traverse entries in reverse order with keys greater\nthan or equal to the specified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const greaterThanEqualReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "has",
    "description": "Finds the item with key, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const has: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => boolean; <K, V>(self: RedBlackTree<K, V>, key: K): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "insert",
    "description": "Insert a new item into the tree.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const insert: { <K, V>(key: K, value: V): (self: RedBlackTree<K, V>) => RedBlackTree<K, V>; <K, V>(self: RedBlackTree<K, V>, key: K, value: V): RedBlackTree<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "keys",
    "description": "Get all the keys present in the tree in order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const keys: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<K>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "keysReversed",
    "description": "Get all the keys present in the tree in reverse order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const keysReversed: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<K>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "last",
    "description": "Returns the last entry in the tree, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const last: <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "lessThan",
    "description": "Returns an iterator that traverse entries in order with keys less than the\nspecified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const lessThan: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanReversed",
    "description": "Returns an iterator that traverse entries in reverse order with keys less\nthan the specified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const lessThanReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanEqual",
    "description": "Returns an iterator that traverse entries in order with keys less than or\nequal to the specified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const lessThanEqual: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanEqualReversed",
    "description": "Returns an iterator that traverse entries in reverse order with keys less\nthan or equal to the specified key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const lessThanEqualReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "Execute the specified function for each node of the tree, in order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const forEach: { <K, V>(f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, f: (key: K, value: V) => void): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "forEachGreaterThanEqual",
    "description": "Visit each node of the tree in order with key greater then or equal to max.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const forEachGreaterThanEqual: { <K, V>(min: K, f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, min: K, f: (key: K, value: V) => void): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "forEachLessThan",
    "description": "Visit each node of the tree in order with key lower then max.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const forEachLessThan: { <K, V>(max: K, f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, max: K, f: (key: K, value: V) => void): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "forEachBetween",
    "description": "Visit each node of the tree in order with key lower than max and greater\nthan or equal to min.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const forEachBetween: { <K, V>(options: { readonly min: K; readonly max: K; readonly body: (key: K, value: V) => void; }): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, options: { readonly min: K; readonly max: K; readonly body: (key: K, value: V) => void; }): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": "Reduce a state over the entries of the tree.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduce: { <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: RedBlackTree<K, V>) => Z; <Z, V, K>(self: RedBlackTree<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "removeFirst",
    "description": "Removes the entry with the specified key, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const removeFirst: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => RedBlackTree<K, V>; <K, V>(self: RedBlackTree<K, V>, key: K): RedBlackTree<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "reversed",
    "description": "Traverse the tree in reverse order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const reversed: <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the size of the tree.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const size: <K, V>(self: RedBlackTree<K, V>) => number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "values",
    "description": "Get all values present in the tree in order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const values: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<V>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "valuesReversed",
    "description": "Get all values present in the tree in reverse order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const valuesReversed: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<V>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "RedBlackTree",
    "description": "A Red-Black Tree.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RedBlackTree<in out Key, out Value> extends Iterable<[Key, Value]>, Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _Key: Types.Invariant<Key>\n    readonly _Value: Types.Covariant<Value>\n  }\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RedBlackTree",
      "path": [
        "src",
        "RedBlackTree.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "RefTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const RefTypeId: typeof RefTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <A>(value: A) => Effect.Effect<Ref<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const get: <A>(self: Ref<A>) => Effect.Effect<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "getAndSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndSet: { <A>(value: A): (self: Ref<A>) => Effect.Effect<A>; <A>(self: Ref<A>, value: A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndUpdate: { <A>(f: (a: A) => A): (self: Ref<A>) => Effect.Effect<A>; <A>(self: Ref<A>, f: (a: A) => A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdateSome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndUpdateSome: { <A>(pf: (a: A) => Option.Option<A>): (self: Ref<A>) => Effect.Effect<A>; <A>(self: Ref<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "modify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const modify: { <A, B>(f: (a: A) => readonly [B, A]): (self: Ref<A>) => Effect.Effect<B>; <A, B>(self: Ref<A>, f: (a: A) => readonly [B, A]): Effect.Effect<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "modifySome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const modifySome: { <B, A>(fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): (self: Ref<A>) => Effect.Effect<B>; <A, B>(self: Ref<A>, fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): Effect.Effect<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const set: { <A>(value: A): (self: Ref<A>) => Effect.Effect<void>; <A>(self: Ref<A>, value: A): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "setAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const setAndGet: { <A>(value: A): (self: Ref<A>) => Effect.Effect<A>; <A>(self: Ref<A>, value: A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "update",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const update: { <A>(f: (a: A) => A): (self: Ref<A>) => Effect.Effect<void>; <A>(self: Ref<A>, f: (a: A) => A): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "updateAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateAndGet: { <A>(f: (a: A) => A): (self: Ref<A>) => Effect.Effect<A>; <A>(self: Ref<A>, f: (a: A) => A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "updateSome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateSome: { <A>(f: (a: A) => Option.Option<A>): (self: Ref<A>) => Effect.Effect<void>; <A>(self: Ref<A>, f: (a: A) => Option.Option<A>): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "updateSomeAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateSomeAndGet: { <A>(pf: (a: A) => Option.Option<A>): (self: Ref<A>) => Effect.Effect<A>; <A>(self: Ref<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMake",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeMake: <A>(value: A) => Ref<A>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "Ref",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Ref<in out A> extends Ref.Variance<A>, Effect.Effect<A>, Readable.Readable<A> {\n  modify<B>(f: (a: A) => readonly [B, A]): Effect.Effect<B>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: RefUnify<this>\n  readonly [Unify.ignoreSymbol]?: RefUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "RefUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface RefUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Ref?: () => Extract<A[Unify.typeSymbol], Ref<any>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "RefUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface RefUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Ref",
      "path": [
        "src",
        "Ref.ts"
      ]
    },
    "project": "effect",
    "name": "RefTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type RefTypeId = typeof RefTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RegExp",
      "path": [
        "src",
        "RegExp.ts"
      ]
    },
    "project": "effect",
    "name": "isRegExp",
    "description": "Tests if a value is a `RegExp`.",
    "deprecated": false,
    "examples": [
      "import { RegExp } from \"effect\"\n\nassert.deepStrictEqual(RegExp.isRegExp(/a/), true)\nassert.deepStrictEqual(RegExp.isRegExp(\"a\"), false)"
    ],
    "since": "3.9.0",
    "category": "guards",
    "signature": "export declare const isRegExp: (input: unknown) => input is RegExp"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "RegExp",
      "path": [
        "src",
        "RegExp.ts"
      ]
    },
    "project": "effect",
    "name": "escape",
    "description": "Escapes special characters in a regular expression pattern.",
    "deprecated": false,
    "examples": [
      "import { RegExp } from \"effect\"\n\nassert.deepStrictEqual(RegExp.escape(\"a*b\"), \"a\\\\*b\")"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable",
      "path": [
        "src",
        "Reloadable.ts"
      ]
    },
    "project": "effect",
    "name": "ReloadableTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const ReloadableTypeId: typeof ReloadableTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable",
      "path": [
        "src",
        "Reloadable.ts"
      ]
    },
    "project": "effect",
    "name": "auto",
    "description": "Makes a new reloadable service from a layer that describes the construction\nof a static service. The service is automatically reloaded according to the\nprovided schedule.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const auto: <I, S, E, In, R>(tag: Context.Tag<I, S>, options: { readonly layer: Layer.Layer<I, E, In>; readonly schedule: Schedule.Schedule<unknown, unknown, R>; }) => Layer.Layer<Reloadable<I>, E, R | In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable",
      "path": [
        "src",
        "Reloadable.ts"
      ]
    },
    "project": "effect",
    "name": "autoFromConfig",
    "description": "Makes a new reloadable service from a layer that describes the construction\nof a static service. The service is automatically reloaded according to a\nschedule, which is extracted from the input to the layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const autoFromConfig: <I, S, E, In, R>(tag: Context.Tag<I, S>, options: { readonly layer: Layer.Layer<I, E, In>; readonly scheduleFromConfig: (context: Context.Context<In>) => Schedule.Schedule<unknown, unknown, R>; }) => Layer.Layer<Reloadable<I>, E, R | In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable",
      "path": [
        "src",
        "Reloadable.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves the current version of the reloadable service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const get: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<S, never, Reloadable<I>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable",
      "path": [
        "src",
        "Reloadable.ts"
      ]
    },
    "project": "effect",
    "name": "manual",
    "description": "Makes a new reloadable service from a layer that describes the construction\nof a static service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const manual: <I, S, In, E>(tag: Context.Tag<I, S>, options: { readonly layer: Layer.Layer<I, E, In>; }) => Layer.Layer<Reloadable<I>, E, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable",
      "path": [
        "src",
        "Reloadable.ts"
      ]
    },
    "project": "effect",
    "name": "reload",
    "description": "Reloads the specified service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const reload: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<void, unknown, Reloadable<I>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable",
      "path": [
        "src",
        "Reloadable.ts"
      ]
    },
    "project": "effect",
    "name": "tag",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const tag: <I, S>(tag: Context.Tag<I, S>) => Context.Tag<Reloadable<I>, Reloadable<S>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Reloadable",
      "path": [
        "src",
        "Reloadable.ts"
      ]
    },
    "project": "effect",
    "name": "reloadFork",
    "description": "Forks the reload of the service in the background, ignoring any errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const reloadFork: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<void, unknown, Reloadable<I>>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Reloadable",
      "path": [
        "src",
        "Reloadable.ts"
      ]
    },
    "project": "effect",
    "name": "Reloadable",
    "description": "A `Reloadable` is an implementation of some service that can be dynamically\nreloaded, or swapped out for another implementation on-the-fly.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Reloadable<in out A> extends Reloadable.Variance<A> {\n  /**\n   * @internal\n   */\n  readonly scopedRef: ScopedRef.ScopedRef<A>\n  /**\n   * @internal\n   */\n  readonly reload: Effect.Effect<void, unknown>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Reloadable",
      "path": [
        "src",
        "Reloadable.ts"
      ]
    },
    "project": "effect",
    "name": "ReloadableTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type ReloadableTypeId = typeof ReloadableTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "RequestTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const RequestTypeId: typeof RequestTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "isRequest",
    "description": "Returns `true` if the specified value is a `Request`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isRequest: (u: unknown) => u is Request<unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "of",
    "description": "Constructs a new `Request`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const of: <R extends Request<any, any>>() => Request.Constructor<R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "tagged",
    "description": "Constructs a new `Request`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const tagged: <R extends Request<any, any> & { _tag: string; }>(tag: R[\"_tag\"]) => Request.Constructor<R, \"_tag\">"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "Class",
    "description": "Provides a constructor for a Request Class.",
    "deprecated": false,
    "examples": [
      "import { Request } from \"effect\"\n\ntype Success = string\ntype Error = never\n\nclass MyRequest extends Request.Class<Success, Error, {\n  readonly id: string\n}> {}"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Class: new <Success, Error, A extends Record<string, any>>(args: Types.Equals<Omit<A, keyof Request<unknown, unknown>>, {}> extends true ? void : { readonly [P in keyof A as P extends keyof Request<unknown, unknown> ? never : P]: A[P]; }) => Request<Success, Error> & Readonly<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "TaggedClass",
    "description": "Provides a Tagged constructor for a Request Class.",
    "deprecated": false,
    "examples": [
      "import { Request } from \"effect\"\n\ntype Success = string\ntype Error = never\n\nclass MyRequest extends Request.TaggedClass(\"MyRequest\")<Success, Error, {\n  readonly name: string\n}> {}"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const TaggedClass: <Tag extends string>(tag: Tag) => new <Success, Error, A extends Record<string, any>>(args: Types.Equals<Omit<A, keyof Request<unknown, unknown>>, {}> extends true ? void : { readonly [P in keyof A as P extends \"_tag\" | keyof Request<unknown, unknown> ? never : P]: A[P]; }) => Request<Success, Error> & Readonly<A> & { readonly _tag: Tag; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "complete",
    "description": "Complete a `Request` with the specified result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "request completion",
    "signature": "export declare const complete: { <A extends Request<any, any>>(result: Request.Result<A>): (self: A) => Effect.Effect<void>; <A extends Request<any, any>>(self: A, result: Request.Result<A>): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "interruptWhenPossible",
    "description": "Interrupts the child effect when requests are no longer needed",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "request completion",
    "signature": "export declare const interruptWhenPossible: { (all: Iterable<Request<any, any>>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<void, E, R>; <A, E, R>(self: Effect.Effect<A, E, R>, all: Iterable<Request<any, any>>): Effect.Effect<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "completeEffect",
    "description": "Complete a `Request` with the specified effectful computation, failing the\nrequest with the error from the effect workflow if it fails, and completing\nthe request with the value of the effect workflow if it succeeds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "request completion",
    "signature": "export declare const completeEffect: { <A extends Request<any, any>, R>(effect: Effect.Effect<Request.Success<A>, Request.Error<A>, R>): (self: A) => Effect.Effect<void, never, R>; <A extends Request<any, any>, R>(self: A, effect: Effect.Effect<Request.Success<A>, Request.Error<A>, R>): Effect.Effect<void, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": "Complete a `Request` with the specified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "request completion",
    "signature": "export declare const fail: { <A extends Request<any, any>>(error: Request.Error<A>): (self: A) => Effect.Effect<void>; <A extends Request<any, any>>(self: A, error: Request.Error<A>): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "failCause",
    "description": "Complete a `Request` with the specified cause.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "request completion",
    "signature": "export declare const failCause: { <A extends Request<any, any>>(cause: Cause<Request.Error<A>>): (self: A) => Effect.Effect<void>; <A extends Request<any, any>>(self: A, cause: Cause<Request.Error<A>>): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": "Complete a `Request` with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "request completion",
    "signature": "export declare const succeed: { <A extends Request<any, any>>(value: Request.Success<A>): (self: A) => Effect.Effect<void>; <A extends Request<any, any>>(self: A, value: Request.Success<A>): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "EntryTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const EntryTypeId: typeof EntryTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "isEntry",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isEntry: (u: unknown) => u is Entry<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "makeEntry",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeEntry: <A extends Request<any, any>>(options: { readonly request: A; readonly result: Deferred<Request.Success<A>, Request.Error<A>>; readonly listeners: Listeners; readonly ownerId: FiberId; readonly state: { completed: boolean; }; }) => Entry<A>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "makeCache",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "Cache",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Cache extends\n  _Cache.ConsumerCache<Request<any, any>, {\n    listeners: Listeners\n    handle: Deferred<unknown, unknown>\n  }>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "Entry",
    "description": "A `Entry<A>` keeps track of a request of type `A` along with a\n`Ref` containing the result of the request, existentially hiding the result\ntype. This is used internally by the library to support data sources that\nreturn different result types for different requests while guaranteeing that\nresults will be of the type requested.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Entry<out R> extends Entry.Variance<R> {\n  readonly request: R\n  readonly result: Deferred<\n    [R] extends [Request<infer _A, infer _E>] ? _A : never,\n    [R] extends [Request<infer _A, infer _E>] ? _E : never\n  >\n  readonly listeners: Listeners\n  readonly ownerId: FiberId\n  readonly state: {\n    completed: boolean\n  }\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "Listeners",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Listeners {\n  readonly count: number\n  readonly observers: Set<(count: number) => void>\n  interrupted: boolean\n  addObserver(f: (count: number) => void): void\n  removeObserver(f: (count: number) => void): void\n  increment(): void\n  decrement(): void\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "Request",
    "description": "A `Request<A, E>` is a request from a data source for a value of type `A`\nthat may fail with an `E`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Request<out A, out E = never> extends Request.Variance<A, E> {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "EntryTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type EntryTypeId = typeof EntryTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Request",
      "path": [
        "src",
        "Request.ts"
      ]
    },
    "project": "effect",
    "name": "RequestTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type RequestTypeId = typeof RequestTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestBlock",
      "path": [
        "src",
        "RequestBlock.ts"
      ]
    },
    "project": "effect",
    "name": "single",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const single: <A>(dataSource: RequestResolver.RequestResolver<A>, blockedRequest: Request.Entry<A>) => RequestBlock"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestBlock",
      "path": [
        "src",
        "RequestBlock.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: RequestBlock"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestBlock",
      "path": [
        "src",
        "RequestBlock.ts"
      ]
    },
    "project": "effect",
    "name": "mapRequestResolvers",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const mapRequestResolvers: <A>(self: RequestBlock, f: (dataSource: RequestResolver.RequestResolver<A>) => RequestResolver.RequestResolver<A>) => RequestBlock"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestBlock",
      "path": [
        "src",
        "RequestBlock.ts"
      ]
    },
    "project": "effect",
    "name": "parallel",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const parallel: (self: RequestBlock, that: RequestBlock) => RequestBlock"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestBlock",
      "path": [
        "src",
        "RequestBlock.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const reduce: <Z>(self: RequestBlock, reducer: RequestBlock.Reducer<Z>) => Z"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestBlock",
      "path": [
        "src",
        "RequestBlock.ts"
      ]
    },
    "project": "effect",
    "name": "sequential",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sequential: (self: RequestBlock, that: RequestBlock) => RequestBlock"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RequestBlock",
      "path": [
        "src",
        "RequestBlock.ts"
      ]
    },
    "project": "effect",
    "name": "Empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Empty {\n  readonly _tag: \"Empty\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RequestBlock",
      "path": [
        "src",
        "RequestBlock.ts"
      ]
    },
    "project": "effect",
    "name": "Par",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Par {\n  readonly _tag: \"Par\"\n  readonly left: RequestBlock\n  readonly right: RequestBlock\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RequestBlock",
      "path": [
        "src",
        "RequestBlock.ts"
      ]
    },
    "project": "effect",
    "name": "Seq",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Seq {\n  readonly _tag: \"Seq\"\n  readonly left: RequestBlock\n  readonly right: RequestBlock\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RequestBlock",
      "path": [
        "src",
        "RequestBlock.ts"
      ]
    },
    "project": "effect",
    "name": "Single",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Single {\n  readonly _tag: \"Single\"\n  readonly dataSource: RequestResolver.RequestResolver<unknown>\n  readonly blockedRequest: Request.Entry<unknown>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RequestBlock",
      "path": [
        "src",
        "RequestBlock.ts"
      ]
    },
    "project": "effect",
    "name": "RequestBlock",
    "description": "`RequestBlock` captures a collection of blocked requests as a data\nstructure. By doing this the library is able to preserve information about\nwhich requests must be performed sequentially and which can be performed in\nparallel, allowing for maximum possible batching and pipelining while\npreserving ordering guarantees.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type RequestBlock = Empty | Par | Seq | Single"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "RequestResolverTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const RequestResolverTypeId: typeof RequestResolverTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "isRequestResolver",
    "description": "Returns `true` if the specified value is a `RequestResolver`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isRequestResolver: (u: unknown) => u is RequestResolver<unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a data source with the specified identifier and method to run\nrequests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <A, R>(runAll: (requests: Array<Array<A>>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "makeWithEntry",
    "description": "Constructs a data source with the specified identifier and method to run\nrequests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeWithEntry: <A, R>(runAll: (requests: Array<Array<Request.Entry<A>>>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "makeBatched",
    "description": "Constructs a data source from a function taking a collection of requests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeBatched: <A extends Request.Request<any, any>, R>(run: (requests: NonEmptyArray<A>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "around",
    "description": "A data source aspect that executes requests between two effects, `before`\nand `after`, where the result of `before` can be used by `after`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const around: { <A2, R2, X, R3>(before: Effect.Effect<A2, never, R2>, after: (a: A2) => Effect.Effect<X, never, R3>): <A, R>(self: RequestResolver<A, R>) => RequestResolver<A, R2 | R3 | R>; <A, R, A2, R2, X, R3>(self: RequestResolver<A, R>, before: Effect.Effect<A2, never, R2>, after: (a: A2) => Effect.Effect<X, never, R3>): RequestResolver<A, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "aroundRequests",
    "description": "A data source aspect that executes requests between two effects, `before`\nand `after`, where the result of `before` can be used by `after`.\n\nThe `before` and `after` effects are provided with the requests being executed.",
    "deprecated": false,
    "examples": [
      "import { Effect, Request, RequestResolver } from \"effect\"\n\ninterface GetUserById extends Request.Request<unknown> {\n  readonly id: number\n}\n\nconst resolver = RequestResolver.fromFunction(\n  (request: GetUserById) => ({ id: request.id, name: \"John\" })\n)\n\nRequestResolver.aroundRequests(\n  resolver,\n  (requests) => Effect.log(`got ${requests.length} requests`),\n  (requests, _) => Effect.log(`finised running ${requests.length} requests`)\n)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const aroundRequests: { <A, A2, R2, X, R3>(before: (requests: ReadonlyArray<Types.NoInfer<A>>) => Effect.Effect<A2, never, R2>, after: (requests: ReadonlyArray<Types.NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>): <R>(self: RequestResolver<A, R>) => RequestResolver<A, R2 | R3 | R>; <A, R, A2, R2, X, R3>(self: RequestResolver<A, R>, before: (requests: ReadonlyArray<Types.NoInfer<A>>) => Effect.Effect<A2, never, R2>, after: (requests: ReadonlyArray<Types.NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>): RequestResolver<A, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "batchN",
    "description": "Returns a data source that executes at most `n` requests in parallel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const batchN: { (n: number): <A, R>(self: RequestResolver<A, R>) => RequestResolver<A, R>; <A, R>(self: RequestResolver<A, R>, n: number): RequestResolver<A, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputContext",
    "description": "Provides this data source with part of its required context.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const mapInputContext: { <R0, R>(f: (context: Context.Context<R0>) => Context.Context<R>): <A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => RequestResolver<A, R0>; <R, A extends Request.Request<any, any>, R0>(self: RequestResolver<A, R>, f: (context: Context.Context<R0>) => Context.Context<R>): RequestResolver<A, R0>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "eitherWith",
    "description": "Returns a new data source that executes requests of type `C` using the\nspecified function to transform `C` requests into requests that either this\ndata source or that data source can execute.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const eitherWith: { <A extends Request.Request<any, any>, R2, B extends Request.Request<any, any>, C extends Request.Request<any, any>>(that: RequestResolver<B, R2>, f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>): <R>(self: RequestResolver<A, R>) => RequestResolver<C, R2 | R>; <R, A extends Request.Request<any, any>, R2, B extends Request.Request<any, any>, C extends Request.Request<any, any>>(self: RequestResolver<A, R>, that: RequestResolver<B, R2>, f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>): RequestResolver<C, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "fromFunction",
    "description": "Constructs a data source from a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromFunction: <A extends Request.Request<any>>(f: (request: A) => Request.Request.Success<A>) => RequestResolver<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "fromFunctionBatched",
    "description": "Constructs a data source from a pure function that takes a list of requests\nand returns a list of results of the same size. Each item in the result\nlist must correspond to the item at the same index in the request list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromFunctionBatched: <A extends Request.Request<any>>(f: (chunk: NonEmptyArray<A>) => Iterable<Request.Request.Success<A>>) => RequestResolver<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "fromEffect",
    "description": "Constructs a data source from an effectual function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromEffect: <R, A extends Request.Request<any, any>>(f: (a: A) => Effect.Effect<Request.Request.Success<A>, Request.Request.Error<A>, R>) => RequestResolver<A, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "fromEffectTagged",
    "description": "Constructs a data source from a list of tags paired to functions, that takes\na list of requests and returns a list of results of the same size. Each item\nin the result list must correspond to the item at the same index in the\nrequest list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromEffectTagged: <A extends Request.Request<any, any> & { readonly _tag: string; }>() => <Fns extends { readonly [Tag in A[\"_tag\"]]: [Extract<A, { readonly _tag: Tag; }>] extends [infer Req] ? Req extends Request.Request<infer ReqA, infer ReqE> ? (requests: Array<Req>) => Effect.Effect<Iterable<ReqA>, ReqE, any> : never : never; }>(fns: Fns) => RequestResolver<A, ReturnType<Fns[keyof Fns]> extends Effect.Effect<infer _A, infer _E, infer R> ? R : never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "never",
    "description": "A data source that never executes requests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const never: RequestResolver<never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "provideContext",
    "description": "Provides this data source with its required context.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideContext: { <R>(context: Context.Context<R>): <A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => RequestResolver<A>; <R, A extends Request.Request<any, any>>(self: RequestResolver<A, R>, context: Context.Context<R>): RequestResolver<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "race",
    "description": "Returns a new data source that executes requests by sending them to this\ndata source and that data source, returning the results from the first data\nsource to complete and safely interrupting the loser.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const race: { <A2 extends Request.Request<any, any>, R2>(that: RequestResolver<A2, R2>): <A extends Request.Request<any, any>, R>(self: RequestResolver<A, R>) => RequestResolver<A2 | A, R2 | R>; <A extends Request.Request<any, any>, R, A2 extends Request.Request<any, any>, R2>(self: RequestResolver<A, R>, that: RequestResolver<A2, R2>): RequestResolver<A | A2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "locally",
    "description": "Returns a new data source with a localized FiberRef",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const locally: { <A>(self: FiberRef<A>, value: A): <R, B extends Request.Request<any, any>>(use: RequestResolver<B, R>) => RequestResolver<B, R>; <R, B extends Request.Request<any, any>, A>(use: RequestResolver<B, R>, self: FiberRef<A>, value: A): RequestResolver<B, R>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "contextFromEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "contextFromServices",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "RequestResolver",
    "description": "The `RequestResolver<A, R>` interface requires an environment `R` and handles\nthe execution of requests of type `A`.\n\nImplementations must provide a `runAll` method, which processes a collection\nof requests and produces an effect that fulfills these requests. Requests are\norganized into a `Array<Array<A>>`, where the outer `Array` groups requests\ninto batches that are executed sequentially, and each inner `Array` contains\nrequests that can be executed in parallel. This structure allows\nimplementations to analyze all incoming requests collectively and optimize\nquery execution accordingly.\n\nImplementations are typically specialized for a subtype of `Request<A, E>`.\nHowever, they are not strictly limited to these subtypes as long as they can\nmap any given request type to `Request<A, E>`. Implementations should inspect\nthe collection of requests to identify the needed information and execute the\ncorresponding queries. It is imperative that implementations resolve all the\nrequests they receive. Failing to do so will lead to a `QueryFailure` error\nduring query execution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RequestResolver<in A, out R = never> extends RequestResolver.Variance<A, R>, Equal.Equal, Pipeable {\n  /**\n   * Execute a collection of requests. The outer `Array` represents batches\n   * of requests that must be performed sequentially. The inner `Array`\n   * represents a batch of requests that can be performed in parallel.\n   */\n  runAll(requests: Array<Array<Request.Entry<A>>>): Effect.Effect<void, never, R>\n\n  /**\n   * Identify the data source using the specific identifier\n   */\n  identified(...identifiers: Array<unknown>): RequestResolver<A, R>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RequestResolver",
      "path": [
        "src",
        "RequestResolver.ts"
      ]
    },
    "project": "effect",
    "name": "RequestResolverTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type RequestResolverTypeId = typeof RequestResolverTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Resource",
      "path": [
        "src",
        "Resource.ts"
      ]
    },
    "project": "effect",
    "name": "ResourceTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const ResourceTypeId: typeof ResourceTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Resource",
      "path": [
        "src",
        "Resource.ts"
      ]
    },
    "project": "effect",
    "name": "auto",
    "description": "Creates a new `Resource` value that is automatically refreshed according to\nthe specified policy. Note that error retrying is not performed\nautomatically, so if you want to retry on errors, you should first apply\nretry policies to the acquisition effect before passing it to this\nconstructor.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const auto: <A, E, R, Out, R2>(acquire: Effect.Effect<A, E, R>, policy: Schedule.Schedule<Out, unknown, R2>) => Effect.Effect<Resource<A, E>, never, R | R2 | Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Resource",
      "path": [
        "src",
        "Resource.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves the current value stored in the cache.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const get: <A, E>(self: Resource<A, E>) => Effect.Effect<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Resource",
      "path": [
        "src",
        "Resource.ts"
      ]
    },
    "project": "effect",
    "name": "manual",
    "description": "Creates a new `Resource` value that must be manually refreshed by calling\nthe refresh method. Note that error retrying is not performed\nautomatically, so if you want to retry on errors, you should first apply\nretry policies to the acquisition effect before passing it to this\nconstructor.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const manual: <A, E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<Resource<A, E>, never, Scope.Scope | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Resource",
      "path": [
        "src",
        "Resource.ts"
      ]
    },
    "project": "effect",
    "name": "refresh",
    "description": "Refreshes the cache. This method will not return until either the refresh\nis successful, or the refresh operation fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const refresh: <A, E>(self: Resource<A, E>) => Effect.Effect<void, E>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Resource",
      "path": [
        "src",
        "Resource.ts"
      ]
    },
    "project": "effect",
    "name": "Resource",
    "description": "A `Resource` is a possibly resourceful value that is loaded into memory, and\nwhich can be refreshed either manually or automatically.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Resource<in out A, in out E = never> extends Effect.Effect<A, E>, Resource.Variance<A, E> {\n  /** @internal */\n  readonly scopedRef: ScopedRef.ScopedRef<Exit.Exit<A, E>>\n  /** @internal */\n  readonly acquire: Effect.Effect<A, E, Scope.Scope>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: ResourceUnify<this>\n  readonly [Unify.ignoreSymbol]?: ResourceUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Resource",
      "path": [
        "src",
        "Resource.ts"
      ]
    },
    "project": "effect",
    "name": "ResourceUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface ResourceUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Resource?: () => Extract<A[Unify.typeSymbol], Resource<any, any>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Resource",
      "path": [
        "src",
        "Resource.ts"
      ]
    },
    "project": "effect",
    "name": "ResourceUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface ResourceUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Resource",
      "path": [
        "src",
        "Resource.ts"
      ]
    },
    "project": "effect",
    "name": "ResourceTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type ResourceTypeId = typeof ResourceTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "runFork",
    "description": "Executes the effect using the provided Scheduler or using the global\nScheduler if not provided",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "execution",
    "signature": "export declare const runFork: <R>(runtime: Runtime<R>) => <A, E>(self: Effect.Effect<A, E, R>, options?: RunForkOptions) => Fiber.RuntimeFiber<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "runSyncExit",
    "description": "Executes the effect synchronously returning the exit.\n\nThis method is effectful and should only be invoked at the edges of your\nprogram.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "execution",
    "signature": "export declare const runSyncExit: <R>(runtime: Runtime<R>) => <A, E>(effect: Effect.Effect<A, E, R>) => Exit.Exit<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "runSync",
    "description": "Executes the effect synchronously throwing in case of errors or async boundaries.\n\nThis method is effectful and should only be invoked at the edges of your\nprogram.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "execution",
    "signature": "export declare const runSync: <R>(runtime: Runtime<R>) => <A, E>(effect: Effect.Effect<A, E, R>) => A"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "runCallback",
    "description": "Executes the effect asynchronously, eventually passing the exit value to\nthe specified callback.\n\nThis method is effectful and should only be invoked at the edges of your\nprogram.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "execution",
    "signature": "export declare const runCallback: <R>(runtime: Runtime<R>) => <A, E>(effect: Effect.Effect<A, E, R>, options?: RunCallbackOptions<A, E> | undefined) => Cancel<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "runPromise",
    "description": "Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\nwith the value of the effect once the effect has been executed, or will be\nrejected with the first error or exception throw by the effect.\n\nThis method is effectful and should only be used at the edges of your\nprogram.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "execution",
    "signature": "export declare const runPromise: <R>(runtime: Runtime<R>) => <A, E>(effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "runPromiseExit",
    "description": "Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\nwith the `Exit` state of the effect once the effect has been executed.\n\nThis method is effectful and should only be used at the edges of your\nprogram.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "execution",
    "signature": "export declare const runPromiseExit: <R>(runtime: Runtime<R>) => <A, E>(effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<Exit.Exit<A, E>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "defaultRuntime",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const defaultRuntime: Runtime<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "defaultRuntimeFlags",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const defaultRuntimeFlags: RuntimeFlags.RuntimeFlags"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <R>(options: { readonly context: Context.Context<R>; readonly runtimeFlags: RuntimeFlags.RuntimeFlags; readonly fiberRefs: FiberRefs.FiberRefs; }) => Runtime<R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "FiberFailureId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const FiberFailureId: typeof FiberFailureId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "FiberFailureCauseId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const FiberFailureCauseId: typeof FiberFailureCauseId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "isAsyncFiberException",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isAsyncFiberException: (u: unknown) => u is AsyncFiberException<unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "isFiberFailure",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isFiberFailure: (u: unknown) => u is FiberFailure"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "makeFiberFailure",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeFiberFailure: <E>(cause: Cause<E>) => FiberFailure"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "updateRuntimeFlags",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "runtime flags",
    "signature": "export declare const updateRuntimeFlags: { (f: (flags: RuntimeFlags.RuntimeFlags) => RuntimeFlags.RuntimeFlags): <R>(self: Runtime<R>) => Runtime<R>; <R>(self: Runtime<R>, f: (flags: RuntimeFlags.RuntimeFlags) => RuntimeFlags.RuntimeFlags): Runtime<R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "enableRuntimeFlag",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "runtime flags",
    "signature": "export declare const enableRuntimeFlag: { (flag: RuntimeFlags.RuntimeFlag): <R>(self: Runtime<R>) => Runtime<R>; <R>(self: Runtime<R>, flag: RuntimeFlags.RuntimeFlag): Runtime<R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "disableRuntimeFlag",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "runtime flags",
    "signature": "export declare const disableRuntimeFlag: { (flag: RuntimeFlags.RuntimeFlag): <R>(self: Runtime<R>) => Runtime<R>; <R>(self: Runtime<R>, flag: RuntimeFlags.RuntimeFlag): Runtime<R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "updateContext",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const updateContext: { <R, R2>(f: (context: Context.Context<R>) => Context.Context<R2>): (self: Runtime<R>) => Runtime<R2>; <R, R2>(self: Runtime<R>, f: (context: Context.Context<R>) => Context.Context<R2>): Runtime<R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "provideService",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { Context, Runtime } from \"effect\"\n\nclass Name extends Context.Tag(\"Name\")<Name, string>() {}\n\nconst runtime: Runtime.Runtime<Name> = Runtime.defaultRuntime.pipe(\n  Runtime.provideService(Name, \"John\")\n)"
    ],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: S): <R>(self: Runtime<R>) => Runtime<I | R>; <R, I, S>(self: Runtime<R>, tag: Context.Tag<I, S>, service: S): Runtime<R | I>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "updateFiberRefs",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "fiber refs",
    "signature": "export declare const updateFiberRefs: { (f: (fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs): <R>(self: Runtime<R>) => Runtime<R>; <R>(self: Runtime<R>, f: (fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs): Runtime<R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "setFiberRef",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { Effect, FiberRef, Runtime } from \"effect\"\n\nconst ref = FiberRef.unsafeMake(0)\n\nconst updatedRuntime = Runtime.defaultRuntime.pipe(\n  Runtime.setFiberRef(ref, 1)\n)\n\n// returns 1\nconst result = Runtime.runSync(updatedRuntime)(FiberRef.get(ref))"
    ],
    "since": "2.0.0",
    "category": "fiber refs",
    "signature": "export declare const setFiberRef: { <A>(fiberRef: FiberRef.FiberRef<A>, value: A): <R>(self: Runtime<R>) => Runtime<R>; <R, A>(self: Runtime<R>, fiberRef: FiberRef.FiberRef<A>, value: A): Runtime<R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "deleteFiberRef",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { Effect, FiberRef, Runtime } from \"effect\"\n\nconst ref = FiberRef.unsafeMake(0)\n\nconst updatedRuntime = Runtime.defaultRuntime.pipe(\n  Runtime.setFiberRef(ref, 1),\n  Runtime.deleteFiberRef(ref)\n)\n\n// returns 0\nconst result = Runtime.runSync(updatedRuntime)(FiberRef.get(ref))"
    ],
    "since": "2.0.0",
    "category": "fiber refs",
    "signature": "export declare const deleteFiberRef: { <A>(fiberRef: FiberRef.FiberRef<A>): <R>(self: Runtime<R>) => Runtime<R>; <R, A>(self: Runtime<R>, fiberRef: FiberRef.FiberRef<A>): Runtime<R>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "AsyncFiberException",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface AsyncFiberException<out A, out E = never> {\n  readonly _tag: \"AsyncFiberException\"\n  readonly fiber: Fiber.RuntimeFiber<A, E>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "Cancel",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Cancel<out A, out E = never> {\n  (fiberId?: FiberId.FiberId, options?: RunCallbackOptions<A, E> | undefined): void\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "FiberFailure",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface FiberFailure extends Error, Inspectable {\n  readonly [FiberFailureId]: FiberFailureId\n  readonly [FiberFailureCauseId]: Cause<unknown>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "RunCallbackOptions",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RunCallbackOptions<in A, in E = never> extends RunForkOptions {\n  readonly onExit?: ((exit: Exit.Exit<A, E>) => void) | undefined\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "RunForkOptions",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface RunForkOptions {\n  readonly scheduler?: Scheduler | undefined\n  readonly updateRefs?: ((refs: FiberRefs.FiberRefs, fiberId: FiberId.Runtime) => FiberRefs.FiberRefs) | undefined\n  readonly immediate?: boolean\n  readonly scope?: Scope\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "Runtime",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Runtime<in R> extends Pipeable {\n  /**\n   * The context used as initial for forks\n   */\n  readonly context: Context.Context<R>\n  /**\n   * The runtime flags used as initial for forks\n   */\n  readonly runtimeFlags: RuntimeFlags.RuntimeFlags\n  /**\n   * The fiber references used as initial for forks\n   */\n  readonly fiberRefs: FiberRefs.FiberRefs\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "FiberFailureCauseId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "exports",
    "signature": "export type FiberFailureCauseId = typeof FiberFailureCauseId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Runtime",
      "path": [
        "src",
        "Runtime.ts"
      ]
    },
    "project": "effect",
    "name": "FiberFailureId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type FiberFailureId = typeof FiberFailureId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "None",
    "description": "No runtime flags.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const None: RuntimeFlag"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "Interruption",
    "description": "The interruption flag determines whether or not the Effect runtime system will\ninterrupt a fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Interruption: RuntimeFlag"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "OpSupervision",
    "description": "The op supervision flag determines whether or not the Effect runtime system\nwill supervise all operations of the Effect runtime. Use of this flag will\nnegatively impact performance, but is required for some operations, such as\nprofiling.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const OpSupervision: RuntimeFlag"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "RuntimeMetrics",
    "description": "The runtime metrics flag determines whether or not the Effect runtime system\nwill collect metrics about the Effect runtime. Use of this flag will have a\nvery small negative impact on performance, but generates very helpful\noperational insight into running Effect applications that can be exported to\nPrometheus or other tools via Effect Metrics.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const RuntimeMetrics: RuntimeFlag"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "WindDown",
    "description": "The wind down flag determines whether the Effect runtime system will execute\neffects in wind-down mode. In wind-down mode, even if interruption is\nenabled and a fiber has been interrupted, the fiber will continue its\nexecution uninterrupted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const WindDown: RuntimeFlag"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "CooperativeYielding",
    "description": "The cooperative yielding flag determines whether the Effect runtime will\nyield to another fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const CooperativeYielding: RuntimeFlag"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "cooperativeYielding",
    "description": "Returns `true` if the `CooperativeYielding` `RuntimeFlag` is enabled, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const cooperativeYielding: (self: RuntimeFlags) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "diff",
    "description": "Creates a `RuntimeFlagsPatch` which describes the difference between `self`\nand `that`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "diffing",
    "signature": "export declare const diff: { (that: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlagsPatch.RuntimeFlagsPatch; (self: RuntimeFlags, that: RuntimeFlags): RuntimeFlagsPatch.RuntimeFlagsPatch; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "differ",
    "description": "Constructs a differ that knows how to diff `RuntimeFlags` values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const differ: Differ.Differ<RuntimeFlags, RuntimeFlagsPatch.RuntimeFlagsPatch>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "disable",
    "description": "Disables the specified `RuntimeFlag`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const disable: { (flag: RuntimeFlag): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flag: RuntimeFlag): RuntimeFlags; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "disableAll",
    "description": "Disables all of the `RuntimeFlag`s in the specified set of `RuntimeFlags`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const disableAll: { (flags: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flags: RuntimeFlags): RuntimeFlags; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "disableCooperativeYielding",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const disableCooperativeYielding: Layer.Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "disableInterruption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const disableInterruption: Layer.Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "disableOpSupervision",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const disableOpSupervision: Layer.Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "disableRuntimeMetrics",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const disableRuntimeMetrics: Layer.Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "disableWindDown",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const disableWindDown: Layer.Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "enable",
    "description": "Enables the specified `RuntimeFlag`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const enable: { (flag: RuntimeFlag): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flag: RuntimeFlag): RuntimeFlags; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "enableAll",
    "description": "Enables all of the `RuntimeFlag`s in the specified set of `RuntimeFlags`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const enableAll: { (flags: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flags: RuntimeFlags): RuntimeFlags; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "enableCooperativeYielding",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const enableCooperativeYielding: Layer.Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "enableInterruption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const enableInterruption: Layer.Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "enableOpSupervision",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const enableOpSupervision: Layer.Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "enableRuntimeMetrics",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const enableRuntimeMetrics: Layer.Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "enableWindDown",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const enableWindDown: Layer.Layer<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "interruptible",
    "description": "Returns true only if the `Interruption` flag is **enabled** and the\n`WindDown` flag is **disabled**.\n\nA fiber is said to be interruptible if interruption is enabled and the fiber\nis not in its wind-down phase, in which it takes care of cleanup activities\nrelated to fiber shutdown.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const interruptible: (self: RuntimeFlags) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "interruption",
    "description": "Returns `true` if the `Interruption` `RuntimeFlag` is enabled, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const interruption: (self: RuntimeFlags) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "isEnabled",
    "description": "Returns `true` if the specified `RuntimeFlag` is enabled, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const isEnabled: { (flag: RuntimeFlag): (self: RuntimeFlags) => boolean; (self: RuntimeFlags, flag: RuntimeFlag): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "isDisabled",
    "description": "Returns `true` if the specified `RuntimeFlag` is disabled, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const isDisabled: { (flag: RuntimeFlag): (self: RuntimeFlags) => boolean; (self: RuntimeFlags, flag: RuntimeFlag): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: (...flags: ReadonlyArray<RuntimeFlag>) => RuntimeFlags"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "none",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const none: RuntimeFlags"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "opSupervision",
    "description": "Returns `true` if the `OpSupervision` `RuntimeFlag` is enabled, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const opSupervision: (self: RuntimeFlags) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "patch",
    "description": "Patches a set of `RuntimeFlag`s with a `RuntimeFlagsPatch`, returning the\npatched set of `RuntimeFlag`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const patch: { (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, patch: RuntimeFlagsPatch.RuntimeFlagsPatch): RuntimeFlags; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "render",
    "description": "Converts the provided `RuntimeFlags` into a `string`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "export declare const render: (self: RuntimeFlags) => string"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "runtimeMetrics",
    "description": "Returns `true` if the `RuntimeMetrics` `RuntimeFlag` is enabled, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const runtimeMetrics: (self: RuntimeFlags) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "toSet",
    "description": "Converts the provided `RuntimeFlags` into a `ReadonlySet<number>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "conversions",
    "signature": "export declare const toSet: (self: RuntimeFlags) => ReadonlySet<RuntimeFlag>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "windDown",
    "description": "Returns `true` if the `WindDown` `RuntimeFlag` is enabled, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const windDown: (self: RuntimeFlags) => boolean"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "RuntimeFlag",
    "description": "Represents a flag that can be set to enable or disable a particular feature\nof the Effect runtime.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type RuntimeFlag = number & {\n  readonly RuntimeFlag: unique symbol\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RuntimeFlags",
      "path": [
        "src",
        "RuntimeFlags.ts"
      ]
    },
    "project": "effect",
    "name": "RuntimeFlags",
    "description": "Represents a set of `RuntimeFlag`s. `RuntimeFlag`s affect the operation of\nthe Effect runtime system. They are exposed to application-level code because\nthey affect the behavior and performance of application code.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type RuntimeFlags = number & {\n  readonly RuntimeFlags: unique symbol\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "The empty `RuntimeFlagsPatch`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: RuntimeFlagsPatch"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: (active: number, enabled: number) => RuntimeFlagsPatch"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "enable",
    "description": "Creates a `RuntimeFlagsPatch` describing enabling the provided `RuntimeFlag`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const enable: (flag: RuntimeFlags.RuntimeFlag) => RuntimeFlagsPatch"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "disable",
    "description": "Creates a `RuntimeFlagsPatch` describing disabling the provided `RuntimeFlag`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const disable: (flag: RuntimeFlags.RuntimeFlag) => RuntimeFlagsPatch"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the specified `RuntimeFlagsPatch` is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isEmpty: (patch: RuntimeFlagsPatch) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "isActive",
    "description": "Returns `true` if the `RuntimeFlagsPatch` describes the specified\n`RuntimeFlag` as active.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const isActive: { (flag: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlagsPatch): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "isEnabled",
    "description": "Returns `true` if the `RuntimeFlagsPatch` describes the specified\n`RuntimeFlag` as enabled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const isEnabled: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "isDisabled",
    "description": "Returns `true` if the `RuntimeFlagsPatch` describes the specified\n`RuntimeFlag` as disabled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const isDisabled: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "includes",
    "description": "Returns `true` if the `RuntimeFlagsPatch` includes the specified\n`RuntimeFlag`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const includes: { (flag: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlagsPatch): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "andThen",
    "description": "Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,\nfollowed by `that` patch.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const andThen: { (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "both",
    "description": "Creates a `RuntimeFlagsPatch` describing application of both the `self` patch\nand `that` patch.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const both: { (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "either",
    "description": "Creates a `RuntimeFlagsPatch` describing application of either the `self`\npatch or `that` patch.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const either: { (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "exclude",
    "description": "Creates a `RuntimeFlagsPatch` which describes exclusion of the specified\n`RuntimeFlag` from the set of `RuntimeFlags`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const exclude: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): RuntimeFlagsPatch; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "inverse",
    "description": "Creates a `RuntimeFlagsPatch` which describes the inverse of the patch\nspecified by the provided `RuntimeFlagsPatch`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const inverse: (patch: RuntimeFlagsPatch) => RuntimeFlagsPatch"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "enabledSet",
    "description": "Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\nenabled by the specified `RuntimeFlagsPatch`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const enabledSet: (self: RuntimeFlagsPatch) => ReadonlySet<RuntimeFlags.RuntimeFlag>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "disabledSet",
    "description": "Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\ndisabled by the specified `RuntimeFlagsPatch`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const disabledSet: (self: RuntimeFlagsPatch) => ReadonlySet<RuntimeFlags.RuntimeFlag>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "render",
    "description": "Renders the provided `RuntimeFlagsPatch` to a string.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const render: (self: RuntimeFlagsPatch) => string"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "RuntimeFlagsPatch",
      "path": [
        "src",
        "RuntimeFlagsPatch.ts"
      ]
    },
    "project": "effect",
    "name": "RuntimeFlagsPatch",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type RuntimeFlagsPatch = number & {\n  readonly RuntimeFlagsPatch: unique symbol\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "ScheduleTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export declare const ScheduleTypeId: typeof ScheduleTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "ScheduleDriverTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export declare const ScheduleDriverTypeId: typeof ScheduleDriverTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "makeWithState",
    "description": "Creates a new schedule with a custom state and step function.\n\n**Details**\n\nThis function constructs a `Schedule` by defining its initial state and a\nstep function, which determines how the schedule progresses over time. The\nstep function is called on each iteration with the current time, an input\nvalue, and the schedule's current state. It returns the next state, an output\nvalue, and a decision on whether the schedule should continue or stop.\n\nThis function is useful for creating custom scheduling logic that goes beyond\npredefined schedules like fixed intervals or exponential backoff. It allows\nfull control over how the schedule behaves at each step.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const makeWithState: <S, In, Out, R = never>(initial: S, step: (now: number, input: In, state: S) => Effect.Effect<readonly [S, Out, ScheduleDecision.ScheduleDecision], never, R>) => Schedule<Out, In, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "isSchedule",
    "description": "Checks whether a given value is a `Schedule`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Guards",
    "signature": "export declare const isSchedule: (u: unknown) => u is Schedule<unknown, never, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "addDelay",
    "description": "Adds a delay to every interval in a schedule.\n\n**Details**\n\nThis function modifies a given schedule by applying an additional delay to\nevery interval it defines. The delay is determined by the provided function,\nwhich takes the schedule's output and returns a delay duration.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "export declare const addDelay: { <Out>(f: (out: Out) => Duration.DurationInput): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (out: Out) => Duration.DurationInput): Schedule<Out, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "addDelayEffect",
    "description": "Adds an effectfully computed delay to every interval in a schedule.\n\n**Details**\n\nThis function modifies a given schedule by applying an additional delay to\neach interval, where the delay is determined by an effectful function. The\nfunction takes the schedules output and returns an effect that produces a\ndelay duration.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "export declare const addDelayEffect: { <Out, R2>(f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>): Schedule<Out, In, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "andThen",
    "description": "Runs two schedules sequentially, merging their outputs.\n\n**Details**\n\nThis function executes two schedules one after the other. The first schedule\nruns to completion, and then the second schedule begins execution. Unlike\n{@link andThenEither}, this function merges the outputs instead of wrapping\nthem in `Either`, allowing both schedules to contribute their results\ndirectly.\n\nThis is useful when a workflow consists of two phases where the second phase\nshould start only after the first one has fully completed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequential Composition",
    "signature": "export declare const andThen: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2 | Out, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out | Out2, In & In2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "andThenEither",
    "description": "Runs two schedules sequentially, collecting results in an `Either`.\n\n**Details**\n\nThis function combines two schedules in sequence. The first schedule runs to\ncompletion, and then the second schedule starts and runs to completion as\nwell. The outputs of both schedules are collected into an `Either` structure:\n- `Either.Left` contains the output of the second schedule.\n- `Either.Right` contains the output of the first schedule.\n\nThis is useful when you need to switch from one schedule to another after the\nfirst one finishes, while still keeping track of which schedule produced each\nresult.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Sequential Composition",
    "signature": "export declare const andThenEither: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Either.Either<Out2, Out>, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Either.Either<Out2, Out>, In & In2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "as",
    "description": "Transforms a schedule to always produce a constant output.\n\n**Details**\n\nThis function modifies a given schedule so that instead of returning its\ncomputed outputs, it always returns a constant value.\n\nThis is useful when you need a schedule for timing but dont care about its\nactual output, or when you want to standardize results across different\nscheduling strategies.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const as: { <Out2>(out: Out2): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>; <Out, In, R, Out2>(self: Schedule<Out, In, R>, out: Out2): Schedule<Out2, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "asVoid",
    "description": "Transforms a schedule to always return `void` instead of its output.\n\n**Details**\n\nThis function modifies a given schedule so that it no longer returns\nmeaningful outputeach execution produces `void`. This is useful when the\nschedule is used only for timing purposes and the actual output of the\nschedule is irrelevant.\n\nThe schedule still determines when executions should occur, but the results\nare discarded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const asVoid: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<void, In, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "bothInOut",
    "description": "Combines two schedules, preserving both their inputs and outputs.\n\n**Details**\n\nThis function merges two schedules so that both their input types and output\ntypes are retained. When executed, the resulting schedule will take inputs\nfrom both original schedules and produce a tuple containing both outputs.\n\nIt recurs if either schedule wants to continue, using the shorter delay.\n\nThis is useful when you want to track multiple schedules simultaneously,\nensuring that both receive the same inputs and produce combined results.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Zipping",
    "signature": "export declare const bothInOut: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], readonly [In, In2], R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], readonly [In, In2], R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "check",
    "description": "Filters schedule executions based on a custom condition.\n\n**Details**\n\nThis function modifies a schedule by applying a custom test function to each\ninput-output pair. The test function determines whether the schedule should\ncontinue or stop. If the function returns `true`, the schedule proceeds as\nusual; if it returns `false`, the schedule terminates.\n\nThis is useful for conditional retries, custom stop conditions, or\ndynamically controlling execution based on observed inputs and outputs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const check: { <In, Out>(test: (input: In, output: Out) => boolean): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, test: (input: In, output: Out) => boolean): Schedule<Out, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "checkEffect",
    "description": "Conditionally filters schedule executions using an effectful function.\n\n**Details**\n\nThis function modifies a schedule by applying a custom effectful test\nfunction to each input-output pair. The test function determines whether the\nschedule should continue (`true`) or stop (`false`).\n\nThis is useful when the decision to continue depends on external factors such\nas database lookups, API calls, or other asynchronous computations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const checkEffect: { <In, Out, R2>(test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "collectAllInputs",
    "description": "A schedule that collects all inputs into a `Chunk`.\n\n**Details**\n\nThis function creates a schedule that never terminates and continuously\ncollects every input it receives into a `Chunk`. Each time the schedule runs,\nit appends the new input to the collected list.\n\nThis is useful when you need to track all received inputs over time, such as\nlogging user actions, recording retry attempts, or accumulating data for\nlater processing.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const collectAllInputs: <A>() => Schedule<Chunk.Chunk<A>, A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "collectAllOutputs",
    "description": "Collects all outputs of a schedule into a `Chunk`.\n\n**Details**\n\nThis function modifies a given schedule so that instead of returning\nindividual outputs, it accumulates them into a `Chunk`. The schedule\ncontinues to run, appending each output to the collected list.\n\nThis is useful when you need to track all results over time, such as logging\noutputs, aggregating data, or keeping a history of previous values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const collectAllOutputs: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Chunk.Chunk<Out>, In, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "collectUntil",
    "description": "Collects all inputs into a `Chunk` until a condition fails.\n\n**Details**\n\nThis function creates a schedule that continuously collects inputs into a\n`Chunk` until the given predicate function `f` evaluates to `false`. Once the\ncondition fails, the schedule stops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const collectUntil: <A>(f: Predicate<A>) => Schedule<Chunk.Chunk<A>, A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "collectUntilEffect",
    "description": "Collects all inputs into a `Chunk` until an effectful condition fails.\n\n**Details**\n\nThis function creates a schedule that continuously collects inputs into a\n`Chunk` until the given effectful predicate `f` returns `false`. The\npredicate runs as an effect, meaning it can involve asynchronous computations\nlike API calls, database lookups, or randomness.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const collectUntilEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<Chunk.Chunk<A>, A, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "collectWhile",
    "description": "Collects all inputs into a `Chunk` while a condition holds.\n\n**Details**\n\nThis function creates a schedule that continuously collects inputs into a\n`Chunk` while the given predicate function `f` evaluates to `true`. As soon\nas the condition fails, the schedule stops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const collectWhile: <A>(f: Predicate<A>) => Schedule<Chunk.Chunk<A>, A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "collectWhileEffect",
    "description": "Collects all inputs into a `Chunk` while an effectful condition holds.\n\n**Details**\n\nThis function creates a schedule that continuously collects inputs into a\n`Chunk` while the given effectful predicate `f` returns `true`. The predicate\nreturns an effect, meaning it can depend on external state, such as database\nqueries, API responses, or real-time user conditions.\n\nAs soon as the effectful condition returns `false`, the schedule stops. This\nis useful for dynamically controlled data collection, where stopping depends\non an external or asynchronous factor.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Collecting",
    "signature": "export declare const collectWhileEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<Chunk.Chunk<A>, A, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "compose",
    "description": "Chains two schedules, passing the output of the first as the input to the\nsecond, while selecting the shorter delay between them.\n\n**Details**\n\nThis function composes two schedules so that the output of the first schedule\nbecomes the input of the second schedule. The first schedule executes first,\nand once it produces a result, the second schedule receives that result and\ncontinues execution based on it.\n\nThis is useful for building complex scheduling workflows where one schedule's\nbehavior determines how the next schedule behaves.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "export declare const compose: { <Out2, Out, R2>(that: Schedule<Out2, Out, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>; <Out, In, R, Out2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, Out, R2>): Schedule<Out2, In, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "mapInput",
    "description": "Transforms the input type of a schedule.\n\n**Details**\n\nThis function modifies a given schedule by applying a transformation function\nto its inputs. Instead of directly receiving values of type `In`, the\nschedule will now accept values of type `In2`, which are converted to `In`\nusing the provided mapping function `f`.\n\nThis is useful when you have a schedule that expects a specific input type\nbut you need to adapt it to work with a different type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const mapInput: { <In, In2>(f: (in2: In2) => In): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R>; <Out, In, R, In2>(self: Schedule<Out, In, R>, f: (in2: In2) => In): Schedule<Out, In2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputEffect",
    "description": "Transforms the input type of a schedule using an effectful function.\n\n**Details**\n\nThis function modifies a schedule by applying an effectful transformation to\nits inputs. Instead of directly receiving values of type `In`, the schedule\nwill now accept values of type `In2`, which are converted to `In` via an\neffectful function `f`.\n\nThis is useful when the input transformation involves external dependencies,\nsuch as API calls, database lookups, or other asynchronous computations.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const mapInputEffect: { <In2, In, R2>(f: (in2: In2) => Effect.Effect<In, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R2 | R>; <Out, In, R, In2, R2>(self: Schedule<Out, In, R>, f: (in2: In2) => Effect.Effect<In, never, R2>): Schedule<Out, In2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputContext",
    "description": "Transforms the required context of a schedule.\n\n**Details**\n\nThis function modifies a schedule by mapping its required context (`R`) into\na new context (`R0`) using the provided function `f`.\n\nThis is useful when you need to adapt a schedule to work with a different\ndependency environment without changing its core logic.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const mapInputContext: { <R0, R>(f: (env0: Context.Context<R0>) => Context.Context<R>): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, R0>; <Out, In, R, R0>(self: Schedule<Out, In, R>, f: (env0: Context.Context<R0>) => Context.Context<R>): Schedule<Out, In, R0>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "count",
    "description": "A schedule that recurs indefinitely, counting the number of recurrences.\n\n**Details**\n\nThis schedule never stops and simply counts how many times it has executed.\nEach recurrence increases the count, starting from `0`.\n\nThis is useful when tracking the number of attempts in retry policies,\nmeasuring execution loops, or implementing infinite polling scenarios.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const count: Schedule<number, unknown, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "cron",
    "description": "Creates a schedule that recurs based on a cron expression.\n\n**Details**\n\nThis schedule automatically executes at intervals defined by a cron\nexpression. It triggers at the beginning of each matched interval and\nproduces timestamps representing the start and end of the cron window.\n\nThe cron `expression` is validated lazily, meaning errors may only be\ndetected when the schedule is executed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Cron",
    "signature": "export declare const cron: { (cron: Cron.Cron): Schedule<[number, number]>; (expression: string, tz?: DateTime.TimeZone | string): Schedule<[number, number]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "secondOfMinute",
    "description": "Cron-like schedule that recurs at a specific second of each minute.\n\n**Details**\n\nThis schedule triggers at the specified `second` of each minute,\nstarting at zero nanoseconds. It produces a count of executions\n(0, 1, 2, ...). The `second` parameter is validated lazily, meaning\ninvalid values will only be caught at runtime.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Cron",
    "signature": "export declare const secondOfMinute: (second: number) => Schedule<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "minuteOfHour",
    "description": "Creates a schedule that recurs every specified minute of each hour.\n\n**Details**\n\nThis schedule triggers once per hour at the specified `minute`, starting\nexactly at `minute:00` (zero seconds). The schedule produces a count of\nexecutions (`0, 1, 2, ...`), representing how many times it has run.\n\nThe `minute` parameter must be between `0` and `59`. It is validated lazily,\nmeaning an invalid value will cause errors only when the schedule is\nexecuted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Cron",
    "signature": "export declare const minuteOfHour: (minute: number) => Schedule<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "hourOfDay",
    "description": "Creates a schedule that recurs at a specific hour of each day.\n\n**Details**\n\nThis schedule triggers once per day at the specified `hour`, starting at zero\nminutes of that hour. The schedule produces a count of executions (`0, 1, 2,\n...`), indicating how many times it has been triggered.\n\nThe `hour` parameter must be between `0` (midnight) and `23` (11 PM). It is\nvalidated lazily, meaning an invalid value will cause errors only when the\nschedule is executed.\n\nThis is useful for scheduling daily recurring tasks at a fixed time, such as\nrunning batch jobs or refreshing data.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Cron",
    "signature": "export declare const hourOfDay: (hour: number) => Schedule<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "dayOfMonth",
    "description": "Creates a schedule that recurs on a specific day of the month.\n\n**Details**\n\nThis schedule triggers at midnight on the specified day of each month. It\nwill not execute in months that have fewer days than the given day. For\nexample, if the schedule is set to run on the 31st, it will not execute in\nmonths with only 30 days.\n\nThe schedule produces a count of executions, starting at 0 and incrementing\nwith each recurrence.\n\nThe `day` parameter is validated lazily, meaning errors may only be detected\nwhen the schedule is executed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Cron",
    "signature": "export declare const dayOfMonth: (day: number) => Schedule<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "dayOfWeek",
    "description": "Creates a schedule that recurs on a specific day of the week.\n\n**Details**\n\nThis schedule triggers at midnight on the specified day of the week. The\n`day` parameter follows the standard convention where `Monday = 1` and\n`Sunday = 7`. The schedule produces a count of executions, starting at 0 and\nincrementing with each recurrence.\n\nThe `day` parameter is validated lazily, meaning errors may only be detected\nwhen the schedule is executed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Cron",
    "signature": "export declare const dayOfWeek: (day: number) => Schedule<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "delayed",
    "description": "Modifies a schedule by adding a computed delay before each execution.\n\n**Details**\n\nThis function adjusts an existing schedule by applying a transformation to\nits delays. Instead of using the default interval, each delay is modified\nusing the provided function `f`, which takes the current delay and returns a\nnew delay.\n\nThis is useful for dynamically adjusting wait times between executions, such\nas introducing jitter, exponential backoff, or custom delay logic.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "export declare const delayed: { (f: (duration: Duration.Duration) => Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (duration: Duration.Duration) => Duration.DurationInput): Schedule<Out, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "delayedEffect",
    "description": "Modifies a schedule by adding an effectfully computed delay before each\nexecution.\n\n**Details**\n\nThis function adjusts an existing schedule by introducing a delay that is\ncomputed via an effect. Instead of using a fixed delay, each interval is\ndynamically adjusted based on an effectful function `f`, which takes the\ncurrent delay and returns a new delay wrapped in an `Effect`.\n\nThis is useful for adaptive scheduling where delays depend on external\nfactors, such as API calls, database queries, or dynamic system conditions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "export declare const delayedEffect: { <R2>(f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): Schedule<Out, In, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "delayedSchedule",
    "description": "Uses the delays produced by a schedule to further delay its intervals.\n\n**Details**\n\nThis function modifies a schedule by using its own output delays to control\nits execution timing. Instead of executing immediately at each interval, the\nschedule will be delayed by the duration it produces.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "export declare const delayedSchedule: <In, R>(schedule: Schedule<Duration.Duration, In, R>) => Schedule<Duration.Duration, In, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "delays",
    "description": "Transforms a schedule to output the delay between each occurrence.\n\n**Details**\n\nThis function modifies an existing schedule so that instead of producing its\noriginal output, it now returns the delay between each scheduled execution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Monitoring",
    "signature": "export declare const delays: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Duration.Duration, In, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "mapBoth",
    "description": "Transforms both the input and output of a schedule.\n\n**Details**\n\nThis function modifies an existing schedule by applying a transformation to\nboth its input values and its output values. The provided transformation\nfunctions `onInput` and `onOutput` allow you to map the schedule to work with\na different input type while modifying its outputs as well.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const mapBoth: { <In2, In, Out, Out2>(options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2; }): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R>; <Out, In, R, In2, Out2>(self: Schedule<Out, In, R>, options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2; }): Schedule<Out2, In2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "mapBothEffect",
    "description": "Transforms both the input and output of a schedule using effectful\ncomputations.\n\n**Details**\n\nThis function modifies an existing schedule by applying effectful\ntransformations to both its input values and its output values. The provided\neffectful functions `onInput` and `onOutput` allow you to transform inputs\nand outputs using computations that may involve additional logic, resource\naccess, or side effects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const mapBothEffect: { <In2, In, R2, Out, R3, Out2>(options: { readonly onInput: (input: In2) => Effect.Effect<In, never, R2>; readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>; }): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R2 | R3 | R>; <Out, In, R, In2, R2, Out2, R3>(self: Schedule<Out, In, R>, options: { readonly onInput: (input: In2) => Effect.Effect<In, never, R2>; readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>; }): Schedule<Out2, In2, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "driver",
    "description": "Creates a driver to manually control the execution of a schedule.\n\n**Details**\n\nThis function returns a `ScheduleDriver`, which allows stepping through a\nschedule manually while handling delays and sleeping appropriately. A driver\nis useful when you need fine-grained control over how a schedule progresses,\nrather than relying on automatic execution.\n\nThe returned driver exposes methods for retrieving the current state,\nexecuting the next step, and resetting the schedule when needed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getter",
    "signature": "export declare const driver: <Out, In, R>(self: Schedule<Out, In, R>) => Effect.Effect<ScheduleDriver<Out, In, R>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "duration",
    "description": "Alias of {@link fromDelay}.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const duration: (duration: Duration.DurationInput) => Schedule<Duration.Duration>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "either",
    "description": "Alias of {@link union}.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Alternatives",
    "signature": "export declare const either: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "eitherWith",
    "description": "Alias of {@link unionWith}.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Alternatives",
    "signature": "export declare const eitherWith: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "elapsed",
    "description": "Creates a schedule that tracks the total elapsed duration since it started.\n\n**Details**\n\nThis schedule executes continuously and returns the total time that has\npassed since the first execution. The duration keeps increasing with each\nstep, providing a way to measure elapsed time.\n\nThis is useful for tracking execution time, monitoring delays, or\nimplementing logic based on how long a process has been running.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const elapsed: Schedule<Duration.Duration, unknown, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "ensuring",
    "description": "Attaches a finalizer to a schedule that runs when the schedule completes.\n\n**Details**\n\nThis function returns a new schedule that executes a given finalizer when the\nschedule reaches completion. Unlike `Effect.ensuring`, this method does not\nguarantee the finalizer will run in all cases. If the schedule never\ninitializes or is not driven to completion, the finalizer may not execute.\nHowever, if the schedule decides not to continue, the finalizer will be\ninvoked.\n\nThis is useful for cleaning up resources, logging, or executing other side\neffects when a schedule completes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Finalization",
    "signature": "export declare const ensuring: { <X>(finalizer: Effect.Effect<X, never, never>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R, X>(self: Schedule<Out, In, R>, finalizer: Effect.Effect<X, never, never>): Schedule<Out, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "exponential",
    "description": "Creates a schedule that recurs indefinitely with exponentially increasing\ndelays.\n\n**Details**\n\nThis schedule starts with an initial delay of `base` and increases the delay\nexponentially on each repetition using the formula `base * factor^n`, where\n`n` is the number of times the schedule has executed so far. If no `factor`\nis provided, it defaults to `2`, causing the delay to double after each\nexecution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const exponential: (base: Duration.DurationInput, factor?: number) => Schedule<Duration.Duration>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "fibonacci",
    "description": "Creates a schedule that recurs indefinitely with Fibonacci-based increasing\ndelays.\n\n**Details**\n\nThis schedule starts with an initial delay of `one` and increases subsequent\ndelays by summing the two previous delays, following the Fibonacci sequence.\nThe delay pattern follows: `one, one, one + one, (one + one) + one, ...`,\nresulting in `1s, 1s, 2s, 3s, 5s, 8s, 13s, ...` if `one = 1s`.\n\nThis is useful for progressive backoff strategies, where delays grow\nnaturally over time without increasing as aggressively as an exponential\nschedule.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const fibonacci: (one: Duration.DurationInput) => Schedule<Duration.Duration>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "fixed",
    "description": "Creates a schedule that recurs at a fixed interval.\n\n**Details**\n\nThis schedule executes at regular, evenly spaced intervals, returning the\nnumber of times it has run so far. If the action being executed takes longer\nthan the interval, the next execution will happen immediately to prevent\n\"pile-ups,\" ensuring that the schedule remains consistent without overlapping\nexecutions.\n\n```\n|-----interval-----|-----interval-----|-----interval-----|\n|---------action--------||action|-----|action|-----------|\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const fixed: (interval: Duration.DurationInput) => Schedule<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "forever",
    "description": "Creates a schedule that recurs indefinitely, producing a count of\nrepetitions.\n\n**Details**\n\nThis schedule runs indefinitely, returning an increasing count of executions\n(`0, 1, 2, 3, ...`). Each step increments the count by one, allowing tracking\nof how many times it has executed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const forever: Schedule<number, unknown, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "fromDelay",
    "description": "Creates a schedule that recurs once after a specified duration.\n\n**Details**\n\nThis schedule executes a single time after waiting for the given duration.\nOnce it has executed, it does not repeat.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const fromDelay: (delay: Duration.DurationInput) => Schedule<Duration.Duration>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "fromDelays",
    "description": "Creates a schedule that recurs once for each specified duration, applying the\ngiven delays sequentially.\n\n**Details**\n\nThis schedule executes multiple times, each time waiting for the\ncorresponding duration from the provided list of delays. The first execution\nwaits for `delay`, the next for the second value in `delays`, and so on. Once\nall delays have been used, the schedule stops executing.\n\nThis is useful for defining a custom delay sequence that does not follow a\nfixed pattern like exponential or Fibonacci backoff.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const fromDelays: (delay: Duration.DurationInput, ...delays: Array<Duration.DurationInput>) => Schedule<Duration.Duration>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "fromFunction",
    "description": "Creates a schedule that always recurs, transforming input values using the\nspecified function.\n\n**Details**\n\nThis schedule continuously executes and applies the given function `f` to\neach input value, producing a transformed output. The schedule itself does\nnot control delays or stopping conditions; it simply transforms the input\nvalues as they are processed.\n\nThis is useful when defining schedules that map inputs to outputs, allowing\ndynamic transformations of incoming data.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const fromFunction: <A, B>(f: (a: A) => B) => Schedule<B, A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "identity",
    "description": "Creates a schedule that always recurs, passing inputs directly as outputs.\n\n**Details**\n\nThis schedule runs indefinitely, returning each input value as its output\nwithout modification. It effectively acts as a pass-through that simply\nechoes its input values at each step.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const identity: <A>() => Schedule<A, A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "passthrough",
    "description": "Transforms a schedule to pass through its inputs as outputs.\n\n**Details**\n\nThis function modifies an existing schedule so that it returns its input\nvalues instead of its original output values. The schedule's timing remains\nunchanged, but its outputs are replaced with whatever inputs it receives.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const passthrough: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<In, In, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "intersect",
    "description": "Combines two schedules, continuing only if both schedules want to continue,\nusing the longer delay.\n\n**Details**\n\nThis function takes two schedules and creates a new schedule that only\ncontinues execution if both schedules allow it. The interval between\nrecurrences is determined by the longer delay between the two schedules.\n\nThe output of the resulting schedule is a tuple containing the outputs of\nboth schedules. The input type is the intersection of both schedules' input\ntypes.\n\nThis is useful when coordinating multiple scheduling conditions where\nexecution should proceed only when both schedules permit it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "export declare const intersect: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "intersectWith",
    "description": "Combines two schedules, continuing only if both want to continue, merging\nintervals using a custom function.\n\n**Details**\n\nThis function takes two schedules and creates a new schedule that only\ncontinues execution if both schedules allow it. Instead of automatically\nusing the longer delay (like {@link intersect}), this function applies a\nuser-provided merge function `f` to determine the next interval between\nexecutions.\n\nThe output of the resulting schedule is a tuple containing the outputs of\nboth schedules, and the input type is the intersection of both schedules'\ninput types.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "export declare const intersectWith: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "jittered",
    "description": "Returns a new schedule that randomly adjusts the interval size within a\nrange.\n\n**Details**\n\nThis function modifies a schedule so that its delay between executions is\nrandomly varied within a range. By default, the delay is adjusted between\n`80%` (`0.8 * interval`) and `120%` (`1.2 * interval`) of the original\ninterval size.\n\nThis is useful for adding randomness to repeated executions, reducing\ncontention in distributed systems, and avoiding synchronized execution\npatterns that can cause bottlenecks.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "export declare const jittered: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "jitteredWith",
    "description": "Returns a new schedule that randomly adjusts the interval size within a\nuser-defined range.\n\n**Details**\n\nThis function modifies a schedule so that its delay between executions is\nrandomly varied within a specified range. Instead of using the default `0.8 -\n1.2` range like {@link jittered}, this function allows customizing the `min`\nand `max` multipliers.\n\nThe delay for each step will be adjusted within `min * original_interval` and\n`max * original_interval`. If `min` and `max` are not provided, the defaults\nare `0.8` and `1.2`, respectively.\n\nThis is useful for introducing randomness into scheduling behavior while\nhaving precise control over the jitter range.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "export declare const jitteredWith: { (options: { min?: number | undefined; max?: number | undefined; }): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, options: { min?: number | undefined; max?: number | undefined; }): Schedule<Out, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "linear",
    "description": "Creates a schedule that recurs indefinitely, increasing the delay linearly.\n\n**Details**\n\nThis schedule starts with an initial delay of `base` and increases the delay\non each recurrence in a linear fashion, following the formula:\n\n`delay = base * n`\n\nwhere `n` is the number of times the schedule has executed so far. This\nresults in increasing intervals between executions.\n\nThis is useful for implementing linear backoff strategies where the wait time\nbetween retries increases at a steady rate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const linear: (base: Duration.DurationInput) => Schedule<Duration.Duration>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Returns a new schedule that transforms its output using the specified\nfunction.\n\n**Details**\n\nThis function modifies an existing schedule so that its outputs are\ntransformed by the provided function `f`. The timing and recurrence behavior\nof the schedule remain unchanged, but the values it produces are mapped to\nnew values.\n\nThis is useful when composing schedules where you need to adjust the output\nformat or apply additional processing.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const map: { <Out, Out2>(f: (out: Out) => Out2): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>; <Out, In, R, Out2>(self: Schedule<Out, In, R>, f: (out: Out) => Out2): Schedule<Out2, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "mapEffect",
    "description": "Returns a new schedule that applies an effectful transformation to its\noutput.\n\n**Details**\n\nThis function modifies an existing schedule by applying an effectful function\n`f` to its output values. The timing and recurrence behavior of the schedule\nremain unchanged, but each output is mapped to a new value within an\n`Effect`.\n\nThis is useful when you need to perform side effects or asynchronous\ntransformations before passing the output forward.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Mapping",
    "signature": "export declare const mapEffect: { <Out, Out2, R2>(f: (out: Out) => Effect.Effect<Out2, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>; <Out, In, R, Out2, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<Out2, never, R2>): Schedule<Out2, In, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "modifyDelay",
    "description": "Returns a new schedule that modifies the delay between executions using a\ncustom function.\n\n**Details**\n\nThis function transforms an existing schedule by applying `f` to modify the\ndelay before each execution. The function receives both the schedule's output\n(`out`) and the originally computed delay (`duration`), and returns a new\nadjusted delay.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "export declare const modifyDelay: { <Out>(f: (out: Out, duration: Duration.Duration) => Duration.DurationInput): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (out: Out, duration: Duration.Duration) => Duration.DurationInput): Schedule<Out, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "modifyDelayEffect",
    "description": "Returns a new schedule that modifies the delay before execution using an\neffectful function.\n\n**Details**\n\nThis function takes an existing schedule and applies an effectful function\n`f` to dynamically adjust the delay before each execution. The function\nreceives both the schedule's output (`out`) and the originally computed delay\n(`duration`), returning a new adjusted delay wrapped in an `Effect`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Timing & Delay",
    "signature": "export declare const modifyDelayEffect: { <Out, R2>(f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): Schedule<Out, In, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "onDecision",
    "description": "Returns a new schedule that executes an effect every time the schedule makes\na decision.\n\n**Details**\n\nThis function enhances an existing schedule by running an effectful function\n`f` whenever a scheduling decision is made. The function receives the current\nschedule output (`out`) and the decision (`ScheduleDecision`), allowing\nadditional logic to be executed, such as logging, monitoring, or side\neffects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const onDecision: { <Out, X, R2>(f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, X, R2>(self: Schedule<Out, In, R>, f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>): Schedule<Out, In, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "once",
    "description": "A schedule that executes only once and then stops.\n\n**Details**\n\nThis schedule triggers a single execution and then terminates. It does not\nrepeat or apply any additional logic.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const once: Schedule<void, unknown, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "provideContext",
    "description": "Returns a new schedule with a provided context, eliminating the need for\nexternal dependencies.\n\n**Details**\n\nThis function supplies a required `context` to a schedule, allowing it to run\nwithout requiring external dependencies. After calling this function, the\nschedule can be used freely without needing to pass a context at execution\ntime.\n\nThis is useful when working with schedules that rely on contextual\ninformation, such as logging services, database connections, or configuration\nsettings.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const provideContext: { <R>(context: Context.Context<R>): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, never>; <Out, In, R>(self: Schedule<Out, In, R>, context: Context.Context<R>): Schedule<Out, In, never>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "provideService",
    "description": "Returns a new schedule with a single required service provided, eliminating\nthe need for external dependencies.\n\n**Details**\n\nThis function supplies a single service dependency to a schedule, allowing it\nto run without requiring that service externally. If a schedule depends on\nmultiple services, consider using `provideContext` instead.\n\nThis is useful when working with schedules that require a specific service,\nsuch as logging, metrics, or configuration retrieval.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Context",
    "signature": "export declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: Types.NoInfer<S>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, Exclude<R, I>>; <Out, In, R, I, S>(self: Schedule<Out, In, R>, tag: Context.Tag<I, S>, service: Types.NoInfer<S>): Schedule<Out, In, Exclude<R, I>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "recurUntil",
    "description": "A schedule that recurs until the given predicate evaluates to true.\n\n**Details**\n\nThis schedule will continue executing as long as the provided predicate `f`\nreturns `false` for the input value. Once `f` evaluates to `true`, the\nschedule stops recurring.\n\nThis is useful for defining schedules that should stop when a certain\ncondition is met, such as detecting a success state, reaching a threshold, or\navoiding unnecessary retries.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const recurUntil: <A>(f: Predicate<A>) => Schedule<A, A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "recurUntilEffect",
    "description": "A schedule that recurs until the given effectful predicate evaluates to true.\n\n**Details**\n\nThis schedule continues executing as long as the provided effectful predicate\n`f` returns `false`. Once `f` evaluates to `true`, the schedule stops\nrecurring. Unlike {@link recurUntil}, this function allows the stopping\ncondition to be computed asynchronously or based on external dependencies.\n\nThis is useful when the stopping condition depends on an effectful\ncomputation, such as checking a database, making an API call, or retrieving\nsystem state dynamically.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const recurUntilEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<A, A, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "recurUntilOption",
    "description": "A schedule that recurs until the input value matches a partial function, then\nmaps the value.\n\n**Details**\n\nThis schedule continues executing until the provided partial function `pf`\nreturns `Some(value)`. At that point, it stops and maps the resulting value\nto an `Option<B>`. If `pf` returns `None`, the schedule continues.\n\nThis is useful when defining schedules that should stop once a certain\ncondition is met and transform the final value before completion.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const recurUntilOption: <A, B>(pf: (a: A) => Option.Option<B>) => Schedule<Option.Option<B>, A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "recurUpTo",
    "description": "A schedule that recurs until the specified duration has elapsed.\n\n**Details**\n\nThis schedule continues executing for the given `duration`, after which it\nstops. The schedule outputs the elapsed time on each recurrence.\n\nThis is useful for limiting the duration of retries, enforcing time-based\nconstraints, or ensuring that an operation does not run indefinitely.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const recurUpTo: (duration: Duration.DurationInput) => Schedule<Duration.Duration>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "recurWhile",
    "description": "A schedule that recurs as long as the given predicate evaluates to true.\n\n**Details*\n\nThis schedule continues executing as long as the provided predicate `f`\nreturns `true` for the input value. Once `f` evaluates to `false`, the\nschedule stops recurring.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const recurWhile: <A>(f: Predicate<A>) => Schedule<A, A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "recurWhileEffect",
    "description": "A schedule that recurs as long as the given effectful predicate evaluates to\ntrue.\n\n**Details**\n\nThis schedule continues executing as long as the provided effectful predicate\n`f` returns `true`. Once `f` evaluates to `false`, the schedule stops\nrecurring. Unlike {@link recurWhile}, this function allows the condition to\nbe computed dynamically using an effectful computation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const recurWhileEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<A, A, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "recurs",
    "description": "A schedule that recurs a fixed number of times before terminating.\n\n**Details**\n\nThis schedule will continue executing until it has been stepped `n` times,\nafter which it will stop. The output of the schedule is the current count of\nrecurrences.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const recurs: (n: number) => Schedule<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": "Returns a new schedule that folds over the outputs of this one.\n\n**Details**\n\nThis schedule transforms the output by accumulating values over time using a\nreducer function `f`. It starts with an initial value `zero` and updates it\neach time the schedule produces an output.\n\nThis is useful for tracking statistics, aggregating results, or summarizing\ndata across multiple executions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Reducing",
    "signature": "export declare const reduce: { <Out, Z>(zero: Z, f: (z: Z, out: Out) => Z): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R>; <Out, In, R, Z>(self: Schedule<Out, In, R>, zero: Z, f: (z: Z, out: Out) => Z): Schedule<Z, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "reduceEffect",
    "description": "Returns a new schedule that effectfully folds over the outputs of this one.\n\n**Details**\n\nThis schedule accumulates outputs over time using an effectful reducer\nfunction `f`. It starts with an initial value `zero` and updates it\nasynchronously or based on external dependencies.\n\nThis is useful for asynchronous state tracking, logging, external metrics\naggregation, or any scenario where accumulation needs to involve an effectful\ncomputation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Reducing",
    "signature": "export declare const reduceEffect: { <Z, Out, R2>(zero: Z, f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R2 | R>; <Out, In, R, Z, R2>(self: Schedule<Out, In, R>, zero: Z, f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>): Schedule<Z, In, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "repeatForever",
    "description": "Alias of {@link forever}.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const repeatForever: Schedule<number, unknown, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "repetitions",
    "description": "Returns a new schedule that outputs the number of repetitions of this one.\n\n**Details**\n\nThis schedule tracks how many times the given schedule has executed and\noutputs the count instead of the original values. The first execution starts\nat `0`, and the count increases with each recurrence.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Monitoring",
    "signature": "export declare const repetitions: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<number, In, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "resetAfter",
    "description": "Returns a new schedule that automatically resets to its initial state after a\nperiod of inactivity defined by `duration`.\n\n**Details**\n\nThis function modifies a schedule so that if no inputs are received for the\nspecified `duration`, the schedule resets as if it were new.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "State Management",
    "signature": "export declare const resetAfter: { (duration: Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, duration: Duration.DurationInput): Schedule<Out, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "resetWhen",
    "description": "Resets the schedule when the specified predicate on the schedule output\nevaluates to `true`.\n\n**Details**\n\nThis function modifies a schedule so that it resets to its initial state\nwhenever the provided predicate `f` returns `true` for an output value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "State Management",
    "signature": "export declare const resetWhen: { <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "run",
    "description": "Runs a schedule using the provided inputs and collects all outputs.\n\n**Details**\n\nThis function executes a given schedule with a sequence of input values and\naccumulates all outputs into a `Chunk`. The schedule starts execution at the\nspecified `now` timestamp and proceeds according to its defined behavior.\n\nThis is useful for batch processing, simulating execution, or testing\nschedules with predefined input sequences.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Execution",
    "signature": "export declare const run: { <In>(now: number, input: Iterable<In>): <Out, R>(self: Schedule<Out, In, R>) => Effect.Effect<Chunk.Chunk<Out>, never, R>; <Out, In, R>(self: Schedule<Out, In, R>, now: number, input: Iterable<In>): Effect.Effect<Chunk.Chunk<Out>, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "spaced",
    "description": "Returns a schedule that recurs continuously, with each repetition\nspaced by the specified `duration` from the last run.\n\n**Details**\n\nThis schedule ensures that executions occur at a fixed interval,\nmaintaining a consistent delay between repetitions. The delay starts\nfrom the end of the last execution, not from the schedule start time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const spaced: (duration: Duration.DurationInput) => Schedule<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "stop",
    "description": "A schedule that does not recur and stops immediately.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const stop: Schedule<void, unknown, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": "Returns a schedule that recurs indefinitely, always producing the specified\nconstant value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const succeed: <A>(value: A) => Schedule<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "sync",
    "description": "Returns a schedule that recurs indefinitely, evaluating the given function to\nproduce a constant value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const sync: <A>(evaluate: LazyArg<A>) => Schedule<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "tapInput",
    "description": "Returns a new schedule that runs the given effectful function for each input\nbefore continuing execution.\n\n**Details**\n\nThis function allows side effects to be performed on each input processed by\nthe schedule. It does not modify the schedules behavior but ensures that the\nprovided function `f` runs before each step.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tapping",
    "signature": "export declare const tapInput: { <In2, X, R2>(f: (input: In2) => Effect.Effect<X, never, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>; <Out, In, R, In2, X, R2>(self: Schedule<Out, In, R>, f: (input: In2) => Effect.Effect<X, never, R2>): Schedule<Out, In & In2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "tapOutput",
    "description": "Returns a new schedule that runs the given effectful function for each output\nbefore continuing execution.\n\n**Details**\n\nThis function allows side effects to be performed on each output produced by\nthe schedule. It does not modify the schedules behavior but ensures that the\nprovided function `f` runs after each step.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Tapping",
    "signature": "export declare const tapOutput: { <X, R2, Out>(f: (out: Types.NoInfer<Out>) => Effect.Effect<X, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, X, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<X, never, R2>): Schedule<Out, In, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "unfold",
    "description": "Creates a schedule that repeatedly applies a function to transform a state\nvalue, producing a sequence of values.\n\n**Details**\n\nThis function starts with an `initial` value and applies `f` recursively to\ngenerate the next state at each step. The schedule continues indefinitely,\nproducing a stream of values by unfolding the state over time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const unfold: <A>(initial: A, f: (a: A) => A) => Schedule<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "union",
    "description": "Combines two schedules, continuing execution as long as at least one of them\nallows it, using the shorter delay.\n\n**Details**\n\nThis function combines two schedules into a single schedule that executes in\nparallel. If either schedule allows continuation, the merged schedule\ncontinues. When both schedules produce delays, the schedule selects the\nshorter delay to determine the next step.\n\nThe output of the new schedule is a tuple containing the outputs of both\nschedules. The input type is the intersection of both schedules' input types.\n\nThis is useful for scenarios where multiple scheduling conditions should be\nconsidered, ensuring execution proceeds if at least one schedule permits it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "export declare const union: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "unionWith",
    "description": "Combines two schedules, continuing execution as long as at least one of them\nwants to continue, merging their intervals using a custom merge function.\n\n**Details**\n\nThis function allows you to combine two schedules while defining how their\nintervals should be merged. Unlike {@link union}, which simply selects the\nshorter delay, this function lets you specify a custom merging strategy for\nthe schedules intervals.\n\nThe merged schedule continues execution as long as at least one of the input\nschedules allows it. The next interval is determined by applying the provided\nmerge function to the intervals of both schedules.\n\nThe output of the resulting schedule is a tuple containing the outputs of\nboth schedules. The input type is the intersection of both schedules' input\ntypes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "export declare const unionWith: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "untilInput",
    "description": "Returns a new schedule that stops execution when the given predicate on the\ninput evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it continues executing\nonly while the provided predicate returns `false` for incoming inputs. Once\nan input satisfies the condition, the schedule terminates immediately.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const untilInput: { <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "untilInputEffect",
    "description": "Returns a new schedule that stops execution when the given effectful\npredicate on the input evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it continues executing\nonly while the provided effectful predicate returns `false` for incoming\ninputs. The predicate is an `Effect`, meaning it can involve asynchronous\ncomputations or dependency-based logic.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const untilInputEffect: { <In, R2>(f: (input: In) => Effect.Effect<boolean, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (input: In) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "untilOutput",
    "description": "Returns a new schedule that stops execution when the given predicate on the\noutput evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecuting while the given predicate returns false for its output values. Once\nthe predicate evaluates to `true`, execution stops.\n\nThe output of the resulting schedule remains the same, but its duration is\nnow constrained by a stopping condition based on its own output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const untilOutput: { <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "untilOutputEffect",
    "description": "Returns a new schedule that stops execution when the given effectful\npredicate on the output evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecuting while the provided effectful predicate returns `false` for its\noutput values. Once the predicate returns `true`, execution stops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const untilOutputEffect: { <Out, R2>(f: (out: Out) => Effect.Effect<boolean, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "upTo",
    "description": "Returns a new schedule that limits execution to a fixed duration.\n\n**Details**\n\nThis function modifies an existing schedule to stop execution after a\nspecified duration has passed. The schedule continues as normal until the\nduration is reached, at which point it stops automatically.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const upTo: { (duration: Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, duration: Duration.DurationInput): Schedule<Out, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "whileInput",
    "description": "Returns a new schedule that continues execution as long as the given\npredicate on the input is true.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecution while a specified predicate holds true for its input. If the\npredicate evaluates to `false` at any step, the schedule stops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const whileInput: { <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "whileInputEffect",
    "description": "Returns a new schedule that continues execution for as long as the given\neffectful predicate on the input evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecution while an effectful predicate holds true for its input. If the\npredicate evaluates to `false` at any step, the schedule stops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const whileInputEffect: { <In, R2>(f: (input: In) => Effect.Effect<boolean, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (input: In) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "whileOutput",
    "description": "Returns a new schedule that continues execution for as long as the given\npredicate on the output evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecution while a provided condition holds true for its output. If the\npredicate returns `false`, the schedule stops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const whileOutput: { <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "whileOutputEffect",
    "description": "Returns a new schedule that continues execution for as long as the given\neffectful predicate on the output evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecution while an effectful condition holds true for its output. If the\neffectful predicate returns `false`, the schedule stops.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Recurrence Conditions",
    "signature": "export declare const whileOutputEffect: { <Out, R2>(f: (out: Out) => Effect.Effect<boolean, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "windowed",
    "description": "Creates a schedule that divides time into fixed `interval`-long windows,\ntriggering execution at the start of each new window.\n\n**Details**\n\nThis function produces a schedule that waits until the next time window\nboundary before executing. Each window spans a fixed duration specified by\n`interval`. If an action completes midway through a window, the schedule\nwaits until the next full window starts before proceeding.\n\nFor example, `windowed(Duration.seconds(10))` would produce a schedule as\nfollows:\n\n```\n     10s        10s        10s       10s\n|----------|----------|----------|----------|\n|action------|sleep---|act|-sleep|action----|\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Constructors",
    "signature": "export declare const windowed: (interval: Duration.DurationInput) => Schedule<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "The same as {@link intersect} but ignores the right output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "export declare const zipLeft: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out, In & In2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "zipRight",
    "description": "The same as {@link intersect} but ignores the left output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "export declare const zipRight: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out2, In & In2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Equivalent to {@link intersect} followed by {@link map}.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Composition",
    "signature": "export declare const zipWith: { <Out2, In2, R2, Out, Out3>(that: Schedule<Out2, In2, R2>, f: (out: Out, out2: Out2) => Out3): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out3, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2, Out3>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (out: Out, out2: Out2) => Out3): Schedule<Out3, In & In2, R | R2>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "Schedule",
    "description": "A `Schedule<Out, In, R>` defines a recurring schedule, which consumes values\nof type `In`, and which returns values of type `Out`.\n\nThe `Schedule` type is structured as follows:\n\n```text\n           The type of output produced by the schedule\n              The type of input consumed by the schedule\n                   Additional requirements for the schedule\n                  \nSchedule<Out, In, Requirements>\n```\n\nA schedule operates by consuming values of type `In` (such as errors in the\ncase of `Effect.retry`, or values in the case of `Effect.repeat`) and\nproducing values of type `Out`. It determines when to halt or continue the\nexecution based on input values and its internal state.\n\nThe inclusion of a `Requirements` parameter allows the schedule to leverage\nadditional services or resources as needed.\n\nSchedules are defined as a possibly infinite set of intervals spread out over\ntime. Each interval defines a window in which recurrence is possible.\n\nWhen schedules are used to repeat or retry effects, the starting boundary of\neach interval produced by a schedule is used as the moment when the effect\nwill be executed again.\n\nSchedules can be composed in different ways:\n\n- Union: Combines two schedules and recurs if either schedule wants to\n  continue, using the shorter delay.\n- Intersection: Combines two schedules and recurs only if both schedules want\n  to continue, using the longer delay.\n- Sequencing: Combines two schedules by running the first one fully, then\n  switching to the second.\n\nIn addition, schedule inputs and outputs can be transformed, filtered (to\nterminate a schedule early in response to some input or output), and so\nforth.\n\nA variety of other operators exist for transforming and combining schedules,\nand the companion object for `Schedule` contains all common types of\nschedules, both for performing retrying, as well as performing repetition.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Model",
    "signature": "export interface Schedule<out Out, in In = unknown, out R = never> extends Schedule.Variance<Out, In, R>, Pipeable {\n  /**\n   * Initial State\n   */\n  readonly initial: any\n  /**\n   * Schedule Step\n   */\n  step(\n    now: number,\n    input: In,\n    state: any\n  ): Effect.Effect<readonly [any, Out, ScheduleDecision.ScheduleDecision], never, R>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "ScheduleDriver",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Models",
    "signature": "export interface ScheduleDriver<out Out, in In = unknown, out R = never> extends Schedule.DriverVariance<Out, In, R> {\n  readonly state: Effect.Effect<unknown>\n  readonly last: Effect.Effect<Out, Cause.NoSuchElementException>\n  readonly reset: Effect.Effect<void>\n  next(input: In): Effect.Effect<Out, Option.Option<never>, R>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "ScheduleDriverTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export type ScheduleDriverTypeId = typeof ScheduleDriverTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schedule",
      "path": [
        "src",
        "Schedule.ts"
      ]
    },
    "project": "effect",
    "name": "ScheduleTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "Symbols",
    "signature": "export type ScheduleTypeId = typeof ScheduleTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleDecision",
      "path": [
        "src",
        "ScheduleDecision.ts"
      ]
    },
    "project": "effect",
    "name": "continueWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const continueWith: (interval: Interval.Interval) => ScheduleDecision"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleDecision",
      "path": [
        "src",
        "ScheduleDecision.ts"
      ]
    },
    "project": "effect",
    "name": "done",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const done: ScheduleDecision"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleDecision",
      "path": [
        "src",
        "ScheduleDecision.ts"
      ]
    },
    "project": "effect",
    "name": "isContinue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isContinue: (self: ScheduleDecision) => self is Continue"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleDecision",
      "path": [
        "src",
        "ScheduleDecision.ts"
      ]
    },
    "project": "effect",
    "name": "isDone",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isDone: (self: ScheduleDecision) => self is Done"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "ScheduleDecision",
      "path": [
        "src",
        "ScheduleDecision.ts"
      ]
    },
    "project": "effect",
    "name": "continue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const continue: (intervals: Intervals.Intervals) => ScheduleDecision"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScheduleDecision",
      "path": [
        "src",
        "ScheduleDecision.ts"
      ]
    },
    "project": "effect",
    "name": "Continue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Continue {\n  readonly _tag: \"Continue\"\n  readonly intervals: Intervals.Intervals\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScheduleDecision",
      "path": [
        "src",
        "ScheduleDecision.ts"
      ]
    },
    "project": "effect",
    "name": "Done",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Done {\n  readonly _tag: \"Done\"\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ScheduleDecision",
      "path": [
        "src",
        "ScheduleDecision.ts"
      ]
    },
    "project": "effect",
    "name": "ScheduleDecision",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type ScheduleDecision = Continue | Done"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "IntervalTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const IntervalTypeId: typeof IntervalTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new interval from the two specified endpoints. If the start\nendpoint greater than the end endpoint, then a zero size interval will be\nreturned.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: (startMillis: number, endMillis: number) => Interval"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "An `Interval` of zero-width.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: Interval"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "lessThan",
    "description": "Returns `true` if this `Interval` is less than `that` interval, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "export declare const lessThan: { (that: Interval): (self: Interval) => boolean; (self: Interval, that: Interval): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "min",
    "description": "Returns the minimum of two `Interval`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "export declare const min: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "max",
    "description": "Returns the maximum of two `Interval`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "export declare const max: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the specified `Interval` is empty, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "export declare const isEmpty: (self: Interval) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "isNonEmpty",
    "description": "Returns `true` if the specified `Interval` is non-empty, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "export declare const isNonEmpty: (self: Interval) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "intersect",
    "description": "Computes a new `Interval` which is the intersection of this `Interval` and\nthat `Interval`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "export declare const intersect: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Calculates the size of the `Interval` as the `Duration` from the start of the\ninterval to the end of the interval.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const size: (self: Interval) => Duration.Duration"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "union",
    "description": "Computes a new `Interval` which is the union of this `Interval` and that\n`Interval` as a `Some`, otherwise returns `None` if the two intervals cannot\nform a union.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const union: { (that: Interval): (self: Interval) => Option.Option<Interval>; (self: Interval, that: Interval): Option.Option<Interval>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "after",
    "description": "Construct an `Interval` that includes all time equal to and after the\nspecified start time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const after: (startMilliseconds: number) => Interval"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "before",
    "description": "Construct an `Interval` that includes all time equal to and before the\nspecified end time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const before: (endMilliseconds: number) => Interval"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "Interval",
    "description": "An `Interval` represents an interval of time. Intervals can encompass all\ntime, or no time at all.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Interval {\n  readonly [IntervalTypeId]: IntervalTypeId\n  readonly startMillis: number\n  readonly endMillis: number\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ScheduleInterval",
      "path": [
        "src",
        "ScheduleInterval.ts"
      ]
    },
    "project": "effect",
    "name": "IntervalTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type IntervalTypeId = typeof IntervalTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals",
      "path": [
        "src",
        "ScheduleIntervals.ts"
      ]
    },
    "project": "effect",
    "name": "IntervalsTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const IntervalsTypeId: typeof IntervalsTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals",
      "path": [
        "src",
        "ScheduleIntervals.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new `Intervals` from a `List` of `Interval`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: (intervals: Check.Chunk<Interval.Interval>) => Intervals"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals",
      "path": [
        "src",
        "ScheduleIntervals.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "Constructs an empty list of `Interval`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: Intervals"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals",
      "path": [
        "src",
        "ScheduleIntervals.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates `Intervals` from the specified `Iterable<Interval>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterable: (intervals: Iterable<Interval.Interval>) => Intervals"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals",
      "path": [
        "src",
        "ScheduleIntervals.ts"
      ]
    },
    "project": "effect",
    "name": "union",
    "description": "Computes the union of this `Intervals` and  that `Intervals`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const union: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals",
      "path": [
        "src",
        "ScheduleIntervals.ts"
      ]
    },
    "project": "effect",
    "name": "intersect",
    "description": "Produces the intersection of this `Intervals` and that `Intervals`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const intersect: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals",
      "path": [
        "src",
        "ScheduleIntervals.ts"
      ]
    },
    "project": "effect",
    "name": "start",
    "description": "The start of the earliest interval in the specified `Intervals`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const start: (self: Intervals) => number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals",
      "path": [
        "src",
        "ScheduleIntervals.ts"
      ]
    },
    "project": "effect",
    "name": "end",
    "description": "The end of the latest interval in the specified `Intervals`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const end: (self: Intervals) => number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals",
      "path": [
        "src",
        "ScheduleIntervals.ts"
      ]
    },
    "project": "effect",
    "name": "lessThan",
    "description": "Returns `true` if the start of this `Intervals` is before the start of that\n`Intervals`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "export declare const lessThan: { (that: Intervals): (self: Intervals) => boolean; (self: Intervals, that: Intervals): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals",
      "path": [
        "src",
        "ScheduleIntervals.ts"
      ]
    },
    "project": "effect",
    "name": "isNonEmpty",
    "description": "Returns `true` if this `Intervals` is non-empty, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isNonEmpty: (self: Intervals) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScheduleIntervals",
      "path": [
        "src",
        "ScheduleIntervals.ts"
      ]
    },
    "project": "effect",
    "name": "max",
    "description": "Returns the maximum of the two `Intervals` (i.e. which has the latest start).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "ordering",
    "signature": "export declare const max: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScheduleIntervals",
      "path": [
        "src",
        "ScheduleIntervals.ts"
      ]
    },
    "project": "effect",
    "name": "Intervals",
    "description": "An `Intervals` represents a list of several `Interval`s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Intervals {\n  readonly [IntervalsTypeId]: IntervalsTypeId\n  readonly intervals: Check.Chunk<Interval.Interval>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ScheduleIntervals",
      "path": [
        "src",
        "ScheduleIntervals.ts"
      ]
    },
    "project": "effect",
    "name": "IntervalsTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type IntervalsTypeId = typeof IntervalsTypeId"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Scheduler",
      "path": [
        "src",
        "Scheduler.ts"
      ]
    },
    "project": "effect",
    "name": "ControlledScheduler",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare class ControlledScheduler"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Scheduler",
      "path": [
        "src",
        "Scheduler.ts"
      ]
    },
    "project": "effect",
    "name": "MixedScheduler",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare class MixedScheduler { constructor(\n    /**\n     * @since 2.0.0\n     */\n    readonly maxNextTickBeforeTimer: number\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Scheduler",
      "path": [
        "src",
        "Scheduler.ts"
      ]
    },
    "project": "effect",
    "name": "PriorityBuckets",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare class PriorityBuckets<T>"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Scheduler",
      "path": [
        "src",
        "Scheduler.ts"
      ]
    },
    "project": "effect",
    "name": "SyncScheduler",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare class SyncScheduler"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scheduler",
      "path": [
        "src",
        "Scheduler.ts"
      ]
    },
    "project": "effect",
    "name": "defaultScheduler",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "schedulers",
    "signature": "export declare const defaultScheduler: Scheduler"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Scheduler",
      "path": [
        "src",
        "Scheduler.ts"
      ]
    },
    "project": "effect",
    "name": "makeMatrix",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Scheduler",
      "path": [
        "src",
        "Scheduler.ts"
      ]
    },
    "project": "effect",
    "name": "defaultShouldYield",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utilities",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Scheduler",
      "path": [
        "src",
        "Scheduler.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Scheduler",
      "path": [
        "src",
        "Scheduler.ts"
      ]
    },
    "project": "effect",
    "name": "makeBatched",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Scheduler",
      "path": [
        "src",
        "Scheduler.ts"
      ]
    },
    "project": "effect",
    "name": "timer",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Scheduler",
      "path": [
        "src",
        "Scheduler.ts"
      ]
    },
    "project": "effect",
    "name": "timerBatched",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Scheduler",
      "path": [
        "src",
        "Scheduler.ts"
      ]
    },
    "project": "effect",
    "name": "Scheduler",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Scheduler {\n  shouldYield(fiber: RuntimeFiber<unknown, unknown>): number | false\n  scheduleTask(task: Task, priority: number): void\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Scheduler",
      "path": [
        "src",
        "Scheduler.ts"
      ]
    },
    "project": "effect",
    "name": "Task",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type Task = () => void"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Any",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "export declare class Any"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ArrayFormatterIssue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.12.5",
    "category": "ArrayFormatter",
    "signature": "export declare class ArrayFormatterIssue"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BigDecimal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal transformations",
    "signature": "export declare class BigDecimal"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BigDecimalFromNumber",
    "description": "A schema that transforms a `number` into a `BigDecimal`.\nWhen encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal transformations",
    "signature": "export declare class BigDecimalFromNumber"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BigDecimalFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal constructors",
    "signature": "export declare class BigDecimalFromSelf"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BigIntFromNumber",
    "description": "This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.\n\nIt returns an error if the value can't be safely encoded as a `number` due to being out of range.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint transformations",
    "signature": "export declare class BigIntFromNumber"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BigIntFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "export declare class BigIntFromSelf"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BooleanFromString",
    "description": "Converts an `string` value into its corresponding `boolean`\n(\"true\" as `true` and \"false\" as `false`).",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "boolean transformations",
    "signature": "export declare class BooleanFromString"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BooleanFromUnknown",
    "description": "Converts an arbitrary value to a `boolean` by testing whether it is truthy.\nUses `!!val` to coerce the value to a `boolean`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "boolean constructors",
    "signature": "export declare class BooleanFromUnknown"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Capitalize",
    "description": "This schema converts a string to capitalized one.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "export declare class Capitalize"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Capitalized",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "export declare class Capitalized"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Char",
    "description": "A schema representing a single character.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "export declare class Char"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DateFromNumber",
    "description": "Defines a schema that converts a `number` into a `Date` object using the `new\nDate` constructor. This schema does not validate the numerical input,\nallowing potentially invalid values such as `NaN`, `Infinity`, and\n`-Infinity` to be converted into `Date` objects. During the encoding process,\nany invalid `Date` object will be encoded to `NaN`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date transformations",
    "signature": "export declare class DateFromNumber"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DateFromSelf",
    "description": "Describes a schema that accommodates potentially invalid `Date` instances,\nsuch as `new Date(\"Invalid Date\")`, without rejection.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date constructors",
    "signature": "export declare class DateFromSelf"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DateFromString",
    "description": "Defines a schema that attempts to convert a `string` to a `Date` object using\nthe `new Date` constructor. This conversion is lenient, meaning it does not\nreject strings that do not form valid dates (e.g., using `new Date(\"Invalid\nDate\")` results in a `Date` object, despite being invalid).",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date transformations",
    "signature": "export declare class DateFromString"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DateTimeUtc",
    "description": "Defines a schema that attempts to convert a `string` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "DateTime.Utc transformations",
    "signature": "export declare class DateTimeUtc"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DateTimeUtcFromDate",
    "description": "Defines a schema that attempts to convert a `Date` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "DateTime.Utc transformations",
    "signature": "export declare class DateTimeUtcFromDate"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DateTimeUtcFromNumber",
    "description": "Defines a schema that attempts to convert a `number` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "DateTime.Utc transformations",
    "signature": "export declare class DateTimeUtcFromNumber"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DateTimeUtcFromSelf",
    "description": "Describes a schema that represents a `DateTime.Utc` instance.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "DateTime.Utc constructors",
    "signature": "export declare class DateTimeUtcFromSelf"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DateTimeZoned",
    "description": "Defines a schema that attempts to convert a `string` to a `DateTime.Zoned` instance.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "DateTime.Zoned transformations",
    "signature": "export declare class DateTimeZoned"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DateTimeZonedFromSelf",
    "description": "Describes a schema that represents a `DateTime.Zoned` instance.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "DateTime.Zoned constructors",
    "signature": "export declare class DateTimeZonedFromSelf"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Defect",
    "description": "Defines a schema for handling JavaScript errors (`Error` instances) and other types of defects.\nIt decodes objects into Error instances if they match the expected structure (i.e., have a `message` and optionally a `name` and `stack`),\nor converts other values to their string representations.\n\nWhen encoding, it converts `Error` instances back into plain objects containing only the error's name and message,\nor other values into their string forms.\n\nThis is useful for serializing and deserializing errors across network boundaries where error objects do not natively serialize.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "defect",
    "signature": "export declare class Defect"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Duration",
    "description": "A schema that converts a JSON-compatible tagged union into a `Duration`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration transformations",
    "signature": "export declare class Duration"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DurationFromMillis",
    "description": "A schema that transforms a (possibly Infinite) non negative number into a\n`Duration`. Treats the value as the number of milliseconds.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration transformations",
    "signature": "export declare class DurationFromMillis"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DurationFromNanos",
    "description": "A schema that transforms a non negative `bigint` into a `Duration`. Treats\nthe value as the number of nanoseconds.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration transformations",
    "signature": "export declare class DurationFromNanos"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DurationFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration constructors",
    "signature": "export declare class DurationFromSelf"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "FiberId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "FiberId transformations",
    "signature": "export declare class FiberId"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "FiberIdFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "FiberId constructors",
    "signature": "export declare class FiberIdFromSelf"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Finite",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "export declare class Finite"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "FromPropertySignature",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "export declare class FromPropertySignature { constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly fromKey?: PropertyKey | undefined\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Int",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "export declare class Int"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonNumber",
    "description": "The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid\nnumber by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON\nformat.",
    "deprecated": false,
    "examples": [
      "import * as Schema from \"effect/Schema\"\n\nconst is = Schema.is(S.JsonNumber)\n\nassert.deepStrictEqual(is(42), true)\nassert.deepStrictEqual(is(Number.NaN), false)\nassert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)\nassert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)"
    ],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "export declare class JsonNumber"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Lowercase",
    "description": "This schema converts a string to lowercase.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "export declare class Lowercase"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Lowercased",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "export declare class Lowercased"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Negative",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "export declare class Negative"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Never",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "export declare class Never"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonEmptyString",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "export declare class NonEmptyString"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonEmptyTrimmedString",
    "description": "Useful for validating strings that must contain meaningful characters without\nleading or trailing whitespace.",
    "deprecated": false,
    "examples": [
      "import { Schema } from \"effect\"\n\nconsole.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"\")) // Option.none()\nconsole.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\" a \")) // Option.none()\nconsole.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")"
    ],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "export declare class NonEmptyTrimmedString"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonNaN",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "export declare class NonNaN"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonNegative",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "export declare class NonNegative"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonPositive",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "export declare class NonPositive"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Not",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "boolean transformations",
    "signature": "export declare class Not"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Null",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "export declare class Null"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NumberFromString",
    "description": "This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.\n\nIt returns an error if the value can't be converted (for example when non-numeric characters are provided).\n\nThe following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number transformations",
    "signature": "export declare class NumberFromString"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "OptionFromNonEmptyTrimmedString",
    "description": "Transforms strings into an Option type, effectively filtering out empty or\nwhitespace-only strings by trimming them and checking their length. Returns\n`none` for invalid inputs and `some` for valid non-empty strings.",
    "deprecated": false,
    "examples": [
      "import { Schema } from \"effect\"\n\nconsole.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"\")) // Option.none()\nconsole.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\" a \")) // Option.some(\"a\")\nconsole.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(\"a\")) // Option.some(\"a\")"
    ],
    "since": "3.10.0",
    "category": "Option transformations",
    "signature": "export declare class OptionFromNonEmptyTrimmedString"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Positive",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number constructors",
    "signature": "export declare class Positive"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "PropertySignatureDeclaration",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "export declare class PropertySignatureDeclaration { constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "PropertySignatureTransformation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "export declare class PropertySignatureTransformation { constructor(\n    readonly from: FromPropertySignature,\n    readonly to: ToPropertySignature,\n    readonly decode: AST.PropertySignatureTransformation[\"decode\"],\n    readonly encode: AST.PropertySignatureTransformation[\"encode\"]\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "SymbolFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "export declare class SymbolFromSelf"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TimeZone",
    "description": "Defines a schema that attempts to convert a `string` to a `TimeZone` using the `DateTime.zoneFromString` constructor.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "TimeZone transformations",
    "signature": "export declare class TimeZone"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TimeZoneFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "TimeZone constructors",
    "signature": "export declare class TimeZoneFromSelf"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TimeZoneNamed",
    "description": "Defines a schema that attempts to convert a `string` to a `TimeZone.Named` instance using the `DateTime.zoneUnsafeMakeNamed` constructor.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "TimeZone transformations",
    "signature": "export declare class TimeZoneNamed"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TimeZoneNamedFromSelf",
    "description": "Describes a schema that represents a `TimeZone.Named` instance.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "TimeZone constructors",
    "signature": "export declare class TimeZoneNamedFromSelf"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TimeZoneOffset",
    "description": "Defines a schema that converts a `number` to a `TimeZone.Offset` instance using the `DateTime.zoneMakeOffset` constructor.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "TimeZone transformations",
    "signature": "export declare class TimeZoneOffset"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TimeZoneOffsetFromSelf",
    "description": "Describes a schema that represents a `TimeZone.Offset` instance.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "TimeZone constructors",
    "signature": "export declare class TimeZoneOffsetFromSelf"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ToPropertySignature",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "export declare class ToPropertySignature { constructor(\n    type: AST.AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations: AST.Annotations,\n    readonly defaultValue: (() => unknown) | undefined\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Trim",
    "description": "This schema allows removing whitespaces from the beginning and end of a string.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "export declare class Trim"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Trimmed",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "export declare class Trimmed"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ULID",
    "description": "Represents a Universally Unique Lexicographically Sortable Identifier (ULID).\n\nULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.\nThis schema ensures that the provided string adheres to the standard ULID format.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "export declare class ULID"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "URLFromSelf",
    "description": "Defines a schema that represents a `URL` object.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "URL constructors",
    "signature": "export declare class URLFromSelf"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "UUID",
    "description": "Represents a Universally Unique Identifier (UUID).\n\nThis schema ensures that the provided string adheres to the standard UUID format.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "export declare class UUID"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Uint8",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.10",
    "category": "number constructors",
    "signature": "export declare class Uint8"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Uint8ArrayFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Uint8Array constructors",
    "signature": "export declare class Uint8ArrayFromSelf"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Uncapitalize",
    "description": "This schema converts a string to uncapitalized one.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "export declare class Uncapitalize"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Uncapitalized",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "export declare class Uncapitalized"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Undefined",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "export declare class Undefined"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Unknown",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "export declare class Unknown"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Uppercase",
    "description": "This schema converts a string to uppercase.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "export declare class Uppercase"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Uppercased",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string constructors",
    "signature": "export declare class Uppercased"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ValidDateFromSelf",
    "description": "Defines a schema that ensures only valid dates are accepted. This schema\nrejects values like `new Date(\"Invalid Date\")`, which, despite being a `Date`\ninstance, represents an invalid date. Such stringent validation ensures that\nall date objects processed through this schema are properly formed and\nrepresent real dates.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date constructors",
    "signature": "export declare class ValidDateFromSelf"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Void",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "export declare class Void"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "encode",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const encode: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "encodeEither",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const encodeEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "encodePromise",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const encodePromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => Promise<I>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "decode",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const decode: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "decodeEither",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const decodeEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "decodePromise",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const decodePromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => Promise<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "declare",
    "description": "The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.\nThis ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const declare: { <A>(is: (input: unknown) => input is A, annotations?: Annotations.Schema<A>): declare<A>; <A, I, const P extends ReadonlyArray<Schema.All>>(typeParameters: P, options: { readonly decode: (...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never>; }) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<A, ParseResult.ParseIssue, never>; readonly encode: (...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never>; }) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<I, ParseResult.ParseIssue, never>; }, annotations?: Annotations.Schema<A, { readonly [K in keyof P]: Schema.Type<P[K]>; }>): declare<A, I, P>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BrandSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const BrandSchemaId: typeof BrandSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "InstanceOfSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const InstanceOfSchemaId: typeof InstanceOfSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "PropertySignatureTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "export declare const PropertySignatureTypeId: typeof PropertySignatureTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "withConstructorDefault",
    "description": "Enhances a property signature with a default constructor value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "export declare const withConstructorDefault: { <Type>(defaultValue: () => Types.NoInfer<Type>): <TypeToken extends PropertySignature.Token, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, R>(self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>; <TypeToken extends PropertySignature.Token, Type, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, R>(self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>, defaultValue: () => Types.NoInfer<Type>): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "withDecodingDefault",
    "description": "Enhances a property signature with a default decoding value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "export declare const withDecodingDefault: { <Type>(defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>): <Key extends PropertyKey, Encoded, R>(self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R>; <Type, Key extends PropertyKey, Encoded, R>(self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, false, R>, defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, false, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "withDefaults",
    "description": "Enhances a property signature with a default decoding value and a default constructor value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "export declare const withDefaults: { <Type>(defaults: { constructor: () => Types.NoInfer<Exclude<Type, undefined>>; decoding: () => Types.NoInfer<Exclude<Type, undefined>>; }): <Key extends PropertyKey, Encoded, R>(self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>) => PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>; <Type, Key extends PropertyKey, Encoded, R>(self: PropertySignature<\"?:\", Type, Key, \"?:\", Encoded, boolean, R>, defaults: { constructor: () => Types.NoInfer<Exclude<Type, undefined>>; decoding: () => Types.NoInfer<Exclude<Type, undefined>>; }): PropertySignature<\":\", Exclude<Type, undefined>, Key, \"?:\", Encoded, true, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "fromKey",
    "description": "Enhances a property signature by specifying a different key for it in the Encoded type.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "export declare const fromKey: { <Key extends PropertyKey>(key: Key): <TypeToken extends PropertySignature.Token, Type, EncodedToken extends PropertySignature.Token, Encoded, HasDefault extends boolean, R>(self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>; <Type, TypeToken extends PropertySignature.Token, Encoded, EncodedToken extends PropertySignature.Token, HasDefault extends boolean, R, Key extends PropertyKey>(self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>, key: Key): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "optionalWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "export declare const optionalWith: { <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(options: Options): (self: S) => optionalWith<S, Options>; <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(self: S, options: Options): optionalWith<S, Options>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "pluck",
    "description": "Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,\nproducing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.",
    "deprecated": false,
    "examples": [
      "import * as Schema from \"effect/Schema\"\n\n// ---------------------------------------------\n// use case: pull out a single field from a\n// struct through a transformation\n// ---------------------------------------------\n\nconst mytable = Schema.Struct({\n  column1: Schema.NumberFromString,\n  column2: Schema.Number\n})\n\n// const pullOutColumn: S.Schema<number, {\n//     readonly column1: string;\n// }, never>\nconst pullOutColumn = mytable.pipe(Schema.pluck(\"column1\"))\n\nconsole.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: \"1\", column2: 100 }, { column1: \"2\", column2: 300 }]))\n// Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }"
    ],
    "since": "3.10.0",
    "category": "struct transformations",
    "signature": "export declare const pluck: { <A, I, K extends keyof A & keyof I>(key: K): <R>(schema: Schema<A, I, R>) => SchemaClass<A[K], Simplify<Pick<I, K>>, R>; <A, I, R, K extends keyof A & keyof I>(schema: Schema<A, I, R>, key: K): SchemaClass<A[K], Simplify<Pick<I, K>>, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "partialWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "export declare const partialWith: { <const Options extends { readonly exact: true; }>(options: Options): <A, I, R>(self: Schema<A, I, R>) => SchemaClass<{ [K in keyof A]?: A[K]; }, { [K in keyof I]?: I[K]; }, R>; <A, I, R, const Options extends { readonly exact: true; } | undefined>(self: Schema<A, I, R>, options: Options): SchemaClass<{ [K in keyof A]?: A[K]; }, { [K in keyof I]?: I[K]; }, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "extend",
    "description": "Extends a schema with another schema.\n\nNot all extensions are supported, and their support depends on the nature of the involved schemas.\n\nPossible extensions include:\n- `Schema.String` with another `Schema.String` refinement or a string literal\n- `Schema.Number` with another `Schema.Number` refinement or a number literal\n- `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean literal\n- A struct with another struct where overlapping fields support extension\n- A struct with in index signature\n- A struct with a union of supported schemas\n- A refinement of a struct with a supported schema\n- A suspend of a struct with a supported schema",
    "deprecated": false,
    "examples": [
      "import * as Schema from \"effect/Schema\"\n\nconst schema = Schema.Struct({\n  a: Schema.String,\n  b: Schema.String\n})\n\n// const extended: Schema<\n//   {\n//     readonly a: string\n//     readonly b: string\n//   } & {\n//     readonly c: string\n//   } & {\n//     readonly [x: string]: string\n//   }\n// >\nconst extended = Schema.asSchema(schema.pipe(\n  Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields\n  Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures\n))"
    ],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "export declare const extend: { <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>; <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "compose",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "export declare const compose: { <To extends Schema.Any, From extends Schema.Any, C extends Schema.Type<From>>(to: To & Schema<Schema.Type<To>, C, Schema.Context<To>>): (from: From) => transform<From, To>; <To extends Schema.Any>(to: To): <From extends Schema.Any, B extends Schema.Encoded<To>>(from: From & Schema<B, Schema.Encoded<From>, Schema.Context<From>>) => transform<From, To>; <To extends Schema.Any>(to: To, options?: { readonly strict: true; }): <From extends Schema.Any>(from: From & Schema<Schema.Encoded<To>, Schema.Encoded<From>, Schema.Context<From>>) => transform<From, To>; <To extends Schema.Any>(to: To, options: { readonly strict: false; }): <From extends Schema.Any>(from: From) => transform<From, To>; <From extends Schema.Any, To extends Schema.Any, C extends Schema.Type<From>>(from: From, to: To & Schema<Schema.Type<To>, C, Schema.Context<To>>): transform<From, To>; <From extends Schema.Any, B extends Schema.Encoded<To>, To extends Schema.Any>(from: From & Schema<B, Schema.Encoded<From>, Schema.Context<From>>, to: To): transform<From, To>; <From extends Schema.Any, To extends Schema.Any>(from: From & Schema<Schema.Encoded<To>, Schema.Encoded<From>, Schema.Context<From>>, to: To, options?: { readonly strict: true; }): transform<From, To>; <From extends Schema.Any, To extends Schema.Any>(from: From, to: To, options: { readonly strict: false; }): transform<From, To>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "RefineSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "export declare const RefineSchemaId: typeof RefineSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "filterEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "transformations",
    "signature": "export declare const filterEffect: { <S extends Schema.Any, FD>(f: (a: Types.NoInfer<Schema.Type<S>>, options: ParseOptions, self: AST.Transformation) => Effect.Effect<FilterReturnType, never, FD>): (self: S) => filterEffect<S, FD>; <S extends Schema.Any, RD>(self: S, f: (a: Types.NoInfer<Schema.Type<S>>, options: ParseOptions, self: AST.Transformation) => Effect.Effect<FilterReturnType, never, RD>): filterEffect<S, RD>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "transformOrFail",
    "description": "Create a new `Schema` by transforming the input and output of an existing `Schema`\nusing the provided decoding functions.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "transformations",
    "signature": "export declare const transformOrFail: { <To extends Schema.Any, From extends Schema.Any, RD, RE>(to: To, options: { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>; readonly strict: false; }): (from: From) => transformOrFail<From, To, RD | RE>; <To extends Schema.Any, From extends Schema.Any, RD, RE>(from: From, to: To, options: { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>; readonly strict: false; }): transformOrFail<From, To, RD | RE>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "transform",
    "description": "Create a new `Schema` by transforming the input and output of an existing `Schema`\nusing the provided mapping functions.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "transformations",
    "signature": "export declare const transform: { <To extends Schema.Any, From extends Schema.Any>(to: To, options: { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown; readonly strict: false; }): (from: From) => transform<From, To>; <To extends Schema.Any, From extends Schema.Any>(from: From, to: To, options: { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown; readonly strict: false; }): transform<From, To>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "attachPropertySignature",
    "description": "Attaches a property signature with the specified key and value to the schema.\nThis API is useful when you want to add a property to your schema which doesn't describe the shape of the input,\nbut rather maps to another schema, for example when you want to add a discriminant to a simple union.",
    "deprecated": false,
    "examples": [
      "import * as S from \"effect/Schema\"\nimport { pipe } from \"effect/Function\"\n\nconst Circle = S.Struct({ radius: S.Number })\nconst Square = S.Struct({ sideLength: S.Number })\nconst Shape = S.Union(\n  Circle.pipe(S.attachPropertySignature(\"kind\", \"circle\")),\n  Square.pipe(S.attachPropertySignature(\"kind\", \"square\"))\n)\n\nassert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {\n  kind: \"circle\",\n  radius: 10\n})"
    ],
    "since": "3.10.0",
    "category": "combinators",
    "signature": "export declare const attachPropertySignature: { <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(key: K, value: V, annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V; }>>): <I, R>(schema: SchemaClass<A, I, R>) => SchemaClass<Simplify<A & { readonly [k in K]: V; }>, I, R>; <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(schema: Schema<A, I, R>, key: K, value: V, annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V; }>>): SchemaClass<Simplify<A & { readonly [k in K]: V; }>, I, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "annotations",
    "description": "Merges a set of new annotations with existing ones, potentially overwriting\nany duplicates.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const annotations: { <S extends Annotable.All>(annotations: Annotations.GenericSchema<Schema.Type<S>>): (self: S) => Annotable.Self<S>; <S extends Annotable.All>(self: S, annotations: Annotations.GenericSchema<Schema.Type<S>>): Annotable.Self<S>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "rename",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "renaming",
    "signature": "export declare const rename: { <A, const M extends { readonly [K in keyof A]?: PropertyKey; } & { readonly [K in Exclude<keyof M, keyof A>]: never; }>(mapping: M): <I, R>(self: Schema<A, I, R>) => SchemaClass<Simplify<Rename<A, M>>, I, R>; <A, I, R, const M extends { readonly [K in keyof A]?: PropertyKey; } & { readonly [K in Exclude<keyof M, keyof A>]: never; }>(self: Schema<A, I, R>, mapping: M): SchemaClass<Simplify<Rename<A, M>>, I, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TrimmedSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const TrimmedSchemaId: typeof TrimmedSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "MaxLengthSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const MaxLengthSchemaId: typeof MaxLengthSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "MinLengthSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const MinLengthSchemaId: typeof MinLengthSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LengthSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const LengthSchemaId: typeof LengthSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "PatternSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const PatternSchemaId: typeof PatternSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "StartsWithSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const StartsWithSchemaId: typeof StartsWithSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "EndsWithSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const EndsWithSchemaId: typeof EndsWithSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "IncludesSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const IncludesSchemaId: typeof IncludesSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LowercasedSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const LowercasedSchemaId: typeof LowercasedSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "UppercasedSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const UppercasedSchemaId: typeof UppercasedSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "CapitalizedSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const CapitalizedSchemaId: typeof CapitalizedSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "UncapitalizedSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const UncapitalizedSchemaId: typeof UncapitalizedSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "UUIDSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const UUIDSchemaId: typeof UUIDSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ULIDSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const ULIDSchemaId: typeof ULIDSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "FiniteSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const FiniteSchemaId: typeof FiniteSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "GreaterThanSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const GreaterThanSchemaId: typeof GreaterThanSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "GreaterThanOrEqualToSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const GreaterThanOrEqualToSchemaId: typeof GreaterThanOrEqualToSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "MultipleOfSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const MultipleOfSchemaId: typeof MultipleOfSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "IntSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const IntSchemaId: typeof IntSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LessThanSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const LessThanSchemaId: typeof LessThanSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LessThanOrEqualToSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const LessThanOrEqualToSchemaId: typeof LessThanOrEqualToSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BetweenSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const BetweenSchemaId: typeof BetweenSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonNaNSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const NonNaNSchemaId: typeof NonNaNSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonNumberSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const JsonNumberSchemaId: typeof JsonNumberSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "GreaterThanBigIntSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const GreaterThanBigIntSchemaId: typeof GreaterThanBigIntSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "GreaterThanOrEqualToBigIntSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const GreaterThanOrEqualToBigIntSchemaId: typeof GreaterThanOrEqualToBigIntSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LessThanBigIntSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const LessThanBigIntSchemaId: typeof LessThanBigIntSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LessThanOrEqualToBigIntSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const LessThanOrEqualToBigIntSchemaId: typeof LessThanOrEqualToBigIntSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BetweenBigIntSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const BetweenBigIntSchemaId: typeof BetweenBigIntSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "PositiveBigIntFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "export declare const PositiveBigIntFromSelf: filter<Schema<bigint, bigint, never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "PositiveBigInt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "export declare const PositiveBigInt: filter<Schema<bigint, string, never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NegativeBigIntFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "export declare const NegativeBigIntFromSelf: filter<Schema<bigint, bigint, never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NegativeBigInt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "export declare const NegativeBigInt: filter<Schema<bigint, string, never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonPositiveBigIntFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "export declare const NonPositiveBigIntFromSelf: filter<Schema<bigint, bigint, never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonPositiveBigInt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "export declare const NonPositiveBigInt: filter<Schema<bigint, string, never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonNegativeBigIntFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "export declare const NonNegativeBigIntFromSelf: filter<Schema<bigint, bigint, never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonNegativeBigInt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint constructors",
    "signature": "export declare const NonNegativeBigInt: filter<Schema<bigint, string, never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonNegativeInt",
    "description": "A non-negative integer. +Infinity is excluded.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.10",
    "category": "number constructors",
    "signature": "export declare const NonNegativeInt: refine<number, typeof NonNegative>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LessThanDurationSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const LessThanDurationSchemaId: typeof LessThanDurationSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LessThanOrEqualToDurationSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const LessThanOrEqualToDurationSchemaId: typeof LessThanOrEqualToDurationSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "GreaterThanDurationSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const GreaterThanDurationSchemaId: typeof GreaterThanDurationSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "GreaterThanOrEqualToDurationSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const GreaterThanOrEqualToDurationSchemaId: typeof GreaterThanOrEqualToDurationSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BetweenDurationSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const BetweenDurationSchemaId: typeof BetweenDurationSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Uint8ArrayFromBase64",
    "description": "Decodes a base64 (RFC4648) encoded string into a `Uint8Array`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Uint8Array transformations",
    "signature": "export declare const Uint8ArrayFromBase64: Schema<Uint8Array, string, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Uint8ArrayFromBase64Url",
    "description": "Decodes a base64 (URL) encoded string into a `Uint8Array`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Uint8Array transformations",
    "signature": "export declare const Uint8ArrayFromBase64Url: Schema<Uint8Array, string, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Uint8ArrayFromHex",
    "description": "Decodes a hex encoded string into a `Uint8Array`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Uint8Array transformations",
    "signature": "export declare const Uint8ArrayFromHex: Schema<Uint8Array, string, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "StringFromBase64",
    "description": "Decodes a base64 (RFC4648) encoded string into a UTF-8 string.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "export declare const StringFromBase64: Schema<string, string, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "StringFromBase64Url",
    "description": "Decodes a base64 (URL) encoded string into a UTF-8 string.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "export declare const StringFromBase64Url: Schema<string, string, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "StringFromHex",
    "description": "Decodes a hex encoded string into a UTF-8 string.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": "export declare const StringFromHex: Schema<string, string, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "StringFromUriComponent",
    "description": "Decodes a URI component encoded string into a UTF-8 string.\nCan be used to store data in a URL.",
    "deprecated": false,
    "examples": [
      "import { Schema } from \"effect\"\n\nconst PaginationSchema = Schema.Struct({\n  maxItemPerPage: Schema.Number,\n  page: Schema.Number\n})\n\nconst UrlSchema = Schema.compose(Schema.StringFromUriComponent, Schema.parseJson(PaginationSchema))\n\nconsole.log(Schema.encodeSync(UrlSchema)({ maxItemPerPage: 10, page: 1 }))\n// Output: %7B%22maxItemPerPage%22%3A10%2C%22page%22%3A1%7D"
    ],
    "since": "3.12.0",
    "category": "string transformations",
    "signature": "export declare const StringFromUriComponent: transformOrFail<SchemaClass<string, string, never>, typeof String$, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "MinItemsSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const MinItemsSchemaId: typeof MinItemsSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "MaxItemsSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const MaxItemsSchemaId: typeof MaxItemsSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ItemsCountSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const ItemsCountSchemaId: typeof ItemsCountSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "headOrElse",
    "description": "Retrieves the first element of a `ReadonlyArray`.\n\nIf the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyArray transformations",
    "signature": "export declare const headOrElse: { <S extends Schema.Any, A extends ReadonlyArray<unknown>>(fallback?: LazyArg<A[number]>): (self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, SchemaClass<A[number]>>; <S extends Schema.Any, A extends ReadonlyArray<unknown>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>, fallback?: LazyArg<A[number]>): transform<S, SchemaClass<A[number]>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ValidDateSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const ValidDateSchemaId: typeof ValidDateSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LessThanDateSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const LessThanDateSchemaId: typeof LessThanDateSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LessThanOrEqualToDateSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const LessThanOrEqualToDateSchemaId: typeof LessThanOrEqualToDateSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "GreaterThanDateSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const GreaterThanDateSchemaId: typeof GreaterThanDateSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "GreaterThanOrEqualToDateSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const GreaterThanOrEqualToDateSchemaId: typeof GreaterThanOrEqualToDateSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BetweenDateSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const BetweenDateSchemaId: typeof BetweenDateSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DateFromSelfSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.8",
    "category": "schema id",
    "signature": "export declare const DateFromSelfSchemaId: typeof DateFromSelfSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "GreaterThanBigDecimalSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const GreaterThanBigDecimalSchemaId: typeof GreaterThanBigDecimalSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "GreaterThanOrEqualToBigDecimalSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const GreaterThanOrEqualToBigDecimalSchemaId: typeof GreaterThanOrEqualToBigDecimalSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LessThanBigDecimalSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const LessThanBigDecimalSchemaId: typeof LessThanBigDecimalSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LessThanOrEqualToBigDecimalSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const LessThanOrEqualToBigDecimalSchemaId: typeof LessThanOrEqualToBigDecimalSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "PositiveBigDecimalSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const PositiveBigDecimalSchemaId: typeof PositiveBigDecimalSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "PositiveBigDecimalFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal constructors",
    "signature": "export declare const PositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal, bigDecimal_.BigDecimal, never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonNegativeBigDecimalSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const NonNegativeBigDecimalSchemaId: typeof NonNegativeBigDecimalSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonNegativeBigDecimalFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal constructors",
    "signature": "export declare const NonNegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal, bigDecimal_.BigDecimal, never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NegativeBigDecimalSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const NegativeBigDecimalSchemaId: typeof NegativeBigDecimalSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NegativeBigDecimalFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal constructors",
    "signature": "export declare const NegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal, bigDecimal_.BigDecimal, never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonPositiveBigDecimalSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const NonPositiveBigDecimalSchemaId: typeof NonPositiveBigDecimalSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonPositiveBigDecimalFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal constructors",
    "signature": "export declare const NonPositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal, bigDecimal_.BigDecimal, never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BetweenBigDecimalSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const BetweenBigDecimalSchemaId: typeof BetweenBigDecimalSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "symbolSerializable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "export declare const symbolSerializable: typeof symbolSerializable"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "deserialize",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const deserialize: { (value: unknown): <A, I, R>(self: Serializable<A, I, R>) => Effect.Effect<A, ParseResult.ParseError, R>; <A, I, R>(self: Serializable<A, I, R>, value: unknown): Effect.Effect<A, ParseResult.ParseError, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "symbolWithResult",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "export declare const symbolWithResult: typeof symbolWithResult"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "serializeFailure",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const serializeFailure: { <FA>(value: FA): <SA, SI, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<FI, ParseResult.ParseError, R>; <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: FA): Effect.Effect<FI, ParseResult.ParseError, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "deserializeFailure",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const deserializeFailure: { (value: unknown): <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<FA, ParseResult.ParseError, R>; <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<FA, ParseResult.ParseError, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "serializeSuccess",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const serializeSuccess: { <SA>(value: SA): <SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<SI, ParseResult.ParseError, R>; <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: SA): Effect.Effect<SI, ParseResult.ParseError, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "deserializeSuccess",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const deserializeSuccess: { (value: unknown): <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<SA, ParseResult.ParseError, R>; <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<SA, ParseResult.ParseError, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "serializeExit",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const serializeExit: { <SA, FA>(value: exit_.Exit<SA, FA>): <SI, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R>; <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: exit_.Exit<SA, FA>): Effect.Effect<ExitEncoded<SI, FI, unknown>, ParseResult.ParseError, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "deserializeExit",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const deserializeExit: { (value: unknown): <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>) => Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R>; <SA, SI, FA, FI, R>(self: WithResult<SA, SI, FA, FI, R>, value: unknown): Effect.Effect<exit_.Exit<SA, FA>, ParseResult.ParseError, R>; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "asserts",
    "description": "By default the option `exact` is set to `true`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": "export declare const asserts: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => asserts u is A"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "decodeOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const decodeOption: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => option_.Option<A>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "decodeSync",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const decodeSync: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => A"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "decodeUnknownOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const decodeUnknownOption: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => option_.Option<A>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "decodeUnknownSync",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": "export declare const decodeUnknownSync: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => A"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "encodeOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const encodeOption: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (input: A, overrideOptions?: ParseOptions) => option_.Option<I>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "encodeSync",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const encodeSync: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => I"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "encodeUnknownOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const encodeUnknownOption: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => option_.Option<I>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "encodeUnknownSync",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": "export declare const encodeUnknownSync: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => I"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "is",
    "description": "By default the option `exact` is set to `true`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": "export declare const is: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions | number) => u is A"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "validateOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": "export declare const validateOption: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => option_.Option<A>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "validateSync",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": "export declare const validateSync: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => A"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Boolean",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "export declare const Boolean: typeof Boolean$"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Number",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "export declare const Number: typeof Number$"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Object",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "export declare const Object: typeof Object$"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "String",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "primitives",
    "signature": "export declare const String: typeof String$"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Array",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const Array: <Value extends Schema.Any>(value: Value) => Array$<Value>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "URL",
    "description": "Defines a schema that attempts to convert a `string` to a `URL` object using\nthe `new URL` constructor.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "URL transformations",
    "signature": "export declare const URL: typeof URL$"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Symbol",
    "description": "Converts a string key into a globally shared symbol.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol transformations",
    "signature": "export declare const Symbol: typeof Symbol$"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BigInt",
    "description": "This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.\n\nIt returns an error if the value can't be converted (for example when non-numeric characters are provided).",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint transformations",
    "signature": "export declare const BigInt: typeof BigInt$"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Uint8Array",
    "description": "A schema that transforms an array of numbers into a `Uint8Array`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Uint8Array transformations",
    "signature": "export declare const Uint8Array: typeof Uint8Array$"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Date",
    "description": "This schema converts a `string` into a `Date` object using the `new Date`\nconstructor. It ensures that only valid date strings are accepted,\nrejecting any strings that would result in an invalid date, such as `new\nDate(\"Invalid Date\")`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date transformations",
    "signature": "export declare const Date: typeof Date$"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Map",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Map transformations",
    "signature": "export declare const Map: typeof map"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Set",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Set transformations",
    "signature": "export declare const Set: typeof set"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "PropertyKey",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.12.5",
    "category": null,
    "signature": "export declare const PropertyKey: typeof PropertyKey$"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "asSchema",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Literal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Union",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Tuple",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ArrayEnsure",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonEmptyArrayEnsure",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Struct",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "filtering",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "transformLiteral",
    "description": "Creates a new `Schema` which transforms literal values.",
    "deprecated": false,
    "examples": [
      "import * as S from \"effect/Schema\"\n\nconst schema = S.transformLiteral(0, \"a\")\n\nassert.deepStrictEqual(S.decodeSync(schema)(0), \"a\")"
    ],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "transformLiterals",
    "description": "Creates a new `Schema` which maps between corresponding literal values.",
    "deprecated": false,
    "examples": [
      "import * as S from \"effect/Schema\"\n\nconst Animal = S.transformLiterals(\n  [0, \"cat\"],\n  [1, \"dog\"],\n  [2, \"cow\"]\n)\n\nassert.deepStrictEqual(S.decodeSync(Animal)(1), \"dog\")"
    ],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "parseNumber",
    "description": "Transforms a `string` into a `number` by parsing the string using the `parse`\nfunction of the `effect/Number` module.\n\nIt returns an error if the value can't be converted (for example when\nnon-numeric characters are provided).\n\nThe following special string values are supported: \"NaN\", \"Infinity\",\n\"-Infinity\".",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Redacted",
    "description": "A transformation that transform a `Schema<A, I, R>` into a\n`RedactedFromSelf<A>`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Redacted transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "head",
    "description": "Get the first element of a `ReadonlyArray`, or `None` if the array is empty.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyArray transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "headNonEmpty",
    "description": "Get the first element of a `NonEmptyReadonlyArray`.",
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "NonEmptyReadonlyArray transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Option",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Option transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "OptionFromNullOr",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Option transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "OptionFromNullishOr",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Option transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "OptionFromUndefinedOr",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Option transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlyMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyMap transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlySet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlySet transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Chunk",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Chunk transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonEmptyChunk",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Chunk transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "HashSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "HashSet transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "List",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "List transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "SortedSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "SortedSet transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "standardSchemaV1",
    "description": "Returns a \"Standard Schema\" object conforming to the [Standard Schema\nv1](https://standardschema.dev/) specification.\n\nThis function creates a schema whose `validate` method attempts to decode and\nvalidate the provided input synchronously. If the underlying `Schema`\nincludes any asynchronous components (e.g., asynchronous message resolutions\nor checks), then validation will necessarily return a `Promise` instead.\n\nAny detected defects will be reported via a single issue containing no\n`path`.",
    "deprecated": false,
    "examples": [
      "import { Schema } from \"effect\"\n\nconst schema = Schema.Struct({\n  name: Schema.String\n})\n\n//       StandardSchemaV1<{ readonly name: string; }>\n//      \nconst standardSchema = Schema.standardSchemaV1(schema)"
    ],
    "since": "3.13.0",
    "category": "Standard Schema",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "format",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "formatting",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "encodedSchema",
    "description": "The `encodedSchema` function allows you to extract the `Encoded` portion of a\nschema, creating a new schema that conforms to the properties defined in the\noriginal schema without retaining any refinements or transformations that\nwere applied previously.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "encodedBoundSchema",
    "description": "The `encodedBoundSchema` function is similar to `encodedSchema` but preserves\nthe refinements up to the first transformation point in the original schema.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "typeSchema",
    "description": "The `typeSchema` function allows you to extract the `Type` portion of a\nschema, creating a new schema that conforms to the properties defined in the\noriginal schema without considering the initial encoding or transformation\nprocesses.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "encodeUnknown",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "encodeUnknownEither",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "encodeUnknownPromise",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "decodeUnknown",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "decodeUnknownEither",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "decodeUnknownPromise",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "decoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "validate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "validateEither",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "validatePromise",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "validation",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "isSchema",
    "description": "Tests if a value is a `Schema`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "pickLiteral",
    "description": "Creates a new `Schema` from a literal schema.",
    "deprecated": false,
    "examples": [
      "import * as Schema from \"effect/Schema\"\nimport { Either } from \"effect\"\n\nconst schema = Schema.Literal(\"a\", \"b\", \"c\").pipe(Schema.pickLiteral(\"a\", \"b\"))\n\nassert.deepStrictEqual(Schema.decodeSync(schema)(\"a\"), \"a\")\nassert.deepStrictEqual(Schema.decodeSync(schema)(\"b\"), \"b\")\nassert.strictEqual(Either.isLeft(Schema.decodeUnknownEither(schema)(\"c\")), true)"
    ],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "UniqueSymbolFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Enums",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TemplateLiteral",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "template literal",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TemplateLiteralParser",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "template literal",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "fromBrand",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "instanceOf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NullOr",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "UndefinedOr",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NullishOr",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "keyof",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "element",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "optionalElement",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonEmptyArray",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "isPropertySignature",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "makePropertySignature",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "propertySignature",
    "description": "Lifts a `Schema` into a `PropertySignature`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "optionalToRequired",
    "description": "Converts an optional property to a required one through a transformation `Option -> Type`.\n\n- `decode`: `none` as argument means the value is missing in the input.\n- `encode`: `none` as return value means the value will be missing in the output.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "requiredToOptional",
    "description": "Converts an optional property to a required one through a transformation `Type -> Option`.\n\n- `decode`: `none` as return value means the value will be missing in the output.\n- `encode`: `none` as argument means the value is missing in the input.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "optionalToOptional",
    "description": "Converts an optional property to another optional property through a transformation `Option -> Option`.\n\n- `decode`:\n  - `none` as argument means the value is missing in the input.\n  - `none` as return value means the value will be missing in the output.\n- `encode`:\n  - `none` as argument means the value is missing in the input.\n  - `none` as return value means the value will be missing in the output.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "optional",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "tag",
    "description": "Returns a property signature that represents a tag.\nA tag is a literal value that is used to distinguish between different types of objects.\nThe tag is optional when using the `make` method.",
    "deprecated": false,
    "examples": [
      "import { Schema } from \"effect\"\n\nconst User = Schema.Struct({\n  _tag: Schema.tag(\"User\"),\n  name: Schema.String,\n  age: Schema.Number\n})\n\nassert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })"
    ],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TaggedStruct",
    "description": "A tagged struct is a struct that has a tag property that is used to distinguish between different types of objects.\n\nThe tag is optional when using the `make` method.",
    "deprecated": false,
    "examples": [
      "import { Schema } from \"effect\"\n\nconst User = Schema.TaggedStruct(\"User\", {\n  name: Schema.String,\n  age: Schema.Number\n})\n\nassert.deepStrictEqual(User.make({ name: \"John\", age: 44 }), { _tag: \"User\", name: \"John\", age: 44 })"
    ],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Record",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "pick",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "struct transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "omit",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "struct transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "brand",
    "description": "Returns a nominal branded schema by applying a brand to a given schema.\n\n```\nSchema<A> + B -> Schema<A & Brand<B>>\n```",
    "deprecated": false,
    "examples": [
      "import * as Schema from \"effect/Schema\"\n\nconst Int = Schema.Number.pipe(Schema.int(), Schema.brand(\"Int\"))\ntype Int = Schema.Schema.Type<typeof Int> // number & Brand<\"Int\">"
    ],
    "since": "3.10.0",
    "category": "branding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "partial",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "required",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "mutable",
    "description": "Creates a new schema with shallow mutability applied to its properties.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "combinators",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "suspend",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "trimmed",
    "description": "Verifies that a string contains no leading or trailing whitespaces.\n\nNote. This combinator does not make any transformations, it only validates.\nIf what you were looking for was a combinator to trim strings, then check out the `trim` combinator.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "maxLength",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "minLength",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "length",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "pattern",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "startsWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "endsWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "includes",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "lowercased",
    "description": "Verifies that a string is lowercased.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "uppercased",
    "description": "Verifies that a string is uppercased.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "capitalized",
    "description": "Verifies that a string is capitalized.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "uncapitalized",
    "description": "Verifies that a string is uncapitalized.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "nonEmptyString",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "split",
    "description": "Returns a schema that allows splitting a string into an array of strings.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "parseJson",
    "description": "The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying\nfunctionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.\n\nYou can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.\n\nOptionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.",
    "deprecated": false,
    "examples": [
      "import * as Schema from \"effect/Schema\"\n\nassert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{\"a\":\"1\"}`), { a: \"1\" })\nassert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{\"a\":\"1\"}`), { a: 1 })"
    ],
    "since": "3.10.0",
    "category": "string transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "finite",
    "description": "Ensures that the provided value is a finite number (excluding NaN, +Infinity, and -Infinity).",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThan",
    "description": "This filter checks whether the provided number is greater than the specified minimum.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanOrEqualTo",
    "description": "This filter checks whether the provided number is greater than or equal to the specified minimum.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "multipleOf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "int",
    "description": "Ensures that the provided value is an integer number (excluding NaN, +Infinity, and -Infinity).",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "lessThan",
    "description": "This filter checks whether the provided number is less than the specified maximum.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanOrEqualTo",
    "description": "This schema checks whether the provided number is less than or equal to the specified maximum.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "between",
    "description": "This filter checks whether the provided number falls within the specified minimum and maximum values.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "nonNaN",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "positive",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "negative",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "nonPositive",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "nonNegative",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "clamp",
    "description": "Clamps a number between a minimum and a maximum value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "number transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanBigInt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanOrEqualToBigInt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanBigInt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanOrEqualToBigInt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "betweenBigInt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "positiveBigInt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "negativeBigInt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "nonNegativeBigInt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "nonPositiveBigInt",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "clampBigInt",
    "description": "Clamps a bigint between a minimum and a maximum value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "bigint transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "RedactedFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Redacted constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "clampDuration",
    "description": "Clamps a `Duration` between a minimum and a maximum value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanDuration",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanOrEqualToDuration",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanDuration",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanOrEqualToDuration",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "betweenDuration",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Duration filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "minItems",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyArray filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "maxItems",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyArray filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "itemsCount",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyArray filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "getNumberIndexedAccess",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyArray transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "validDate",
    "description": "Defines a filter that specifically rejects invalid dates, such as `new\nDate(\"Invalid Date\")`. This filter ensures that only properly formatted and\nvalid date objects are accepted, enhancing data integrity by preventing\nerroneous date values from being processed.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanDate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanOrEqualToDate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanDate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanOrEqualToDate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "betweenDate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Date filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "OptionFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Option transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "EitherFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Either transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Either",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Either transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "EitherFromUnion",
    "description": null,
    "deprecated": false,
    "examples": [
      "import * as Schema from \"effect/Schema\"\n\n// Schema<string | number, Either<string, number>>\nSchema.EitherFromUnion({ left: Schema.String, right: Schema.Number })"
    ],
    "since": "3.10.0",
    "category": "Either transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlyMapFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyMap",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "MapFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Map",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlyMapFromRecord",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlyMap transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "MapFromRecord",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Map transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlySetFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "ReadonlySet",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "SetFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Set",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanBigDecimal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "greaterThanOrEqualToBigDecimal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanBigDecimal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "lessThanOrEqualToBigDecimal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "positiveBigDecimal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "nonNegativeBigDecimal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "negativeBigDecimal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "nonPositiveBigDecimal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "betweenBigDecimal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal filters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "clampBigDecimal",
    "description": "Clamps a `BigDecimal` between a minimum and a maximum value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "BigDecimal transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ChunkFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Chunk",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonEmptyChunkFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Chunk",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DataFromSelf",
    "description": "Type and Encoded must extend `Readonly<Record<string, any>> |\nReadonlyArray<any>` to be compatible with this API.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Data transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Data",
    "description": "Type and Encoded must extend `Readonly<Record<string, any>> |\nReadonlyArray<any>` to be compatible with this API.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Data transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Class",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { Schema } from \"effect\"\n\nclass MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n someField: Schema.String\n}) {\n someMethod() {\n   return this.someField + \"bar\"\n }\n}"
    ],
    "since": "3.10.0",
    "category": "classes",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TaggedClass",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { Schema } from \"effect\"\n\nclass MyClass extends Schema.TaggedClass<MyClass>(\"MyClass\")(\"MyClass\", {\n a: Schema.String\n}) {}"
    ],
    "since": "3.10.0",
    "category": "classes",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TaggedError",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { Schema } from \"effect\"\n\nclass MyError extends Schema.TaggedError<MyError>(\"MyError\")(\n  \"MyError\",\n  {\n    module: Schema.String,\n    method: Schema.String,\n    description: Schema.String\n  }\n) {\n  get message(): string {\n    return `${this.module}.${this.method}: ${this.description}`\n  }\n}"
    ],
    "since": "3.10.0",
    "category": "classes",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "CauseFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Cause transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Cause",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Cause transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ExitFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Exit transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Exit",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Exit transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "HashSetFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "HashSet transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "HashMapFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "HashMap transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "HashMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "HashMap transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ListFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "List transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "SortedSetFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "SortedSet transformations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Config",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Config validations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "asSerializable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "serializableSchema",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "accessor",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "serialize",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "encoding",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "asWithResult",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "failureSchema",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "accessor",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "successSchema",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "accessor",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "exitSchema",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "accessor",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "asSerializableWithResult",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TaggedRequest",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { Schema } from \"effect\"\n\nclass MyRequest extends Schema.TaggedRequest<MyRequest>(\"MyRequest\")(\"MyRequest\", {\n failure: Schema.String,\n success: Schema.Number,\n payload: { id: Schema.String }\n}) {}"
    ],
    "since": "3.10.0",
    "category": "classes",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "equivalence",
    "description": "Given a schema `Schema<A, I, R>`, returns an `Equivalence` instance for `A`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Equivalence",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Annotable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export interface Annotable<Self extends Schema<A, I, R>, A, I = A, R = never> extends Schema<A, I, R> {\n  annotations(annotations: Annotations.GenericSchema<A>): Self\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "AnnotableClass",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export interface AnnotableClass<Self extends Schema<A, I, R>, A, I = A, R = never> extends Annotable<Self, A, I, R> {\n  new(_: never): Schema.Variance<A, I, R>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "AnnotableDeclare",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.13.3",
    "category": "api interface",
    "signature": "export interface AnnotableDeclare<\n  Self extends declare<A, I, P, R>,\n  A,\n  I = A,\n  P extends ReadonlyArray<Schema.All> = readonly [],\n  R = Schema.Context<P[number]>\n> extends declare<A, I, P, R> {\n  annotations(annotations: Annotations.Schema<A>): Self\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Array$",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Array$<Value extends Schema.Any> extends TupleType<[], [Value]> {\n  readonly value: Value\n  annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>): Array$<Value>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ArrayEnsure",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ArrayEnsure<Value extends Schema.Any>\n  extends transform<Union<[Value, Array$<Value>]>, Array$<SchemaClass<Schema.Type<Value>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BrandSchema",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "branding",
    "signature": "export interface BrandSchema<A extends Brand<any>, I = A, R = never>\n  extends AnnotableClass<BrandSchema<A, I, R>, A, I, R>\n{\n  make(a: Brand.Unbranded<A>, options?: MakeOptions): A\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Cause",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Cause<E extends Schema.All, D extends Schema.All> extends\n  transform<\n    SchemaClass<\n      CauseEncoded<Schema.Type<E>, Schema.Type<Defect>>,\n      CauseEncoded<Schema.Encoded<E>, Schema.Encoded<Defect>>,\n      Schema.Context<E> | Schema.Context<D>\n    >,\n    CauseFromSelf<SchemaClass<Schema.Type<E>>, SchemaClass<Schema.Type<D>>>\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "CauseFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface CauseFromSelf<E extends Schema.All, D extends Schema.All> extends\n  AnnotableDeclare<\n    CauseFromSelf<E, D>,\n    cause_.Cause<Schema.Type<E>>,\n    cause_.Cause<Schema.Encoded<E>>,\n    [E, D]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Chunk",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Chunk<Value extends Schema.Any>\n  extends transform<Array$<Value>, ChunkFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ChunkFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    ChunkFromSelf<Value>,\n    chunk_.Chunk<Schema.Type<Value>>,\n    chunk_.Chunk<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Class",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Class<Self, Fields extends Struct.Fields, I, R, C, Inherited, Proto>\n  extends Schema<Self, Simplify<I>, R>\n{\n  new(\n    props: RequiredKeys<C> extends never ? void | Simplify<C> : Simplify<C>,\n    options?: MakeOptions\n  ): Struct.Type<Fields> & Inherited & Proto\n\n  /** @since 3.10.0 */\n  readonly ast: AST.Transformation\n\n  make<Args extends Array<any>, X>(this: { new(...args: Args): X }, ...args: Args): X\n\n  annotations(annotations: Annotations.Schema<Self>): SchemaClass<Self, Simplify<I>, R>\n\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n\n  readonly identifier: string\n\n  /**\n   * @example\n   * ```ts\n   * import { Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *  myField: Schema.String\n   * }) {\n   *  myMethod() {\n   *    return this.myField + \"my\"\n   *  }\n   * }\n   *\n   * class NextClass extends MyClass.extend<NextClass>(\"NextClass\")({\n   *  nextField: Schema.Number\n   * }) {\n   *  nextMethod() {\n   *    return this.myMethod() + this.myField + this.nextField\n   *  }\n   * }\n   * ```\n   */\n  extend<Extended = never>(identifier: string): <NewFields extends Struct.Fields>(\n    fields: NewFields | HasFields<NewFields>,\n    annotations?: ClassAnnotations<Extended, Simplify<Struct.Type<Fields & NewFields>>>\n  ) => [Extended] extends [never] ? MissingSelfGeneric<\"Base.extend\">\n    : Class<\n      Extended,\n      Fields & NewFields,\n      I & Struct.Encoded<NewFields>,\n      R | Struct.Context<NewFields>,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n\n  /**\n   * @example\n   * ```ts\n   * import { Effect, Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *   myField: Schema.String\n   * }) {\n   *   myMethod() {\n   *     return this.myField + \"my\"\n   *   }\n   * }\n   *\n   * class NextClass extends MyClass.transformOrFail<NextClass>(\"NextClass\")({\n   *   nextField: Schema.Number\n   * }, {\n   *   decode: (i) =>\n   *     Effect.succeed({\n   *       myField: i.myField,\n   *       nextField: i.myField.length\n   *     }),\n   *   encode: (a) => Effect.succeed({ myField: a.myField })\n   * }) {\n   *   nextMethod() {\n   *     return this.myMethod() + this.myField + this.nextField\n   *   }\n   * }\n   * ```\n   */\n  transformOrFail<Transformed = never>(identifier: string): <\n    NewFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: NewFields,\n    options: {\n      readonly decode: (\n        input: Simplify<Struct.Type<Fields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<Struct.Type<Fields & NewFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<Struct.Type<Fields & NewFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Struct.Type<Fields>, ParseResult.ParseIssue, R3>\n    },\n    annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformOrFail\">\n    : Class<\n      Transformed,\n      Fields & NewFields,\n      I,\n      R | Struct.Context<NewFields> | R2 | R3,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n\n  /**\n   * @example\n   * ```ts\n   * import { Effect, Schema } from \"effect\"\n   *\n   * class MyClass extends Schema.Class<MyClass>(\"MyClass\")({\n   *   myField: Schema.String\n   * }) {\n   *   myMethod() {\n   *     return this.myField + \"my\"\n   *   }\n   * }\n   *\n   * class NextClass extends MyClass.transformOrFailFrom<NextClass>(\"NextClass\")({\n   *   nextField: Schema.Number\n   * }, {\n   *   decode: (i) =>\n   *     Effect.succeed({\n   *       myField: i.myField,\n   *       nextField: i.myField.length\n   *     }),\n   *   encode: (a) => Effect.succeed({ myField: a.myField })\n   * }) {\n   *   nextMethod() {\n   *     return this.myMethod() + this.myField + this.nextField\n   *   }\n   * }\n   * ```\n   */\n  transformOrFailFrom<Transformed = never>(identifier: string): <\n    NewFields extends Struct.Fields,\n    R2,\n    R3\n  >(\n    fields: NewFields,\n    options: {\n      readonly decode: (\n        input: Simplify<I>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<Simplify<I & Struct.Encoded<NewFields>>, ParseResult.ParseIssue, R2>\n      readonly encode: (\n        input: Simplify<I & Struct.Encoded<NewFields>>,\n        options: ParseOptions,\n        ast: AST.Transformation\n      ) => Effect.Effect<I, ParseResult.ParseIssue, R3>\n    },\n    annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>\n  ) => [Transformed] extends [never] ? MissingSelfGeneric<\"Base.transformOrFailFrom\">\n    : Class<\n      Transformed,\n      Fields & NewFields,\n      I,\n      R | Struct.Context<NewFields> | R2 | R3,\n      C & Struct.Constructor<NewFields>,\n      Self,\n      Proto\n    >\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Data",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.13.3",
    "category": "api interface",
    "signature": "export interface Data<Value extends Schema.Any>\n  extends transform<Value, DataFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DataFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.13.3",
    "category": "api interface",
    "signature": "export interface DataFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    DataFromSelf<Value>,\n    Schema.Type<Value>,\n    Schema.Encoded<Value>,\n    [Value]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Either",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Either<Right extends Schema.All, Left extends Schema.All> extends\n  transform<\n    Union<[\n      Struct<{\n        _tag: Literal<[\"Right\"]>\n        right: Right\n      }>,\n      Struct<{\n        _tag: Literal<[\"Left\"]>\n        left: Left\n      }>\n    ]>,\n    EitherFromSelf<SchemaClass<Schema.Type<Right>>, SchemaClass<Schema.Type<Left>>>\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "EitherFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface EitherFromSelf<R extends Schema.All, L extends Schema.All> extends\n  AnnotableDeclare<\n    EitherFromSelf<R, L>,\n    either_.Either<Schema.Type<R>, Schema.Type<L>>,\n    either_.Either<Schema.Encoded<R>, Schema.Encoded<L>>,\n    [R, L]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "EitherFromUnion",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface EitherFromUnion<Right extends Schema.All, Left extends Schema.All> extends\n  transform<\n    Union<[\n      transform<Right, Struct<{ _tag: Literal<[\"Right\"]>; right: SchemaClass<Schema.Type<Right>> }>>,\n      transform<Left, Struct<{ _tag: Literal<[\"Left\"]>; right: SchemaClass<Schema.Type<Left>> }>>\n    ]>,\n    EitherFromSelf<SchemaClass<Schema.Type<Right>>, SchemaClass<Schema.Type<Left>>>\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Element",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "API interface",
    "signature": "export interface Element<S extends Schema.Any, Token extends Element.Token>\n  extends Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  readonly _Token: Token\n  readonly ast: AST.OptionalType\n  readonly from: S\n  annotations(annotations: Element.Annotations<Schema.Type<S>>): Element<S, Token>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Enums",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Enums<A extends EnumsDefinition> extends AnnotableClass<Enums<A>, A[keyof A]> {\n  readonly enums: A\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Exit",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Exit<A extends Schema.All, E extends Schema.All, D extends Schema.All> extends\n  transform<\n    Union<[\n      Struct<{\n        _tag: Literal<[\"Failure\"]>\n        cause: SchemaClass<\n          CauseEncoded<Schema.Type<E>, Schema.Type<D>>,\n          CauseEncoded<Schema.Encoded<E>, Schema.Encoded<D>>,\n          Schema.Context<E> | Schema.Context<D>\n        >\n      }>,\n      Struct<{\n        _tag: Literal<[\"Success\"]>\n        value: A\n      }>\n    ]>,\n    ExitFromSelf<SchemaClass<Schema.Type<A>>, SchemaClass<Schema.Type<E>>, SchemaClass<Schema.Type<D>>>\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ExitFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ExitFromSelf<A extends Schema.All, E extends Schema.All, D extends Schema.All>\n  extends\n    AnnotableDeclare<\n      ExitFromSelf<A, E, D>,\n      exit_.Exit<Schema.Type<A>, Schema.Type<E>>,\n      exit_.Exit<Schema.Encoded<A>, Schema.Encoded<E>>,\n      [A, E, D]\n    >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "FilterIssue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "filtering",
    "signature": "export interface FilterIssue {\n  readonly path: ReadonlyArray<PropertyKey>\n  readonly message: string\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "HashMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface HashMap<K extends Schema.Any, V extends Schema.Any>\n  extends transform<Array$<Tuple2<K, V>>, HashMapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "HashMapFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface HashMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableDeclare<\n    HashMapFromSelf<K, V>,\n    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,\n    hashMap_.HashMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    [K, V]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "HashSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface HashSet<Value extends Schema.Any>\n  extends transform<Array$<Value>, HashSetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "HashSetFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface HashSetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    HashSetFromSelf<Value>,\n    hashSet_.HashSet<Schema.Type<Value>>,\n    hashSet_.HashSet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "List",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface List<Value extends Schema.Any>\n  extends transform<Array$<Value>, ListFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ListFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ListFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    ListFromSelf<Value>,\n    list_.List<Schema.Type<Value>>,\n    list_.List<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Literal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>\n  extends AnnotableClass<Literal<Literals>, Literals[number]>\n{\n  readonly literals: Readonly<Literals>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Map$",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Map$<K extends Schema.Any, V extends Schema.Any>\n  extends transform<Array$<Tuple2<K, V>>, MapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "MapFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface MapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableDeclare<\n    MapFromSelf<K, V>,\n    Map<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    [K, V]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonEmptyArray",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface NonEmptyArray<Value extends Schema.Any> extends\n  AnnotableClass<\n    NonEmptyArray<Value>,\n    array_.NonEmptyReadonlyArray<Schema.Type<Value>>,\n    array_.NonEmptyReadonlyArray<Schema.Encoded<Value>>,\n    Schema.Context<Value>\n  >\n{\n  readonly elements: readonly [Value]\n  readonly rest: readonly [Value]\n  readonly value: Value\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonEmptyArrayEnsure",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface NonEmptyArrayEnsure<Value extends Schema.Any>\n  extends transform<Union<[Value, NonEmptyArray<Value>]>, NonEmptyArray<SchemaClass<Schema.Type<Value>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonEmptyChunk",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface NonEmptyChunk<Value extends Schema.Any>\n  extends transform<NonEmptyArray<Value>, NonEmptyChunkFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonEmptyChunkFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface NonEmptyChunkFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    NonEmptyChunkFromSelf<Value>,\n    chunk_.NonEmptyChunk<Schema.Type<Value>>,\n    chunk_.NonEmptyChunk<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NullOr",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface NullOr<S extends Schema.All> extends Union<[S, typeof Null]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null>): NullOr<S>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NullishOr",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface NullishOr<S extends Schema.All> extends Union<[S, typeof Null, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | null | undefined>): NullishOr<S>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Option",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Option<Value extends Schema.Any> extends\n  transform<\n    Union<[\n      Struct<{ _tag: Literal<[\"None\"]> }>,\n      Struct<{ _tag: Literal<[\"Some\"]>; value: Value }>\n    ]>,\n    OptionFromSelf<SchemaClass<Schema.Type<Value>>>\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "OptionFromNullOr",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface OptionFromNullOr<Value extends Schema.Any>\n  extends transform<NullOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "OptionFromNullishOr",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface OptionFromNullishOr<Value extends Schema.Any>\n  extends transform<NullishOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "OptionFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface OptionFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    OptionFromSelf<Value>,\n    option_.Option<Schema.Type<Value>>,\n    option_.Option<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "OptionFromUndefinedOr",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface OptionFromUndefinedOr<Value extends Schema.Any>\n  extends transform<UndefinedOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "PropertySignature",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "PropertySignature",
    "signature": "export interface PropertySignature<\n  TypeToken extends PropertySignature.Token,\n  Type,\n  Key extends PropertyKey,\n  EncodedToken extends PropertySignature.Token,\n  Encoded,\n  HasDefault extends boolean = false,\n  R = never\n> extends Schema.Variance<Type, Encoded, R>, Pipeable {\n  readonly [PropertySignatureTypeId]: null\n  readonly _TypeToken: TypeToken\n  readonly _EncodedToken: EncodedToken\n  readonly _HasDefault: HasDefault\n  readonly _Key: Key\n  readonly ast: PropertySignature.AST\n\n  annotations(\n    annotations: PropertySignature.Annotations<Type>\n  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlyMap$",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ReadonlyMap$<K extends Schema.Any, V extends Schema.Any>\n  extends transform<Array$<Tuple2<K, V>>, ReadonlyMapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlyMapFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ReadonlyMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends\n  AnnotableDeclare<\n    ReadonlyMapFromSelf<K, V>,\n    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,\n    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,\n    [K, V]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlySet$",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ReadonlySet$<Value extends Schema.Any>\n  extends transform<Array$<Value>, ReadonlySetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ReadonlySetFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface ReadonlySetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    ReadonlySetFromSelf<Value>,\n    ReadonlySet<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Record$",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Record$<K extends Schema.All, V extends Schema.All> extends TypeLiteral<{}, [{ key: K; value: V }]> {\n  readonly key: K\n  readonly value: V\n  annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<{}, [{ key: K; value: V }]>>>\n  ): Record$<K, V>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Redacted",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Redacted<Value extends Schema.Any>\n  extends transform<Value, RedactedFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "RedactedFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface RedactedFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    RedactedFromSelf<Value>,\n    redacted_.Redacted<Schema.Type<Value>>,\n    redacted_.Redacted<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Schema",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface Schema<in out A, in out I = A, out R = never> extends Schema.Variance<A, I, R>, Pipeable {\n  readonly Type: A\n  readonly Encoded: I\n  readonly Context: R\n  readonly ast: AST.AST\n  /**\n   * Merges a set of new annotations with existing ones, potentially overwriting\n   * any duplicates.\n   */\n  annotations(annotations: Annotations.GenericSchema<A>): Schema<A, I, R>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "SchemaClass",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface SchemaClass<A, I = A, R = never> extends AnnotableClass<SchemaClass<A, I, R>, A, I, R> {}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Serializable",
    "description": "The `Serializable` trait allows objects to define their own schema for\nserialization.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface Serializable<A, I, R> {\n  readonly [symbolSerializable]: Schema<A, I, R>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "SerializableWithResult",
    "description": "The `SerializableWithResult` trait is specifically designed to model remote\nprocedures that require serialization of their input and output, managing\nboth successful and failed outcomes.\n\nThis trait combines functionality from both the `Serializable` and `WithResult`\ntraits to handle data serialization and the bifurcation of operation results\ninto success or failure categories.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface SerializableWithResult<\n  A,\n  I,\n  R,\n  Success,\n  SuccessEncoded,\n  Failure,\n  FailureEncoded,\n  ResultR\n> extends Serializable<A, I, R>, WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Set$",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Set$<Value extends Schema.Any>\n  extends transform<Array$<Value>, SetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "SetFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface SetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    SetFromSelf<Value>,\n    Set<Schema.Type<Value>>,\n    ReadonlySet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "SortedSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface SortedSet<Value extends Schema.Any>\n  extends transform<Array$<Value>, SortedSetFromSelf<SchemaClass<Schema.Type<Value>>>>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "SortedSetFromSelf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface SortedSetFromSelf<Value extends Schema.Any> extends\n  AnnotableDeclare<\n    SortedSetFromSelf<Value>,\n    sortedSet_.SortedSet<Schema.Type<Value>>,\n    sortedSet_.SortedSet<Schema.Encoded<Value>>,\n    [Value]\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Struct",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Struct<Fields extends Struct.Fields> extends TypeLiteral<Fields, []> {\n  annotations(annotations: Annotations.Schema<Simplify<Struct.Type<Fields>>>): Struct<Fields>\n  pick<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Pick<Fields, Keys[number]>>>\n  omit<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Omit<Fields, Keys[number]>>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TaggedClass",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface TaggedClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    {}\n  >\n{\n  readonly _tag: Tag\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TaggedErrorClass",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface TaggedErrorClass<Self, Tag extends string, Fields extends Struct.Fields> extends\n  Class<\n    Self,\n    Fields,\n    Struct.Encoded<Fields>,\n    Struct.Context<Fields>,\n    Struct.Constructor<Omit<Fields, \"_tag\">>,\n    {},\n    cause_.YieldableError\n  >\n{\n  readonly _tag: Tag\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TaggedRequest",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export interface TaggedRequest<\n  Tag extends string,\n  A,\n  I,\n  R,\n  SuccessType,\n  SuccessEncoded,\n  FailureType,\n  FailureEncoded,\n  ResultR\n> extends\n  Request.Request<SuccessType, FailureType>,\n  SerializableWithResult<\n    A,\n    I,\n    R,\n    SuccessType,\n    SuccessEncoded,\n    FailureType,\n    FailureEncoded,\n    ResultR\n  >\n{\n  readonly _tag: Tag\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TaggedRequestClass",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface TaggedRequestClass<\n  Self,\n  Tag extends string,\n  Payload extends Struct.Fields,\n  Success extends Schema.All,\n  Failure extends Schema.All\n> extends\n  Class<\n    Self,\n    Payload,\n    Struct.Encoded<Payload>,\n    Struct.Context<Payload>,\n    Struct.Constructor<Omit<Payload, \"_tag\">>,\n    TaggedRequest<\n      Tag,\n      Self,\n      Struct.Encoded<Payload>,\n      Struct.Context<Payload>,\n      Schema.Type<Success>,\n      Schema.Encoded<Success>,\n      Schema.Type<Failure>,\n      Schema.Encoded<Failure>,\n      Schema.Context<Success> | Schema.Context<Failure>\n    >,\n    {}\n  >\n{\n  readonly _tag: Tag\n  readonly success: Success\n  readonly failure: Failure\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TemplateLiteral",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "API interface",
    "signature": "export interface TemplateLiteral<A> extends SchemaClass<A> {}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TemplateLiteralParser",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "API interface",
    "signature": "export interface TemplateLiteralParser<Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>\n  extends\n    Schema<\n      GetTemplateLiteralParserType<Params>,\n      GetTemplateLiteralParserEncoded<Params>,\n      Schema.Context<Params[number]>\n    >\n{\n  readonly params: Params\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Tuple",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Tuple<Elements extends TupleType.Elements> extends TupleType<Elements, []> {\n  annotations(annotations: Annotations.Schema<TupleType.Type<Elements, []>>): Tuple<Elements>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Tuple2",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.13.3",
    "category": "api interface",
    "signature": "export interface Tuple2<Fst extends Schema.Any, Snd extends Schema.Any> extends\n  AnnotableClass<\n    Tuple2<Fst, Snd>,\n    readonly [Schema.Type<Fst>, Schema.Type<Snd>],\n    readonly [Schema.Encoded<Fst>, Schema.Encoded<Snd>],\n    Schema.Context<Fst> | Schema.Context<Snd>\n  >\n{\n  readonly elements: readonly [Fst, Snd]\n  readonly rest: readonly []\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TupleType",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface TupleType<Elements extends TupleType.Elements, Rest extends TupleType.Rest> extends\n  AnnotableClass<\n    TupleType<Elements, Rest>,\n    TupleType.Type<Elements, Rest>,\n    TupleType.Encoded<Elements, Rest>,\n    Schema.Context<Elements[number]> | Schema.Context<Rest[number]>\n  >\n{\n  readonly elements: Readonly<Elements>\n  readonly rest: Readonly<Rest>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TypeLiteral",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface TypeLiteral<\n  Fields extends Struct.Fields,\n  Records extends IndexSignature.Records\n> extends\n  AnnotableClass<\n    TypeLiteral<Fields, Records>,\n    Simplify<TypeLiteral.Type<Fields, Records>>,\n    Simplify<TypeLiteral.Encoded<Fields, Records>>,\n    | Struct.Context<Fields>\n    | IndexSignature.Context<Records>\n  >\n{\n  readonly fields: { readonly [K in keyof Fields]: Fields[K] }\n  readonly records: Readonly<Records>\n  annotations(\n    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>\n  ): TypeLiteral<Fields, Records>\n  make(\n    props: RequiredKeys<TypeLiteral.Constructor<Fields, Records>> extends never\n      ? void | Simplify<TypeLiteral.Constructor<Fields, Records>>\n      : Simplify<TypeLiteral.Constructor<Fields, Records>>,\n    options?: MakeOptions\n  ): Simplify<TypeLiteral.Type<Fields, Records>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "UndefinedOr",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface UndefinedOr<S extends Schema.All> extends Union<[S, typeof Undefined]> {\n  annotations(annotations: Annotations.Schema<Schema.Type<S> | undefined>): UndefinedOr<S>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Union",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface Union<Members extends ReadonlyArray<Schema.All>> extends\n  AnnotableClass<\n    Union<Members>,\n    Schema.Type<Members[number]>,\n    Schema.Encoded<Members[number]>,\n    Schema.Context<Members[number]>\n  >\n{\n  readonly members: Readonly<Members>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "WithResult",
    "description": "The `WithResult` trait is designed to encapsulate the outcome of an\noperation, distinguishing between success and failure cases. Each case is\nassociated with a schema that defines the structure and types of the success\nor failure data.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {\n  readonly [symbolWithResult]: {\n    readonly success: Schema<Success, SuccessEncoded, ResultR>\n    readonly failure: Schema<Failure, FailureEncoded, ResultR>\n  }\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "brand",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface brand<S extends Schema.Any, B extends string | symbol>\n  extends BrandSchema<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>\n{\n  readonly from: S\n  annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "declare",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.13.3",
    "category": "api interface",
    "signature": "export interface declare<\n  A,\n  I = A,\n  P extends ReadonlyArray<Schema.All> = readonly [],\n  R = Schema.Context<P[number]>\n> extends AnnotableClass<declare<A, I, P, R>, A, I, R> {\n  readonly typeParameters: Readonly<P>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "extend",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface extend<Self extends Schema.Any, That extends Schema.Any> extends\n  AnnotableClass<\n    extend<Self, That>,\n    Schema.Type<Self> & Schema.Type<That>,\n    Schema.Encoded<Self> & Schema.Encoded<That>,\n    Schema.Context<Self> | Schema.Context<That>\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface filter<From extends Schema.Any> extends refine<Schema.Type<From>, From> {}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "filterEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface filterEffect<S extends Schema.Any, FD = never>\n  extends transformOrFail<S, SchemaClass<Schema.Type<S>>, FD>\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "instanceOf",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface instanceOf<A> extends AnnotableDeclare<instanceOf<A>, A> {}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "mutable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface mutable<S extends Schema.Any> extends\n  AnnotableClass<\n    mutable<S>,\n    SimplifyMutable<Schema.Type<S>>,\n    SimplifyMutable<Schema.Encoded<S>>,\n    Schema.Context<S>\n  >\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "optional",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface optional<S extends Schema.All> extends\n  PropertySignature<\n    \"?:\",\n    Schema.Type<S> | undefined,\n    never,\n    \"?:\",\n    Schema.Encoded<S> | undefined,\n    false,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S> | undefined>): optional<S>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "optionalWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface optionalWith<S extends Schema.All, Options> extends\n  PropertySignature<\n    Types.Has<Options, \"as\" | \"default\"> extends true ? \":\" : \"?:\",\n    | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n    | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined),\n    never,\n    \"?:\",\n    | Schema.Encoded<S>\n    | (Types.Has<Options, \"nullable\"> extends true ? null : never)\n    | (Types.Has<Options, \"exact\"> extends true ? never : undefined),\n    Types.Has<Options, \"default\">,\n    Schema.Context<S>\n  >\n{\n  readonly from: S\n  annotations(\n    annotations: PropertySignature.Annotations<\n      | (Types.Has<Options, \"as\"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)\n      | (Types.Has<Options, \"as\" | \"default\" | \"exact\"> extends true ? never : undefined)\n    >\n  ): optionalWith<S, Options>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "propertySignature",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "1.0.0",
    "category": "API interface",
    "signature": "export interface propertySignature<S extends Schema.All>\n  extends PropertySignature<\":\", Schema.Type<S>, never, \":\", Schema.Encoded<S>, false, Schema.Context<S>>\n{\n  readonly from: S\n  annotations(annotations: PropertySignature.Annotations<Schema.Type<S>>): propertySignature<S>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "refine",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface refine<A, From extends Schema.Any>\n  extends AnnotableClass<refine<A, From>, A, Schema.Encoded<From>, Schema.Context<From>>\n{\n  /** The following is required for {@link HasFields} to work */\n  readonly [RefineSchemaId]: From\n  readonly from: From\n  readonly filter: (\n    a: Schema.Type<From>,\n    options: ParseOptions,\n    self: AST.Refinement\n  ) => option_.Option<ParseResult.ParseIssue>\n  make(a: Schema.Type<From>, options?: MakeOptions): A\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "suspend",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface suspend<A, I, R> extends AnnotableClass<suspend<A, I, R>, A, I, R> {}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "tag",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface tag<Tag extends AST.LiteralValue> extends PropertySignature<\":\", Tag, never, \":\", Tag, true, never> {}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "transform",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface transform<From extends Schema.All, To extends Schema.All> extends transformOrFail<From, To> {\n  annotations(annotations: Annotations.Schema<Schema.Type<To>>): transform<From, To>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "transformLiteral",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface transformLiteral<Type extends AST.LiteralValue, Encoded extends AST.LiteralValue>\n  extends transform<Literal<[Encoded]>, Literal<[Type]>>\n{\n  annotations(annotations: Annotations.Schema<Type>): transformLiteral<Type, Encoded>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "transformOrFail",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export interface transformOrFail<From extends Schema.All, To extends Schema.All, R = never> extends\n  AnnotableClass<\n    transformOrFail<From, To, R>,\n    Schema.Type<To>,\n    Schema.Encoded<From>,\n    Schema.Context<From> | Schema.Context<To> | R\n  >\n{\n  readonly from: From\n  readonly to: To\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BetweenBigIntSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type BetweenBigIntSchemaId = typeof BetweenBigIntSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "BetweenSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type BetweenSchemaId = typeof BetweenSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "CauseEncoded",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Cause utils",
    "signature": "export type CauseEncoded<E, D> =\n  | {\n    readonly _tag: \"Empty\"\n  }\n  | {\n    readonly _tag: \"Fail\"\n    readonly error: E\n  }\n  | {\n    readonly _tag: \"Die\"\n    readonly defect: D\n  }\n  | {\n    readonly _tag: \"Interrupt\"\n    readonly fiberId: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"Sequential\"\n    readonly left: CauseEncoded<E, D>\n    readonly right: CauseEncoded<E, D>\n  }\n  | {\n    readonly _tag: \"Parallel\"\n    readonly left: CauseEncoded<E, D>\n    readonly right: CauseEncoded<E, D>\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DateFromSelfSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.8",
    "category": "schema id",
    "signature": "export type DateFromSelfSchemaId = typeof DateFromSelfSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "DurationEncoded",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.12.8",
    "category": "Duration utils",
    "signature": "export type DurationEncoded =\n  | {\n    readonly _tag: \"Millis\"\n    readonly millis: number\n  }\n  | {\n    readonly _tag: \"Nanos\"\n    readonly nanos: string\n  }\n  | {\n    readonly _tag: \"Infinity\"\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "EitherEncoded",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Either utils",
    "signature": "export type EitherEncoded<IR, IL> = RightEncoded<IR> | LeftEncoded<IL>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "EnumsDefinition",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export type EnumsDefinition = { [x: string]: string | number }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ExitEncoded",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Exit utils",
    "signature": "export type ExitEncoded<A, E, D> =\n  | {\n    readonly _tag: \"Failure\"\n    readonly cause: CauseEncoded<E, D>\n  }\n  | {\n    readonly _tag: \"Success\"\n    readonly value: A\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "FiberIdEncoded",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "FiberId",
    "signature": "export type FiberIdEncoded =\n  | {\n    readonly _tag: \"Composite\"\n    readonly left: FiberIdEncoded\n    readonly right: FiberIdEncoded\n  }\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Runtime\"\n    readonly id: number\n    readonly startTimeMillis: number\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "FilterOutput",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "filtering",
    "signature": "export type FilterOutput = undefined | boolean | string | ParseResult.ParseIssue | FilterIssue"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "FiniteSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type FiniteSchemaId = typeof FiniteSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "GreaterThanBigIntSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type GreaterThanBigIntSchemaId = typeof GreaterThanBigIntSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "GreaterThanOrEqualToBigIntSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type GreaterThanOrEqualToBigIntSchemaId = typeof GreaterThanOrEqualToBigIntSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "GreaterThanOrEqualToSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type GreaterThanOrEqualToSchemaId = typeof GreaterThanOrEqualToSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "GreaterThanSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type GreaterThanSchemaId = typeof GreaterThanSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "IntSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type IntSchemaId = typeof IntSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ItemsCountSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type ItemsCountSchemaId = typeof ItemsCountSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "JsonNumberSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type JsonNumberSchemaId = typeof JsonNumberSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LeftEncoded",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Either utils",
    "signature": "export type LeftEncoded<IE> = {\n  readonly _tag: \"Left\"\n  readonly left: IE\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LengthSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type LengthSchemaId = typeof LengthSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LessThanBigIntSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type LessThanBigIntSchemaId = typeof LessThanBigIntSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LessThanOrEqualToBigIntSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type LessThanOrEqualToBigIntSchemaId = typeof LessThanOrEqualToBigIntSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LessThanOrEqualToSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type LessThanOrEqualToSchemaId = typeof LessThanOrEqualToSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "LessThanSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type LessThanSchemaId = typeof LessThanSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "MakeOptions",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.13.4",
    "category": "Constructor utils",
    "signature": "export type MakeOptions = boolean | {\n  readonly disableValidation?: boolean | undefined\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "MaxItemsSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type MaxItemsSchemaId = typeof MaxItemsSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "MaxLengthSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type MaxLengthSchemaId = typeof MaxLengthSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "MinItemsSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type MinItemsSchemaId = typeof MinItemsSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "MinLengthSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type MinLengthSchemaId = typeof MinLengthSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "NonNaNSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export type NonNaNSchemaId = typeof NonNaNSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "OptionEncoded",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Option utils",
    "signature": "export type OptionEncoded<I> =\n  | {\n    readonly _tag: \"None\"\n  }\n  | {\n    readonly _tag: \"Some\"\n    readonly value: I\n  }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "OptionalOptions",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export type OptionalOptions<A> = {\n  readonly default?: never\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly default: LazyArg<A>\n  readonly as?: never\n  readonly exact?: true\n  readonly nullable?: true\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable?: never\n  readonly onNoneEncoding?: LazyArg<option_.Option<undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact?: never\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null | undefined>>\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable?: never\n  readonly onNoneEncoding?: never\n} | {\n  readonly as: \"Option\"\n  readonly default?: never\n  readonly exact: true\n  readonly nullable: true\n  readonly onNoneEncoding?: LazyArg<option_.Option<null>>\n} | undefined"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "ParseJsonOptions",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export type ParseJsonOptions = {\n  readonly reviver?: Parameters<typeof JSON.parse>[1]\n  readonly replacer?: Parameters<typeof JSON.stringify>[1]\n  readonly space?: Parameters<typeof JSON.stringify>[2]\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "PropertySignatureTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "export type PropertySignatureTypeId = typeof PropertySignatureTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "RefineSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "export type RefineSchemaId = typeof RefineSchemaId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "RightEncoded",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "Either utils",
    "signature": "export type RightEncoded<IA> = {\n  readonly _tag: \"Right\"\n  readonly right: IA\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "Simplify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export type Simplify<A> = { [K in keyof A]: A[K] } & {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "SimplifyMutable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export type SimplifyMutable<A> = {\n  -readonly [K in keyof A]: A[K]\n} extends infer B ? B : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TaggedStruct",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "api interface",
    "signature": "export type TaggedStruct<Tag extends AST.LiteralValue, Fields extends Struct.Fields> = Struct<\n  { _tag: tag<Tag> } & Fields\n>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Schema",
      "path": [
        "src",
        "Schema.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "AnyKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class AnyKeyword { constructor(readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "BigIntKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class BigIntKeyword { constructor(readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "BooleanKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class BooleanKeyword { constructor(readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "ComposeTransformation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class ComposeTransformation"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "Declaration",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Declaration { constructor(\n    readonly typeParameters: ReadonlyArray<AST>,\n    readonly decodeUnknown: (\n      ...typeParameters: ReadonlyArray<AST>\n    ) => (input: unknown, options: ParseOptions, self: Declaration) => Effect<any, ParseIssue, any>,\n    readonly encodeUnknown: (\n      ...typeParameters: ReadonlyArray<AST>\n    ) => (input: unknown, options: ParseOptions, self: Declaration) => Effect<any, ParseIssue, any>,\n    readonly annotations: Annotations = {}\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "Enums",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Enums { constructor(\n    readonly enums: ReadonlyArray<readonly [string, string | number]>,\n    readonly annotations: Annotations = {}\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "FinalTransformation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class FinalTransformation { constructor(\n    readonly decode: (\n      fromA: any,\n      options: ParseOptions,\n      self: Transformation,\n      fromI: any\n    ) => Effect<any, ParseIssue, any>,\n    readonly encode: (toI: any, options: ParseOptions, self: Transformation, toA: any) => Effect<any, ParseIssue, any>\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "IndexSignature",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class IndexSignature { constructor(\n    parameter: AST,\n    readonly type: AST,\n    readonly isReadonly: boolean\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "Literal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Literal { constructor(readonly literal: LiteralValue, readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "NeverKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class NeverKeyword { constructor(readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "NumberKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class NumberKeyword { constructor(readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "ObjectKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class ObjectKeyword { constructor(readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "OptionalType",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class OptionalType { constructor(\n    type: AST,\n    readonly isOptional: boolean,\n    annotations: Annotations = {}\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "PropertySignature",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class PropertySignature { constructor(\n    readonly name: PropertyKey,\n    type: AST,\n    isOptional: boolean,\n    readonly isReadonly: boolean,\n    annotations?: Annotations\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "PropertySignatureTransformation",
    "description": "Represents a `PropertySignature -> PropertySignature` transformation\n\nThe semantic of `decode` is:\n- `none()` represents the absence of the key/value pair\n- `some(value)` represents the presence of the key/value pair\n\nThe semantic of `encode` is:\n- `none()` you don't want to output the key/value pair\n- `some(value)` you want to output the key/value pair",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class PropertySignatureTransformation { constructor(\n    readonly from: PropertyKey,\n    readonly to: PropertyKey,\n    readonly decode: (o: Option.Option<any>) => Option.Option<any>,\n    readonly encode: (o: Option.Option<any>) => Option.Option<any>\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "Refinement",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Refinement<From> { constructor(\n    readonly from: From,\n    readonly filter: (\n      input: any,\n      options: ParseOptions,\n      self: Refinement\n    ) => Option.Option<ParseIssue>,\n    readonly annotations: Annotations = {}\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "StringKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class StringKeyword { constructor(readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "Suspend",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Suspend { constructor(readonly f: () => AST, readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "SymbolKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class SymbolKeyword { constructor(readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "TemplateLiteral",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class TemplateLiteral { constructor(\n    readonly head: string,\n    readonly spans: Arr.NonEmptyReadonlyArray<TemplateLiteralSpan>,\n    readonly annotations: Annotations = {}\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "TemplateLiteralSpan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class TemplateLiteralSpan { constructor(type: AST, readonly literal: string) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "Transformation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Transformation { constructor(\n    readonly from: AST,\n    readonly to: AST,\n    readonly transformation: TransformationKind,\n    readonly annotations: Annotations = {}\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "TupleType",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class TupleType { constructor(\n    readonly elements: ReadonlyArray<OptionalType>,\n    readonly rest: ReadonlyArray<Type>,\n    readonly isReadonly: boolean,\n    readonly annotations: Annotations = {}\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "Type",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Type { constructor(\n    readonly type: AST,\n    readonly annotations: Annotations = {}\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "TypeLiteral",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class TypeLiteral { constructor(\n    propertySignatures: ReadonlyArray<PropertySignature>,\n    indexSignatures: ReadonlyArray<IndexSignature>,\n    readonly annotations: Annotations = {}\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "TypeLiteralTransformation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class TypeLiteralTransformation { constructor(\n    readonly propertySignatureTransformations: ReadonlyArray<\n      PropertySignatureTransformation\n    >\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "UndefinedKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class UndefinedKeyword { constructor(readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "Union",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class Union<M> { private constructor(readonly types: Members<M>, readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "UniqueSymbol",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class UniqueSymbol { constructor(readonly symbol: symbol, readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "UnknownKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class UnknownKeyword { constructor(readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "VoidKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export declare class VoidKeyword { constructor(readonly annotations: Annotations = {}) }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "BrandAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const BrandAnnotationId: typeof BrandAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "SchemaIdAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const SchemaIdAnnotationId: typeof SchemaIdAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "MessageAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const MessageAnnotationId: typeof MessageAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "MissingMessageAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const MissingMessageAnnotationId: typeof MissingMessageAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "IdentifierAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const IdentifierAnnotationId: typeof IdentifierAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "TitleAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const TitleAnnotationId: typeof TitleAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "DescriptionAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const DescriptionAnnotationId: typeof DescriptionAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "ExamplesAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const ExamplesAnnotationId: typeof ExamplesAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "DefaultAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const DefaultAnnotationId: typeof DefaultAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "JSONSchemaAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const JSONSchemaAnnotationId: typeof JSONSchemaAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "ArbitraryAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const ArbitraryAnnotationId: typeof ArbitraryAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "PrettyAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const PrettyAnnotationId: typeof PrettyAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "EquivalenceAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const EquivalenceAnnotationId: typeof EquivalenceAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "DocumentationAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const DocumentationAnnotationId: typeof DocumentationAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "ConcurrencyAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const ConcurrencyAnnotationId: typeof ConcurrencyAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "BatchingAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const BatchingAnnotationId: typeof BatchingAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "ParseIssueTitleAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const ParseIssueTitleAnnotationId: typeof ParseIssueTitleAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "ParseOptionsAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const ParseOptionsAnnotationId: typeof ParseOptionsAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "DecodingFallbackAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const DecodingFallbackAnnotationId: typeof DecodingFallbackAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "SurrogateAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const SurrogateAnnotationId: typeof SurrogateAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getAnnotation: { <A>(key: symbol): (annotated: Annotated) => Option.Option<A>; <A>(annotated: Annotated, key: symbol): Option.Option<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getBrandAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getBrandAnnotation: (annotated: Annotated) => Option.Option<readonly [string | symbol, ...(string | symbol)[]]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getMessageAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getMessageAnnotation: (annotated: Annotated) => Option.Option<MessageAnnotation>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getMissingMessageAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getMissingMessageAnnotation: (annotated: Annotated) => Option.Option<MissingMessageAnnotation>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getTitleAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getTitleAnnotation: (annotated: Annotated) => Option.Option<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getIdentifierAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getIdentifierAnnotation: (annotated: Annotated) => Option.Option<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getDescriptionAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getDescriptionAnnotation: (annotated: Annotated) => Option.Option<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getExamplesAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getExamplesAnnotation: (annotated: Annotated) => Option.Option<readonly [unknown, ...unknown[]]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getDefaultAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getDefaultAnnotation: (annotated: Annotated) => Option.Option<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getJSONSchemaAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getJSONSchemaAnnotation: (annotated: Annotated) => Option.Option<object>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getDocumentationAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getDocumentationAnnotation: (annotated: Annotated) => Option.Option<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getConcurrencyAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getConcurrencyAnnotation: (annotated: Annotated) => Option.Option<ConcurrencyAnnotation>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getBatchingAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getBatchingAnnotation: (annotated: Annotated) => Option.Option<BatchingAnnotation>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getParseIssueTitleAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getParseIssueTitleAnnotation: (annotated: Annotated) => Option.Option<ParseIssueTitleAnnotation>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getParseOptionsAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getParseOptionsAnnotation: (annotated: Annotated) => Option.Option<ParseOptions>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getDecodingFallbackAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getDecodingFallbackAnnotation: (annotated: Annotated) => Option.Option<DecodingFallbackAnnotation<unknown>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getSurrogateAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getSurrogateAnnotation: (annotated: Annotated) => Option.Option<AST>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "JSONIdentifierAnnotationId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const JSONIdentifierAnnotationId: typeof JSONIdentifierAnnotationId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getJSONIdentifierAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export declare const getJSONIdentifierAnnotation: (annotated: Annotated) => Option.Option<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "ParseJsonSchemaId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "schema id",
    "signature": "export declare const ParseJsonSchemaId: typeof ParseJsonSchemaId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isDeclaration",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isDeclaration: (ast: AST) => ast is Declaration"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isLiteral",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isLiteral: (ast: AST) => ast is Literal"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isUniqueSymbol",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isUniqueSymbol: (ast: AST) => ast is UniqueSymbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "undefinedKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const undefinedKeyword: UndefinedKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isUndefinedKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isUndefinedKeyword: (ast: AST) => ast is UndefinedKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "voidKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const voidKeyword: VoidKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isVoidKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isVoidKeyword: (ast: AST) => ast is VoidKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "neverKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const neverKeyword: NeverKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isNeverKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isNeverKeyword: (ast: AST) => ast is NeverKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "unknownKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const unknownKeyword: UnknownKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isUnknownKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isUnknownKeyword: (ast: AST) => ast is UnknownKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "anyKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const anyKeyword: AnyKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isAnyKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isAnyKeyword: (ast: AST) => ast is AnyKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "stringKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const stringKeyword: StringKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isStringKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isStringKeyword: (ast: AST) => ast is StringKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "numberKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const numberKeyword: NumberKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isNumberKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isNumberKeyword: (ast: AST) => ast is NumberKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "booleanKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const booleanKeyword: BooleanKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isBooleanKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isBooleanKeyword: (ast: AST) => ast is BooleanKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "bigIntKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const bigIntKeyword: BigIntKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isBigIntKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isBigIntKeyword: (ast: AST) => ast is BigIntKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "symbolKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const symbolKeyword: SymbolKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isSymbolKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isSymbolKeyword: (ast: AST) => ast is SymbolKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "objectKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const objectKeyword: ObjectKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isObjectKeyword",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isObjectKeyword: (ast: AST) => ast is ObjectKeyword"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isEnums",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isEnums: (ast: AST) => ast is Enums"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isTemplateLiteral",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isTemplateLiteral: (ast: AST) => ast is TemplateLiteral"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isTupleType",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isTupleType: (ast: AST) => ast is TupleType"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isTypeLiteral",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isTypeLiteral: (ast: AST) => ast is TypeLiteral"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isUnion",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isUnion: (ast: AST) => ast is Union"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isSuspend",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isSuspend: (ast: AST) => ast is Suspend"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isRefinement",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isRefinement: (ast: AST) => ast is Refinement<AST>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "defaultParseOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export declare const defaultParseOption: ParseOptions"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isTransformation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isTransformation: (ast: AST) => ast is Transformation"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isFinalTransformation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isFinalTransformation: (ast: TransformationKind) => ast is FinalTransformation"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "composeTransformation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const composeTransformation: ComposeTransformation"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isComposeTransformation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isComposeTransformation: (ast: TransformationKind) => ast is ComposeTransformation"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isTypeLiteralTransformation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "guards",
    "signature": "export declare const isTypeLiteralTransformation: (ast: TransformationKind) => ast is TypeLiteralTransformation"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "null",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const null: Literal"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getJSONIdentifier",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "isParameter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "annotations",
    "description": "Merges a set of new annotations with existing ones, potentially overwriting\nany duplicates.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "keyof",
    "description": "Equivalent at runtime to the TypeScript type-level `keyof` operator.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getTemplateLiteralRegExp",
    "description": "Generates a regular expression from a `TemplateLiteral` AST node.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getTemplateLiteralCapturingRegExp",
    "description": "Generates a regular expression that captures the pattern defined by the given `TemplateLiteral` AST.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getPropertySignatures",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "pick",
    "description": "Equivalent at runtime to the built-in TypeScript utility type `Pick`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "omit",
    "description": "Equivalent at runtime to the built-in TypeScript utility type `Omit`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "partial",
    "description": "Equivalent at runtime to the built-in TypeScript utility type `Partial`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "required",
    "description": "Equivalent at runtime to the built-in TypeScript utility type `Required`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "mutable",
    "description": "Creates a new AST with shallow mutability applied to its properties.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "getCompiler",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "typeAST",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "encodedAST",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "encodedBoundAST",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "Annotated",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export interface Annotated {\n  readonly annotations: Annotations\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "Annotations",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export interface Annotations {\n  readonly [_: string]: unknown\n  readonly [_: symbol]: unknown\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "ParseOptions",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export interface ParseOptions {\n  /**\n   * The `errors` option allows you to receive all parsing errors when\n   * attempting to parse a value using a schema. By default only the first error\n   * is returned, but by setting the `errors` option to `\"all\"`, you can receive\n   * all errors that occurred during the parsing process. This can be useful for\n   * debugging or for providing more comprehensive error messages to the user.\n   *\n   * default: \"first\"\n   *\n   * @since 3.10.0\n   */\n  readonly errors?: \"first\" | \"all\" | undefined\n  /**\n   * When using a `Schema` to parse a value, by default any properties that are\n   * not specified in the `Schema` will be stripped out from the output. This is\n   * because the `Schema` is expecting a specific shape for the parsed value,\n   * and any excess properties do not conform to that shape.\n   *\n   * However, you can use the `onExcessProperty` option (default value:\n   * `\"ignore\"`) to trigger a parsing error. This can be particularly useful in\n   * cases where you need to detect and handle potential errors or unexpected\n   * values.\n   *\n   * If you want to allow excess properties to remain, you can use\n   * `onExcessProperty` set to `\"preserve\"`.\n   *\n   * default: \"ignore\"\n   *\n   * @since 3.10.0\n   */\n  readonly onExcessProperty?: \"ignore\" | \"error\" | \"preserve\" | undefined\n  /**\n   * The `propertyOrder` option provides control over the order of object fields\n   * in the output. This feature is particularly useful when the sequence of\n   * keys is important for the consuming processes or when maintaining the input\n   * order enhances readability and usability.\n   *\n   * By default, the `propertyOrder` option is set to `\"none\"`. This means that\n   * the internal system decides the order of keys to optimize parsing speed.\n   * The order of keys in this mode should not be considered stable, and it's\n   * recommended not to rely on key ordering as it may change in future updates\n   * without notice.\n   *\n   * Setting `propertyOrder` to `\"original\"` ensures that the keys are ordered\n   * as they appear in the input during the decoding/encoding process.\n   *\n   * default: \"none\"\n   *\n   * @since 3.10.0\n   */\n  readonly propertyOrder?: \"none\" | \"original\" | undefined\n  /**\n   * Handles missing properties in data structures. By default, missing\n   * properties are treated as if present with an `undefined` value. To treat\n   * missing properties as errors, set the `exact` option to `true`. This\n   * setting is already enabled by default for `is` and `asserts` functions,\n   * treating absent properties strictly unless overridden.\n   *\n   * default: false\n   *\n   * @since 3.10.0\n   */\n  readonly exact?: boolean | undefined\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "AST",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export type AST =\n  | Declaration\n  | Literal\n  | UniqueSymbol\n  | UndefinedKeyword\n  | VoidKeyword\n  | NeverKeyword\n  | UnknownKeyword\n  | AnyKeyword\n  | StringKeyword\n  | NumberKeyword\n  | BooleanKeyword\n  | BigIntKeyword\n  | SymbolKeyword\n  | ObjectKeyword\n  | Enums\n  | TemplateLiteral\n  // possible transformations\n  | Refinement\n  | TupleType\n  | TypeLiteral\n  | Union\n  | Suspend\n  // transformations\n  | Transformation"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "BatchingAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type BatchingAnnotation = boolean | \"inherit\" | undefined"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "BrandAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type BrandAnnotation = Arr.NonEmptyReadonlyArray<string | symbol>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "Compiler",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export type Compiler<A> = (ast: AST, path: ReadonlyArray<PropertyKey>) => A"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "ConcurrencyAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type ConcurrencyAnnotation = Concurrency | undefined"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "DecodingFallbackAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type DecodingFallbackAnnotation<A> = (issue: ParseIssue) => Effect<A, ParseIssue>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "DefaultAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type DefaultAnnotation<A> = A"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "DescriptionAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type DescriptionAnnotation = string"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "DocumentationAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type DocumentationAnnotation = string"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "EquivalenceAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type EquivalenceAnnotation<A, TypeParameters extends ReadonlyArray<any> = readonly []> = (\n  ...equivalences: { readonly [K in keyof TypeParameters]: Equivalence<TypeParameters[K]> }\n) => Equivalence<A>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "ExamplesAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type ExamplesAnnotation<A> = Arr.NonEmptyReadonlyArray<A>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "IdentifierAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type IdentifierAnnotation = string"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "JSONSchemaAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type JSONSchemaAnnotation = object"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "LiteralValue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export type LiteralValue = string | number | boolean | null | bigint"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "Match",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export type Match<A> = {\n  [K in AST[\"_tag\"]]: (ast: Extract<AST, { _tag: K }>, compile: Compiler<A>, path: ReadonlyArray<PropertyKey>) => A\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "Members",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export type Members<A> = readonly [A, A, ...Array<A>]"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "MessageAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type MessageAnnotation = (issue: ParseIssue) => string | Effect<string> | {\n  readonly message: string | Effect<string>\n  readonly override: boolean\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "MissingMessageAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type MissingMessageAnnotation = () => string | Effect<string>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "Parameter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": null,
    "signature": "export type Parameter = StringKeyword | SymbolKeyword | TemplateLiteral | Refinement<Parameter>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "ParseIssueTitleAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type ParseIssueTitleAnnotation = (issue: ParseIssue) => string | undefined"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "SchemaIdAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type SchemaIdAnnotation = string | symbol"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "SurrogateAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type SurrogateAnnotation = AST"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "TitleAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "annotations",
    "signature": "export type TitleAnnotation = string"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SchemaAST",
      "path": [
        "src",
        "SchemaAST.ts"
      ]
    },
    "project": "effect",
    "name": "TransformationKind",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "model",
    "signature": "export type TransformationKind =\n  | FinalTransformation\n  | ComposeTransformation\n  | TypeLiteralTransformation"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope",
      "path": [
        "src",
        "Scope.ts"
      ]
    },
    "project": "effect",
    "name": "ScopeTypeId",
    "description": "A unique identifier for the `Scope` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const ScopeTypeId: typeof ScopeTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope",
      "path": [
        "src",
        "Scope.ts"
      ]
    },
    "project": "effect",
    "name": "CloseableScopeTypeId",
    "description": "A unique identifier for the `CloseableScope` type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const CloseableScopeTypeId: typeof CloseableScopeTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope",
      "path": [
        "src",
        "Scope.ts"
      ]
    },
    "project": "effect",
    "name": "Scope",
    "description": "A tag representing the current `Scope` in the environment.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const Scope: Context.Tag<Scope, Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope",
      "path": [
        "src",
        "Scope.ts"
      ]
    },
    "project": "effect",
    "name": "addFinalizer",
    "description": "Adds a finalizer to this scope. The finalizer is guaranteed to be run when\nthe scope is closed. Use this when the finalizer does not need to know the\n`Exit` value that the scope is closed with.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const addFinalizer: (self: Scope, finalizer: Effect.Effect<unknown>) => Effect.Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope",
      "path": [
        "src",
        "Scope.ts"
      ]
    },
    "project": "effect",
    "name": "addFinalizerExit",
    "description": "Adds a finalizer to this scope. The finalizer receives the `Exit` value\nwhen the scope is closed, allowing it to perform different actions based\non the exit status.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const addFinalizerExit: (self: Scope, finalizer: Scope.Finalizer) => Effect.Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope",
      "path": [
        "src",
        "Scope.ts"
      ]
    },
    "project": "effect",
    "name": "close",
    "description": "Closes this scope with the specified exit value, running all finalizers that\nhave been added to the scope.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const close: (self: CloseableScope, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope",
      "path": [
        "src",
        "Scope.ts"
      ]
    },
    "project": "effect",
    "name": "extend",
    "description": "Extends the scope of an `Effect` that requires a scope into this scope.\nIt provides this scope to the effect but does not close the scope when the\neffect completes execution. This allows extending a scoped value into a\nlarger scope.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const extend: { (scope: Scope): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope>>; <A, E, R>(effect: Effect.Effect<A, E, R>, scope: Scope): Effect.Effect<A, E, Exclude<R, Scope>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope",
      "path": [
        "src",
        "Scope.ts"
      ]
    },
    "project": "effect",
    "name": "fork",
    "description": "Forks a new child scope with the specified execution strategy. The child scope\nwill automatically be closed when this scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const fork: (self: Scope, strategy: ExecutionStrategy.ExecutionStrategy) => Effect.Effect<CloseableScope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope",
      "path": [
        "src",
        "Scope.ts"
      ]
    },
    "project": "effect",
    "name": "use",
    "description": "Provides this closeable scope to an `Effect` that requires a scope,\nguaranteeing that the scope is closed with the result of that effect as\nsoon as the effect completes execution, whether by success, failure, or\ninterruption.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const use: { (scope: CloseableScope): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope>>; <A, E, R>(effect: Effect.Effect<A, E, R>, scope: CloseableScope): Effect.Effect<A, E, Exclude<R, Scope>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Scope",
      "path": [
        "src",
        "Scope.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new closeable scope where finalizers will run according to the\nspecified `ExecutionStrategy`. If no execution strategy is provided, `sequential`\nwill be used by default.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: (executionStrategy?: ExecutionStrategy.ExecutionStrategy) => Effect.Effect<CloseableScope>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Scope",
      "path": [
        "src",
        "Scope.ts"
      ]
    },
    "project": "effect",
    "name": "CloseableScope",
    "description": "A scope that can be explicitly closed with a specified exit value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface CloseableScope extends Scope, Pipeable {\n  readonly [CloseableScopeTypeId]: CloseableScopeTypeId\n\n  /**\n   * Closes this scope with the given exit value, running all finalizers.\n   *\n   * @internal\n   */\n  close(exit: Exit.Exit<unknown, unknown>): Effect.Effect<void>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Scope",
      "path": [
        "src",
        "Scope.ts"
      ]
    },
    "project": "effect",
    "name": "Scope",
    "description": "Represents a scope that manages finalizers and can fork child scopes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Scope extends Pipeable {\n  readonly [ScopeTypeId]: ScopeTypeId\n  /**\n   * The execution strategy for running finalizers in this scope.\n   */\n  readonly strategy: ExecutionStrategy.ExecutionStrategy\n  /**\n   * Forks a new child scope with the specified execution strategy. The child scope\n   * will automatically be closed when this scope is closed.\n   *\n   * @internal\n   */\n  fork(strategy: ExecutionStrategy.ExecutionStrategy): Effect.Effect<Scope.Closeable>\n  /**\n   * Adds a finalizer to this scope. The finalizer will be run when the scope is closed.\n   *\n   * @internal\n   */\n  addFinalizer(finalizer: Scope.Finalizer): Effect.Effect<void>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Scope",
      "path": [
        "src",
        "Scope.ts"
      ]
    },
    "project": "effect",
    "name": "CloseableScopeTypeId",
    "description": "The type of the unique identifier for `CloseableScope`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type CloseableScopeTypeId = typeof CloseableScopeTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Scope",
      "path": [
        "src",
        "Scope.ts"
      ]
    },
    "project": "effect",
    "name": "ScopeTypeId",
    "description": "The type of the unique identifier for `Scope`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type ScopeTypeId = typeof ScopeTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedCache",
      "path": [
        "src",
        "ScopedCache.ts"
      ]
    },
    "project": "effect",
    "name": "ScopedCacheTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const ScopedCacheTypeId: typeof ScopedCacheTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedCache",
      "path": [
        "src",
        "ScopedCache.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new cache with the specified capacity, time to live, and\nlookup function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <Key, Value, Error = never, Environment = never>(options: { readonly lookup: Lookup<Key, Value, Error, Environment>; readonly capacity: number; readonly timeToLive: Duration.DurationInput; }) => Effect.Effect<ScopedCache<Key, Value, Error>, never, Scope.Scope | Environment>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedCache",
      "path": [
        "src",
        "ScopedCache.ts"
      ]
    },
    "project": "effect",
    "name": "makeWith",
    "description": "Constructs a new cache with the specified capacity, time to live, and\nlookup function, where the time to live can depend on the `Exit` value\nreturned by the lookup function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const makeWith: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly lookup: Lookup<Key, Value, Error, Environment>; readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput; }) => Effect.Effect<ScopedCache<Key, Value, Error>, never, Scope.Scope | Environment>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScopedCache",
      "path": [
        "src",
        "ScopedCache.ts"
      ]
    },
    "project": "effect",
    "name": "ScopedCache",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ScopedCache<in Key, out Value, out Error = never>\n  extends ScopedCache.Variance<Key, Value, Error>, Pipeable\n{\n  /**\n   * Retrieves the value associated with the specified key if it exists.\n   * Otherwise returns `Option.none`.\n   */\n  getOption(key: Key): Effect.Effect<Option.Option<Value>, Error, Scope.Scope>\n\n  /**\n   * Retrieves the value associated with the specified key if it exists and the\n   * lookup function has completed. Otherwise returns `Option.none`.\n   */\n  getOptionComplete(key: Key): Effect.Effect<Option.Option<Value>, never, Scope.Scope>\n\n  /**\n   * Returns statistics for this cache.\n   */\n  readonly cacheStats: Effect.Effect<Cache.CacheStats>\n\n  /**\n   * Return whether a resource associated with the specified key exists in the\n   * cache. Sometime `contains` can return true if the resource is currently\n   * being created but not yet totally created.\n   */\n  contains(key: Key): Effect.Effect<boolean>\n\n  /**\n   * Return statistics for the specified entry.\n   */\n  entryStats(key: Key): Effect.Effect<Option.Option<Cache.EntryStats>>\n\n  /**\n   * Gets the value from the cache if it exists or otherwise computes it, the\n   * release action signals to the cache that the value is no longer being used\n   * and can potentially be finalized subject to the policies of the cache.\n   */\n  get(key: Key): Effect.Effect<Value, Error, Scope.Scope>\n\n  /**\n   * Invalidates the resource associated with the specified key.\n   */\n  invalidate(key: Key): Effect.Effect<void>\n\n  /**\n   * Invalidates all values in the cache.\n   */\n  readonly invalidateAll: Effect.Effect<void>\n\n  /**\n   * Force the reuse of the lookup function to compute the returned scoped\n   * effect associated with the specified key immediately. Once the new resource\n   * is recomputed, the old resource associated to the key is cleaned (once all\n   * fiber using it are done with it). During the time the new resource is\n   * computed, concurrent call the .get will use the old resource if this one is\n   * not expired.\n   */\n  refresh(key: Key): Effect.Effect<void, Error>\n\n  /**\n   * Returns the approximate number of values in the cache.\n   */\n  readonly size: Effect.Effect<number>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ScopedCache",
      "path": [
        "src",
        "ScopedCache.ts"
      ]
    },
    "project": "effect",
    "name": "Lookup",
    "description": "Similar to `Cache.Lookup`, but executes the lookup function within a `Scope`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type Lookup<Key, Value, Error = never, Environment = never> = (\n  key: Key\n) => Effect.Effect<Value, Error, Environment | Scope.Scope>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ScopedCache",
      "path": [
        "src",
        "ScopedCache.ts"
      ]
    },
    "project": "effect",
    "name": "ScopedCacheTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type ScopedCacheTypeId = typeof ScopedCacheTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedRef",
      "path": [
        "src",
        "ScopedRef.ts"
      ]
    },
    "project": "effect",
    "name": "ScopedRefTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const ScopedRefTypeId: typeof ScopedRefTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedRef",
      "path": [
        "src",
        "ScopedRef.ts"
      ]
    },
    "project": "effect",
    "name": "fromAcquire",
    "description": "Creates a new `ScopedRef` from an effect that resourcefully produces a\nvalue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromAcquire: <A, E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<ScopedRef<A>, E, Scope.Scope | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedRef",
      "path": [
        "src",
        "ScopedRef.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves the current value of the scoped reference.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const get: <A>(self: ScopedRef<A>) => Effect.Effect<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedRef",
      "path": [
        "src",
        "ScopedRef.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new `ScopedRef` from the specified value. This method should\nnot be used for values whose creation require the acquisition of resources.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <A>(evaluate: LazyArg<A>) => Effect.Effect<ScopedRef<A>, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "ScopedRef",
      "path": [
        "src",
        "ScopedRef.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": "Sets the value of this reference to the specified resourcefully-created\nvalue. Any resources associated with the old value will be released.\n\nThis method will not return until either the reference is successfully\nchanged to the new value, with old resources released, or until the attempt\nto acquire a new value fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const set: { <A, R, E>(acquire: Effect.Effect<A, E, R>): (self: ScopedRef<A>) => Effect.Effect<void, E, Exclude<R, Scope.Scope>>; <A, R, E>(self: ScopedRef<A>, acquire: Effect.Effect<A, E, R>): Effect.Effect<void, E, Exclude<R, Scope.Scope>>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScopedRef",
      "path": [
        "src",
        "ScopedRef.ts"
      ]
    },
    "project": "effect",
    "name": "ScopedRef",
    "description": "A `ScopedRef` is a reference whose value is associated with resources,\nwhich must be released properly. You can both get the current value of any\n`ScopedRef`, as well as set it to a new value (which may require new\nresources). The reference itself takes care of properly releasing resources\nfor the old value whenever a new value is obtained.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ScopedRef<in out A> extends Effect.Effect<A>, ScopedRef.Variance<A>, Pipeable {\n  /** @internal */\n  readonly ref: Synchronized.SynchronizedRef<readonly [Scope.Scope.Closeable, A]>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: ScopedRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: ScopedRefUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScopedRef",
      "path": [
        "src",
        "ScopedRef.ts"
      ]
    },
    "project": "effect",
    "name": "ScopedRefUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface ScopedRefUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  ScopedRef?: () => Extract<A[Unify.typeSymbol], ScopedRef<any>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "ScopedRef",
      "path": [
        "src",
        "ScopedRef.ts"
      ]
    },
    "project": "effect",
    "name": "ScopedRefUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": "models",
    "signature": "export interface ScopedRefUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "ScopedRef",
      "path": [
        "src",
        "ScopedRef.ts"
      ]
    },
    "project": "effect",
    "name": "ScopedRefTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type ScopedRefTypeId = typeof ScopedRefTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SingleProducerAsyncInput",
      "path": [
        "src",
        "SingleProducerAsyncInput.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <Err, Elem, Done>() => Effect.Effect<SingleProducerAsyncInput<Err, Elem, Done>>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SingleProducerAsyncInput",
      "path": [
        "src",
        "SingleProducerAsyncInput.ts"
      ]
    },
    "project": "effect",
    "name": "AsyncInputConsumer",
    "description": "Consumer-side view of `SingleProducerAsyncInput` for variance purposes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface AsyncInputConsumer<out Err, out Elem, out Done> {\n  takeWith<A>(\n    onError: (cause: Cause.Cause<Err>) => A,\n    onElement: (element: Elem) => A,\n    onDone: (value: Done) => A\n  ): Effect.Effect<A>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SingleProducerAsyncInput",
      "path": [
        "src",
        "SingleProducerAsyncInput.ts"
      ]
    },
    "project": "effect",
    "name": "AsyncInputProducer",
    "description": "Producer-side view of `SingleProducerAsyncInput` for variance purposes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface AsyncInputProducer<in Err, in Elem, in Done> {\n  awaitRead(): Effect.Effect<unknown>\n  done(value: Done): Effect.Effect<unknown>\n  emit(element: Elem): Effect.Effect<unknown>\n  error(cause: Cause.Cause<Err>): Effect.Effect<unknown>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SingleProducerAsyncInput",
      "path": [
        "src",
        "SingleProducerAsyncInput.ts"
      ]
    },
    "project": "effect",
    "name": "SingleProducerAsyncInput",
    "description": "An MVar-like abstraction for sending data to channels asynchronously which is\ndesigned for one producer and multiple consumers.\n\nFeatures the following semantics:\n  - Buffer of size 1.\n  - When emitting, the producer waits for a consumer to pick up the value to\n    prevent \"reading ahead\" too much.\n  - Once an emitted element is read by a consumer, it is cleared from the\n    buffer, so that at most one consumer sees every emitted element.\n  - When sending a done or error signal, the producer does not wait for a\n    consumer to pick up the signal. The signal stays in the buffer after\n    being read by a consumer, so it can be propagated to multiple consumers.\n  - Trying to publish another emit/error/done after an error/done have\n    already been published results in an interruption.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SingleProducerAsyncInput<in out Err, in out Elem, in out Done>\n  extends AsyncInputProducer<Err, Elem, Done>, AsyncInputConsumer<Err, Elem, Done>\n{\n  readonly close: Effect.Effect<unknown>\n  readonly take: Effect.Effect<Exit.Exit<Elem, Either.Either<Done, Err>>>\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "SinkTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const SinkTypeId: typeof SinkTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "as",
    "description": "Replaces this sink's result with the provided value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const as: { <A2>(a: A2): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E, R>; <A, In, L, E, R, A2>(self: Sink<A, In, L, E, R>, a: A2): Sink<A2, In, L, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "collectAll",
    "description": "A sink that collects all elements into a `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const collectAll: <In>() => Sink<Chunk.Chunk<In>, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "collectAllN",
    "description": "A sink that collects first `n` elements into a chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const collectAllN: <In>(n: number) => Sink<Chunk.Chunk<In>, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "collectAllFrom",
    "description": "Repeatedly runs the sink and accumulates its results into a `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const collectAllFrom: <A, In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<Chunk.Chunk<A>, In, L, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "collectAllToMap",
    "description": "A sink that collects all of its inputs into a map. The keys are extracted\nfrom inputs using the keying function `key`; if multiple inputs use the\nsame key, they are merged using the `merge` function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const collectAllToMap: <In, K>(key: (input: In) => K, merge: (x: In, y: In) => In) => Sink<HashMap.HashMap<K, In>, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "collectAllToMapN",
    "description": "A sink that collects first `n` keys into a map. The keys are calculated\nfrom inputs using the keying function `key`; if multiple inputs use the the\nsame key, they are merged using the `merge` function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const collectAllToMapN: <In, K>(n: number, key: (input: In) => K, merge: (x: In, y: In) => In) => Sink<HashMap.HashMap<K, In>, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "collectAllToSet",
    "description": "A sink that collects all of its inputs into a set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const collectAllToSet: <In>() => Sink<HashSet.HashSet<In>, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "collectAllToSetN",
    "description": "A sink that collects first `n` distinct inputs into a set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const collectAllToSetN: <In>(n: number) => Sink<HashSet.HashSet<In>, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "collectAllUntil",
    "description": "Accumulates incoming elements into a chunk until predicate `p` is\nsatisfied.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const collectAllUntil: <In>(p: Predicate<In>) => Sink<Chunk.Chunk<In>, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "collectAllUntilEffect",
    "description": "Accumulates incoming elements into a chunk until effectful predicate `p` is\nsatisfied.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const collectAllUntilEffect: <In, E, R>(p: (input: In) => Effect.Effect<boolean, E, R>) => Sink<Chunk.Chunk<In>, In, In, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "collectAllWhile",
    "description": "Accumulates incoming elements into a chunk as long as they verify predicate\n`p`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const collectAllWhile: { <In, Out extends In>(refinement: Refinement<In, Out>): Sink<Chunk.Chunk<Out>, In, In>; <In>(predicate: Predicate<In>): Sink<Chunk.Chunk<In>, In, In>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "collectAllWhileEffect",
    "description": "Accumulates incoming elements into a chunk as long as they verify effectful\npredicate `p`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const collectAllWhileEffect: <In, E, R>(predicate: (input: In) => Effect.Effect<boolean, E, R>) => Sink<Chunk.Chunk<In>, In, In, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "collectAllWhileWith",
    "description": "Repeatedly runs the sink for as long as its results satisfy the predicate\n`p`. The sink's results will be accumulated using the stepping function `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const collectAllWhileWith: { <A, S>(options: { readonly initial: S; readonly while: Predicate<A>; readonly body: (s: S, a: A) => S; }): <In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<S, In, L, E, R>; <A, In, L extends In, E, R, S>(self: Sink<A, In, L, E, R>, options: { readonly initial: S; readonly while: Predicate<A>; readonly body: (s: S, a: A) => S; }): Sink<S, In, L, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "collectLeftover",
    "description": "Collects the leftovers from the stream when the sink succeeds and returns\nthem as part of the sink's result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const collectLeftover: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, Chunk.Chunk<L>], In, never, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "mapInput",
    "description": "Transforms this sink's input elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapInput: { <In0, In>(f: (input: In0) => In): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E, R>; <A, In, L, E, R, In0>(self: Sink<A, In, L, E, R>, f: (input: In0) => In): Sink<A, In0, L, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputEffect",
    "description": "Effectfully transforms this sink's input elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapInputEffect: { <In0, In, E2, R2>(f: (input: In0) => Effect.Effect<In, E2, R2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E2 | E, R2 | R>; <A, In, L, E, R, In0, E2, R2>(self: Sink<A, In, L, E, R>, f: (input: In0) => Effect.Effect<In, E2, R2>): Sink<A, In0, L, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputChunks",
    "description": "Transforms this sink's input chunks. `f` must preserve chunking-invariance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapInputChunks: { <In0, In>(f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E, R>; <A, In, L, E, R, In0>(self: Sink<A, In, L, E, R>, f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>): Sink<A, In0, L, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputChunksEffect",
    "description": "Effectfully transforms this sink's input chunks. `f` must preserve\nchunking-invariance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapInputChunksEffect: { <In0, In, E2, R2>(f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E2 | E, R2 | R>; <A, In, L, E, R, In0, E2, R2>(self: Sink<A, In, L, E, R>, f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>): Sink<A, In0, L, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "count",
    "description": "A sink that counts the number of elements fed to it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const count: Sink<number, unknown, never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "die",
    "description": "Creates a sink halting with the specified defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const die: (defect: unknown) => Sink<never, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "dieMessage",
    "description": "Creates a sink halting with the specified message, wrapped in a\n`RuntimeException`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dieMessage: (message: string) => Sink<never, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "dieSync",
    "description": "Creates a sink halting with the specified defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dieSync: (evaluate: LazyArg<unknown>) => Sink<never, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "dimap",
    "description": "Transforms both inputs and result of this sink using the provided\nfunctions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const dimap: { <In0, In, A, A2>(options: { readonly onInput: (input: In0) => In; readonly onDone: (a: A) => A2; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E, R>; <A, In, L, E, R, In0, A2>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (input: In0) => In; readonly onDone: (a: A) => A2; }): Sink<A2, In0, L, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "dimapEffect",
    "description": "Effectfully transforms both inputs and result of this sink using the\nprovided functions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const dimapEffect: { <In0, In, E2, R2, A, A2, E3, R3>(options: { readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>; <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): Sink<A2, In0, L, E | E2 | E3, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "dimapChunks",
    "description": "Transforms both input chunks and result of this sink using the provided\nfunctions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const dimapChunks: { <In0, In, A, A2>(options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>; readonly onDone: (a: A) => A2; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E, R>; <A, In, L, E, R, In0, A2>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>; readonly onDone: (a: A) => A2; }): Sink<A2, In0, L, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "dimapChunksEffect",
    "description": "Effectfully transforms both input chunks and result of this sink using the\nprovided functions. `f` and `g` must preserve chunking-invariance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const dimapChunksEffect: { <In0, In, E2, R2, A, A2, E3, R3>(options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>; <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): Sink<A2, In0, L, E | E2 | E3, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "drain",
    "description": "A sink that ignores its inputs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const drain: Sink<void, unknown, never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "drop",
    "description": "Creates a sink that drops `n` elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const drop: <In>(n: number) => Sink<unknown, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "dropUntil",
    "description": "Drops incoming elements until the predicate is satisfied.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dropUntil: <In>(predicate: Predicate<In>) => Sink<unknown, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "dropUntilEffect",
    "description": "Drops incoming elements until the effectful predicate is satisfied.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dropUntilEffect: <In, E, R>(predicate: (input: In) => Effect.Effect<boolean, E, R>) => Sink<unknown, In, In, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "dropWhile",
    "description": "Drops incoming elements as long as the predicate is satisfied.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dropWhile: <In>(predicate: Predicate<In>) => Sink<unknown, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "dropWhileEffect",
    "description": "Drops incoming elements as long as the effectful predicate is satisfied.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dropWhileEffect: <In, E, R>(predicate: (input: In) => Effect.Effect<boolean, E, R>) => Sink<unknown, In, In, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "ensuring",
    "description": "Returns a new sink with an attached finalizer. The finalizer is guaranteed\nto be executed so long as the sink begins execution (and regardless of\nwhether or not it completes).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "finalization",
    "signature": "export declare const ensuring: { <X, R2>(finalizer: Effect.Effect<X, never, R2>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, R2 | R>; <A, In, L, E, R, X, R2>(self: Sink<A, In, L, E, R>, finalizer: Effect.Effect<X, never, R2>): Sink<A, In, L, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "ensuringWith",
    "description": "Returns a new sink with an attached finalizer. The finalizer is guaranteed\nto be executed so long as the sink begins execution (and regardless of\nwhether or not it completes).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "finalization",
    "signature": "export declare const ensuringWith: { <A, E, X, R2>(finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>): <In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, R2 | R>; <A, In, L, E, R, X, R2>(self: Sink<A, In, L, E, R>, finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>): Sink<A, In, L, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "context",
    "description": "Accesses the whole context of the sink.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const context: <R>() => Sink<Context.Context<R>, unknown, never, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "contextWith",
    "description": "Accesses the context of the sink.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const contextWith: <R, Z>(f: (context: Context.Context<R>) => Z) => Sink<Z, unknown, never, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "contextWithEffect",
    "description": "Accesses the context of the sink in the context of an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const contextWithEffect: <R0, A, E, R>(f: (context: Context.Context<R0>) => Effect.Effect<A, E, R>) => Sink<A, unknown, never, E, R0 | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "contextWithSink",
    "description": "Accesses the context of the sink in the context of a sink.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const contextWithSink: <R0, A, In, L, E, R>(f: (context: Context.Context<R0>) => Sink<A, In, L, E, R>) => Sink<A, In, L, E, R0 | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "every",
    "description": "A sink that returns whether all elements satisfy the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const every: <In>(predicate: Predicate<In>) => Sink<boolean, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": "A sink that always fails with the specified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fail: <E>(e: E) => Sink<never, unknown, never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "failSync",
    "description": "A sink that always fails with the specified lazily evaluated error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failSync: <E>(evaluate: LazyArg<E>) => Sink<never, unknown, never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "failCause",
    "description": "Creates a sink halting with a specified `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failCause: <E>(cause: Cause.Cause<E>) => Sink<never, unknown, never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "failCauseSync",
    "description": "Creates a sink halting with a specified lazily evaluated `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Sink<never, unknown, never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "filterInput",
    "description": "Filters the sink's input with the given predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterInput: { <In, In1 extends In, In2 extends In1>(f: Refinement<In1, In2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In2, L, E, R>; <In, In1 extends In>(f: Predicate<In1>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In1, L, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "filterInputEffect",
    "description": "Effectfully filter the input of this sink using the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterInputEffect: { <In, In1 extends In, E2, R2>(f: (input: In1) => Effect.Effect<boolean, E2, R2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In1, L, E2 | E, R2 | R>; <A, In, L, E, R, In1 extends In, E2, R2>(self: Sink<A, In, L, E, R>, f: (input: In1) => Effect.Effect<boolean, E2, R2>): Sink<A, In1, L, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "findEffect",
    "description": "Creates a sink that produces values until one verifies the predicate `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findEffect: { <A, E2, R2>(f: (a: A) => Effect.Effect<boolean, E2, R2>): <In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<Option.Option<A>, In, L, E2 | E, R2 | R>; <A, In, L extends In, E, R, E2, R2>(self: Sink<A, In, L, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Sink<Option.Option<A>, In, L, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "fold",
    "description": "A sink that folds its inputs with the provided function, termination\npredicate and initial state.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const fold: <S, In>(s: S, contFn: Predicate<S>, f: (s: S, input: In) => S) => Sink<S, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "foldSink",
    "description": "Folds over the result of the sink",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const foldSink: { <E, A1, In, In1 extends In, L1, E1, R1, A, A2, In2 extends In, L2, E2, R2>(options: { readonly onFailure: (err: E) => Sink<A1, In1, L1, E1, R1>; readonly onSuccess: (a: A) => Sink<A2, In2, L2, E2, R2>; }): <L, R>(self: Sink<A, In, L, E, R>) => Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R1 | R2 | R>; <A, In, L, E, R, A1, In1 extends In, L1, E1, R1, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, options: { readonly onFailure: (err: E) => Sink<A1, In1, L1, E1, R1>; readonly onSuccess: (a: A) => Sink<A2, In2, L2, E2, R2>; }): Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R | R1 | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "foldChunks",
    "description": "A sink that folds its input chunks with the provided function, termination\npredicate and initial state. `contFn` condition is checked only for the\ninitial value and at the end of processing of each chunk. `f` and `contFn`\nmust preserve chunking-invariance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const foldChunks: <S, In>(s: S, contFn: Predicate<S>, f: (s: S, chunk: Chunk.Chunk<In>) => S) => Sink<S, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "foldChunksEffect",
    "description": "A sink that effectfully folds its input chunks with the provided function,\ntermination predicate and initial state. `contFn` condition is checked only\nfor the initial value and at the end of processing of each chunk. `f` and\n`contFn` must preserve chunking-invariance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const foldChunksEffect: <S, In, E, R>(s: S, contFn: Predicate<S>, f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "foldEffect",
    "description": "A sink that effectfully folds its inputs with the provided function,\ntermination predicate and initial state.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const foldEffect: <S, In, E, R>(s: S, contFn: Predicate<S>, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "foldLeft",
    "description": "A sink that folds its inputs with the provided function and initial state.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const foldLeft: <S, In>(s: S, f: (s: S, input: In) => S) => Sink<S, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "foldLeftChunks",
    "description": "A sink that folds its input chunks with the provided function and initial\nstate. `f` must preserve chunking-invariance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const foldLeftChunks: <S, In>(s: S, f: (s: S, chunk: Chunk.Chunk<In>) => S) => Sink<S, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "foldLeftChunksEffect",
    "description": "A sink that effectfully folds its input chunks with the provided function\nand initial state. `f` must preserve chunking-invariance.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const foldLeftChunksEffect: <S, In, E, R>(s: S, f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>) => Sink<S, In, never, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "foldLeftEffect",
    "description": "A sink that effectfully folds its inputs with the provided function and\ninitial state.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const foldLeftEffect: <S, In, E, R>(s: S, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "foldUntil",
    "description": "Creates a sink that folds elements of type `In` into a structure of type\n`S` until `max` elements have been folded.\n\nLike `Sink.foldWeighted`, but with a constant cost function of `1`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const foldUntil: <In, S>(s: S, max: number, f: (s: S, input: In) => S) => Sink<S, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "foldUntilEffect",
    "description": "Creates a sink that effectfully folds elements of type `In` into a\nstructure of type `S` until `max` elements have been folded.\n\nLike `Sink.foldWeightedEffect` but with a constant cost function of `1`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const foldUntilEffect: <S, In, E, R>(s: S, max: number, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "foldWeighted",
    "description": "Creates a sink that folds elements of type `In` into a structure of type\n`S`, until `max` worth of elements (determined by the `costFn`) have been\nfolded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const foldWeighted: <S, In>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => number; readonly body: (s: S, input: In) => S; }) => Sink<S, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "foldWeightedDecompose",
    "description": "Creates a sink that folds elements of type `In` into a structure of type\n`S`, until `max` worth of elements (determined by the `costFn`) have been\nfolded.\n\nThe `decompose` function will be used for decomposing elements that cause\nan `S` aggregate to cross `max` into smaller elements. For example:\n\n```ts\npipe(\n  Stream.make(1, 5, 1),\n  Stream.transduce(\n    Sink.foldWeightedDecompose(\n      Chunk.empty<number>(),\n      4,\n      (n: number) => n,\n      (n: number) => Chunk.make(n - 1, 1),\n      (acc, el) => pipe(acc, Chunk.append(el))\n    )\n  ),\n  Stream.runCollect\n)\n```\n\nThe stream would emit the elements `Chunk(1), Chunk(4), Chunk(1, 1)`.\n\nBe vigilant with this function, it has to generate \"simpler\" values or the\nfold may never end. A value is considered indivisible if `decompose` yields\nthe empty chunk or a single-valued chunk. In these cases, there is no other\nchoice than to yield a value that will cross the threshold.\n\n`Sink.foldWeightedDecomposeEffect` allows the decompose function to return an\neffect value, and consequently it allows the sink to fail.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const foldWeightedDecompose: <S, In>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => number; readonly decompose: (input: In) => Chunk.Chunk<In>; readonly body: (s: S, input: In) => S; }) => Sink<S, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "foldWeightedDecomposeEffect",
    "description": "Creates a sink that effectfully folds elements of type `In` into a\nstructure of type `S`, until `max` worth of elements (determined by the\n`costFn`) have been folded.\n\nThe `decompose` function will be used for decomposing elements that cause\nan `S` aggregate to cross `max` into smaller elements. Be vigilant with\nthis function, it has to generate \"simpler\" values or the fold may never\nend. A value is considered indivisible if `decompose` yields the empty\nchunk or a single-valued chunk. In these cases, there is no other choice\nthan to yield a value that will cross the threshold.\n\nSee `Sink.foldWeightedDecompose` for an example.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const foldWeightedDecomposeEffect: <S, In, E, R, E2, R2, E3, R3>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>; readonly decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly body: (s: S, input: In) => Effect.Effect<S, E3, R3>; }) => Sink<S, In, In, E | E2 | E3, R | R2 | R3>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "foldWeightedEffect",
    "description": "Creates a sink that effectfully folds elements of type `In` into a\nstructure of type `S`, until `max` worth of elements (determined by the\n`costFn`) have been folded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const foldWeightedEffect: <S, In, E, R, E2, R2>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>; readonly body: (s: S, input: In) => Effect.Effect<S, E2, R2>; }) => Sink<S, In, In, E | E2, R | R2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "A sink that executes the provided effectful function for every element fed\nto it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const forEach: <In, X, E, R>(f: (input: In) => Effect.Effect<X, E, R>) => Sink<void, In, never, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "forEachChunk",
    "description": "A sink that executes the provided effectful function for every chunk fed to\nit.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const forEachChunk: <In, X, E, R>(f: (input: Chunk.Chunk<In>) => Effect.Effect<X, E, R>) => Sink<void, In, never, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "forEachChunkWhile",
    "description": "A sink that executes the provided effectful function for every chunk fed to\nit until `f` evaluates to `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const forEachChunkWhile: <In, E, R>(f: (input: Chunk.Chunk<In>) => Effect.Effect<boolean, E, R>) => Sink<void, In, In, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "forEachWhile",
    "description": "A sink that executes the provided effectful function for every element fed\nto it until `f` evaluates to `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const forEachWhile: <In, E, R>(f: (input: In) => Effect.Effect<boolean, E, R>) => Sink<void, In, In, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Runs this sink until it yields a result, then uses that result to create\nanother sink from the provided function which will continue to run until it\nyields a result.\n\nThis function essentially runs sinks in sequence.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMap: { <A, A1, In, In1 extends In, L1, E1, R1>(f: (a: A) => Sink<A1, In1, L1, E1, R1>): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A1, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1 extends In, L1, E1, R1>(self: Sink<A, In, L, E, R>, f: (a: A) => Sink<A1, In1, L1, E1, R1>): Sink<A1, In & In1, L | L1, E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "fromChannel",
    "description": "Creates a sink from a `Channel`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromChannel: <L, In, E, A, R>(channel: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>) => Sink<A, In, L, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "toChannel",
    "description": "Creates a `Channel` from a Sink.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const toChannel: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "fromEffect",
    "description": "Creates a single-value sink produced from an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Sink<A, unknown, never, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "fromPubSub",
    "description": "Create a sink which publishes each element to the specified `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromPubSub: <In>(pubsub: PubSub.PubSub<In>, options?: { readonly shutdown?: boolean | undefined; }) => Sink<void, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "fromPush",
    "description": "Creates a sink from a chunk processing function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromPush: <In, L0, R0, L, R>(push: Effect.Effect<(_: Option.Option<Chunk.Chunk<In>>) => Effect.Effect<void, readonly [Either.Either<R0, L0>, Chunk.Chunk<L>], R>, never, R>) => Sink<R0, In, L, L0, Exclude<R, Scope.Scope>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "fromQueue",
    "description": "Create a sink which enqueues each element into the specified queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromQueue: <In>(queue: Queue.Enqueue<In>, options?: { readonly shutdown?: boolean | undefined; }) => Sink<void, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "head",
    "description": "Creates a sink containing the first value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const head: <In>() => Sink<Option.Option<In>, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "ignoreLeftover",
    "description": "Drains the remaining elements from the stream after the sink finishes",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const ignoreLeftover: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, never, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "last",
    "description": "Creates a sink containing the last value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const last: <In>() => Sink<Option.Option<In>, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "leftover",
    "description": "Creates a sink that does not consume any input but provides the given chunk\nas its leftovers",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const leftover: <L>(chunk: Chunk.Chunk<L>) => Sink<void, unknown, L>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms this sink's result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <A, A2>(f: (a: A) => A2): <In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E, R>; <A, In, L, E, R, A2>(self: Sink<A, In, L, E, R>, f: (a: A) => A2): Sink<A2, In, L, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "mapEffect",
    "description": "Effectfully transforms this sink's result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<A2, E2, R2>): <In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E2 | E, R2 | R>; <A, In, L, E, R, A2, E2, R2>(self: Sink<A, In, L, E, R>, f: (a: A) => Effect.Effect<A2, E2, R2>): Sink<A2, In, L, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "mapError",
    "description": "Transforms the errors emitted by this sink using `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapError: { <E, E2>(f: (error: E) => E2): <A, In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E2, R>; <A, In, L, E, R, E2>(self: Sink<A, In, L, E, R>, f: (error: E) => E2): Sink<A, In, L, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "mapLeftover",
    "description": "Transforms the leftovers emitted by this sink using `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapLeftover: { <L, L2>(f: (leftover: L) => L2): <A, In, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L2, E, R>; <A, In, L, E, R, L2>(self: Sink<A, In, L, E, R>, f: (leftover: L) => L2): Sink<A, In, L2, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "mkString",
    "description": "Creates a sink which transforms it's inputs into a string.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const mkString: Sink<string, unknown, never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "never",
    "description": "Creates a sink which never terminates.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const never: Sink<never, unknown, never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "orElse",
    "description": "Switch to another sink in case of failure",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElse: { <A2, In2, L2, E2, R2>(that: LazyArg<Sink<A2, In2, L2, E2, R2>>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2 | A, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: LazyArg<Sink<A2, In2, L2, E2, R2>>): Sink<A | A2, In & In2, L | L2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "provideContext",
    "description": "Provides the sink with its required context, which eliminates its\ndependency on `R`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideContext: { <R>(context: Context.Context<R>): <A, In, L, E>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, never>; <A, In, L, E, R>(self: Sink<A, In, L, E, R>, context: Context.Context<R>): Sink<A, In, L, E, never>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "race",
    "description": "Runs both sinks in parallel on the input, , returning the result or the\nerror from the one that finishes first.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const race: { <R1, E1, In1, L1, A1>(that: Sink<A1, In1, L1, E1, R1>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A1 | A, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1, L1, E1, R1>(self: Sink<A, In, L, E, R>, that: Sink<A1, In1, L1, E1, R1>): Sink<A | A1, In & In1, L | L1, E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "raceBoth",
    "description": "Runs both sinks in parallel on the input, returning the result or the error\nfrom the one that finishes first.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const raceBoth: { <A1, In1, L1, E1, R1>(that: Sink<A1, In1, L1, E1, R1>, options?: { readonly capacity?: number | undefined; } | undefined): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<Either.Either<A1, A>, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1, L1, E1, R1>(self: Sink<A, In, L, E, R>, that: Sink<A1, In1, L1, E1, R1>, options?: { readonly capacity?: number | undefined; } | undefined): Sink<Either.Either<A1, A>, In & In1, L | L1, E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "raceWith",
    "description": "Runs both sinks in parallel on the input, using the specified merge\nfunction as soon as one result or the other has been computed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const raceWith: { <A2, In2, L2, E2, R2, A, E, A3, A4>(options: { readonly other: Sink<A2, In2, L2, E2, R2>; readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E2 | E, A3>; readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E2 | E, A4>; readonly capacity?: number | undefined; }): <In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A3 | A4, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2, L2, E2, R2, A3, A4>(self: Sink<A, In, L, E, R>, options: { readonly other: Sink<A2, In2, L2, E2, R2>; readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E | E2, A3>; readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E | E2, A4>; readonly capacity?: number | undefined; }): Sink<A3 | A4, In & In2, L | L2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "refineOrDie",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const refineOrDie: { <E, E2>(pf: (error: E) => Option.Option<E2>): <A, In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E2, R>; <A, In, L, E, R, E2>(self: Sink<A, In, L, E, R>, pf: (error: E) => Option.Option<E2>): Sink<A, In, L, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "refineOrDieWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const refineOrDieWith: { <E, E2>(pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): <A, In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E2, R>; <A, In, L, E, R, E2>(self: Sink<A, In, L, E, R>, pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): Sink<A, In, L, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": "A sink that returns whether an element satisfies the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const some: <In>(predicate: Predicate<In>) => Sink<boolean, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "splitWhere",
    "description": "Splits the sink on the specified predicate, returning a new sink that\nconsumes elements until an element after the first satisfies the specified\npredicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const splitWhere: { <In>(f: Predicate<In>): <A, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, In, E, R>; <A, In, L extends In, E, R>(self: Sink<A, In, L, E, R>, f: Predicate<In>): Sink<A, In, In, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": "A sink that immediately ends with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const succeed: <A>(a: A) => Sink<A, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "sum",
    "description": "A sink that sums incoming numeric values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sum: Sink<number, number, never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "summarized",
    "description": "Summarize a sink by running an effect when the sink starts and again when\nit completes.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const summarized: { <A2, E2, R2, A3>(summary: Effect.Effect<A2, E2, R2>, f: (start: A2, end: A2) => A3): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, A3], In, L, E2 | E, R2 | R>; <A, In, L, E, R, A2, E2, R2, A3>(self: Sink<A, In, L, E, R>, summary: Effect.Effect<A2, E2, R2>, f: (start: A2, end: A2) => A3): Sink<[A, A3], In, L, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "suspend",
    "description": "Returns a lazily constructed sink that may require effects for its\ncreation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const suspend: <A, In, L, E, R>(evaluate: LazyArg<Sink<A, In, L, E, R>>) => Sink<A, In, L, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "sync",
    "description": "A sink that immediately ends with the specified lazy value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sync: <A>(evaluate: LazyArg<A>) => Sink<A, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "take",
    "description": "A sink that takes the specified number of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const take: <In>(n: number) => Sink<Chunk.Chunk<In>, In, In>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "timed",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const timed: Sink<Duration.Duration, unknown, never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "unwrap",
    "description": "Creates a sink produced from an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unwrap: <A, In, L, E2, R2, E, R>(effect: Effect.Effect<Sink<A, In, L, E2, R2>, E, R>) => Sink<A, In, L, E2 | E, R2 | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "unwrapScoped",
    "description": "Creates a sink produced from a scoped effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unwrapScoped: <A, In, L, E, R>(effect: Effect.Effect<Sink<A, In, L, E, R>, E, R>) => Sink<A, In, L, E, Exclude<R, Scope.Scope>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "unwrapScopedWith",
    "description": "Constructs a `Sink` from a function which receives a `Scope` and returns\nan effect that will result in a `Sink` if successful.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "export declare const unwrapScopedWith: <A, In, L, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Sink<A, In, L, E, R>, E, R>) => Sink<A, In, L, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "withDuration",
    "description": "Returns the sink that executes this one and times its execution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const withDuration: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, Duration.Duration], In, L, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Feeds inputs to this sink until it yields a result, then switches over to\nthe provided sink until it yields a result, finally combining the two\nresults into a tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zip: { <A2, In, In2 extends In, L2, E2, R2>(that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, A2], In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<[A, A2], In & In2, L | L2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Like `Sink.zip` but keeps only the result from this sink.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipLeft: { <A2, In, In2 extends In, L2, E2, R2>(that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<A, In & In2, L | L2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Like `Sink.zip` but keeps only the result from `that` sink.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipRight: { <A2, In, In2 extends In, L2, E2, R2>(that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<A2, In & In2, L | L2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Feeds inputs to this sink until it yields a result, then switches over to\nthe provided sink until it yields a result, finally combining the two\nresults with `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWith: { <A2, In, In2 extends In, L2, E2, R2, A, A3>(that: Sink<A2, In2, L2, E2, R2>, f: (a: A, a2: A2) => A3, options?: { readonly concurrent?: boolean | undefined; } | undefined): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A3, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2, A3>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, f: (a: A, a2: A2) => A3, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<A3, In & In2, L | L2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "Sink",
    "description": "A `Sink<A, In, L, E, R>` is used to consume elements produced by a `Stream`.\nYou can think of a sink as a function that will consume a variable amount of\n`In` elements (could be 0, 1, or many), might fail with an error of type `E`,\nand will eventually yield a value of type `A` together with a remainder of\ntype `L` (i.e. any leftovers).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Sink<out A, in In = unknown, out L = never, out E = never, out R = never>\n  extends Sink.Variance<A, In, L, E, R>, Pipeable\n{}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "SinkUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SinkUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Sink?: () => A[Unify.typeSymbol] extends\n    | Sink<\n      infer A,\n      infer In,\n      infer L,\n      infer E,\n      infer R\n    >\n    | infer _ ? Sink<A, In, L, E, R>\n    : never\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "SinkUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SinkUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Sink?: true\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Sink",
      "path": [
        "src",
        "Sink.ts"
      ]
    },
    "project": "effect",
    "name": "SinkTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type SinkTypeId = typeof SinkTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `SortedMap` from an iterable collection of key/value pairs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterable: { <B>(ord: Order<B>): <K extends B, V>(iterable: Iterable<readonly [K, V]>) => SortedMap<K, V>; <K extends B, V, B>(iterable: Iterable<readonly [K, V]>, ord: Order<B>): SortedMap<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const get: { <K>(key: K): <V>(self: SortedMap<K, V>) => Option.Option<V>; <K, V>(self: SortedMap<K, V>, key: K): Option.Option<V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "has",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const has: { <K>(key: K): <V>(self: SortedMap<K, V>) => boolean; <K, V>(self: SortedMap<K, V>, key: K): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <A, K, B>(f: (a: A, k: K) => B): (self: SortedMap<K, A>) => SortedMap<K, B>; <K, A, B>(self: SortedMap<K, A>, f: (a: A, k: K) => B): SortedMap<K, B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduce: { <B, A, K>(zero: B, f: (acc: B, value: A, key: K) => B): (self: SortedMap<K, A>) => B; <K, A, B>(self: SortedMap<K, A>, zero: B, f: (acc: B, value: A, key: K) => B): B; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "remove",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const remove: { <K>(key: K): <V>(self: SortedMap<K, V>) => SortedMap<K, V>; <K, V>(self: SortedMap<K, V>, key: K): SortedMap<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const set: { <K, V>(key: K, value: V): (self: SortedMap<K, V>) => SortedMap<K, V>; <K, V>(self: SortedMap<K, V>, key: K, value: V): SortedMap<K, V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "partition",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.1.0",
    "category": "filtering",
    "signature": "export declare const partition: { <K, V>(predicate: (a: Types.NoInfer<K>) => boolean): (self: SortedMap<K, V>) => [excluded: SortedMap<K, V>, satisfying: SortedMap<K, V>]; <K, V>(self: SortedMap<K, V>, predicate: (a: K) => boolean): [excluded: SortedMap<K, V>, satisfying: SortedMap<K, V>]; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "isSortedMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "isNonEmpty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "predicates",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "getOrder",
    "description": "Gets the `Order<K>` that the `SortedMap<K, V>` is using.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "headOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "keys",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "values",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "entries",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "lastOption",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.1.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "SortedMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SortedMap<in out K, out V> extends Iterable<[K, V]>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _K: Types.Invariant<K>\n    readonly _V: Types.Covariant<V>\n  }\n  /** @internal */\n  readonly tree: RBT.RedBlackTree<K, V>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SortedMap",
      "path": [
        "src",
        "SortedMap.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `SortedSet` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterable: { <B>(ord: Order<B>): <A extends B>(iterable: Iterable<A>) => SortedSet<A>; <A extends B, B>(iterable: Iterable<A>, ord: Order<B>): SortedSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "add",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const add: { <A>(value: A): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, value: A): SortedSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "difference",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const difference: { <A, B extends A>(that: Iterable<B>): (self: SortedSet<A>) => SortedSet<A>; <A, B extends A>(self: SortedSet<A>, that: Iterable<B>): SortedSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "every",
    "description": "Check if a predicate holds true for every `SortedSet` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const every: { <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filter: { <A, B extends A>(predicate: Predicate<B>): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, predicate: Predicate<A>): SortedSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMap: { <B, A>(O: Order<B>, f: (a: A) => Iterable<B>): (self: SortedSet<A>) => SortedSet<B>; <A, B>(self: SortedSet<A>, O: Order<B>, f: (a: A) => Iterable<B>): SortedSet<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const forEach: { <A>(f: (a: A) => void): (self: SortedSet<A>) => void; <A>(self: SortedSet<A>, f: (a: A) => void): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "has",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const has: { <A>(value: A): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, value: A): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "intersection",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const intersection: { <A>(that: Iterable<A>): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, that: Iterable<A>): SortedSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "isSubset",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const isSubset: { <A>(that: SortedSet<A>): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, that: SortedSet<A>): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <B, A>(O: Order<B>, f: (a: A) => B): (self: SortedSet<A>) => SortedSet<B>; <B, A>(self: SortedSet<A>, O: Order<B>, f: (a: A) => B): SortedSet<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "partition",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const partition: { <A>(predicate: (a: NoInfer<A>) => boolean): (self: SortedSet<A>) => [excluded: SortedSet<A>, satisfying: SortedSet<A>]; <A>(self: SortedSet<A>, predicate: (a: A) => boolean): [excluded: SortedSet<A>, satisfying: SortedSet<A>]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "remove",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const remove: { <A>(value: A): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, value: A): SortedSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": "Check if a predicate holds true for some `SortedSet` element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const some: { <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "toggle",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const toggle: { <A>(value: A): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, value: A): SortedSet<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "union",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const union: { <A>(that: Iterable<A>): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, that: Iterable<A>): SortedSet<A>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "isSortedSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "values",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "equivalence",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "SortedSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SortedSet<in out A> extends Iterable<A>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _A: Invariant<A>\n  }\n  /** @internal */\n  readonly keyTree: RBT.RedBlackTree<A, boolean>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SortedSet",
      "path": [
        "src",
        "SortedSet.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "STMTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const STMTypeId: typeof STMTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "isSTM",
    "description": "Returns `true` if the provided value is an `STM`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isSTM: (u: unknown) => u is STM<unknown, unknown, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "acquireUseRelease",
    "description": "Treats the specified `acquire` transaction as the acquisition of a\nresource. The `acquire` transaction will be executed interruptibly. If it\nis a success and is committed the specified `release` workflow will be\nexecuted uninterruptibly as soon as the `use` workflow completes execution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const acquireUseRelease: { <A, A2, E2, R2, A3, E3, R3>(use: (resource: A) => STM<A2, E2, R2>, release: (resource: A) => STM<A3, E3, R3>): <E, R>(acquire: STM<A, E, R>) => Effect.Effect<A2, E2 | E3 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(acquire: STM<A, E, R>, use: (resource: A) => STM<A2, E2, R2>, release: (resource: A) => STM<A3, E3, R3>): Effect.Effect<A2, E | E2 | E3, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "all",
    "description": "Runs all the provided transactional effects in sequence respecting the\nstructure provided in input.\n\nSupports multiple arguments, a single argument tuple / array or record /\nstruct.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const all: All.Signature"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "as",
    "description": "Maps the success value of this effect to the specified constant value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const as: { <A2>(value: A2): <A, E, R>(self: STM<A, E, R>) => STM<A2, E, R>; <A, E, R, A2>(self: STM<A, E, R>, value: A2): STM<A2, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "asSome",
    "description": "Maps the success value of this effect to an optional value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const asSome: <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "asSomeError",
    "description": "Maps the error value of this effect to an optional value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const asSomeError: <A, E, R>(self: STM<A, E, R>) => STM<A, Option.Option<E>, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "asVoid",
    "description": "This function maps the success value of an `STM` to `void`. If the original\n`STM` succeeds, the returned `STM` will also succeed. If the original `STM`\nfails, the returned `STM` will fail with the same error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const asVoid: <A, E, R>(self: STM<A, E, R>) => STM<void, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "attempt",
    "description": "Creates an `STM` value from a partial (but pure) function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const attempt: <A>(evaluate: LazyArg<A>) => STM<A, unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "catchAll",
    "description": "Recovers from all errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const catchAll: { <E, B, E1, R1>(f: (e: E) => STM<B, E1, R1>): <A, R>(self: STM<A, E, R>) => STM<B | A, E1, R1 | R>; <A, E, R, B, E1, R1>(self: STM<A, E, R>, f: (e: E) => STM<B, E1, R1>): STM<A | B, E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "catchSome",
    "description": "Recovers from some or all of the error cases.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const catchSome: { <E, A2, E2, R2>(pf: (error: E) => Option.Option<STM<A2, E2, R2>>): <A, R>(self: STM<A, E, R>) => STM<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<STM<A2, E2, R2>>): STM<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "catchTag",
    "description": "Recovers from the specified tagged error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const catchTag: { <K extends E[\"_tag\"] & string, E extends { _tag: string; }, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => STM<A1, E1, R1>): <A, R>(self: STM<A, E, R>) => STM<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E extends { _tag: string; }, R, K extends E[\"_tag\"] & string, A1, E1, R1>(self: STM<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => STM<A1, E1, R1>): STM<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "catchTags",
    "description": "Recovers from multiple tagged errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const catchTags: { <E extends { _tag: string; }, Cases extends { [K in E[\"_tag\"]]+?: ((error: Extract<E, { _tag: K; }>) => STM<any, any, any>); }>(cases: Cases): <A, R>(self: STM<A, E, R>) => STM<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, any, infer R> ? R : never; }[keyof Cases]>; <R, E extends { _tag: string; }, A, Cases extends { [K in E[\"_tag\"]]+?: ((error: Extract<E, { _tag: K; }>) => STM<any, any, any>); }>(self: STM<A, E, R>, cases: Cases): STM<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, any, infer R> ? R : never; }[keyof Cases]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "check",
    "description": "Checks the condition, and if it's true, returns unit, otherwise, retries.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const check: (predicate: LazyArg<boolean>) => STM<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "collect",
    "description": "Simultaneously filters and maps the value produced by this effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const collect: { <A, A2>(pf: (a: A) => Option.Option<A2>): <E, R>(self: STM<A, E, R>) => STM<A2, E, R>; <A, E, R, A2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<A2>): STM<A2, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "collectSTM",
    "description": "Simultaneously filters and maps the value produced by this effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const collectSTM: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<STM<A2, E2, R2>>): <E, R>(self: STM<A, E, R>) => STM<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<STM<A2, E2, R2>>): STM<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "commit",
    "description": "Commits this transaction atomically.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const commit: <A, E, R>(self: STM<A, E, R>) => Effect.Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "commitEither",
    "description": "Commits this transaction atomically, regardless of whether the transaction\nis a success or a failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const commitEither: <A, E, R>(self: STM<A, E, R>) => Effect.Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "cond",
    "description": "Similar to Either.cond, evaluate the predicate, return the given A as\nsuccess if predicate returns true, and the given E as error otherwise",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const cond: <A, E>(predicate: LazyArg<boolean>, error: LazyArg<E>, result: LazyArg<A>) => STM<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "context",
    "description": "Retrieves the environment inside an stm.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const context: <R>() => STM<Context.Context<R>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "contextWith",
    "description": "Accesses the environment of the transaction to perform a transaction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const contextWith: <R0, R>(f: (environment: Context.Context<R0>) => R) => STM<R, never, R0>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "contextWithSTM",
    "description": "Accesses the environment of the transaction to perform a transaction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const contextWithSTM: <R0, A, E, R>(f: (environment: Context.Context<R0>) => STM<A, E, R>) => STM<A, E, R0 | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputContext",
    "description": "Transforms the environment being provided to this effect with the specified\nfunction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const mapInputContext: { <R0, R>(f: (context: Context.Context<R0>) => Context.Context<R>): <A, E>(self: STM<A, E, R>) => STM<A, E, R0>; <A, E, R0, R>(self: STM<A, E, R>, f: (context: Context.Context<R0>) => Context.Context<R>): STM<A, E, R0>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "die",
    "description": "Fails the transactional effect with the specified defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const die: (defect: unknown) => STM<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "dieMessage",
    "description": "Kills the fiber running the effect with a `Cause.RuntimeException` that\ncontains the specified message.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dieMessage: (message: string) => STM<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "dieSync",
    "description": "Fails the transactional effect with the specified lazily evaluated defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dieSync: (evaluate: LazyArg<unknown>) => STM<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "either",
    "description": "Converts the failure channel into an `Either`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const either: <A, E, R>(self: STM<A, E, R>) => STM<Either.Either<A, E>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "ensuring",
    "description": "Executes the specified finalization transaction whether or not this effect\nsucceeds. Note that as with all STM transactions, if the full transaction\nfails, everything will be rolled back.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "finalization",
    "signature": "export declare const ensuring: { <R1, B>(finalizer: STM<B, never, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E, R1 | R>; <A, E, R, R1, B>(self: STM<A, E, R>, finalizer: STM<B, never, R1>): STM<A, E, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "eventually",
    "description": "Returns an effect that ignores errors and runs repeatedly until it\neventually succeeds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const eventually: <A, E, R>(self: STM<A, E, R>) => STM<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "every",
    "description": "Determines whether all elements of the `Iterable<A>` satisfy the effectual\npredicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const every: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<boolean, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<boolean, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "exists",
    "description": "Determines whether any element of the `Iterable[A]` satisfies the effectual\npredicate `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const exists: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<boolean, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<boolean, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": "Fails the transactional effect with the specified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fail: <E>(error: E) => STM<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "failSync",
    "description": "Fails the transactional effect with the specified lazily evaluated error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failSync: <E>(evaluate: LazyArg<E>) => STM<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "fiberId",
    "description": "Returns the fiber id of the fiber committing the transaction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fiberId: STM<FiberId.FiberId, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters the collection using the specified effectual predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const filter: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<Array<A>, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<Array<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "filterNot",
    "description": "Filters the collection using the specified effectual predicate, removing\nall elements that satisfy the predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const filterNot: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<Array<A>, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<Array<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "filterOrDie",
    "description": "Dies with specified defect if the predicate fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterOrDie: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, defect: LazyArg<unknown>): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, defect: LazyArg<unknown>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>, defect: LazyArg<unknown>): STM<B, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>, defect: LazyArg<unknown>): STM<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "filterOrDieMessage",
    "description": "Dies with a `Cause.RuntimeException` having the specified  message if the\npredicate fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterOrDieMessage: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>, message: string): STM<B, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>, message: string): STM<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "filterOrElse",
    "description": "Supplies `orElse` if the predicate fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterOrElse: { <A, B extends A, C, E2, R2>(refinement: Refinement<NoInfer<A>, B>, orElse: (a: NoInfer<A>) => STM<C, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<B | C, E2 | E, R2 | R>; <A, B, E2, R2>(predicate: Predicate<NoInfer<A>>, orElse: (a: NoInfer<A>) => STM<B, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<A | B, E2 | E, R2 | R>; <A, E, R, B extends A, C, E2, R2>(self: STM<A, E, R>, refinement: Refinement<A, B>, orElse: (a: A) => STM<C, E2, R2>): STM<B | C, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: STM<A, E, R>, predicate: Predicate<A>, orElse: (a: A) => STM<B, E2, R2>): STM<A | B, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "filterOrFail",
    "description": "Fails with the specified error if the predicate fails.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterOrFail: { <A, B extends A, E2>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: STM<A, E, R>) => STM<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R>; <A, E, R, B extends A, E2>(self: STM<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): STM<B, E | E2, R>; <A, E, R, E2>(self: STM<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): STM<A, E | E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Feeds the value produced by this effect to the specified function, and then\nruns the returned effect as well to produce its results.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMap: { <A, A2, E1, R1>(f: (a: A) => STM<A2, E1, R1>): <E, R>(self: STM<A, E, R>) => STM<A2, E1 | E, R1 | R>; <A, E, R, A2, E1, R1>(self: STM<A, E, R>, f: (a: A) => STM<A2, E1, R1>): STM<A2, E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens out a nested `STM` effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatten: <A, E2, R2, E, R>(self: STM<STM<A, E2, R2>, E, R>) => STM<A, E2 | E, R2 | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "flip",
    "description": "Flips the success and failure channels of this transactional effect. This\nallows you to use all methods on the error channel, possibly before\nflipping back.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const flip: <A, E, R>(self: STM<A, E, R>) => STM<E, A, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "flipWith",
    "description": "Swaps the error/value parameters, applies the function `f` and flips the\nparameters back",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const flipWith: { <E, A, R, E2, A2, R2>(f: (stm: STM<E, A, R>) => STM<E2, A2, R2>): (self: STM<A, E, R>) => STM<A | A2, E | E2, R | R2>; <A, E, R, E2, A2, R2>(self: STM<A, E, R>, f: (stm: STM<E, A, R>) => STM<E2, A2, R2>): STM<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Folds over the `STM` effect, handling both failure and success, but not\nretry.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const match: { <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: STM<A, E, R>) => STM<A2 | A3, never, R>; <A, E, R, A2, A3>(self: STM<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): STM<A2 | A3, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "matchSTM",
    "description": "Effectfully folds over the `STM` effect, handling both failure and success.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const matchSTM: { <E, A1, E1, R1, A, A2, E2, R2>(options: { readonly onFailure: (e: E) => STM<A1, E1, R1>; readonly onSuccess: (a: A) => STM<A2, E2, R2>; }): <R>(self: STM<A, E, R>) => STM<A1 | A2, E1 | E2, R1 | R2 | R>; <A, E, R, A1, E1, R1, A2, E2, R2>(self: STM<A, E, R>, options: { readonly onFailure: (e: E) => STM<A1, E1, R1>; readonly onSuccess: (a: A) => STM<A2, E2, R2>; }): STM<A1 | A2, E1 | E2, R | R1 | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "Applies the function `f` to each element of the `Iterable<A>` and returns\na transactional effect that produces a new `Chunk<A2>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const forEach: { <A, A2, E, R>(f: (a: A) => STM<A2, E, R>, options?: { readonly discard?: false | undefined; } | undefined): (elements: Iterable<A>) => STM<Array<A2>, E, R>; <A, A2, E, R>(f: (a: A) => STM<A2, E, R>, options: { readonly discard: true; }): (elements: Iterable<A>) => STM<void, E, R>; <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>, options?: { readonly discard?: false | undefined; } | undefined): STM<Array<A2>, E, R>; <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>, options: { readonly discard: true; }): STM<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "fromEither",
    "description": "Lifts an `Either` into a `STM`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromEither: <A, E>(either: Either.Either<A, E>) => STM<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "fromOption",
    "description": "Lifts an `Option` into a `STM`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromOption: <A>(option: Option.Option<A>) => STM<A, Option.Option<never>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "gen",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const gen: <Self, Eff extends YieldWrap<STM<any, any, any>>, AEff>(...args: [self: Self, body: (this: Self, resume: Adapter) => Generator<Eff, AEff, never>] | [body: (resume: Adapter) => Generator<Eff, AEff, never>]) => STM<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<STM<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<STM<infer _A, infer _E, infer R>>] ? R : never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "head",
    "description": "Returns a successful effect with the head of the list if the list is\nnon-empty or fails with the error `None` if the list is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const head: <A, E, R>(self: STM<Iterable<A>, E, R>) => STM<A, Option.Option<E>, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "ignore",
    "description": "Returns a new effect that ignores the success or failure of this effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const ignore: <A, E, R>(self: STM<A, E, R>) => STM<void, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "interrupt",
    "description": "Interrupts the fiber running the effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const interrupt: STM<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "interruptAs",
    "description": "Interrupts the fiber running the effect with the specified `FiberId`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const interruptAs: (fiberId: FiberId.FiberId) => STM<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "isFailure",
    "description": "Returns whether this transactional effect is a failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isFailure: <A, E, R>(self: STM<A, E, R>) => STM<boolean, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "isSuccess",
    "description": "Returns whether this transactional effect is a success.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isSuccess: <A, E, R>(self: STM<A, E, R>) => STM<boolean, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "iterate",
    "description": "Iterates with the specified transactional function. The moral equivalent\nof:\n\n```ts\nconst s = initial\n\nwhile (cont(s)) {\n  s = body(s)\n}\n\nreturn s\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const iterate: <Z, E, R>(initial: Z, options: { readonly while: Predicate<Z>; readonly body: (z: Z) => STM<Z, E, R>; }) => STM<Z, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "loop",
    "description": "Loops with the specified transactional function, collecting the results\ninto a list. The moral equivalent of:\n\n```ts\nconst as = []\nlet s  = initial\n\nwhile (cont(s)) {\n  as.push(body(s))\n  s  = inc(s)\n}\n\nreturn as\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const loop: { <Z, A, E, R>(initial: Z, options: { readonly while: (z: Z) => boolean; readonly step: (z: Z) => Z; readonly body: (z: Z) => STM<A, E, R>; readonly discard?: false | undefined; }): STM<Array<A>, E, R>; <Z, A, E, R>(initial: Z, options: { readonly while: (z: Z) => boolean; readonly step: (z: Z) => Z; readonly body: (z: Z) => STM<A, E, R>; readonly discard: true; }): STM<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Maps the value produced by the effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A, E, R, B>(self: STM<A, E, R>, f: (a: A) => B): STM<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "mapAttempt",
    "description": "Maps the value produced by the effect with the specified function that may\nthrow exceptions but is otherwise pure, translating any thrown exceptions\ninto typed failed effects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapAttempt: { <A, B>(f: (a: A) => B): <E, R>(self: STM<A, E, R>) => STM<B, unknown, R>; <A, E, R, B>(self: STM<A, E, R>, f: (a: A) => B): STM<B, unknown, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "mapBoth",
    "description": "Returns an `STM` effect whose failure and success channels have been mapped\nby the specified pair of functions, `f` and `g`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (error: E) => E2; readonly onSuccess: (value: A) => A2; }): <R>(self: STM<A, E, R>) => STM<A2, E2, R>; <A, E, R, E2, A2>(self: STM<A, E, R>, options: { readonly onFailure: (error: E) => E2; readonly onSuccess: (value: A) => A2; }): STM<A2, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "mapError",
    "description": "Maps from one error type to another.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, f: (error: E) => E2): STM<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "merge",
    "description": "Returns a new effect where the error channel has been merged into the\nsuccess channel to their common combined type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const merge: <A, E, R>(self: STM<A, E, R>) => STM<E | A, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "mergeAll",
    "description": "Merges an `Iterable<STM>` to a single `STM`, working sequentially.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const mergeAll: { <A2, A>(zero: A2, f: (a2: A2, a: A) => A2): <E, R>(iterable: Iterable<STM<A, E, R>>) => STM<A2, E, R>; <A, E, R, A2>(iterable: Iterable<STM<A, E, R>>, zero: A2, f: (a2: A2, a: A) => A2): STM<A2, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "negate",
    "description": "Returns a new effect where boolean value of this effect is negated.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const negate: <E, R>(self: STM<boolean, E, R>) => STM<boolean, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "none",
    "description": "Requires the option produced by this value to be `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const none: <A, E, R>(self: STM<Option.Option<A>, E, R>) => STM<void, Option.Option<E>, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "option",
    "description": "Converts the failure channel into an `Option`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const option: <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "orDie",
    "description": "Translates `STM` effect failure into death of the fiber, making all\nfailures unchecked and not a part of the type of the effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orDie: <A, E, R>(self: STM<A, E, R>) => STM<A, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "orDieWith",
    "description": "Keeps none of the errors, and terminates the fiber running the `STM` effect\nwith them, using the specified function to convert the `E` into a defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orDieWith: { <E>(f: (error: E) => unknown): <A, R>(self: STM<A, E, R>) => STM<A, never, R>; <A, E, R>(self: STM<A, E, R>, f: (error: E) => unknown): STM<A, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "orElse",
    "description": "Tries this effect first, and if it fails or retries, tries the other\neffect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElse: { <A2, E2, R2>(that: LazyArg<STM<A2, E2, R2>>): <A, E, R>(self: STM<A, E, R>) => STM<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, that: LazyArg<STM<A2, E2, R2>>): STM<A | A2, E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "orElseEither",
    "description": "Returns a transactional effect that will produce the value of this effect\nin left side, unless it fails or retries, in which case, it will produce\nthe value of the specified effect in right side.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElseEither: { <A2, E2, R2>(that: LazyArg<STM<A2, E2, R2>>): <A, E, R>(self: STM<A, E, R>) => STM<Either.Either<A2, A>, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, that: LazyArg<STM<A2, E2, R2>>): STM<Either.Either<A2, A>, E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "orElseFail",
    "description": "Tries this effect first, and if it fails or retries, fails with the\nspecified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElseFail: { <E2>(error: LazyArg<E2>): <A, E, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, error: LazyArg<E2>): STM<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "orElseOptional",
    "description": "Returns an effect that will produce the value of this effect, unless it\nfails with the `None` value, in which case it will produce the value of the\nspecified effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElseOptional: { <A2, E2, R2>(that: LazyArg<STM<A2, Option.Option<E2>, R2>>): <A, E, R>(self: STM<A, Option.Option<E>, R>) => STM<A2 | A, Option.Option<E2 | E>, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, Option.Option<E>, R>, that: LazyArg<STM<A2, Option.Option<E2>, R2>>): STM<A | A2, Option.Option<E | E2>, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "orElseSucceed",
    "description": "Tries this effect first, and if it fails or retries, succeeds with the\nspecified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElseSucceed: { <A2>(value: LazyArg<A2>): <A, E, R>(self: STM<A, E, R>) => STM<A2 | A, never, R>; <A, E, R, A2>(self: STM<A, E, R>, value: LazyArg<A2>): STM<A | A2, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "orTry",
    "description": "Tries this effect first, and if it enters retry, then it tries the other\neffect. This is an equivalent of Haskell's orElse.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orTry: { <A1, E1, R1>(that: LazyArg<STM<A1, E1, R1>>): <A, E, R>(self: STM<A, E, R>) => STM<A1 | A, E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: LazyArg<STM<A1, E1, R1>>): STM<A | A1, E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "partition",
    "description": "Feeds elements of type `A` to a function `f` that returns an effect.\nCollects all successes and failures in a tupled fashion.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const partition: { <A, A2, E, R>(f: (a: A) => STM<A2, E, R>): (elements: Iterable<A>) => STM<[excluded: Array<E>, satisfying: Array<A2>], never, R>; <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>): STM<[excluded: Array<E>, satisfying: Array<A2>], never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "provideContext",
    "description": "Provides the transaction its required environment, which eliminates its\ndependency on `R`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideContext: { <R>(env: Context.Context<R>): <A, E>(self: STM<A, E, R>) => STM<A, E>; <A, E, R>(self: STM<A, E, R>, env: Context.Context<R>): STM<A, E>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "provideSomeContext",
    "description": "Splits the context into two parts, providing one part using the\nspecified layer and leaving the remainder `R0`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideSomeContext: { <R>(context: Context.Context<R>): <R1, E, A>(self: STM<A, E, R1>) => STM<A, E, Exclude<R1, R>>; <R, R1, E, A>(self: STM<A, E, R1>, context: Context.Context<R>): STM<A, E, Exclude<R1, R>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "provideService",
    "description": "Provides the effect with the single service it requires. If the transactional\neffect requires more than one service use `provideEnvironment` instead.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideService: { <I, S>(tag: Context.Tag<I, S>, resource: NoInfer<S>): <A, E, R>(self: STM<A, E, R>) => STM<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: STM<A, E, R>, tag: Context.Tag<I, S>, resource: NoInfer<S>): STM<A, E, Exclude<R, I>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "provideServiceSTM",
    "description": "Provides the effect with the single service it requires. If the transactional\neffect requires more than one service use `provideEnvironment` instead.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideServiceSTM: { <I, S, E1, R1>(tag: Context.Tag<I, S>, stm: STM<NoInfer<S>, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E1 | E, R1 | Exclude<R, I>>; <A, E, R, I, S, E1, R1>(self: STM<A, E, R>, tag: Context.Tag<I, S>, stm: STM<NoInfer<S>, E1, R1>): STM<A, E1 | E, R1 | Exclude<R, I>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": "Folds an `Iterable<A>` using an effectual function f, working sequentially\nfrom left to right.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const reduce: { <S, A, E, R>(zero: S, f: (s: S, a: A) => STM<S, E, R>): (iterable: Iterable<A>) => STM<S, E, R>; <S, A, E, R>(iterable: Iterable<A>, zero: S, f: (s: S, a: A) => STM<S, E, R>): STM<S, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "reduceAll",
    "description": "Reduces an `Iterable<STM>` to a single `STM`, working sequentially.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const reduceAll: { <A, E2, R2>(initial: STM<A, E2, R2>, f: (x: A, y: A) => A): <E, R>(iterable: Iterable<STM<A, E, R>>) => STM<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(iterable: Iterable<STM<A, E, R>>, initial: STM<A, E2, R2>, f: (x: A, y: A) => A): STM<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "reduceRight",
    "description": "Folds an `Iterable<A>` using an effectual function f, working sequentially\nfrom right to left.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const reduceRight: { <S, A, R, E>(zero: S, f: (s: S, a: A) => STM<S, E, R>): (iterable: Iterable<A>) => STM<S, E, R>; <S, A, R, E>(iterable: Iterable<A>, zero: S, f: (s: S, a: A) => STM<S, E, R>): STM<S, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "refineOrDie",
    "description": "Keeps some of the errors, and terminates the fiber with the rest.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const refineOrDie: { <E, E2>(pf: (error: E) => Option.Option<E2>): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<E2>): STM<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "refineOrDieWith",
    "description": "Keeps some of the errors, and terminates the fiber with the rest, using the\nspecified function to convert the `E` into a `Throwable`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const refineOrDieWith: { <E, E2>(pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): STM<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "reject",
    "description": "Fail with the returned value if the `PartialFunction` matches, otherwise\ncontinue with our held value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const reject: { <A, E2>(pf: (a: A) => Option.Option<E2>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R>; <A, E, R, E2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<E2>): STM<A, E | E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "rejectSTM",
    "description": "Continue with the returned computation if the specified partial function\nmatches, translating the successful match into a failure, otherwise continue\nwith our held value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const rejectSTM: { <A, E2, R2>(pf: (a: A) => Option.Option<STM<E2, E2, R2>>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<STM<E2, E2, R2>>): STM<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "repeatUntil",
    "description": "Repeats this `STM` effect until its result satisfies the specified\npredicate.\n\n**WARNING**: `repeatUntil` uses a busy loop to repeat the effect and will\nconsume a thread until it completes (it cannot yield). This is because STM\ndescribes a single atomic transaction which must either complete, retry or\nfail a transaction before yielding back to the Effect runtime.\n  - Use `retryUntil` instead if you don't need to maintain transaction\n    state for repeats.\n  - Ensure repeating the STM effect will eventually satisfy the predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const repeatUntil: { <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "repeatWhile",
    "description": "Repeats this `STM` effect while its result satisfies the specified\npredicate.\n\n**WARNING**: `repeatWhile` uses a busy loop to repeat the effect and will\nconsume a thread until it completes (it cannot yield). This is because STM\ndescribes a single atomic transaction which must either complete, retry or\nfail a transaction before yielding back to the Effect runtime.\n  - Use `retryWhile` instead if you don't need to maintain transaction\n    state for repeats.\n  - Ensure repeating the STM effect will eventually not satisfy the\n    predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const repeatWhile: { <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "replicate",
    "description": "Replicates the given effect n times. If 0 or negative numbers are given, an\nempty `Chunk` will be returned.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const replicate: { (n: number): <A, E, R>(self: STM<A, E, R>) => Array<STM<A, E, R>>; <A, E, R>(self: STM<A, E, R>, n: number): Array<STM<A, E, R>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "replicateSTM",
    "description": "Performs this transaction the specified number of times and collects the\nresults.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const replicateSTM: { (n: number): <A, E, R>(self: STM<A, E, R>) => STM<Array<A>, E, R>; <A, E, R>(self: STM<A, E, R>, n: number): STM<Array<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "replicateSTMDiscard",
    "description": "Performs this transaction the specified number of times, discarding the\nresults.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const replicateSTMDiscard: { (n: number): <A, E, R>(self: STM<A, E, R>) => STM<void, E, R>; <A, E, R>(self: STM<A, E, R>, n: number): STM<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "retry",
    "description": "Abort and retry the whole transaction when any of the underlying\ntransactional variables have changed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const retry: STM<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "retryUntil",
    "description": "Filters the value produced by this effect, retrying the transaction until\nthe predicate returns `true` for the value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const retryUntil: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>): STM<B, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "retryWhile",
    "description": "Filters the value produced by this effect, retrying the transaction while\nthe predicate returns `true` for the value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const retryWhile: { <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": "Converts an option on values into an option on errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const some: <A, E, R>(self: STM<Option.Option<A>, E, R>) => STM<A, Option.Option<E>, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": "Returns an `STM` effect that succeeds with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const succeed: <A>(value: A) => STM<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "succeedNone",
    "description": "Returns an effect with the empty value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const succeedNone: STM<Option.Option<never>, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "succeedSome",
    "description": "Returns an effect with the optional value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const succeedSome: <A>(value: A) => STM<Option.Option<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "summarized",
    "description": "Summarizes a `STM` effect by computing a provided value before and after\nexecution, and then combining the values to produce a summary, together\nwith the result of execution.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const summarized: { <A2, E2, R2, A3>(summary: STM<A2, E2, R2>, f: (before: A2, after: A2) => A3): <A, E, R>(self: STM<A, E, R>) => STM<[A3, A], E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: STM<A, E, R>, summary: STM<A2, E2, R2>, f: (before: A2, after: A2) => A3): STM<[A3, A], E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "suspend",
    "description": "Suspends creation of the specified transaction lazily.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const suspend: <A, E, R>(evaluate: LazyArg<STM<A, E, R>>) => STM<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "sync",
    "description": "Returns an `STM` effect that succeeds with the specified lazily evaluated\nvalue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sync: <A>(evaluate: () => A) => STM<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "tap",
    "description": "\"Peeks\" at the success of transactional effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const tap: { <A, X, E2, R2>(f: (a: A) => STM<X, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: STM<A, E, R>, f: (a: A) => STM<X, E2, R2>): STM<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "tapBoth",
    "description": "\"Peeks\" at both sides of an transactional effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const tapBoth: { <XE extends E, A2, E2, R2, XA extends A, A3, E3, R3, A, E>(options: { readonly onFailure: (error: XE) => STM<A2, E2, R2>; readonly onSuccess: (value: XA) => STM<A3, E3, R3>; }): <R>(self: STM<A, E, R>) => STM<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, XE extends E, A2, E2, R2, XA extends A, A3, E3, R3>(self: STM<A, E, R>, options: { readonly onFailure: (error: XE) => STM<A2, E2, R2>; readonly onSuccess: (value: XA) => STM<A3, E3, R3>; }): STM<A, E | E2 | E3, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "tapError",
    "description": "\"Peeks\" at the error of the transactional effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const tapError: { <E, X, E2, R2>(f: (error: NoInfer<E>) => STM<X, E2, R2>): <A, R>(self: STM<A, E, R>) => STM<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: STM<A, E, R>, f: (error: E) => STM<X, E2, R2>): STM<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "unless",
    "description": "The moral equivalent of `if (!p) exp`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const unless: { (predicate: LazyArg<boolean>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: LazyArg<boolean>): STM<Option.Option<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "unlessSTM",
    "description": "The moral equivalent of `if (!p) exp` when `p` has side-effects",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const unlessSTM: { <E2, R2>(predicate: STM<boolean, E2, R2>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: STM<A, E, R>, predicate: STM<boolean, E2, R2>): STM<Option.Option<A>, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "unsome",
    "description": "Converts an option on errors into an option on values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const unsome: <A, E, R>(self: STM<A, Option.Option<E>, R>) => STM<Option.Option<A>, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "validateAll",
    "description": "Feeds elements of type `A` to `f` and accumulates all errors in error\nchannel or successes in success channel.\n\nThis combinator is lossy meaning that if there are errors all successes\nwill be lost. To retain all information please use `STM.partition`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const validateAll: { <A, B, E, R>(f: (a: A) => STM<B, E, R>): (elements: Iterable<A>) => STM<Array<B>, [E, ...Array<E>], R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A) => STM<B, E, R>): STM<Array<B>, [E, ...Array<E>], R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "validateFirst",
    "description": "Feeds elements of type `A` to `f` until it succeeds. Returns first success\nor the accumulation of all errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const validateFirst: { <A, B, E, R>(f: (a: A) => STM<B, E, R>): (elements: Iterable<A>) => STM<B, Array<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A) => STM<B, E, R>): STM<B, Array<E>, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "when",
    "description": "The moral equivalent of `if (p) exp`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const when: { (predicate: LazyArg<boolean>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: LazyArg<boolean>): STM<Option.Option<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "whenSTM",
    "description": "The moral equivalent of `if (p) exp` when `p` has side-effects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const whenSTM: { <E2, R2>(predicate: STM<boolean, E2, R2>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: STM<A, E, R>, predicate: STM<boolean, E2, R2>): STM<Option.Option<A>, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Sequentially zips this value with the specified one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zip: { <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<[A, A1], E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<[A, A1], E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Sequentially zips this value with the specified one, discarding the second\nelement of the tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipLeft: { <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<A, E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Sequentially zips this value with the specified one, discarding the first\nelement of the tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipRight: { <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A1, E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<A1, E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Sequentially zips this value with the specified one, combining the values\nusing the specified combiner function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWith: { <A1, E1, R1, A, A2>(that: STM<A1, E1, R1>, f: (a: A, b: A1) => A2): <E, R>(self: STM<A, E, R>) => STM<A2, E1 | E, R1 | R>; <A, E, R, A1, E1, R1, A2>(self: STM<A, E, R>, that: STM<A1, E1, R1>, f: (a: A, b: A1) => A2): STM<A2, E | E1, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "Do",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "export declare const Do: STM<{}, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "bind",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "export declare const bind: { <N extends string, K, A, E2, R2>(tag: Exclude<N, keyof K>, f: (_: NoInfer<K>) => STM<A, E2, R2>): <E, R>(self: STM<K, E, R>) => STM<MergeRecord<K, { [k in N]: A; }>, E2 | E, R2 | R>; <K, E, R, N extends string, A, E2, R2>(self: STM<K, E, R>, tag: Exclude<N, keyof K>, f: (_: NoInfer<K>) => STM<A, E2, R2>): STM<MergeRecord<K, { [k in N]: A; }>, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "bindTo",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "export declare const bindTo: { <N extends string>(tag: N): <A, E, R>(self: STM<A, E, R>) => STM<Record<N, A>, E, R>; <A, E, R, N extends string>(self: STM<A, E, R>, tag: N): STM<Record<N, A>, E, R>; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "if",
    "description": "Runs `onTrue` if the result of `b` is `true` and `onFalse` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const if: { <A, E1, R1, A2, E2, R2>(options: { readonly onTrue: STM<A, E1, R1>; readonly onFalse: STM<A2, E2, R2>; }): <E = never, R = never>(self: boolean | STM<boolean, E, R>) => STM<A | A2, E1 | E2 | E, R1 | R2 | R>; <A, E1, R1, A2, E2, R2, E = never, R = never>(self: boolean, options: { readonly onTrue: STM<A, E1, R1>; readonly onFalse: STM<A2, E2, R2>; }): STM<A | A2, E1 | E2 | E, R1 | R2 | R>; <E, R, A, E1, R1, A2, E2, R2>(self: STM<boolean, E, R>, options: { readonly onTrue: STM<A, E1, R1>; readonly onFalse: STM<A2, E2, R2>; }): STM<A | A2, E | E1 | E2, R | R1 | R2>; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "try",
    "description": "Imports a synchronous side-effect into a pure value, translating any thrown\nexceptions into typed failed effects.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const try: { <A, E>(options: { readonly try: LazyArg<A>; readonly catch: (u: unknown) => E; }): STM<A, E>; <A>(try_: LazyArg<A>): STM<A, unknown>; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "void",
    "description": "Returns an `STM` effect that succeeds with `void`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const void: STM<void, never, never>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "let",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "export declare const let: { <N extends string, K, A>(tag: Exclude<N, keyof K>, f: (_: NoInfer<K>) => A): <E, R>(self: STM<K, E, R>) => STM<MergeRecord<K, { [k in N]: A; }>, E, R>; <K, E, R, N extends string, A>(self: STM<K, E, R>, tag: Exclude<N, keyof K>, f: (_: NoInfer<K>) => A): STM<MergeRecord<K, { [k in N]: A; }>, E, R>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "firstSuccessOf",
    "description": "This function takes an iterable of `STM` values and returns a new\n`STM` value that represents the first `STM` value in the iterable\nthat succeeds. If all of the `Effect` values in the iterable fail, then\nthe resulting `STM` value will fail as well.\n\nThis function is sequential, meaning that the `STM` values in the\niterable will be executed in sequence, and the first one that succeeds\nwill determine the outcome of the resulting `STM` value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "Adapter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Adapter {\n  <A, E, R>(self: STM<A, E, R>): STM<A, E, R>\n  <A, _R, _E, _A>(a: A, ab: (a: A) => STM<_A, _E, _R>): STM<_A, _E, _R>\n  <A, B, _R, _E, _A>(a: A, ab: (a: A) => B, bc: (b: B) => STM<_A, _E, _R>): STM<_A, _E, _R>\n  <A, B, C, _R, _E, _A>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => STM<_A, _E, _R>): STM<_A, _E, _R>\n  <A, B, C, D, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: F) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (g: H) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => T,\n    tu: (s: T) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "STM",
    "description": "`STM<A, E, R>` represents an effect that can be performed transactionally,\n resulting in a failure `E` or a value `A` that may require an environment\n `R` to execute.\n\nSoftware Transactional Memory is a technique which allows composition of\narbitrary atomic operations.  It is the software analog of transactions in\ndatabase systems.\n\nThe API is lifted directly from the Haskell package Control.Concurrent.STM\nalthough the implementation does not resemble the Haskell one at all.\n\nSee http://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM.html\n\nSTM in Haskell was introduced in:\n\nComposable memory transactions, by Tim Harris, Simon Marlow, Simon Peyton\nJones, and Maurice Herlihy, in ACM Conference on Principles and Practice of\nParallel Programming 2005.\n\nSee https://www.microsoft.com/en-us/research/publication/composable-memory-transactions/\n\nSee also:\n Lock Free Data Structures using STMs in Haskell, by Anthony Discolo, Tim\n Harris, Simon Marlow, Simon Peyton Jones, Satnam Singh) FLOPS 2006: Eighth\n International Symposium on Functional and Logic Programming, Fuji Susono,\n JAPAN, April 2006\n\n https://www.microsoft.com/en-us/research/publication/lock-free-data-structures-using-stms-in-haskell/\n\nThe implemtation is based on the ZIO STM module, while JS environments have\nno race conditions from multiple threads STM provides greater benefits for\nsynchronization of Fibers and transactional data-types can be quite useful.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface STM<out A, out E = never, out R = never>\n  extends Effect.Effect<A, E, R>, STM.Variance<A, E, R>, Pipeable\n{\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: STMUnify<this>\n  [Unify.ignoreSymbol]?: STMUnifyIgnore\n  [Symbol.iterator](): Effect.EffectGenerator<STM<A, E, R>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "STMTypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface STMTypeLambda extends TypeLambda {\n  readonly type: STM<this[\"Target\"], this[\"Out1\"], this[\"Out2\"]>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "STMUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface STMUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  STM?: () => A[Unify.typeSymbol] extends STM<infer A0, infer E0, infer R0> | infer _ ? STM<A0, E0, R0> : never\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "STMUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface STMUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "STM",
      "path": [
        "src",
        "STM.ts"
      ]
    },
    "project": "effect",
    "name": "STMTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type STMTypeId = typeof STMTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "StreamTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const StreamTypeId: typeof StreamTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "DefaultChunkSize",
    "description": "The default chunk size used by the various combinators and constructors of\n`Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constants",
    "signature": "export declare const DefaultChunkSize: number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "accumulate",
    "description": "Collects each underlying Chunk of the stream into a new chunk, and emits it\non each pull.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const accumulate: <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "accumulateChunks",
    "description": "Re-chunks the elements of the stream by accumulating each underlying chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const accumulateChunks: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "acquireRelease",
    "description": "Creates a stream from a single value that will get cleaned up after the\nstream is consumed.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect, Stream } from \"effect\"\n\n// Simulating File operations\nconst open = (filename: string) =>\n  Effect.gen(function*() {\n    yield* Console.log(`Opening ${filename}`)\n    return {\n      getLines: Effect.succeed([\"Line 1\", \"Line 2\", \"Line 3\"]),\n      close: Console.log(`Closing ${filename}`)\n    }\n  })\n\nconst stream = Stream.acquireRelease(\n  open(\"file.txt\"),\n  (file) => file.close\n).pipe(Stream.flatMap((file) => file.getLines))\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Opening file.txt\n// Closing file.txt\n// { _id: 'Chunk', values: [ [ 'Line 1', 'Line 2', 'Line 3' ] ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const acquireRelease: <A, E, R, R2, X>(acquire: Effect.Effect<A, E, R>, release: (resource: A, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<X, never, R2>) => Stream<A, E, R | R2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "aggregate",
    "description": "Aggregates elements of this stream using the provided sink for as long as\nthe downstream operators on the stream are busy.\n\nThis operator divides the stream into two asynchronous \"islands\". Operators\nupstream of this operator run on one fiber, while downstream operators run\non another. Whenever the downstream fiber is busy processing elements, the\nupstream fiber will feed elements into the sink until it signals\ncompletion.\n\nAny sink can be used here, but see `Sink.foldWeightedEffect` and\n`Sink.foldUntilEffect` for sinks that cover the common usecases.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const aggregate: { <B, A, A2, E2, R2>(sink: Sink.Sink<B, A | A2, A2, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R>; <A, E, R, B, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>): Stream<B, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "aggregateWithin",
    "description": "Like `aggregateWithinEither`, but only returns the `Right` results.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const aggregateWithin: { <B, A, A2, E2, R2, C, R3>(sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R3 | R>; <A, E, R, B, A2, E2, R2, C, R3>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): Stream<B, E | E2, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "aggregateWithinEither",
    "description": "Aggregates elements using the provided sink until it completes, or until\nthe delay signalled by the schedule has passed.\n\nThis operator divides the stream into two asynchronous islands. Operators\nupstream of this operator run on one fiber, while downstream operators run\non another. Elements will be aggregated by the sink until the downstream\nfiber pulls the aggregated value, or until the schedule's delay has passed.\n\nAggregated elements will be fed into the schedule to determine the delays\nbetween pulls.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const aggregateWithinEither: { <B, A, A2, E2, R2, C, R3>(sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): <E, R>(self: Stream<A, E, R>) => Stream<Either.Either<B, C>, E2 | E, R2 | R3 | R>; <A, E, R, B, A2, E2, R2, C, R3>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): Stream<Either.Either<B, C>, E | E2, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "as",
    "description": "Maps the success values of this stream to the specified constant value.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.range(1, 5).pipe(Stream.as(null))\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ null, null, null, null, null ] }"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const as: { <B>(value: B): <A, E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, value: B): Stream<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "asyncEffect",
    "description": "Creates a stream from an asynchronous callback that can be called multiple\ntimes The registration of the callback itself returns an effect. The\noptionality of the error type `E` can be used to signal the end of the\nstream, by setting it to `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const asyncEffect: <A, E = never, R = never>(register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<unknown, E, R>, bufferSize?: number | \"unbounded\" | { readonly bufferSize?: number | undefined; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; } | undefined) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "asyncPush",
    "description": "Creates a stream from an external push-based resource.\n\nYou can use the `emit` helper to emit values to the stream. The `emit` helper\nreturns a boolean indicating whether the value was emitted or not.\n\nYou can also use the `emit` helper to signal the end of the stream by\nusing apis such as `emit.end` or `emit.fail`.\n\nBy default it uses an \"unbounded\" buffer size.\nYou can customize the buffer size and strategy by passing an object as the\nsecond argument with the `bufferSize` and `strategy` fields.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nStream.asyncPush<string>((emit) =>\n  Effect.acquireRelease(\n    Effect.gen(function*() {\n      yield* Effect.log(\"subscribing\")\n      return setInterval(() => emit.single(\"tick\"), 1000)\n    }),\n    (handle) =>\n      Effect.gen(function*() {\n        yield* Effect.log(\"unsubscribing\")\n        clearInterval(handle)\n      })\n  ), { bufferSize: 16, strategy: \"dropping\" })"
    ],
    "since": "3.6.0",
    "category": "constructors",
    "signature": "export declare const asyncPush: <A, E = never, R = never>(register: (emit: Emit.EmitOpsPush<E, A>) => Effect.Effect<unknown, E, R | Scope.Scope>, options?: { readonly bufferSize: \"unbounded\"; } | { readonly bufferSize?: number | undefined; readonly strategy?: \"dropping\" | \"sliding\" | undefined; } | undefined) => Stream<A, E, Exclude<R, Scope.Scope>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "asyncScoped",
    "description": "Creates a stream from an asynchronous callback that can be called multiple\ntimes. The registration of the callback itself returns an a scoped\nresource. The optionality of the error type `E` can be used to signal the\nend of the stream, by setting it to `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const asyncScoped: <A, E = never, R = never>(register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<unknown, E, R | Scope.Scope>, bufferSize?: number | \"unbounded\" | { readonly bufferSize?: number | undefined; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; } | undefined) => Stream<A, E, Exclude<R, Scope.Scope>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "branchAfter",
    "description": "Returns a `Stream` that first collects `n` elements from the input `Stream`,\nand then creates a new `Stream` using the specified function, and sends all\nthe following elements through that.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const branchAfter: { <A, A2, E2, R2>(n: number, f: (input: Chunk.Chunk<A>) => Stream<A2, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, n: number, f: (input: Chunk.Chunk<A>) => Stream<A2, E2, R2>): Stream<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "broadcast",
    "description": "Fan out the stream, producing a list of streams that have the same elements\nas this stream. The driver stream will only ever advance the `maximumLag`\nchunks before the slowest downstream stream.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect, Fiber, Schedule, Stream } from \"effect\"\n\nconst numbers = Effect.scoped(\n  Stream.range(1, 20).pipe(\n    Stream.tap((n) => Console.log(`Emit ${n} element before broadcasting`)),\n    Stream.broadcast(2, 5),\n    Stream.flatMap(([first, second]) =>\n      Effect.gen(function*() {\n        const fiber1 = yield* Stream.runFold(first, 0, (acc, e) => Math.max(acc, e)).pipe(\n          Effect.andThen((max) => Console.log(`Maximum: ${max}`)),\n          Effect.fork\n        )\n        const fiber2 = yield* second.pipe(\n          Stream.schedule(Schedule.spaced(\"1 second\")),\n          Stream.runForEach((n) => Console.log(`Logging to the Console: ${n}`)),\n          Effect.fork\n        )\n        yield* Fiber.join(fiber1).pipe(\n          Effect.zip(Fiber.join(fiber2), { concurrent: true })\n        )\n      })\n    ),\n    Stream.runCollect\n  )\n)\n\n// Effect.runPromise(numbers).then(console.log)\n// Emit 1 element before broadcasting\n// Emit 2 element before broadcasting\n// Emit 3 element before broadcasting\n// Emit 4 element before broadcasting\n// Emit 5 element before broadcasting\n// Emit 6 element before broadcasting\n// Emit 7 element before broadcasting\n// Emit 8 element before broadcasting\n// Emit 9 element before broadcasting\n// Emit 10 element before broadcasting\n// Emit 11 element before broadcasting\n// Logging to the Console: 1\n// Logging to the Console: 2\n// Logging to the Console: 3\n// Logging to the Console: 4\n// Logging to the Console: 5\n// Emit 12 element before broadcasting\n// Emit 13 element before broadcasting\n// Emit 14 element before broadcasting\n// Emit 15 element before broadcasting\n// Emit 16 element before broadcasting\n// Logging to the Console: 6\n// Logging to the Console: 7\n// Logging to the Console: 8\n// Logging to the Console: 9\n// Logging to the Console: 10\n// Emit 17 element before broadcasting\n// Emit 18 element before broadcasting\n// Emit 19 element before broadcasting\n// Emit 20 element before broadcasting\n// Logging to the Console: 11\n// Logging to the Console: 12\n// Logging to the Console: 13\n// Logging to the Console: 14\n// Logging to the Console: 15\n// Maximum: 20\n// Logging to the Console: 16\n// Logging to the Console: 17\n// Logging to the Console: 18\n// Logging to the Console: 19\n// Logging to the Console: 20\n// { _id: 'Chunk', values: [ undefined ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const broadcast: { <N extends number>(n: N, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Stream<A, E>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, n: N, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<TupleOf<N, Stream<A, E>>, never, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "share",
    "description": "Returns a new Stream that multicasts the original Stream, subscribing to it as soon as the first consumer subscribes.\nAs long as there is at least one consumer, the upstream will continue running and emitting data.\nWhen all consumers have exited, the upstream will be finalized.",
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "utils",
    "signature": "export declare const share: { <A, E>(config: { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; }): <R>(self: Stream<A, E, R>) => Effect.Effect<Stream<A, E>, never, R | Scope.Scope>; <A, E, R>(self: Stream<A, E, R>, config: { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; readonly idleTimeToLive?: Duration.DurationInput | undefined; }): Effect.Effect<Stream<A, E>, never, R | Scope.Scope>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "broadcastDynamic",
    "description": "Fan out the stream, producing a dynamic number of streams that have the\nsame elements as this stream. The driver stream will only ever advance the\n`maximumLag` chunks before the slowest downstream stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const broadcastDynamic: { (maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Stream<A, E>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<Stream<A, E>, never, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "broadcastedQueues",
    "description": "Converts the stream to a scoped list of queues. Every value will be\nreplicated to every queue with the slowest queue being allowed to buffer\n`maximumLag` chunks before the driver is back pressured.\n\nQueues can unsubscribe from upstream by shutting down.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const broadcastedQueues: { <N extends number>(n: N, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, n: N, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "broadcastedQueuesDynamic",
    "description": "Converts the stream to a scoped dynamic amount of queues. Every chunk will\nbe replicated to every queue with the slowest queue being allowed to buffer\n`maximumLag` chunks before the driver is back pressured.\n\nQueues can unsubscribe from upstream by shutting down.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const broadcastedQueuesDynamic: { (maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, maximumLag: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "buffer",
    "description": "Allows a faster producer to progress independently of a slower consumer by\nbuffering up to `capacity` elements in a queue.\n\nNote: This combinator destroys the chunking structure. It's recommended to\n      use rechunk afterwards. Additionally, prefer capacities that are powers\n      of 2 for better performance.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect, Schedule, Stream } from \"effect\"\n\nconst stream = Stream.range(1, 10).pipe(\n  Stream.tap((n) => Console.log(`before buffering: ${n}`)),\n  Stream.buffer({ capacity: 4 }),\n  Stream.tap((n) => Console.log(`after buffering: ${n}`)),\n  Stream.schedule(Schedule.spaced(\"5 seconds\"))\n)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// before buffering: 1\n// before buffering: 2\n// before buffering: 3\n// before buffering: 4\n// before buffering: 5\n// before buffering: 6\n// after buffering: 1\n// after buffering: 2\n// before buffering: 7\n// after buffering: 3\n// before buffering: 8\n// after buffering: 4\n// before buffering: 9\n// after buffering: 5\n// before buffering: 10\n// ..."
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const buffer: { (options: { readonly capacity: \"unbounded\"; } | { readonly capacity: number; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly capacity: \"unbounded\"; } | { readonly capacity: number; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; }): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "bufferChunks",
    "description": "Allows a faster producer to progress independently of a slower consumer by\nbuffering up to `capacity` chunks in a queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const bufferChunks: { (options: { readonly capacity: number; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly capacity: number; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; }): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "catchAll",
    "description": "Switches over to the stream produced by the provided function in case this\none fails with a typed error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const catchAll: { <E, A2, E2, R2>(f: (error: E) => Stream<A2, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (error: E) => Stream<A2, E2, R2>): Stream<A | A2, E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "catchAllCause",
    "description": "Switches over to the stream produced by the provided function in case this\none fails. Allows recovery from all causes of failure, including\ninterruption if the stream is uninterruptible.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const catchAllCause: { <E, A2, E2, R2>(f: (cause: Cause.Cause<E>) => Stream<A2, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Stream<A2, E2, R2>): Stream<A | A2, E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "catchSome",
    "description": "Switches over to the stream produced by the provided function in case this\none fails with some typed error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const catchSome: { <E, A2, E2, R2>(pf: (error: E) => Option.Option<Stream<A2, E2, R2>>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "catchTag",
    "description": "Switches over to the stream produced by the provided function in case this\none fails with an error matching the given `_tag`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const catchTag: { <K extends E[\"_tag\"] & string, E extends { _tag: string; }, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => Stream<A1, E1, R1>): <A, R>(self: Stream<A, E, R>) => Stream<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E extends { _tag: string; }, R, K extends E[\"_tag\"] & string, A1, E1, R1>(self: Stream<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Stream<A1, E1, R1>): Stream<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "catchTags",
    "description": "Switches over to the stream produced by one of the provided functions, in\ncase this one fails with an error matching one of the given `_tag`'s.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const catchTags: { <E extends { _tag: string; }, Cases extends { [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K; }>) => Stream<any, any, any>; }>(cases: Cases): <A, R>(self: Stream<A, E, R>) => Stream<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer A, infer _E, infer _R> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _A, infer E, infer _R> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _A, infer _E, infer R> ? R : never; }[keyof Cases]>; <A, E extends { _tag: string; }, R, Cases extends { [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K; }>) => Stream<any, any, any>; }>(self: Stream<A, E, R>, cases: Cases): Stream<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _R, infer _E, infer A> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _R, infer E, infer _A> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer R, infer _E, infer _A> ? R : never; }[keyof Cases]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "catchSomeCause",
    "description": "Switches over to the stream produced by the provided function in case this\none fails with some errors. Allows recovery from all causes of failure,\nincluding interruption if the stream is uninterruptible.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const catchSomeCause: { <E, A2, E2, R2>(pf: (cause: Cause.Cause<E>) => Option.Option<Stream<A2, E2, R2>>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (cause: Cause.Cause<E>) => Option.Option<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "changes",
    "description": "Returns a new stream that only emits elements that are not equal to the\nprevious element emitted, using natural equality to determine whether two\nelements are equal.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 1, 1, 2, 2, 3, 4).pipe(Stream.changes)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const changes: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "changesWith",
    "description": "Returns a new stream that only emits elements that are not equal to the\nprevious element emitted, using the specified function to determine whether\ntwo elements are equal.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const changesWith: { <A>(f: (x: A, y: A) => boolean): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, f: (x: A, y: A) => boolean): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "changesWithEffect",
    "description": "Returns a new stream that only emits elements that are not equal to the\nprevious element emitted, using the specified effectual function to\ndetermine whether two elements are equal.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const changesWithEffect: { <A, E2, R2>(f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "chunks",
    "description": "Exposes the underlying chunks of the stream as a stream of chunks of\nelements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const chunks: <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "chunksWith",
    "description": "Performs the specified stream transformation with the chunk structure of\nthe stream exposed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const chunksWith: { <A, E, R, A2, E2, R2>(f: (stream: Stream<Chunk.Chunk<A>, E, R>) => Stream<Chunk.Chunk<A2>, E2, R2>): (self: Stream<A, E, R>) => Stream<A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (stream: Stream<Chunk.Chunk<A>, E, R>) => Stream<Chunk.Chunk<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "combine",
    "description": "Combines the elements from this stream and the specified stream by\nrepeatedly applying the function `f` to extract an element using both sides\nand conceptually \"offer\" it to the destination stream. `f` can maintain\nsome internal state to control the combining process, with the initial\nstate being specified by `s`.\n\nWhere possible, prefer `Stream.combineChunks` for a more efficient\nimplementation.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const combine: { <A2, E2, R2, S, R3, E, A, R4, R5, A3>(that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<A, Option.Option<E>, R3>, pullRight: Effect.Effect<A2, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>): <R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>; <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<A, Option.Option<E>, R3>, pullRight: Effect.Effect<A2, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>): Stream<A3, E2 | E, R | R2 | R3 | R4 | R5>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "combineChunks",
    "description": "Combines the chunks from this stream and the specified stream by repeatedly\napplying the function `f` to extract a chunk using both sides and\nconceptually \"offer\" it to the destination stream. `f` can maintain some\ninternal state to control the combining process, with the initial state\nbeing specified by `s`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const combineChunks: { <A2, E2, R2, S, R3, E, A, R4, R5, A3>(that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>, pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>): <R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>; <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>, pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>): Stream<A3, E2 | E, R | R2 | R3 | R4 | R5>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "concat",
    "description": "Concatenates the specified stream with this stream, resulting in a stream\nthat emits the elements from this stream and then the elements from the\nspecified stream.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3)\nconst s2 = Stream.make(4, 5)\n\nconst stream = Stream.concat(s1, s2)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const concat: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "concatAll",
    "description": "Concatenates all of the streams in the chunk to one stream.",
    "deprecated": false,
    "examples": [
      "import { Chunk, Effect, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3)\nconst s2 = Stream.make(4, 5)\nconst s3 = Stream.make(6, 7, 8)\n\nconst stream = Stream.concatAll(Chunk.make(s1, s2, s3))\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [\n//     1, 2, 3, 4,\n//     5, 6, 7, 8\n//   ]\n// }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const concatAll: <A, E, R>(streams: Chunk.Chunk<Stream<A, E, R>>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "cross",
    "description": "Composes this stream with the specified stream to create a cartesian\nproduct of elements. The `right` stream would be run multiple times, for\nevery element in the `left` stream.\n\nSee also `Stream.zip` for the more common point-wise variant.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3)\nconst s2 = Stream.make(\"a\", \"b\")\n\nconst product = Stream.cross(s1, s2)\n\n// Effect.runPromise(Stream.runCollect(product)).then(console.log)\n// {\n//   _id: \"Chunk\",\n//   values: [\n//     [ 1, \"a\" ], [ 1, \"b\" ], [ 2, \"a\" ], [ 2, \"b\" ], [ 3, \"a\" ], [ 3, \"b\" ]\n//   ]\n// }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const cross: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<[AL, AR], EL | ER, RL | RR>; <AL, ER, RR, AR, EL, RL>(left: Stream<AL, ER, RR>, right: Stream<AR, EL, RL>): Stream<[AL, AR], EL | ER, RL | RR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "crossLeft",
    "description": "Composes this stream with the specified stream to create a cartesian\nproduct of elements, but keeps only elements from `left` stream. The `right`\nstream would be run multiple times, for every element in the `left` stream.\n\nSee also `Stream.zipLeft` for the more common point-wise variant.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const crossLeft: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "crossRight",
    "description": "Composes this stream with the specified stream to create a cartesian\nproduct of elements, but keeps only elements from the `right` stream. The\n`left` stream would be run multiple times, for every element in the `right`\nstream.\n\nSee also `Stream.zipRight` for the more common point-wise variant.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const crossRight: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "crossWith",
    "description": "Composes this stream with the specified stream to create a cartesian\nproduct of elements with a specified function. The `right` stream would be\nrun multiple times, for every element in the `left` stream.\n\nSee also `Stream.zipWith` for the more common point-wise variant.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const crossWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "debounce",
    "description": "Delays the emission of values by holding new values for a set duration. If\nno new values arrive during that time the value is emitted, however if a\nnew value is received during the holding period the previous value is\ndiscarded and the process is repeated with the new value.\n\nThis operator is useful if you have a stream of \"bursty\" events which\neventually settle down and you only need the final event of the burst. For\nexample, a search engine may only want to initiate a search after a user\nhas paused typing so as to not prematurely recommend results.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nlet last = Date.now()\nconst log = (message: string) =>\n  Effect.sync(() => {\n    const end = Date.now()\n    console.log(`${message} after ${end - last}ms`)\n    last = end\n  })\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.concat(\n    Stream.fromEffect(Effect.sleep(\"200 millis\").pipe(Effect.as(4))) // Emit 4 after 200 ms\n  ),\n  Stream.concat(Stream.make(5, 6)), // Continue with more rapid values\n  Stream.concat(\n    Stream.fromEffect(Effect.sleep(\"150 millis\").pipe(Effect.as(7))) // Emit 7 after 150 ms\n  ),\n  Stream.concat(Stream.make(8)),\n  Stream.tap((n) => log(`Received ${n}`)),\n  Stream.debounce(\"100 millis\"), // Only emit values after a pause of at least 100 milliseconds,\n  Stream.tap((n) => log(`> Emitted ${n}`))\n)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Received 1 after 5ms\n// Received 2 after 2ms\n// Received 3 after 0ms\n// > Emitted 3 after 104ms\n// Received 4 after 99ms\n// Received 5 after 1ms\n// Received 6 after 0ms\n// > Emitted 6 after 101ms\n// Received 7 after 50ms\n// Received 8 after 1ms\n// > Emitted 8 after 101ms\n// { _id: 'Chunk', values: [ 3, 6, 8 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const debounce: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "die",
    "description": "The stream that dies with the specified defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const die: (defect: unknown) => Stream<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "dieSync",
    "description": "The stream that dies with the specified lazily evaluated defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dieSync: (evaluate: LazyArg<unknown>) => Stream<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "dieMessage",
    "description": "The stream that dies with an exception described by `message`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dieMessage: (message: string) => Stream<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "distributedWith",
    "description": "More powerful version of `Stream.broadcast`. Allows to provide a function\nthat determines what queues should receive which elements. The decide\nfunction will receive the indices of the queues in the resulting list.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const distributedWith: { <N extends number, A>(options: { readonly size: N; readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>>; }): <E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, options: { readonly size: N; readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>>; }): Effect.Effect<TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>, never, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "distributedWithDynamic",
    "description": "More powerful version of `Stream.distributedWith`. This returns a function\nthat will produce new queues and corresponding indices. You can also\nprovide a function that will be executed after the final events are\nenqueued in all queues. Shutdown of the queues is handled by the driver.\nDownstream users can also shutdown queues manually. In this case the driver\nwill continue but no longer backpressure on them.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const distributedWithDynamic: { <A>(options: { readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>, never, never>; }): <E, R>(self: Stream<A, E, R>) => Effect.Effect<Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>], never, never>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>, never, never>; }): Effect.Effect<Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>], never, never>, never, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "drain",
    "description": "Converts this stream to a stream that executes its effects but emits no\nelements. Useful for sequencing effects using streams:",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\n// We create a stream and immediately drain it.\nconst stream = Stream.range(1, 6).pipe(Stream.drain)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const drain: <A, E, R>(self: Stream<A, E, R>) => Stream<never, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "drainFork",
    "description": "Drains the provided stream in the background for as long as this stream is\nrunning. If this stream ends before `other`, `other` will be interrupted.\nIf `other` fails, this stream will fail with that error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const drainFork: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "drop",
    "description": "Drops the specified number of elements from this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const drop: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "dropRight",
    "description": "Drops the last specified number of elements from this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const dropRight: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "dropUntil",
    "description": "Drops all elements of the stream until the specified predicate evaluates to\n`true`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const dropUntil: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "dropUntilEffect",
    "description": "Drops all elements of the stream until the specified effectful predicate\nevaluates to `true`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const dropUntilEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "dropWhile",
    "description": "Drops all elements of the stream for as long as the specified predicate\nevaluates to `true`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const dropWhile: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "dropWhileEffect",
    "description": "Drops all elements of the stream for as long as the specified predicate\nproduces an effect that evalutates to `true`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const dropWhileEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "either",
    "description": "Returns a stream whose failures and successes have been lifted into an\n`Either`. The resulting stream cannot fail, because the failures have been\nexposed as part of the `Either` success case.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const either: <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A, E>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "The empty stream.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.empty\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: Stream<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "ensuring",
    "description": "Executes the provided finalizer after this stream's finalizers run.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect, Stream } from \"effect\"\n\nconst program = Stream.fromEffect(Console.log(\"Application Logic.\")).pipe(\n  Stream.concat(Stream.finalizer(Console.log(\"Finalizing the stream\"))),\n  Stream.ensuring(\n    Console.log(\"Doing some other works after stream's finalization\")\n  )\n)\n\n// Effect.runPromise(Stream.runCollect(program)).then(console.log)\n// Application Logic.\n// Finalizing the stream\n// Doing some other works after stream's finalization\n// { _id: 'Chunk', values: [ undefined, undefined ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const ensuring: { <X, R2>(finalizer: Effect.Effect<X, never, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, finalizer: Effect.Effect<X, never, R2>): Stream<A, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "ensuringWith",
    "description": "Executes the provided finalizer after this stream's finalizers run.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const ensuringWith: { <E, R2>(finalizer: (exit: Exit.Exit<unknown, E>) => Effect.Effect<unknown, never, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, R2>(self: Stream<A, E, R>, finalizer: (exit: Exit.Exit<unknown, E>) => Effect.Effect<unknown, never, R2>): Stream<A, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "context",
    "description": "Accesses the whole context of the stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const context: <R>() => Stream<Context.Context<R>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "contextWith",
    "description": "Accesses the context of the stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const contextWith: <R, A>(f: (env: Context.Context<R>) => A) => Stream<A, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "contextWithEffect",
    "description": "Accesses the context of the stream in the context of an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const contextWithEffect: <R0, A, E, R>(f: (env: Context.Context<R0>) => Effect.Effect<A, E, R>) => Stream<A, E, R0 | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "contextWithStream",
    "description": "Accesses the context of the stream in the context of a stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const contextWithStream: <R0, A, E, R>(f: (env: Context.Context<R0>) => Stream<A, E, R>) => Stream<A, E, R0 | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "execute",
    "description": "Creates a stream that executes the specified effect but emits no elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const execute: <X, E, R>(effect: Effect.Effect<X, E, R>) => Stream<never, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": "Terminates with the specified error.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.fail(\"Uh oh!\")\n\nEffect.runPromiseExit(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }\n// }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fail: <E>(error: E) => Stream<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "failSync",
    "description": "Terminates with the specified lazily evaluated error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failSync: <E>(evaluate: LazyArg<E>) => Stream<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "failCause",
    "description": "The stream that always fails with the specified `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failCause: <E>(cause: Cause.Cause<E>) => Stream<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "failCauseSync",
    "description": "The stream that always fails with the specified lazily evaluated `Cause`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Stream<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters the elements emitted by this stream using the provided function.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.range(1, 11).pipe(Stream.filter((n) => n % 2 === 0))\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 2, 4, 6, 8, 10 ] }"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, B extends A>(predicate: Predicate<B>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "filterEffect",
    "description": "Effectfully filters the elements emitted by this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterEffect: { <A, E2, R2>(f: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Performs a filter and map in a single step.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const filterMap: { <A, B>(pf: (a: A) => Option.Option<B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<B>): Stream<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "filterMapEffect",
    "description": "Performs an effectful filter and map in a single step.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const filterMapEffect: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "filterMapWhile",
    "description": "Transforms all elements of the stream for as long as the specified partial\nfunction is defined.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const filterMapWhile: { <A, A2>(pf: (a: A) => Option.Option<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<A2>): Stream<A2, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "filterMapWhileEffect",
    "description": "Effectfully transforms all elements of the stream for as long as the\nspecified partial function is defined.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const filterMapWhileEffect: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "finalizer",
    "description": "Creates a one-element stream that never fails and executes the finalizer\nwhen it ends.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect, Stream } from \"effect\"\n\nconst application = Stream.fromEffect(Console.log(\"Application Logic.\"))\n\nconst deleteDir = (dir: string) => Console.log(`Deleting dir: ${dir}`)\n\nconst program = application.pipe(\n  Stream.concat(\n    Stream.finalizer(\n      deleteDir(\"tmp\").pipe(\n        Effect.andThen(Console.log(\"Temporary directory was deleted.\"))\n      )\n    )\n  )\n)\n\n// Effect.runPromise(Stream.runCollect(program)).then(console.log)\n// Application Logic.\n// Deleting dir: tmp\n// Temporary directory was deleted.\n// { _id: 'Chunk', values: [ undefined, undefined ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const finalizer: <R, X>(finalizer: Effect.Effect<X, never, R>) => Stream<void, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "find",
    "description": "Finds the first element emitted by this stream that satisfies the provided\npredicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const find: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "findEffect",
    "description": "Finds the first element emitted by this stream that satisfies the provided\neffectful predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "flatMap",
    "description": "Returns a stream made of the concatenation in strict order of all the\nstreams produced by passing each element of this stream to `f0`",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatMap: { <A, A2, E2, R2>(f: (a: A) => Stream<A2, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; readonly switch?: boolean | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Stream<A2, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; readonly switch?: boolean | undefined; } | undefined): Stream<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "flatten",
    "description": "Flattens this stream-of-streams into a stream made of the concatenation in\nstrict order of all the streams.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flatten: { (options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; } | undefined): <A, E2, R2, E, R>(self: Stream<Stream<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E2, R2, E, R>(self: Stream<Stream<A, E2, R2>, E, R>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; } | undefined): Stream<A, E2 | E, R2 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "flattenChunks",
    "description": "Submerges the chunks carried by this stream into the stream's structure,\nwhile still preserving them.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flattenChunks: <A, E, R>(self: Stream<Chunk.Chunk<A>, E, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "flattenEffect",
    "description": "Flattens `Effect` values into the stream's structure, preserving all\ninformation about the effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flattenEffect: { (options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly unordered?: boolean | undefined; } | undefined): <A, E2, R2, E, R>(self: Stream<Effect.Effect<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E2, R2, E, R>(self: Stream<Effect.Effect<A, E2, R2>, E, R>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly unordered?: boolean | undefined; } | undefined): Stream<A, E2 | E, R2 | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "flattenExitOption",
    "description": "Unwraps `Exit` values that also signify end-of-stream by failing with `None`.\n\nFor `Exit` values that do not signal end-of-stream, prefer:\n\n```ts\nstream.mapZIO(ZIO.done(_))\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flattenExitOption: <A, E2, E, R>(self: Stream<Exit.Exit<A, Option.Option<E2>>, E, R>) => Stream<A, E | E2, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "flattenIterables",
    "description": "Submerges the iterables carried by this stream into the stream's structure,\nwhile still preserving them.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flattenIterables: <A, E, R>(self: Stream<Iterable<A>, E, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "flattenTake",
    "description": "Unwraps `Exit` values and flatten chunks that also signify end-of-stream\nby failing with `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const flattenTake: <A, E2, E, R>(self: Stream<Take.Take<A, E2>, E, R>) => Stream<A, E | E2, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "forever",
    "description": "Repeats this stream forever.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const forever: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromAsyncIterable",
    "description": "Creates a stream from an `AsyncIterable`.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst myAsyncIterable = async function*() {\n  yield 1\n  yield 2\n}\n\nconst stream = Stream.fromAsyncIterable(\n  myAsyncIterable(),\n  (e) => new Error(String(e)) // Error Handling\n)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromAsyncIterable: <A, E>(iterable: AsyncIterable<A>, onError: (e: unknown) => E) => Stream<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromChannel",
    "description": "Creates a stream from a `Channel`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromChannel: <A, E, R>(channel: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "toChannel",
    "description": "Creates a channel from a `Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const toChannel: <A, E, R>(stream: Stream<A, E, R>) => Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromChunk",
    "description": "Creates a stream from a `Chunk` of values.",
    "deprecated": false,
    "examples": [
      "import { Chunk, Effect, Stream } from \"effect\"\n\n// Creating a stream with values from a single Chunk\nconst stream = Stream.fromChunk(Chunk.make(1, 2, 3))\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromChunk: <A>(chunk: Chunk.Chunk<A>) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromChunkPubSub",
    "description": "Creates a stream from a subscription to a `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromChunkPubSub: { <A>(pubsub: PubSub.PubSub<Chunk.Chunk<A>>, options: { readonly scoped: true; readonly shutdown?: boolean | undefined; }): Effect.Effect<Stream<A>, never, Scope.Scope>; <A>(pubsub: PubSub.PubSub<Chunk.Chunk<A>>, options?: { readonly scoped?: false | undefined; readonly shutdown?: boolean | undefined; } | undefined): Stream<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromChunkQueue",
    "description": "Creates a stream from a `Queue` of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromChunkQueue: <A>(queue: Queue.Dequeue<Chunk.Chunk<A>>, options?: { readonly shutdown?: boolean | undefined; }) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromChunks",
    "description": "Creates a stream from an arbitrary number of chunks.",
    "deprecated": false,
    "examples": [
      "import { Chunk, Effect, Stream } from \"effect\"\n\n// Creating a stream with values from multiple Chunks\nconst stream = Stream.fromChunks(Chunk.make(1, 2, 3), Chunk.make(4, 5, 6))\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromChunks: <A>(...chunks: Array<Chunk.Chunk<A>>) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromEffect",
    "description": "Either emits the success value of this effect or terminates the stream\nwith the failure value of this effect.",
    "deprecated": false,
    "examples": [
      "import { Effect, Random, Stream } from \"effect\"\n\nconst stream = Stream.fromEffect(Random.nextInt)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Example Output: { _id: 'Chunk', values: [ 922694024 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromEffectOption",
    "description": "Creates a stream from an effect producing a value of type `A` or an empty\n`Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromEffectOption: <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromPubSub",
    "description": "Creates a stream from a subscription to a `PubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromPubSub: { <A>(pubsub: PubSub.PubSub<A>, options: { readonly scoped: true; readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; }): Effect.Effect<Stream<A>, never, Scope.Scope>; <A>(pubsub: PubSub.PubSub<A>, options?: { readonly scoped?: false | undefined; readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; } | undefined): Stream<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromTPubSub",
    "description": "Creates a stream from a subscription to a `TPubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const fromTPubSub: <A>(pubsub: TPubSub<A>) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `Stream` from an iterable collection of values.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst numbers = [1, 2, 3]\n\nconst stream = Stream.fromIterable(numbers)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterable: <A>(iterable: Iterable<A>) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterableEffect",
    "description": "Creates a stream from an effect producing a value of type `Iterable<A>`.",
    "deprecated": false,
    "examples": [
      "import { Context, Effect, Stream } from \"effect\"\n\nclass Database extends Context.Tag(\"Database\")<\n  Database,\n  { readonly getUsers: Effect.Effect<Array<string>> }\n>() {}\n\nconst getUsers = Database.pipe(Effect.andThen((_) => _.getUsers))\n\nconst stream = Stream.fromIterableEffect(getUsers)\n\n// Effect.runPromise(\n//   Stream.runCollect(stream.pipe(Stream.provideService(Database, { getUsers: Effect.succeed([\"user1\", \"user2\"]) })))\n// ).then(console.log)\n// { _id: 'Chunk', values: [ 'user1', 'user2' ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterableEffect: <A, E, R>(effect: Effect.Effect<Iterable<A>, E, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromIteratorSucceed",
    "description": "Creates a stream from an iterator",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIteratorSucceed: <A>(iterator: IterableIterator<A>, maxChunkSize?: number) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromPull",
    "description": "Creates a stream from an effect that pulls elements from another stream.\n\nSee `Stream.toPull` for reference.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromPull: <R, R2, E, A>(effect: Effect.Effect<Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R2>, never, Scope.Scope | R>) => Stream<A, E, R2 | Exclude<R, Scope.Scope>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromQueue",
    "description": "Creates a stream from a queue of values",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromQueue: <A>(queue: Queue.Dequeue<A>, options?: { readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; }) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromTQueue",
    "description": "Creates a stream from a TQueue of values",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const fromTQueue: <A>(queue: TDequeue<A>) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromReadableStream",
    "description": "Creates a stream from a `ReadableStream`.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromReadableStream: { <A, E>(options: { readonly evaluate: LazyArg<ReadableStream<A>>; readonly onError: (error: unknown) => E; readonly releaseLockOnEnd?: boolean | undefined; }): Stream<A, E>; <A, E>(evaluate: LazyArg<ReadableStream<A>>, onError: (error: unknown) => E): Stream<A, E>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromReadableStreamByob",
    "description": "Creates a stream from a `ReadableStreamBYOBReader`.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamBYOBReader.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromReadableStreamByob: { <E>(options: { readonly evaluate: LazyArg<ReadableStream<Uint8Array>>; readonly onError: (error: unknown) => E; readonly bufferSize?: number | undefined; readonly releaseLockOnEnd?: boolean | undefined; }): Stream<Uint8Array, E>; <E>(evaluate: LazyArg<ReadableStream<Uint8Array>>, onError: (error: unknown) => E, allocSize?: number): Stream<Uint8Array, E>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromSchedule",
    "description": "Creates a stream from a `Schedule` that does not require any further\ninput. The stream will emit an element for each value output from the\nschedule, continuing for as long as the schedule continues.",
    "deprecated": false,
    "examples": [
      "import { Effect, Schedule, Stream } from \"effect\"\n\n// Emits values every 1 second for a total of 5 emissions\nconst schedule = Schedule.spaced(\"1 second\").pipe(\n  Schedule.compose(Schedule.recurs(5))\n)\n\nconst stream = Stream.fromSchedule(schedule)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromSchedule: <A, R>(schedule: Schedule.Schedule<A, unknown, R>) => Stream<A, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "groupAdjacentBy",
    "description": "Creates a pipeline that groups on adjacent keys, calculated by the\nspecified function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "export declare const groupAdjacentBy: { <A, K>(f: (a: A) => K): <E, R>(self: Stream<A, E, R>) => Stream<[K, Chunk.NonEmptyChunk<A>], E, R>; <A, E, R, K>(self: Stream<A, E, R>, f: (a: A) => K): Stream<[K, Chunk.NonEmptyChunk<A>], E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "groupBy",
    "description": "More powerful version of `Stream.groupByKey`.",
    "deprecated": false,
    "examples": [
      "import { Chunk, Effect, GroupBy, Stream } from \"effect\"\n\nconst groupByKeyResult = Stream.fromIterable([\n  \"Mary\",\n  \"James\",\n  \"Robert\",\n  \"Patricia\",\n  \"John\",\n  \"Jennifer\",\n  \"Rebecca\",\n  \"Peter\"\n]).pipe(\n  Stream.groupBy((name) => Effect.succeed([name.substring(0, 1), name]))\n)\n\nconst stream = GroupBy.evaluate(groupByKeyResult, (key, stream) =>\n  Stream.fromEffect(\n    Stream.runCollect(stream).pipe(\n      Effect.andThen((chunk) => [key, Chunk.size(chunk)] as const)\n    )\n  ))\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [ [ 'M', 1 ], [ 'J', 3 ], [ 'R', 2 ], [ 'P', 2 ] ]\n// }"
    ],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "export declare const groupBy: { <A, K, V, E2, R2>(f: (a: A) => Effect.Effect<readonly [K, V], E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => GroupBy.GroupBy<K, V, E2 | E, R2 | R>; <A, E, R, K, V, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<readonly [K, V], E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): GroupBy.GroupBy<K, V, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "groupByKey",
    "description": "Partition a stream using a function and process each stream individually.\nThis returns a data structure that can be used to further filter down which\ngroups shall be processed.\n\nAfter calling apply on the GroupBy object, the remaining groups will be\nprocessed in parallel and the resulting streams merged in a\nnondeterministic fashion.\n\nUp to `buffer` elements may be buffered in any group stream before the\nproducer is backpressured. Take care to consume from all streams in order\nto prevent deadlocks.\n\nFor example, to collect the first 2 words for every starting letter from a\nstream of words:\n\n```ts\nimport * as GroupBy from \"./GroupBy\"\nimport * as Stream from \"./Stream\"\nimport { pipe } from \"./Function\"\n\npipe(\n  Stream.fromIterable([\"hello\", \"world\", \"hi\", \"holla\"]),\n  Stream.groupByKey((word) => word[0]),\n  GroupBy.evaluate((key, stream) =>\n    pipe(\n      stream,\n      Stream.take(2),\n      Stream.map((words) => [key, words] as const)\n    )\n  )\n)\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "export declare const groupByKey: { <A, K>(f: (a: A) => K, options?: { readonly bufferSize?: number | undefined; }): <E, R>(self: Stream<A, E, R>) => GroupBy.GroupBy<K, A, E, R>; <A, E, R, K>(self: Stream<A, E, R>, f: (a: A) => K, options?: { readonly bufferSize?: number | undefined; }): GroupBy.GroupBy<K, A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "grouped",
    "description": "Partitions the stream with specified `chunkSize`.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.range(0, 8).pipe(Stream.grouped(3))\n\n// Effect.runPromise(Stream.runCollect(stream)).then((chunks) => console.log(\"%o\", chunks))\n// {\n//   _id: 'Chunk',\n//   values: [\n//     { _id: 'Chunk', values: [ 0, 1, 2, [length]: 3 ] },\n//     { _id: 'Chunk', values: [ 3, 4, 5, [length]: 3 ] },\n//     { _id: 'Chunk', values: [ 6, 7, 8, [length]: 3 ] },\n//     [length]: 3\n//   ]\n// }"
    ],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "export declare const grouped: { (chunkSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number): Stream<Chunk.Chunk<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "groupedWithin",
    "description": "Partitions the stream with the specified `chunkSize` or until the specified\n`duration` has passed, whichever is satisfied first.",
    "deprecated": false,
    "examples": [
      "import { Chunk, Effect, Schedule, Stream } from \"effect\"\n\nconst stream = Stream.range(0, 9).pipe(\n  Stream.repeat(Schedule.spaced(\"1 second\")),\n  Stream.groupedWithin(18, \"1.5 seconds\"),\n  Stream.take(3)\n)\n\n// Effect.runPromise(Stream.runCollect(stream)).then((chunks) => console.log(Chunk.toArray(chunks)))\n// [\n//   {\n//     _id: 'Chunk',\n//     values: [\n//       0, 1, 2, 3, 4, 5, 6,\n//       7, 8, 9, 0, 1, 2, 3,\n//       4, 5, 6, 7\n//     ]\n//   },\n//   {\n//     _id: 'Chunk',\n//     values: [\n//       8, 9, 0, 1, 2,\n//       3, 4, 5, 6, 7,\n//       8, 9\n//     ]\n//   },\n//   {\n//     _id: 'Chunk',\n//     values: [\n//       0, 1, 2, 3, 4, 5, 6,\n//       7, 8, 9, 0, 1, 2, 3,\n//       4, 5, 6, 7\n//     ]\n//   }\n// ]"
    ],
    "since": "2.0.0",
    "category": "grouping",
    "signature": "export declare const groupedWithin: { (chunkSize: number, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number, duration: Duration.DurationInput): Stream<Chunk.Chunk<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "haltAfter",
    "description": "Specialized version of haltWhen which halts the evaluation of this stream\nafter the given duration.\n\nAn element in the process of being pulled will not be interrupted when the\ngiven duration completes. See `interruptAfter` for this behavior.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const haltAfter: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "haltWhen",
    "description": "Halts the evaluation of this stream when the provided effect completes. The\ngiven effect will be forked as part of the returned stream, and its success\nwill be discarded.\n\nAn element in the process of being pulled will not be interrupted when the\neffect completes. See `interruptWhen` for this behavior.\n\nIf the effect completes with a failure, the stream will emit that failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const haltWhen: { <X, E2, R2>(effect: Effect.Effect<X, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "haltWhenDeferred",
    "description": "Halts the evaluation of this stream when the provided promise resolves.\n\nIf the promise completes with a failure, the stream will emit that failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const haltWhenDeferred: { <X, E2>(deferred: Deferred.Deferred<X, E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, X, E2>(self: Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>): Stream<A, E | E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "identity",
    "description": "The identity pipeline, which does not modify streams in any way.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const identity: <A, E = never, R = never>() => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "interleave",
    "description": "Interleaves this stream and the specified stream deterministically by\nalternating pulling values from this stream and the specified stream. When\none stream is exhausted all remaining values in the other stream will be\npulled.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3)\nconst s2 = Stream.make(4, 5, 6)\n\nconst stream = Stream.interleave(s1, s2)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 4, 2, 5, 3, 6 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const interleave: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "interleaveWith",
    "description": "Combines this stream and the specified stream deterministically using the\nstream of boolean values `pull` to control which stream to pull from next.\nA value of `true` indicates to pull from this stream and a value of `false`\nindicates to pull from the specified stream. Only consumes as many elements\nas requested by the `pull` stream. If either this stream or the specified\nstream are exhausted further requests for values from that stream will be\nignored.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 3, 5, 7, 9)\nconst s2 = Stream.make(2, 4, 6, 8, 10)\n\nconst booleanStream = Stream.make(true, false, false).pipe(Stream.forever)\n\nconst stream = Stream.interleaveWith(s1, s2, booleanStream)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [\n//     1, 2,  4, 3, 6,\n//     8, 5, 10, 7, 9\n//   ]\n// }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const interleaveWith: { <A2, E2, R2, E3, R3>(that: Stream<A2, E2, R2>, decider: Stream<boolean, E3, R3>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E3 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, E3, R3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, decider: Stream<boolean, E3, R3>): Stream<A | A2, E | E2 | E3, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "intersperse",
    "description": "Intersperse stream with provided `element`.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3, 4, 5).pipe(Stream.intersperse(0))\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [\n//     1, 0, 2, 0, 3,\n//     0, 4, 0, 5\n//   ]\n// }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const intersperse: { <A2>(element: A2): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, element: A2): Stream<A | A2, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "intersperseAffixes",
    "description": "Intersperse the specified element, also adding a prefix and a suffix.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3, 4, 5).pipe(\n  Stream.intersperseAffixes({\n    start: \"[\",\n    middle: \"-\",\n    end: \"]\"\n  })\n)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [\n//     '[', 1,   '-', 2,   '-',\n//     3,   '-', 4,   '-', 5,\n//     ']'\n//   ]\n// }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const intersperseAffixes: { <A2, A3, A4>(options: { readonly start: A2; readonly middle: A3; readonly end: A4; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A3 | A4 | A, E, R>; <A, E, R, A2, A3, A4>(self: Stream<A, E, R>, options: { readonly start: A2; readonly middle: A3; readonly end: A4; }): Stream<A | A2 | A3 | A4, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "interruptAfter",
    "description": "Specialized version of `Stream.interruptWhen` which interrupts the\nevaluation of this stream after the given `Duration`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const interruptAfter: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "interruptWhen",
    "description": "Interrupts the evaluation of this stream when the provided effect\ncompletes. The given effect will be forked as part of this stream, and its\nsuccess will be discarded. This combinator will also interrupt any\nin-progress element being pulled from upstream.\n\nIf the effect completes with a failure before the stream completes, the\nreturned stream will emit that failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const interruptWhen: { <X, E2, R2>(effect: Effect.Effect<X, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "interruptWhenDeferred",
    "description": "Interrupts the evaluation of this stream when the provided promise\nresolves. This combinator will also interrupt any in-progress element being\npulled from upstream.\n\nIf the promise completes with a failure, the stream will emit that failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const interruptWhenDeferred: { <X, E2>(deferred: Deferred.Deferred<X, E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, X, E2>(self: Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>): Stream<A, E | E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "iterate",
    "description": "The infinite stream of iterative function application: a, f(a), f(f(a)),\nf(f(f(a))), ...",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\n// An infinite Stream of numbers starting from 1 and incrementing\nconst stream = Stream.iterate(1, (n) => n + 1)\n\n// Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(10)))).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const iterate: <A>(value: A, next: (value: A) => A) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a stream from an sequence of values.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <As extends Array<any>>(...as: As) => Stream<As[number]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms the elements of this stream using the supplied function.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3).pipe(Stream.map((n) => n + 1))\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 2, 3, 4 ] }"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, f: (a: A) => B): Stream<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mapAccum",
    "description": "Statefully maps over the elements of this stream to produce new elements.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst runningTotal = (stream: Stream.Stream<number>): Stream.Stream<number> =>\n  stream.pipe(Stream.mapAccum(0, (s, a) => [s + a, s + a]))\n\n// input:  0, 1, 2, 3, 4, 5, 6\n// Effect.runPromise(Stream.runCollect(runningTotal(Stream.range(0, 6)))).then(\n//   console.log\n// )\n// { _id: \"Chunk\", values: [ 0, 1, 3, 6, 10, 15, 21 ] }"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapAccum: { <S, A, A2>(s: S, f: (s: S, a: A) => readonly [S, A2]): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, S, A2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => readonly [S, A2]): Stream<A2, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mapAccumEffect",
    "description": "Statefully and effectfully maps over the elements of this stream to produce\nnew elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapAccumEffect: { <S, A, A2, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, S, A2, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>): Stream<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mapBoth",
    "description": "Returns a stream whose failure and success channels have been mapped by the\nspecified `onFailure` and `onSuccess` functions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Stream<A, E, R>) => Stream<A2, E2, R>; <A, E, R, E2, A2>(self: Stream<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Stream<A2, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mapChunks",
    "description": "Transforms the chunks emitted by this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapChunks: { <A, B>(f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>): Stream<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mapChunksEffect",
    "description": "Effectfully transforms the chunks emitted by this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapChunksEffect: { <A, B, E2, R2>(f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R>; <A, E, R, B, E2, R2>(self: Stream<A, E, R>, f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>): Stream<B, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mapConcat",
    "description": "Maps each element to an iterable, and flattens the iterables into the\noutput of this stream.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst numbers = Stream.make(\"1-2-3\", \"4-5\", \"6\").pipe(\n  Stream.mapConcat((s) => s.split(\"-\")),\n  Stream.map((s) => parseInt(s))\n)\n\n// Effect.runPromise(Stream.runCollect(numbers)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6 ] }"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapConcat: { <A, A2>(f: (a: A) => Iterable<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a: A) => Iterable<A2>): Stream<A2, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mapConcatChunk",
    "description": "Maps each element to a chunk, and flattens the chunks into the output of\nthis stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapConcatChunk: { <A, A2>(f: (a: A) => Chunk.Chunk<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a: A) => Chunk.Chunk<A2>): Stream<A2, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mapConcatChunkEffect",
    "description": "Effectfully maps each element to a chunk, and flattens the chunks into the\noutput of this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapConcatChunkEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mapConcatEffect",
    "description": "Effectfully maps each element to an iterable, and flattens the iterables\ninto the output of this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapConcatEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mapEffect",
    "description": "Maps over elements of the stream with the specified effectful function.",
    "deprecated": false,
    "examples": [
      "import { Effect, Random, Stream } from \"effect\"\n\nconst stream = Stream.make(10, 20, 30).pipe(\n  Stream.mapEffect((n) => Random.nextIntBetween(0, n))\n)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Example Output: { _id: 'Chunk', values: [ 7, 19, 8 ] }"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<A2, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly unordered?: boolean | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, A2, E2, R2, K>(f: (a: A) => Effect.Effect<A2, E2, R2>, options: { readonly key: (a: A) => K; readonly bufferSize?: number | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<A2, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly unordered?: boolean | undefined; } | undefined): Stream<A2, E | E2, R | R2>; <A, E, R, A2, E2, R2, K>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<A2, E2, R2>, options: { readonly key: (a: A) => K; readonly bufferSize?: number | undefined; }): Stream<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mapError",
    "description": "Transforms the errors emitted by this stream using `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, f: (error: E) => E2): Stream<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mapErrorCause",
    "description": "Transforms the full causes of failures emitted by this stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapErrorCause: { <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Stream<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "merge",
    "description": "Merges this stream and the specified stream together.\n\nNew produced stream will terminate when both specified stream terminate if\nno termination strategy is specified.",
    "deprecated": false,
    "examples": [
      "import { Effect, Schedule, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3).pipe(\n  Stream.schedule(Schedule.spaced(\"100 millis\"))\n)\nconst s2 = Stream.make(4, 5, 6).pipe(\n  Stream.schedule(Schedule.spaced(\"200 millis\"))\n)\n\nconst stream = Stream.merge(s1, s2)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 4, 2, 3, 5, 6 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const merge: { <A2, E2, R2>(that: Stream<A2, E2, R2>, options?: { readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; } | undefined): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, options?: { readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; } | undefined): Stream<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mergeAll",
    "description": "Merges a variable list of streams in a non-deterministic fashion. Up to `n`\nstreams may be consumed in parallel and up to `outputBuffer` chunks may be\nbuffered by this operator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mergeAll: { (options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; }): <A, E, R>(streams: Iterable<Stream<A, E, R>>) => Stream<A, E, R>; <A, E, R>(streams: Iterable<Stream<A, E, R>>, options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; }): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mergeWithTag",
    "description": "Merges a struct of streams into a single stream of tagged values.",
    "deprecated": false,
    "examples": [
      "import { Stream } from \"effect\"\n// Stream.Stream<{ _tag: \"a\"; value: number; } | { _tag: \"b\"; value: string; }>\nconst res = Stream.mergeWithTag({\n   a: Stream.make(0),\n   b: Stream.make(\"\")\n}, { concurrency: \"unbounded\" })"
    ],
    "since": "3.8.5",
    "category": "combinators",
    "signature": "export declare const mergeWithTag: { <S extends { [k in string]: Stream<any, any, any>; }>(streams: S, options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; }): Stream<{ [K in keyof S]: { _tag: K; value: Stream.Success<S[K]>; }; }[keyof S], Stream.Error<S[keyof S]>, Stream.Context<S[keyof S]>>; (options: { readonly concurrency: number | \"unbounded\"; readonly bufferSize?: number | undefined; }): <S extends { [k in string]: Stream<any, any, any>; }>(streams: S) => Stream<{ [K in keyof S]: { _tag: K; value: Stream.Success<S[K]>; }; }[keyof S], Stream.Error<S[keyof S]>, Stream.Context<S[keyof S]>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mergeWith",
    "description": "Merges this stream and the specified stream together to a common element\ntype with the specified mapping functions.\n\nNew produced stream will terminate when both specified stream terminate if\nno termination strategy is specified.",
    "deprecated": false,
    "examples": [
      "import { Effect, Schedule, Stream } from \"effect\"\n\nconst s1 = Stream.make(\"1\", \"2\", \"3\").pipe(\n  Stream.schedule(Schedule.spaced(\"100 millis\"))\n)\nconst s2 = Stream.make(4.1, 5.3, 6.2).pipe(\n  Stream.schedule(Schedule.spaced(\"200 millis\"))\n)\n\nconst stream = Stream.mergeWith(s1, s2, {\n  onSelf: (s) => parseInt(s),\n  onOther: (n) => Math.floor(n)\n})\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 4, 2, 3, 5, 6 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mergeWith: { <A2, E2, R2, A, A3, A4>(other: Stream<A2, E2, R2>, options: { readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A4; readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A3 | A4, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3, A4>(self: Stream<A, E, R>, other: Stream<A2, E2, R2>, options: { readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A4; readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; }): Stream<A3 | A4, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mergeEither",
    "description": "Merges this stream and the specified stream together to produce a stream of\neithers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mergeEither: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A2, A>, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<Either.Either<A2, A>, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mergeLeft",
    "description": "Merges this stream and the specified stream together, discarding the values\nfrom the right stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mergeLeft: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mergeRight",
    "description": "Merges this stream and the specified stream together, discarding the values\nfrom the left stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mergeRight: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mkString",
    "description": "Returns a combined string resulting from concatenating each of the values\nfrom the stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const mkString: <E, R>(self: Stream<string, E, R>) => Effect.Effect<string, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "never",
    "description": "The stream that never produces any value or fails with any error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const never: Stream<never, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "onEnd",
    "description": "Adds an effect to be executed at the end of the stream.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.map((n) => n * 2),\n  Stream.tap((n) => Console.log(`after mapping: ${n}`)),\n  Stream.onEnd(Console.log(\"Stream ended\"))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// after mapping: 2\n// after mapping: 4\n// after mapping: 6\n// Stream ended\n// { _id: 'Chunk', values: [ 2, 4, 6 ] }"
    ],
    "since": "3.6.0",
    "category": "sequencing",
    "signature": "export declare const onEnd: { <_, E2, R2>(effect: Effect.Effect<_, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, _, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<_, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "onError",
    "description": "Runs the specified effect if this stream fails, providing the error to the\neffect if it exists.\n\nNote: Unlike `Effect.onError` there is no guarantee that the provided\neffect will not be interrupted.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const onError: { <E, X, R2>(cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>): Stream<A, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "onDone",
    "description": "Runs the specified effect if this stream ends.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const onDone: { <X, R2>(cleanup: () => Effect.Effect<X, never, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, cleanup: () => Effect.Effect<X, never, R2>): Stream<A, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "onStart",
    "description": "Adds an effect to be executed at the start of the stream.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.onStart(Console.log(\"Stream started\")),\n  Stream.map((n) => n * 2),\n  Stream.tap((n) => Console.log(`after mapping: ${n}`))\n)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Stream started\n// after mapping: 2\n// after mapping: 4\n// after mapping: 6\n// { _id: 'Chunk', values: [ 2, 4, 6 ] }"
    ],
    "since": "3.6.0",
    "category": "sequencing",
    "signature": "export declare const onStart: { <_, E2, R2>(effect: Effect.Effect<_, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, _, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<_, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "orDie",
    "description": "Translates any failure into a stream termination, making the stream\ninfallible and all failures unchecked.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orDie: <A, E, R>(self: Stream<A, E, R>) => Stream<A, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "orDieWith",
    "description": "Keeps none of the errors, and terminates the stream with them, using the\nspecified function to convert the `E` into a defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orDieWith: { <E>(f: (e: E) => unknown): <A, R>(self: Stream<A, E, R>) => Stream<A, never, R>; <A, E, R>(self: Stream<A, E, R>, f: (e: E) => unknown): Stream<A, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "orElse",
    "description": "Switches to the provided stream in case this one fails with a typed error.\n\nSee also `Stream.catchAll`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElse: { <A2, E2, R2>(that: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: LazyArg<Stream<A2, E2, R2>>): Stream<A | A2, E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "orElseEither",
    "description": "Switches to the provided stream in case this one fails with a typed error.\n\nSee also `Stream.catchAll`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElseEither: { <A2, E2, R2>(that: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A2, A>, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: LazyArg<Stream<A2, E2, R2>>): Stream<Either.Either<A2, A>, E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "orElseFail",
    "description": "Fails with given error in case this one fails with a typed error.\n\nSee also `Stream.catchAll`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElseFail: { <E2>(error: LazyArg<E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, error: LazyArg<E2>): Stream<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "orElseIfEmpty",
    "description": "Produces the specified element if this stream is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElseIfEmpty: { <A2>(element: LazyArg<A2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, element: LazyArg<A2>): Stream<A | A2, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "orElseIfEmptyChunk",
    "description": "Produces the specified chunk if this stream is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElseIfEmptyChunk: { <A2>(chunk: LazyArg<Chunk.Chunk<A2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, chunk: LazyArg<Chunk.Chunk<A2>>): Stream<A | A2, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "orElseIfEmptyStream",
    "description": "Switches to the provided stream in case this one is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElseIfEmptyStream: { <A2, E2, R2>(stream: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, stream: LazyArg<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "orElseSucceed",
    "description": "Succeeds with the specified value if this one fails with a typed error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const orElseSucceed: { <A2>(value: LazyArg<A2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, never, R>; <A, E, R, A2>(self: Stream<A, E, R>, value: LazyArg<A2>): Stream<A | A2, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "paginate",
    "description": "Like `Stream.unfold`, but allows the emission of values to end one step further\nthan the unfolding of the state. This is useful for embedding paginated\nAPIs, hence the name.",
    "deprecated": false,
    "examples": [
      "import { Effect, Option, Stream } from \"effect\"\n\nconst stream = Stream.paginate(0, (n) => [\n  n,\n  n < 3 ? Option.some(n + 1) : Option.none()\n])\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const paginate: <S, A>(s: S, f: (s: S) => readonly [A, Option.Option<S>]) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "paginateChunk",
    "description": "Like `Stream.unfoldChunk`, but allows the emission of values to end one step\nfurther than the unfolding of the state. This is useful for embedding\npaginated APIs, hence the name.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const paginateChunk: <S, A>(s: S, f: (s: S) => readonly [Chunk.Chunk<A>, Option.Option<S>]) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "paginateChunkEffect",
    "description": "Like `Stream.unfoldChunkEffect`, but allows the emission of values to end one step\nfurther than the unfolding of the state. This is useful for embedding\npaginated APIs, hence the name.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const paginateChunkEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<readonly [Chunk.Chunk<A>, Option.Option<S>], E, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "paginateEffect",
    "description": "Like `Stream.unfoldEffect` but allows the emission of values to end one step\nfurther than the unfolding of the state. This is useful for embedding\npaginated APIs, hence the name.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const paginateEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<readonly [A, Option.Option<S>], E, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "partition",
    "description": "Splits a stream into two substreams based on a predicate.\n\n**Details**\n\nThe `Stream.partition` function splits a stream into two parts: one for\nelements that satisfy the predicate (evaluated to `true`) and another for\nthose that do not (evaluated to `false`).\n\nThe faster stream may advance up to `bufferSize` elements ahead of the slower\none.",
    "deprecated": false,
    "examples": [
      "// Title: Partitioning a Stream into Even and Odd Numbers\nimport { Effect, Stream } from \"effect\"\n\nconst partition = Stream.range(1, 9).pipe(\n  Stream.partition((n) => n % 2 === 0, { bufferSize: 5 })\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function*() {\n    const [odds, evens] = yield* partition\n    console.log(yield* Stream.runCollect(odds))\n    console.log(yield* Stream.runCollect(evens))\n  })\n)\n\n// Effect.runPromise(program)\n// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }\n// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const partition: { <C extends A, B extends A, A = C>(refinement: Refinement<NoInfer<A>, B>, options?: { bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<C, E, R>) => Effect.Effect<[excluded: Stream<Exclude<C, B>, E, never>, satisfying: Stream<B, E, never>], E, R | Scope.Scope>; <A>(predicate: Predicate<A>, options?: { bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[excluded: Stream<A, E, never>, satisfying: Stream<A, E, never>], E, Scope.Scope | R>; <C extends A, E, R, B extends A, A = C>(self: Stream<C, E, R>, refinement: Refinement<A, B>, options?: { bufferSize?: number | undefined; } | undefined): Effect.Effect<[excluded: Stream<Exclude<C, B>, E, never>, satisfying: Stream<B, E, never>], E, R | Scope.Scope>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>, options?: { bufferSize?: number | undefined; } | undefined): Effect.Effect<[excluded: Stream<A, E, never>, satisfying: Stream<A, E, never>], E, R | Scope.Scope>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "partitionEither",
    "description": "Splits a stream into two substreams based on an effectful condition.\n\n**Details**\n\nThe `Stream.partitionEither` function is used to divide a stream into two\nparts: one for elements that satisfy a condition producing `Either.left`\nvalues, and another for those that produce `Either.right` values. This\nfunction applies an effectful predicate to each element in the stream to\ndetermine which substream it belongs to.\n\nThe faster stream may advance up to `bufferSize` elements ahead of the slower\none.",
    "deprecated": false,
    "examples": [
      "// Title: Partitioning a Stream with an Effectful Predicate\nimport { Effect, Either, Stream } from \"effect\"\n\nconst partition = Stream.range(1, 9).pipe(\n  Stream.partitionEither(\n    (n) => Effect.succeed(n % 2 === 0 ? Either.right(n) : Either.left(n)),\n    { bufferSize: 5 }\n  )\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function*() {\n    const [evens, odds] = yield* partition\n    console.log(yield* Stream.runCollect(evens))\n    console.log(yield* Stream.runCollect(odds))\n  })\n)\n\n// Effect.runPromise(program)\n// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }\n// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const partitionEither: { <A, A3, A2, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<Either.Either<A3, A2>, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[left: Stream<A2, E2 | E, never>, right: Stream<A3, E2 | E, never>], E2 | E, Scope.Scope | R2 | R>; <A, E, R, A3, A2, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<Either.Either<A3, A2>, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): Effect.Effect<[left: Stream<A2, E | E2, never>, right: Stream<A3, E | E2, never>], E | E2, Scope.Scope | R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "peel",
    "description": "Peels off enough material from the stream to construct a `Z` using the\nprovided `Sink` and then returns both the `Z` and the rest of the\n`Stream` in a scope. Like all scoped values, the provided stream is\nvalid only within the scope.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const peel: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[A2, Stream<A, E, never>], E2 | E, Scope.Scope | R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, A, E2, R2>): Effect.Effect<[A2, Stream<A, E, never>], E | E2, Scope.Scope | R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "pipeThrough",
    "description": "Pipes all of the values from this stream through the provided sink.\n\nSee also `Stream.transduce`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const pipeThrough: { <A2, A, L, E2, R2>(sink: Sink.Sink<A2, A, L, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<L, E2 | E, R2 | R>; <A, E, R, A2, L, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, L, E2, R2>): Stream<L, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "pipeThroughChannel",
    "description": "Pipes all the values from this stream through the provided channel.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const pipeThroughChannel: { <R2, E, E2, A, A2>(channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): <R>(self: Stream<A, E, R>) => Stream<A2, E2, R2 | R>; <R, R2, E, E2, A, A2>(self: Stream<A, E, R>, channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): Stream<A2, E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "pipeThroughChannelOrFail",
    "description": "Pipes all values from this stream through the provided channel, passing\nthrough any error emitted by this stream unchanged.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const pipeThroughChannelOrFail: { <R2, E, E2, A, A2>(chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): <R>(self: Stream<A, E, R>) => Stream<A2, E | E2, R2 | R>; <R, R2, E, E2, A, A2>(self: Stream<A, E, R>, chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): Stream<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "prepend",
    "description": "Emits the provided chunk before emitting any other value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const prepend: { <B>(values: Chunk.Chunk<B>): <A, E, R>(self: Stream<A, E, R>) => Stream<B | A, E, R>; <A, E, R, B>(self: Stream<A, E, R>, values: Chunk.Chunk<B>): Stream<A | B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "provideContext",
    "description": "Provides the stream with its required context, which eliminates its\ndependency on `R`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideContext: { <R>(context: Context.Context<R>): <A, E>(self: Stream<A, E, R>) => Stream<A, E>; <A, E, R>(self: Stream<A, E, R>, context: Context.Context<R>): Stream<A, E>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "provideLayer",
    "description": "Provides a `Layer` to the stream, which translates it to another level.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideLayer: { <RIn, E2, ROut>(layer: Layer.Layer<ROut, E2, RIn>): <A, E>(self: Stream<A, E, ROut>) => Stream<A, E2 | E, RIn>; <A, E, RIn, E2, ROut>(self: Stream<A, E, ROut>, layer: Layer.Layer<ROut, E2, RIn>): Stream<A, E | E2, RIn>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "provideService",
    "description": "Provides the stream with the single service it requires. If the stream\nrequires more than one service use `Stream.provideContext` instead.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideService: { <I, S>(tag: Context.Tag<I, S>, resource: NoInfer<S>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, resource: NoInfer<S>): Stream<A, E, Exclude<R, I>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "provideServiceEffect",
    "description": "Provides the stream with the single service it requires. If the stream\nrequires more than one service use `Stream.provideContext` instead.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideServiceEffect: { <I, S, E2, R2>(tag: Context.Tag<I, S>, effect: Effect.Effect<NoInfer<S>, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | Exclude<R, I>>; <A, E, R, I, S, E2, R2>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, effect: Effect.Effect<NoInfer<S>, E2, R2>): Stream<A, E2 | E, R2 | Exclude<R, I>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "provideServiceStream",
    "description": "Provides the stream with the single service it requires. If the stream\nrequires more than one service use `Stream.provideContext` instead.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideServiceStream: { <I, S, E2, R2>(tag: Context.Tag<I, S>, stream: Stream<NoInfer<S>, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | Exclude<R, I>>; <A, E, R, I, S, E2, R2>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, stream: Stream<NoInfer<S>, E2, R2>): Stream<A, E2 | E, R2 | Exclude<R, I>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "mapInputContext",
    "description": "Transforms the context being provided to the stream with the specified\nfunction.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const mapInputContext: { <R0, R>(f: (env: Context.Context<R0>) => Context.Context<R>): <A, E>(self: Stream<A, E, R>) => Stream<A, E, R0>; <A, E, R0, R>(self: Stream<A, E, R>, f: (env: Context.Context<R0>) => Context.Context<R>): Stream<A, E, R0>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "provideSomeLayer",
    "description": "Splits the context into two parts, providing one part using the\nspecified layer and leaving the remainder `R0`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const provideSomeLayer: { <RIn, E2, ROut>(layer: Layer.Layer<ROut, E2, RIn>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, RIn | Exclude<R, ROut>>; <A, E, R, RIn, E2, ROut>(self: Stream<A, E, R>, layer: Layer.Layer<ROut, E2, RIn>): Stream<A, E | E2, RIn | Exclude<R, ROut>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "race",
    "description": "Returns a stream that mirrors the first upstream to emit an item.\nAs soon as one of the upstream emits a first value, the other is interrupted.\nThe resulting stream will forward all items from the \"winning\" source stream.\nAny upstream failures will cause the returned stream to fail.",
    "deprecated": false,
    "examples": [
      "import { Stream, Schedule, Console, Effect } from \"effect\"\n\nconst stream = Stream.fromSchedule(Schedule.spaced('2 millis')).pipe(\n  Stream.race(Stream.fromSchedule(Schedule.spaced('1 millis'))),\n  Stream.take(6),\n  Stream.tap(Console.log)\n)\n\nEffect.runPromise(Stream.runDrain(stream))\n// Output each millisecond from the first stream, the rest streams are interrupted\n// 0\n// 1\n// 2\n// 3\n// 4\n// 5"
    ],
    "since": "3.7.0",
    "category": "racing",
    "signature": "export declare const race: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL | AR, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL | AR, EL | ER, RL | RR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "raceAll",
    "description": "Returns a stream that mirrors the first upstream to emit an item.\nAs soon as one of the upstream emits a first value, all the others are interrupted.\nThe resulting stream will forward all items from the \"winning\" source stream.\nAny upstream failures will cause the returned stream to fail.",
    "deprecated": false,
    "examples": [
      "import { Stream, Schedule, Console, Effect } from \"effect\"\n\nconst stream = Stream.raceAll(\n  Stream.fromSchedule(Schedule.spaced('1 millis')),\n  Stream.fromSchedule(Schedule.spaced('2 millis')),\n  Stream.fromSchedule(Schedule.spaced('4 millis')),\n).pipe(Stream.take(6), Stream.tap(Console.log))\n\nEffect.runPromise(Stream.runDrain(stream))\n// Output each millisecond from the first stream, the rest streams are interrupted\n// 0\n// 1\n// 2\n// 3\n// 4\n// 5"
    ],
    "since": "3.5.0",
    "category": "racing",
    "signature": "export declare const raceAll: <S extends ReadonlyArray<Stream<any, any, any>>>(...streams: S) => Stream<Stream.Success<S[number]>, Stream.Error<S[number]>, Stream.Context<S[number]>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "range",
    "description": "Constructs a stream from a range of integers, including both endpoints.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\n// A Stream with a range of numbers from 1 to 5\nconst stream = Stream.range(1, 5)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const range: (min: number, max: number, chunkSize?: number) => Stream<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "rechunk",
    "description": "Re-chunks the elements of the stream into chunks of `n` elements each. The\nlast chunk might contain less than `n` elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const rechunk: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "refineOrDie",
    "description": "Keeps some of the errors, and terminates the fiber with the rest",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const refineOrDie: { <E, E2>(pf: (error: E) => Option.Option<E2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<E2>): Stream<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "refineOrDieWith",
    "description": "Keeps some of the errors, and terminates the fiber with the rest, using the\nspecified function to convert the `E` into a defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "error handling",
    "signature": "export declare const refineOrDieWith: { <E, E2>(pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): Stream<A, E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "repeat",
    "description": "Repeats the entire stream using the specified schedule. The stream will\nexecute normally, and then repeat again according to the provided schedule.",
    "deprecated": false,
    "examples": [
      "import { Effect, Schedule, Stream } from \"effect\"\n\nconst stream = Stream.repeat(Stream.succeed(1), Schedule.forever)\n\n// Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// { _id: 'Chunk', values: [ 1, 1, 1, 1, 1 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const repeat: { <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<A, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "repeatEffect",
    "description": "Creates a stream from an effect producing a value of type `A` which repeats\nforever.",
    "deprecated": false,
    "examples": [
      "import { Effect, Random, Stream } from \"effect\"\n\nconst stream = Stream.repeatEffect(Random.nextInt)\n\n// Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// Example Output: { _id: 'Chunk', values: [ 3891571149, 4239494205, 2352981603, 2339111046, 1488052210 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const repeatEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "repeatEffectChunk",
    "description": "Creates a stream from an effect producing chunks of `A` values which\nrepeats forever.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const repeatEffectChunk: <A, E, R>(effect: Effect.Effect<Chunk.Chunk<A>, E, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "repeatEffectChunkOption",
    "description": "Creates a stream from an effect producing chunks of `A` values until it\nfails with `None`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const repeatEffectChunkOption: <A, E, R>(effect: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "repeatEffectOption",
    "description": "Creates a stream from an effect producing values of type `A` until it fails\nwith `None`.",
    "deprecated": false,
    "examples": [
      "// In this example, we're draining an Iterator to create a stream from it\nimport { Stream, Effect, Option } from \"effect\"\n\nconst drainIterator = <A>(it: Iterator<A>): Stream.Stream<A> =>\n  Stream.repeatEffectOption(\n    Effect.sync(() => it.next()).pipe(\n      Effect.andThen((res) => {\n        if (res.done) {\n          return Effect.fail(Option.none())\n        }\n        return Effect.succeed(res.value)\n      })\n    )\n  )"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const repeatEffectOption: <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "repeatEffectWithSchedule",
    "description": "Creates a stream from an effect producing a value of type `A`, which is\nrepeated using the specified schedule.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const repeatEffectWithSchedule: <A, E, R, X, A0 extends A, R2>(effect: Effect.Effect<A, E, R>, schedule: Schedule.Schedule<X, A0, R2>) => Stream<A, E, R | R2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "repeatEither",
    "description": "Repeats the entire stream using the specified schedule. The stream will\nexecute normally, and then repeat again according to the provided schedule.\nThe schedule output will be emitted at the end of each repetition.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const repeatEither: { <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A, B>, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<Either.Either<A, B>, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "repeatElements",
    "description": "Repeats each element of the stream using the provided schedule. Repetitions\nare done in addition to the first execution, which means using\n`Schedule.recurs(1)` actually results in the original effect, plus an\nadditional recurrence, for a total of two repetitions of each value in the\nstream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const repeatElements: { <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<A, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "repeatElementsWith",
    "description": "Repeats each element of the stream using the provided schedule. When the\nschedule is finished, then the output of the schedule will be emitted into\nthe stream. Repetitions are done in addition to the first execution, which\nmeans using `Schedule.recurs(1)` actually results in the original effect,\nplus an additional recurrence, for a total of two repetitions of each value\nin the stream.\n\nThis function accepts two conversion functions, which allow the output of\nthis stream and the output of the provided schedule to be unified into a\nsingle type. For example, `Either` or similar data type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const repeatElementsWith: { <B, R2, A, C>(schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, R2, C>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "repeatValue",
    "description": "Repeats the provided value infinitely.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.repeatValue(0)\n\n// Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// { _id: 'Chunk', values: [ 0, 0, 0, 0, 0 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const repeatValue: <A>(value: A) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "repeatWith",
    "description": "Repeats the entire stream using the specified schedule. The stream will\nexecute normally, and then repeat again according to the provided schedule.\nThe schedule output will be emitted at the end of each repetition and can\nbe unified with the stream elements using the provided functions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const repeatWith: { <B, R2, A, C>(schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, R2, C>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "retry",
    "description": "When the stream fails, retry it according to the given schedule\n\nThis retries the entire stream, so will re-execute all of the stream's\nacquire operations.\n\nThe schedule is reset as soon as the first element passes through the\nstream again.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const retry: { <E0 extends E, R2, E, X>(schedule: Schedule.Schedule<X, E0, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, E0 extends E, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<X, E0, R2>): Stream<A, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "run",
    "description": "Runs the sink on the stream to produce either the sink's result or an error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const run: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<A2, E2 | E, Exclude<R | R2, Scope.Scope>>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, unknown, E2, R2>): Effect.Effect<A2, E | E2, Exclude<R | R2, Scope.Scope>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runCollect",
    "description": "Runs the stream and collects all of its elements to a chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runCollect: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Chunk.Chunk<A>, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runCount",
    "description": "Runs the stream and emits the number of elements processed",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runCount: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<number, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runDrain",
    "description": "Runs the stream only for its effects. The emitted elements are discarded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runDrain: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runFold",
    "description": "Executes a pure fold over the stream of values - reduces all elements in\nthe stream to a value of type `S`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runFold: { <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect.Effect<S, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runFoldEffect",
    "description": "Executes an effectful fold over the stream of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runFoldEffect: { <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Exclude<R | R2, Scope.Scope>>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Exclude<R | R2, Scope.Scope>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runFoldScoped",
    "description": "Executes a pure fold over the stream of values. Returns a scoped value that\nrepresents the scope of the stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runFoldScoped: { <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, Scope.Scope | R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect.Effect<S, E, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runFoldScopedEffect",
    "description": "Executes an effectful fold over the stream of values. Returns a scoped\nvalue that represents the scope of the stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runFoldScopedEffect: { <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Scope.Scope | R2 | R>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Scope.Scope | R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runFoldWhile",
    "description": "Reduces the elements in the stream to a value of type `S`. Stops the fold\nearly when the condition is not fulfilled. Example:",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runFoldWhile: { <S, A>(s: S, cont: Predicate<S>, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => S): Effect.Effect<S, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runFoldWhileEffect",
    "description": "Executes an effectful fold over the stream of values. Stops the fold early\nwhen the condition is not fulfilled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runFoldWhileEffect: { <S, A, E2, R2>(s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Exclude<R | R2, Scope.Scope>>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Exclude<R | R2, Scope.Scope>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runFoldWhileScoped",
    "description": "Executes a pure fold over the stream of values. Returns a scoped value that\nrepresents the scope of the stream. Stops the fold early when the condition\nis not fulfilled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runFoldWhileScoped: { <S, A>(s: S, cont: Predicate<S>, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, Scope.Scope | R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => S): Effect.Effect<S, E, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runFoldWhileScopedEffect",
    "description": "Executes an effectful fold over the stream of values. Returns a scoped\nvalue that represents the scope of the stream. Stops the fold early when\nthe condition is not fulfilled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runFoldWhileScopedEffect: { <S, A, E2, R2>(s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, R2 | R | Scope.Scope>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Scope.Scope | R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runForEach",
    "description": "Consumes all elements of the stream, passing them to the specified\ncallback.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runForEach: { <A, X, E2, R2>(f: (a: A) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runForEachChunk",
    "description": "Consumes all elements of the stream, passing them to the specified\ncallback.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runForEachChunk: { <A, X, E2, R2>(f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runForEachChunkScoped",
    "description": "Like `Stream.runForEachChunk`, but returns a scoped effect so the\nfinalization order can be controlled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runForEachChunkScoped: { <A, X, E2, R2>(f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runForEachScoped",
    "description": "Like `Stream.forEach`, but returns a scoped effect so the finalization\norder can be controlled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runForEachScoped: { <A, X, E2, R2>(f: (a: A) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runForEachWhile",
    "description": "Consumes elements of the stream, passing them to the specified callback,\nand terminating consumption when the callback returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runForEachWhile: { <A, E2, R2>(f: (a: A) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Effect.Effect<void, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runForEachWhileScoped",
    "description": "Like `Stream.runForEachWhile`, but returns a scoped effect so the\nfinalization order can be controlled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runForEachWhileScoped: { <A, E2, R2>(f: (a: A) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runHead",
    "description": "Runs the stream to completion and yields the first value emitted by it,\ndiscarding the rest of the elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runHead: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runIntoPubSub",
    "description": "Publishes elements of this stream to a `PubSub`. Stream failure and ending will\nalso be signalled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runIntoPubSub: { <A, E>(pubsub: PubSub.PubSub<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, R>; <A, E, R>(self: Stream<A, E, R>, pubsub: PubSub.PubSub<Take.Take<A, E>>): Effect.Effect<void, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runIntoPubSubScoped",
    "description": "Like `Stream.runIntoPubSub`, but provides the result as a scoped effect to\nallow for scope composition.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runIntoPubSubScoped: { <A, E>(pubsub: PubSub.PubSub<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, pubsub: PubSub.PubSub<Take.Take<A, E>>): Effect.Effect<void, never, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runIntoQueue",
    "description": "Enqueues elements of this stream into a queue. Stream failure and ending\nwill also be signalled.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runIntoQueue: { <A, E>(queue: Queue.Enqueue<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, R>; <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Take.Take<A, E>>): Effect.Effect<void, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runIntoQueueElementsScoped",
    "description": "Like `Stream.runIntoQueue`, but provides the result as a scoped [[ZIO]]\nto allow for scope composition.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runIntoQueueElementsScoped: { <A, E>(queue: Queue.Enqueue<Exit.Exit<A, Option.Option<E>>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Exit.Exit<A, Option.Option<E>>>): Effect.Effect<void, never, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runIntoQueueScoped",
    "description": "Like `Stream.runIntoQueue`, but provides the result as a scoped effect\nto allow for scope composition.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runIntoQueueScoped: { <A, E>(queue: Queue.Enqueue<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Take.Take<A, E>>): Effect.Effect<void, never, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runLast",
    "description": "Runs the stream to completion and yields the last value emitted by it,\ndiscarding the rest of the elements.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runLast: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runScoped",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runScoped: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<A2, E2 | E, Scope.Scope | R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, unknown, E2, R2>): Effect.Effect<A2, E | E2, Scope.Scope | R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "runSum",
    "description": "Runs the stream to a sink which sums elements, provided they are Numeric.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const runSum: <E, R>(self: Stream<number, E, R>) => Effect.Effect<number, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "scan",
    "description": "Statefully maps over the elements of this stream to produce all\nintermediate results of type `S` given an initial S.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.range(1, 6).pipe(Stream.scan(0, (a, b) => a + b))\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0,  1,  3, 6, 10, 15, 21 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const scan: { <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Stream<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Stream<S, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "scanEffect",
    "description": "Statefully and effectfully maps over the elements of this stream to produce\nall intermediate results of type `S` given an initial S.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const scanEffect: { <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<S, E2 | E, R2 | R>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Stream<S, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "scanReduce",
    "description": "Statefully maps over the elements of this stream to produce all\nintermediate results.\n\nSee also `Stream.scan`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const scanReduce: { <A2, A>(f: (a2: A2 | A, a: A) => A2): <E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a2: A | A2, a: A) => A2): Stream<A | A2, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "scanReduceEffect",
    "description": "Statefully and effectfully maps over the elements of this stream to produce\nall intermediate results.\n\nSee also `Stream.scanEffect`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const scanReduceEffect: { <A2, A, E2, R2>(f: (a2: A2 | A, a: A) => Effect.Effect<A2 | A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a2: A | A2, a: A) => Effect.Effect<A | A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "schedule",
    "description": "Schedules the output of the stream using the provided `schedule`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const schedule: { <X, A0 extends A, R2, A>(schedule: Schedule.Schedule<X, A0, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, A0 extends A, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<X, A0, R2>): Stream<A, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "scheduleWith",
    "description": "Schedules the output of the stream using the provided `schedule` and emits\nits output at the end (if `schedule` is finite). Uses the provided function\nto align the stream and schedule outputs on the same type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const scheduleWith: { <B, A0 extends A, R2, A, C>(schedule: Schedule.Schedule<B, A0, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, A0 extends A, R2, C>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, A0, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "scoped",
    "description": "Creates a single-valued stream from a scoped resource.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect, Stream } from \"effect\"\n\n// Creating a single-valued stream from a scoped resource\nconst stream = Stream.scoped(\n Effect.acquireRelease(\n   Console.log(\"acquire\"),\n   () => Console.log(\"release\")\n )\n).pipe(\n Stream.flatMap(() => Console.log(\"use\"))\n)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// acquire\n// use\n// release\n// { _id: 'Chunk', values: [ undefined ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const scoped: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, Exclude<R, Scope.Scope>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "scopedWith",
    "description": "Use a function that receives a scope and returns an effect to emit an output\nelement. The output element will be the result of the returned effect, if\nsuccessful.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "export declare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect.Effect<A, E, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "sliding",
    "description": "Emits a sliding window of `n` elements.\n\n```ts\nimport * as Stream from \"./Stream\"\nimport { pipe } from \"./Function\"\n\npipe(\n  Stream.make(1, 2, 3, 4),\n  Stream.sliding(2),\n  Stream.runCollect\n)\n// => Chunk(Chunk(1, 2), Chunk(2, 3), Chunk(3, 4))\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const sliding: { (chunkSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number): Stream<Chunk.Chunk<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "slidingSize",
    "description": "Like `sliding`, but with a configurable `stepSize` parameter.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const slidingSize: { (chunkSize: number, stepSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number, stepSize: number): Stream<Chunk.Chunk<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": "Converts an option on values into an option on errors.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const some: <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A, Option.Option<E>, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "someOrElse",
    "description": "Extracts the optional value, or returns the given 'default'.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const someOrElse: { <A2>(fallback: LazyArg<A2>): <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<Option.Option<A>, E, R>, fallback: LazyArg<A2>): Stream<A | A2, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "someOrFail",
    "description": "Extracts the optional value, or fails with the given error 'e'.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const someOrFail: { <E2>(error: LazyArg<E2>): <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<Option.Option<A>, E, R>, error: LazyArg<E2>): Stream<A, E | E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "split",
    "description": "Splits elements based on a predicate or refinement.\n\n```ts\nimport * as Stream from \"./Stream\"\nimport { pipe } from \"./Function\"\n\npipe(\n  Stream.range(1, 10),\n  Stream.split((n) => n % 4 === 0),\n  Stream.runCollect\n)\n// => Chunk(Chunk(1, 2, 3), Chunk(5, 6, 7), Chunk(9))\n```",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const split: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<Exclude<A, B>>, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<Chunk.Chunk<Exclude<A, B>>, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<Chunk.Chunk<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "splitOnChunk",
    "description": "Splits elements on a delimiter and transforms the splits into desired output.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const splitOnChunk: { <A>(delimiter: Chunk.Chunk<A>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, delimiter: Chunk.Chunk<A>): Stream<Chunk.Chunk<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "splitLines",
    "description": "Splits strings on newlines. Handles both Windows newlines (`\\r\\n`) and UNIX\nnewlines (`\\n`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const splitLines: <E, R>(self: Stream<string, E, R>) => Stream<string, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": "Creates a single-valued pure stream.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\n// A Stream with a single number\nconst stream = Stream.succeed(3)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 3 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const succeed: <A>(value: A) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "sync",
    "description": "Creates a single-valued pure stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sync: <A>(evaluate: LazyArg<A>) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "suspend",
    "description": "Returns a lazily constructed stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const suspend: <A, E, R>(stream: LazyArg<Stream<A, E, R>>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "take",
    "description": "Takes the specified number of elements from this stream.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.take(Stream.iterate(0, (n) => n + 1), 5)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const take: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "takeRight",
    "description": "Takes the last specified number of elements from this stream.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.takeRight(Stream.make(1, 2, 3, 4, 5, 6), 3)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 4, 5, 6 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const takeRight: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "takeUntil",
    "description": "Takes all elements of the stream until the specified predicate evaluates to\n`true`.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.takeUntil(Stream.iterate(0, (n) => n + 1), (n) => n === 4)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const takeUntil: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "takeUntilEffect",
    "description": "Takes all elements of the stream until the specified effectual predicate\nevaluates to `true`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const takeUntilEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "takeWhile",
    "description": "Takes all elements of the stream for as long as the specified predicate\nevaluates to `true`.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.takeWhile(Stream.iterate(0, (n) => n + 1), (n) => n < 5)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const takeWhile: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "tap",
    "description": "Adds an effect to consumption of every element of the stream.",
    "deprecated": false,
    "examples": [
      "import { Console, Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.tap((n) => Console.log(`before mapping: ${n}`)),\n  Stream.map((n) => n * 2),\n  Stream.tap((n) => Console.log(`after mapping: ${n}`))\n)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// before mapping: 1\n// after mapping: 2\n// before mapping: 2\n// after mapping: 4\n// before mapping: 3\n// after mapping: 6\n// { _id: 'Chunk', values: [ 2, 4, 6 ] }"
    ],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const tap: { <A, X, E2, R2>(f: (a: NoInfer<A>) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: NoInfer<A>) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "tapBoth",
    "description": "Returns a stream that effectfully \"peeks\" at the failure or success of\nthe stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const tapBoth: { <E, X1, E2, R2, A, X2, E3, R3>(options: { readonly onFailure: (e: NoInfer<E>) => Effect.Effect<X1, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect.Effect<X2, E3, R3>; }): <R>(self: Stream<A, E, R>) => Stream<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, X1, E2, R2, X2, E3, R3>(self: Stream<A, E, R>, options: { readonly onFailure: (e: NoInfer<E>) => Effect.Effect<X1, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect.Effect<X2, E3, R3>; }): Stream<A, E | E2 | E3, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "tapError",
    "description": "Returns a stream that effectfully \"peeks\" at the failure of the stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const tapError: { <E, X, E2, R2>(f: (error: NoInfer<E>) => Effect.Effect<X, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (error: E) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "tapErrorCause",
    "description": "Returns a stream that effectfully \"peeks\" at the cause of failure of the\nstream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const tapErrorCause: { <E, X, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Effect.Effect<X, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "tapSink",
    "description": "Sends all elements emitted by this stream to the specified sink in addition\nto emitting them.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const tapSink: { <A, E2, R2>(sink: Sink.Sink<unknown, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<unknown, A, unknown, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "throttle",
    "description": "Delays the chunks of this stream according to the given bandwidth\nparameters using the token bucket algorithm. Allows for burst in the\nprocessing of elements by allowing the token bucket to accumulate tokens up\nto a `units + burst` threshold. The weight of each chunk is determined by\nthe `cost` function.\n\nIf using the \"enforce\" strategy, chunks that do not meet the bandwidth\nconstraints are dropped. If using the \"shape\" strategy, chunks are delayed\nuntil they can be emitted without exceeding the bandwidth constraints.\n\nDefaults to the \"shape\" strategy.",
    "deprecated": false,
    "examples": [
      "import { Chunk, Effect, Schedule, Stream } from \"effect\"\n\nlet last = Date.now()\nconst log = (message: string) =>\n  Effect.sync(() => {\n    const end = Date.now()\n    console.log(`${message} after ${end - last}ms`)\n    last = end\n  })\n\nconst stream = Stream.fromSchedule(Schedule.spaced(\"50 millis\")).pipe(\n  Stream.take(6),\n  Stream.tap((n) => log(`Received ${n}`)),\n  Stream.throttle({\n    cost: Chunk.size,\n    duration: \"100 millis\",\n    units: 1\n  }),\n  Stream.tap((n) => log(`> Emitted ${n}`))\n)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Received 0 after 56ms\n// > Emitted 0 after 0ms\n// Received 1 after 52ms\n// > Emitted 1 after 48ms\n// Received 2 after 52ms\n// > Emitted 2 after 49ms\n// Received 3 after 52ms\n// > Emitted 3 after 48ms\n// Received 4 after 52ms\n// > Emitted 4 after 47ms\n// Received 5 after 52ms\n// > Emitted 5 after 49ms\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4, 5 ] }"
    ],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const throttle: { <A>(options: { readonly cost: (chunk: Chunk.Chunk<A>) => number; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: \"enforce\" | \"shape\" | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly cost: (chunk: Chunk.Chunk<A>) => number; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: \"enforce\" | \"shape\" | undefined; }): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "throttleEffect",
    "description": "Delays the chunks of this stream according to the given bandwidth\nparameters using the token bucket algorithm. Allows for burst in the\nprocessing of elements by allowing the token bucket to accumulate tokens up\nto a `units + burst` threshold. The weight of each chunk is determined by\nthe effectful `costFn` function.\n\nIf using the \"enforce\" strategy, chunks that do not meet the bandwidth\nconstraints are dropped. If using the \"shape\" strategy, chunks are delayed\nuntil they can be emitted without exceeding the bandwidth constraints.\n\nDefaults to the \"shape\" strategy.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const throttleEffect: { <A, E2, R2>(options: { readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: \"enforce\" | \"shape\" | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, options: { readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: \"enforce\" | \"shape\" | undefined; }): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "tick",
    "description": "A stream that emits void values spaced by the specified duration.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nlet last = Date.now()\nconst log = (message: string) =>\n  Effect.sync(() => {\n    const end = Date.now()\n    console.log(`${message} after ${end - last}ms`)\n    last = end\n  })\n\nconst stream = Stream.tick(\"1 seconds\").pipe(Stream.tap(() => log(\"tick\")))\n\n// Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// tick after 4ms\n// tick after 1003ms\n// tick after 1001ms\n// tick after 1002ms\n// tick after 1002ms\n// { _id: 'Chunk', values: [ undefined, undefined, undefined, undefined, undefined ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const tick: (interval: Duration.DurationInput) => Stream<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "timeout",
    "description": "Ends the stream if it does not produce a value after the specified duration.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const timeout: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "timeoutFail",
    "description": "Fails the stream with given error if it does not produce a value after d\nduration.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const timeoutFail: { <E2>(error: LazyArg<E2>, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<A, E, R>, error: LazyArg<E2>, duration: Duration.DurationInput): Stream<A, E | E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "timeoutFailCause",
    "description": "Fails the stream with given cause if it does not produce a value after d\nduration.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const timeoutFailCause: { <E2>(cause: LazyArg<Cause.Cause<E2>>, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<A, E, R>, cause: LazyArg<Cause.Cause<E2>>, duration: Duration.DurationInput): Stream<A, E | E2, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "timeoutTo",
    "description": "Switches the stream if it does not produce a value after the specified\nduration.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const timeoutTo: { <A2, E2, R2>(duration: Duration.DurationInput, that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, duration: Duration.DurationInput, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "toPubSub",
    "description": "Converts the stream to a scoped `PubSub` of chunks. After the scope is closed,\nthe `PubSub` will never again produce values and should be discarded.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toPubSub: { (capacity: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, capacity: number | { readonly capacity: \"unbounded\"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined; readonly replay?: number | undefined; }): Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "toPull",
    "description": "Returns in a scope a ZIO effect that can be used to repeatedly pull chunks\nfrom the stream. The pull effect fails with None when the stream is\nfinished, or with Some error if it fails, otherwise it returns a chunk of\nthe stream's output.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\n// Simulate a chunked stream\nconst stream = Stream.fromIterable([1, 2, 3, 4, 5]).pipe(Stream.rechunk(2))\n\nconst program = Effect.gen(function*() {\n  // Create an effect to get data chunks from the stream\n  const getChunk = yield* Stream.toPull(stream)\n\n  // Continuously fetch and process chunks\n  while (true) {\n    const chunk = yield* getChunk\n    console.log(chunk)\n  }\n})\n\n// Effect.runPromise(Effect.scoped(program)).then(console.log, console.error)\n// { _id: 'Chunk', values: [ 1, 2 ] }\n// { _id: 'Chunk', values: [ 3, 4 ] }\n// { _id: 'Chunk', values: [ 5 ] }\n// (FiberFailure) Error: {\n//   \"_id\": \"Option\",\n//   \"_tag\": \"None\"\n// }"
    ],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toPull: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>, never, Scope.Scope | R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "toQueue",
    "description": "Converts the stream to a scoped queue of chunks. After the scope is closed,\nthe queue will never again produce values and should be discarded.\n\nDefaults to the \"suspend\" back pressure strategy with a capacity of 2.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toQueue: { (options?: { readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; readonly capacity?: number | undefined; } | { readonly strategy: \"unbounded\"; } | undefined): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; readonly capacity?: number | undefined; } | { readonly strategy: \"unbounded\"; } | undefined): Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "toQueueOfElements",
    "description": "Converts the stream to a scoped queue of elements. After the scope is\nclosed, the queue will never again produce values and should be discarded.\n\nDefaults to a capacity of 2.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toQueueOfElements: { (options?: { readonly capacity?: number | undefined; } | undefined): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly capacity?: number | undefined; } | undefined): Effect.Effect<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>, never, Scope.Scope | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "toReadableStream",
    "description": "Converts the stream to a `ReadableStream`.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toReadableStream: { <A>(options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): <E>(self: Stream<A, E>) => ReadableStream<A>; <A, E>(self: Stream<A, E>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): ReadableStream<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "toReadableStreamEffect",
    "description": "Converts the stream to a `Effect<ReadableStream>`.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toReadableStreamEffect: { <A>(options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): <E, R>(self: Stream<A, E, R>) => Effect.Effect<ReadableStream<A>, never, R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): Effect.Effect<ReadableStream<A>, never, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "toReadableStreamRuntime",
    "description": "Converts the stream to a `ReadableStream` using the provided runtime.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toReadableStreamRuntime: { <A, XR>(runtime: Runtime<XR>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): <E, R extends XR>(self: Stream<A, E, R>) => ReadableStream<A>; <A, E, XR, R extends XR>(self: Stream<A, E, R>, runtime: Runtime<XR>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): ReadableStream<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "transduce",
    "description": "Applies the transducer to the stream and emits its outputs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const transduce: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, A, E2, R2>): Stream<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "unfold",
    "description": "Creates a stream by peeling off the \"layers\" of a value of type `S`.",
    "deprecated": false,
    "examples": [
      "import { Effect, Option, Stream } from \"effect\"\n\nconst stream = Stream.unfold(1, (n) => Option.some([n, n + 1]))\n\n// Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unfold: <S, A>(s: S, f: (s: S) => Option.Option<readonly [A, S]>) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "unfoldChunk",
    "description": "Creates a stream by peeling off the \"layers\" of a value of type `S`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unfoldChunk: <S, A>(s: S, f: (s: S) => Option.Option<readonly [Chunk.Chunk<A>, S]>) => Stream<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "unfoldChunkEffect",
    "description": "Creates a stream by effectfully peeling off the \"layers\" of a value of type\n`S`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unfoldChunkEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<Option.Option<readonly [Chunk.Chunk<A>, S]>, E, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "unfoldEffect",
    "description": "Creates a stream by effectfully peeling off the \"layers\" of a value of type\n`S`.",
    "deprecated": false,
    "examples": [
      "import { Effect, Option, Random, Stream } from \"effect\"\n\nconst stream = Stream.unfoldEffect(1, (n) =>\n  Random.nextBoolean.pipe(\n    Effect.map((b) => (b ? Option.some([n, -n]) : Option.some([n, n])))\n  ))\n\n// Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// { _id: 'Chunk', values: [ 1, -1, -1, -1, -1 ] }"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unfoldEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<Option.Option<readonly [A, S]>, E, R>) => Stream<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "unwrap",
    "description": "Creates a stream produced from an `Effect`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unwrap: <A, E2, R2, E, R>(effect: Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R | R2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "unwrapScoped",
    "description": "Creates a stream produced from a scoped `Effect`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unwrapScoped: <A, E2, R2, E, R>(effect: Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R2 | Exclude<R, Scope.Scope>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "unwrapScopedWith",
    "description": "Creates a stream produced from a function which receives a `Scope` and\nreturns an `Effect`. The resulting stream will emit a single element, which\nwill be the result of the returned effect, if successful.",
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": "constructors",
    "signature": "export declare const unwrapScopedWith: <A, E2, R2, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R | R2>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "updateService",
    "description": "Updates the specified service within the context of the `Stream`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const updateService: { <I, S>(tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, I | R>; <A, E, R, I, S>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): Stream<A, E, I | R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "when",
    "description": "Returns the specified stream if the given condition is satisfied, otherwise\nreturns an empty stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const when: { (test: LazyArg<boolean>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, test: LazyArg<boolean>): Stream<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "whenCase",
    "description": "Returns the resulting stream when the given `PartialFunction` is defined\nfor the given value, otherwise returns an empty stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const whenCase: <A, A2, E, R>(evaluate: LazyArg<A>, pf: (a: A) => Option.Option<Stream<A2, E, R>>) => Stream<A2, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "whenCaseEffect",
    "description": "Returns the stream when the given partial function is defined for the given\neffectful value, otherwise returns an empty stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const whenCaseEffect: { <A, A2, E2, R2>(pf: (a: A) => Option.Option<Stream<A2, E2, R2>>): <E, R>(self: Effect.Effect<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect.Effect<A, E, R>, pf: (a: A) => Option.Option<Stream<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "whenEffect",
    "description": "Returns the stream if the given effectful condition is satisfied, otherwise\nreturns an empty stream.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const whenEffect: { <E2, R2>(effect: Effect.Effect<boolean, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "withSpan",
    "description": "Wraps the stream with a new span for tracing.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tracing",
    "signature": "export declare const withSpan: { (name: string, options?: Tracer.SpanOptions | undefined): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, Tracer.ParentSpan>>; <A, E, R>(self: Stream<A, E, R>, name: string, options?: Tracer.SpanOptions | undefined): Stream<A, E, Exclude<R, Tracer.ParentSpan>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zip",
    "description": "Zips this stream with another point-wise and emits tuples of elements from\nboth streams.\n\nThe new stream will end when one of the sides ends.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\n// We create two streams and zip them together.\nconst stream = Stream.zip(\n  Stream.make(1, 2, 3, 4, 5, 6),\n  Stream.make(\"a\", \"b\", \"c\")\n)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ [ 1, 'a' ], [ 2, 'b' ], [ 3, 'c' ] ] }"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zip: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<[A, A2], E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipFlatten",
    "description": "Zips this stream with another point-wise and emits tuples of elements from\nboth streams.\n\nThe new stream will end when one of the sides ends.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipFlatten: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A extends ReadonlyArray<any>, E, R>(self: Stream<A, E, R>) => Stream<[...A, A2], E2 | E, R2 | R>; <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<[...A, A2], E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipAll",
    "description": "Zips this stream with another point-wise, creating a new stream of pairs of\nelements from both sides.\n\nThe defaults `defaultLeft` and `defaultRight` will be used if the streams\nhave different lengths and one of the streams has ended before the other.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipAll(Stream.make(1, 2, 3, 4, 5, 6), {\n  other: Stream.make(\"a\", \"b\", \"c\"),\n  defaultSelf: 0,\n  defaultOther: \"x\"\n})\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: \"Chunk\", values: [ [ 1, \"a\" ], [ 2, \"b\" ], [ 3, \"c\" ], [ 4, \"x\" ], [ 5, \"x\" ], [ 6, \"x\" ] ] }"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipAll: { <A2, E2, R2, A>(options: { readonly other: Stream<A2, E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; }): <E, R>(self: Stream<A, E, R>) => Stream<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, options: { readonly other: Stream<A2, E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; }): Stream<[A, A2], E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipAllLeft",
    "description": "Zips this stream with another point-wise, and keeps only elements from this\nstream.\n\nThe provided default value will be used if the other stream ends before\nthis one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipAllLeft: { <A2, E2, R2, A>(that: Stream<A2, E2, R2>, defaultLeft: A): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, defaultLeft: A): Stream<A, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipAllRight",
    "description": "Zips this stream with another point-wise, and keeps only elements from the\nother stream.\n\nThe provided default value will be used if this stream ends before the\nother one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipAllRight: { <A2, E2, R2>(that: Stream<A2, E2, R2>, defaultRight: A2): <A, E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, defaultRight: A2): Stream<A2, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipAllSortedByKey",
    "description": "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Combines values associated with each key into a tuple,\nusing the specified values `defaultLeft` and `defaultRight` to fill in\nmissing values.\n\nThis allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipAllSortedByKey: { <A2, E2, R2, A, K>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; readonly order: Order.Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, [A, A2]], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; readonly order: Order.Order<K>; }): Stream<[K, [A, A2]], E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipAllSortedByKeyLeft",
    "description": "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Keeps only values from this stream, using the specified\nvalue `default` to fill in missing values.\n\nThis allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipAllSortedByKeyLeft: { <A2, E2, R2, A, K>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly order: Order.Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly order: Order.Order<K>; }): Stream<[K, A], E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipAllSortedByKeyRight",
    "description": "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Keeps only values from that stream, using the specified\nvalue `default` to fill in missing values.\n\nThis allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipAllSortedByKeyRight: { <K, A2, E2, R2>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultOther: A2; readonly order: Order.Order<K>; }): <A, E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A2], E2 | E, R2 | R>; <A, E, R, K, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultOther: A2; readonly order: Order.Order<K>; }): Stream<[K, A2], E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipAllSortedByKeyWith",
    "description": "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Uses the functions `left`, `right`, and `both` to handle\nthe cases where a key and value exist in this stream, that stream, or\nboth streams.\n\nThis allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipAllSortedByKeyWith: { <K, A2, E2, R2, A, A3>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; readonly order: Order.Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A3], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2, A3>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; readonly order: Order.Order<K>; }): Stream<[K, A3], E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipAllWith",
    "description": "Zips this stream with another point-wise. The provided functions will be\nused to create elements for the composed stream.\n\nThe functions `left` and `right` will be used if the streams have different\nlengths and one of the streams has ended before the other.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipAllWith(Stream.make(1, 2, 3, 4, 5, 6), {\n  other: Stream.make(\"a\", \"b\", \"c\"),\n  onSelf: (n) => [n, \"x\"],\n  onOther: (s) => [0, s],\n  onBoth: (n, s) => [n - s.length, s]\n})\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: \"Chunk\", values: [ [ 0, \"a\" ], [ 1, \"b\" ], [ 2, \"c\" ], [ 4, \"x\" ], [ 5, \"x\" ], [ 6, \"x\" ] ] }"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipAllWith: { <A2, E2, R2, A, A3>(options: { readonly other: Stream<A2, E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; }): <E, R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: Stream<A, E, R>, options: { readonly other: Stream<A2, E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; }): Stream<A3, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipLatest",
    "description": "Zips the two streams so that when a value is emitted by either of the two\nstreams, it is combined with the latest value from the other stream to\nproduce a result.\n\nNote: tracking the latest value is done on a per-chunk basis. That means\nthat emitted elements that are not the last value in chunks will never be\nused for zipping.",
    "deprecated": false,
    "examples": [
      "import { Effect, Schedule, Stream } from \"effect\"\n\nconst s1 = Stream.make(1, 2, 3).pipe(\n  Stream.schedule(Schedule.spaced(\"1 second\"))\n)\n\nconst s2 = Stream.make(\"a\", \"b\", \"c\", \"d\").pipe(\n  Stream.schedule(Schedule.spaced(\"500 millis\"))\n)\n\nconst stream = Stream.zipLatest(s1, s2)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: \"Chunk\", values: [ [ 1, \"a\" ], [ 1, \"b\" ], [ 2, \"b\" ], [ 2, \"c\" ], [ 2, \"d\" ], [ 3, \"d\" ] ] }"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipLatest: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<[AL, AR], EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<[AL, AR], EL | ER, RL | RR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipLatestAll",
    "description": "Zips multiple streams so that when a value is emitted by any of the streams,\nit is combined with the latest values from the other streams to produce a result.\n\nNote: tracking the latest value is done on a per-chunk basis. That means\nthat emitted elements that are not the last value in chunks will never be\nused for zipping.",
    "deprecated": false,
    "examples": [
      "import { Stream, Schedule, Console, Effect } from \"effect\"\n\nconst stream = Stream.zipLatestAll(\n    Stream.fromSchedule(Schedule.spaced('1 millis')),\n    Stream.fromSchedule(Schedule.spaced('2 millis')),\n    Stream.fromSchedule(Schedule.spaced('4 millis')),\n).pipe(Stream.take(6), Stream.tap(Console.log))\n\n// Effect.runPromise(Stream.runDrain(stream))\n// Output:\n// [ 0, 0, 0 ]\n// [ 1, 0, 0 ]\n// [ 1, 1, 0 ]\n// [ 2, 1, 0 ]\n// [ 3, 1, 0 ]\n// [ 3, 1, 1 ]\n// ....."
    ],
    "since": "3.3.0",
    "category": "zipping",
    "signature": "export declare const zipLatestAll: <T extends ReadonlyArray<Stream<any, any, any>>>(...streams: T) => Stream<[T[number]] extends [never] ? never : { [K in keyof T]: T[K] extends Stream<infer A, infer _E, infer _R> ? A : never; }, [T[number]] extends [never] ? never : T[number] extends Stream<infer _A, infer _E, infer _R> ? _E : never, [T[number]] extends [never] ? never : T[number] extends Stream<infer _A, infer _E, infer _R> ? _R : never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipLatestWith",
    "description": "Zips the two streams so that when a value is emitted by either of the two\nstreams, it is combined with the latest value from the other stream to\nproduce a result.\n\nNote: tracking the latest value is done on a per-chunk basis. That means\nthat emitted elements that are not the last value in chunks will never be\nused for zipping.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipLatestWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipLeft",
    "description": "Zips this stream with another point-wise, but keeps only the outputs of\n`left` stream.\n\nThe new stream will end when one of the sides ends.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipLeft: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipRight",
    "description": "Zips this stream with another point-wise, but keeps only the outputs of the\n`right` stream.\n\nThe new stream will end when one of the sides ends.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipRight: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipWith",
    "description": "Zips this stream with another point-wise and applies the function to the\npaired elements.\n\nThe new stream will end when one of the sides ends.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\n// We create two streams and zip them with custom logic.\nconst stream = Stream.zipWith(\n  Stream.make(1, 2, 3, 4, 5, 6),\n  Stream.make(\"a\", \"b\", \"c\"),\n  (n, s) => [n - s.length, s]\n)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ [ 0, 'a' ], [ 1, 'b' ], [ 2, 'c' ] ] }"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipWithChunks",
    "description": "Zips this stream with another point-wise and applies the function to the\npaired elements.\n\nThe new stream will end when one of the sides ends.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWithChunks: { <A2, E2, R2, A, A3>(that: Stream<A2, E2, R2>, f: (left: Chunk.Chunk<A>, right: Chunk.Chunk<A2>) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]): <E, R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, f: (left: Chunk.Chunk<A>, right: Chunk.Chunk<A2>) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]): Stream<A3, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipWithNext",
    "description": "Zips each element with the next element if present.",
    "deprecated": false,
    "examples": [
      "import { Chunk, Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipWithNext(Stream.make(1, 2, 3, 4))\n\n// Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))\n// [\n//   [ 1, { _id: 'Option', _tag: 'Some', value: 2 } ],\n//   [ 2, { _id: 'Option', _tag: 'Some', value: 3 } ],\n//   [ 3, { _id: 'Option', _tag: 'Some', value: 4 } ],\n//   [ 4, { _id: 'Option', _tag: 'None' } ]\n// ]"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWithNext: <A, E, R>(self: Stream<A, E, R>) => Stream<[A, Option.Option<A>], E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipWithPrevious",
    "description": "Zips each element with the previous element. Initially accompanied by\n`None`.",
    "deprecated": false,
    "examples": [
      "import { Chunk, Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipWithPrevious(Stream.make(1, 2, 3, 4))\n\n// Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))\n// [\n//   [ { _id: 'Option', _tag: 'None' }, 1 ],\n//   [ { _id: 'Option', _tag: 'Some', value: 1 }, 2 ],\n//   [ { _id: 'Option', _tag: 'Some', value: 2 }, 3 ],\n//   [ { _id: 'Option', _tag: 'Some', value: 3 }, 4 ]\n// ]"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWithPrevious: <A, E, R>(self: Stream<A, E, R>) => Stream<[Option.Option<A>, A], E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipWithPreviousAndNext",
    "description": "Zips each element with both the previous and next element.",
    "deprecated": false,
    "examples": [
      "import { Chunk, Effect, Stream } from \"effect\"\n\nconst stream = Stream.zipWithPreviousAndNext(Stream.make(1, 2, 3, 4))\n\n// Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))\n// [\n//   [\n//     { _id: 'Option', _tag: 'None' },\n//     1,\n//     { _id: 'Option', _tag: 'Some', value: 2 }\n//   ],\n//   [\n//     { _id: 'Option', _tag: 'Some', value: 1 },\n//     2,\n//     { _id: 'Option', _tag: 'Some', value: 3 }\n//   ],\n//   [\n//     { _id: 'Option', _tag: 'Some', value: 2 },\n//     3,\n//     { _id: 'Option', _tag: 'Some', value: 4 }\n//   ],\n//   [\n//     { _id: 'Option', _tag: 'Some', value: 3 },\n//     4,\n//     { _id: 'Option', _tag: 'None' }\n//   ]\n// ]"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWithPreviousAndNext: <A, E, R>(self: Stream<A, E, R>) => Stream<[Option.Option<A>, A, Option.Option<A>], E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "zipWithIndex",
    "description": "Zips this stream together with the index of elements.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(\"Mary\", \"James\", \"Robert\", \"Patricia\")\n\nconst indexedStream = Stream.zipWithIndex(stream)\n\n// Effect.runPromise(Stream.runCollect(indexedStream)).then(console.log)\n// {\n//   _id: 'Chunk',\n//   values: [ [ 'Mary', 0 ], [ 'James', 1 ], [ 'Robert', 2 ], [ 'Patricia', 3 ] ]\n// }"
    ],
    "since": "2.0.0",
    "category": "zipping",
    "signature": "export declare const zipWithIndex: <A, E, R>(self: Stream<A, E, R>) => Stream<[A, number], E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "Do",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "import { Chunk, Effect, pipe, Stream } from \"effect\"\n\nconst result = pipe(\n  Stream.Do,\n  Stream.bind(\"x\", () => Stream.succeed(2)),\n  Stream.bind(\"y\", () => Stream.succeed(3)),\n  Stream.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))"
    ],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "export declare const Do: Stream<{}, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "bind",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "import { Chunk, Effect, pipe, Stream } from \"effect\"\n\nconst result = pipe(\n  Stream.Do,\n  Stream.bind(\"x\", () => Stream.succeed(2)),\n  Stream.bind(\"y\", () => Stream.succeed(3)),\n  Stream.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))"
    ],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "export declare const bind: { <N extends string, A, B, E2, R2>(tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Stream<B, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E, R2 | R>; <A, E, R, N extends string, B, E2, R2>(self: Stream<A, E, R>, tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Stream<B, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; } | undefined): Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "bindEffect",
    "description": "Binds an effectful value in a `do` scope",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "export declare const bindEffect: { <N extends string, A, B, E2, R2>(tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Effect.Effect<B, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly bufferSize?: number | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in keyof A | N]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; <A, E, R, N extends string, B, E2, R2>(self: Stream<A, E, R>, tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Effect.Effect<B, E2, R2>, options?: { readonly concurrency?: number | \"unbounded\" | undefined; readonly unordered?: boolean | undefined; }): Stream<{ [K in keyof A | N]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "bindTo",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "import { Chunk, Effect, pipe, Stream } from \"effect\"\n\nconst result = pipe(\n  Stream.Do,\n  Stream.bind(\"x\", () => Stream.succeed(2)),\n  Stream.bind(\"y\", () => Stream.succeed(3)),\n  Stream.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))"
    ],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "export declare const bindTo: { <N extends string>(name: N): <A, E, R>(self: Stream<A, E, R>) => Stream<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Stream<A, E, R>, name: N): Stream<{ [K in N]: A; }, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "decodeText",
    "description": "Decode Uint8Array chunks into a stream of strings using the specified encoding.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "encoding",
    "signature": "export declare const decodeText: { (encoding?: string | undefined): <E, R>(self: Stream<Uint8Array, E, R>) => Stream<string, E, R>; <E, R>(self: Stream<Uint8Array, E, R>, encoding?: string | undefined): Stream<string, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "encodeText",
    "description": "Encode a stream of strings into a stream of Uint8Array chunks using the specified encoding.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "encoding",
    "signature": "export declare const encodeText: <E, R>(self: Stream<string, E, R>) => Stream<Uint8Array, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "fromEventListener",
    "description": "Creates a `Stream` using addEventListener.",
    "deprecated": false,
    "examples": [],
    "since": "3.1.0",
    "category": null,
    "signature": "export declare const fromEventListener: <A = unknown>(target: EventListener<A>, type: string, options?: boolean | { readonly capture?: boolean; readonly passive?: boolean; readonly once?: boolean; readonly bufferSize?: number | \"unbounded\" | undefined; } | undefined) => Stream<A>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "async",
    "description": "Creates a stream from an asynchronous callback that can be called multiple\ntimes. The optionality of the error type `E` in `Emit` can be used to\nsignal the end of the stream by setting it to `None`.\n\nThe registration function can optionally return an `Effect`, which will be\nexecuted if the `Fiber` executing this Effect is interrupted.",
    "deprecated": false,
    "examples": [
      "import type { StreamEmit } from \"effect\"\nimport { Chunk, Effect, Option, Stream } from \"effect\"\n\nconst events = [1, 2, 3, 4]\n\nconst stream = Stream.async(\n  (emit: StreamEmit.Emit<never, never, number, void>) => {\n    events.forEach((n) => {\n      setTimeout(() => {\n        if (n === 3) {\n          emit(Effect.fail(Option.none())) // Terminate the stream\n        } else {\n          emit(Effect.succeed(Chunk.of(n))) // Add the current item to the stream\n        }\n      }, 100 * n)\n    })\n  }\n)\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ 1, 2 ] }\n"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const async: <A, E = never, R = never>(register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<void, never, R> | void, bufferSize?: number | \"unbounded\" | { readonly bufferSize?: number | undefined; readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined; } | undefined) => Stream<A, E, R>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "void",
    "description": "A stream that contains a single `void` value.",
    "deprecated": false,
    "examples": [
      "import { Effect, Stream } from \"effect\"\n\nconst stream = Stream.void\n\n// Effect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: 'Chunk', values: [ undefined ] }\n"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const void: Stream<void, never, never>"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "let",
    "description": "The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere's how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values",
    "deprecated": false,
    "examples": [
      "import { Chunk, Effect, pipe, Stream } from \"effect\"\n\nconst result = pipe(\n  Stream.Do,\n  Stream.bind(\"x\", () => Stream.succeed(2)),\n  Stream.bind(\"y\", () => Stream.succeed(3)),\n  Stream.let(\"sum\", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))\n"
    ],
    "since": "2.0.0",
    "category": "do notation",
    "signature": "export declare const let: { <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E, R>; <A extends object, E, R, N extends string, B>(self: Stream<A, E, R>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => B): Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E, R>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "EventListener",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.4.0",
    "category": "models",
    "signature": "export interface EventListener<A> {\n  addEventListener(\n    event: string,\n    f: (event: A) => void,\n    options?: {\n      readonly capture?: boolean\n      readonly passive?: boolean\n      readonly once?: boolean\n      readonly signal?: AbortSignal\n    } | boolean\n  ): void\n  removeEventListener(\n    event: string,\n    f: (event: A) => void,\n    options?: {\n      readonly capture?: boolean\n    } | boolean\n  ): void\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "Stream",
    "description": "A `Stream<A, E, R>` is a description of a program that, when evaluated, may\nemit zero or more values of type `A`, may fail with errors of type `E`, and\nuses an context of type `R`. One way to think of `Stream` is as a\n`Effect` program that could emit multiple values.\n\n`Stream` is a purely functional *pull* based stream. Pull based streams offer\ninherent laziness and backpressure, relieving users of the need to manage\nbuffers between operators. As an optimization, `Stream` does not emit\nsingle values, but rather an array of values. This allows the cost of effect\nevaluation to be amortized.\n\n`Stream` forms a monad on its `A` type parameter, and has error management\nfacilities for its `E` type parameter, modeled similarly to `Effect` (with\nsome adjustments for the multiple-valued nature of `Stream`). These aspects\nallow for rich and expressive composition of streams.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Stream<out A, out E = never, out R = never> extends Stream.Variance<A, E, R>, Pipeable {\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: StreamUnify<this>\n  [Unify.ignoreSymbol]?: StreamUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "StreamTypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface StreamTypeLambda extends TypeLambda {\n  readonly type: Stream<this[\"Target\"], this[\"Out1\"], this[\"Out2\"]>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "StreamUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface StreamUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Stream?: () => A[Unify.typeSymbol] extends Stream<infer A0, infer E0, infer R0> | infer _ ? Stream<A0, E0, R0> : never\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "StreamUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface StreamUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Stream",
      "path": [
        "src",
        "Stream.ts"
      ]
    },
    "project": "effect",
    "name": "StreamTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type StreamTypeId = typeof StreamTypeId"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Streamable",
      "path": [
        "src",
        "Streamable.ts"
      ]
    },
    "project": "effect",
    "name": "Class",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare class Class<A, E, R>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "StreamEmit",
      "path": [
        "src",
        "StreamEmit.ts"
      ]
    },
    "project": "effect",
    "name": "Emit",
    "description": "An `Emit<R, E, A, B>` represents an asynchronous callback that can be\ncalled multiple times. The callback can be called with a value of type\n`Effect<Chunk<A>, Option<E>, R>`, where succeeding with a `Chunk<A>`\nindicates to emit those elements, failing with `Some<E>` indicates to\nterminate with that error, and failing with `None` indicates to terminate\nwith an end of stream signal.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Emit<in R, in E, in A, out B> extends EmitOps<R, E, A, B> {\n  (f: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>): Promise<B>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "StreamEmit",
      "path": [
        "src",
        "StreamEmit.ts"
      ]
    },
    "project": "effect",
    "name": "EmitOps",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface EmitOps<in R, in E, in A, out B> {\n  /**\n   * Emits a chunk containing the specified values.\n   */\n  chunk(chunk: Chunk.Chunk<A>): Promise<B>\n\n  /**\n   * Terminates with a cause that dies with the specified defect.\n   */\n  die<Err>(defect: Err): Promise<B>\n\n  /**\n   * Terminates with a cause that dies with a `Throwable` with the specified\n   * message.\n   */\n  dieMessage(message: string): Promise<B>\n\n  /**\n   * Either emits the specified value if this `Exit` is a `Success` or else\n   * terminates with the specified cause if this `Exit` is a `Failure`.\n   */\n  done(exit: Exit.Exit<A, E>): Promise<B>\n\n  /**\n   * Terminates with an end of stream signal.\n   */\n  end(): Promise<B>\n\n  /**\n   * Terminates with the specified error.\n   */\n  fail(error: E): Promise<B>\n\n  /**\n   * Either emits the success value of this effect or terminates the stream\n   * with the failure value of this effect.\n   */\n  fromEffect(effect: Effect.Effect<A, E, R>): Promise<B>\n\n  /**\n   * Either emits the success value of this effect or terminates the stream\n   * with the failure value of this effect.\n   */\n  fromEffectChunk(effect: Effect.Effect<Chunk.Chunk<A>, E, R>): Promise<B>\n\n  /**\n   * Terminates the stream with the specified cause.\n   */\n  halt(cause: Cause.Cause<E>): Promise<B>\n\n  /**\n   * Emits a chunk containing the specified value.\n   */\n  single(value: A): Promise<B>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "StreamEmit",
      "path": [
        "src",
        "StreamEmit.ts"
      ]
    },
    "project": "effect",
    "name": "EmitOpsPush",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.6.0",
    "category": "models",
    "signature": "export interface EmitOpsPush<in E, in A> {\n  /**\n   * Emits a chunk containing the specified values.\n   */\n  chunk(chunk: Chunk.Chunk<A>): boolean\n\n  /**\n   * Emits a chunk containing the specified values.\n   */\n  array(chunk: ReadonlyArray<A>): boolean\n\n  /**\n   * Terminates with a cause that dies with the specified defect.\n   */\n  die<Err>(defect: Err): void\n\n  /**\n   * Terminates with a cause that dies with a `Throwable` with the specified\n   * message.\n   */\n  dieMessage(message: string): void\n\n  /**\n   * Either emits the specified value if this `Exit` is a `Success` or else\n   * terminates with the specified cause if this `Exit` is a `Failure`.\n   */\n  done(exit: Exit.Exit<A, E>): void\n\n  /**\n   * Terminates with an end of stream signal.\n   */\n  end(): void\n\n  /**\n   * Terminates with the specified error.\n   */\n  fail(error: E): void\n\n  /**\n   * Terminates the stream with the specified cause.\n   */\n  halt(cause: Cause.Cause<E>): void\n\n  /**\n   * Emits a chunk containing the specified value.\n   */\n  single(value: A): boolean\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "Left",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Left: HaltStrategy"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "Right",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Right: HaltStrategy"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "Both",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Both: HaltStrategy"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "Either",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Either: HaltStrategy"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "fromInput",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromInput: (input: HaltStrategyInput) => HaltStrategy"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "isLeft",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isLeft: (self: HaltStrategy) => self is Left"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "isRight",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isRight: (self: HaltStrategy) => self is Right"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "isBoth",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isBoth: (self: HaltStrategy) => self is Both"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "isEither",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isEither: (self: HaltStrategy) => self is Either"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Folds over the specified `HaltStrategy` using the provided case functions.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const match: { <Z>(options: { readonly onLeft: () => Z; readonly onRight: () => Z; readonly onBoth: () => Z; readonly onEither: () => Z; }): (self: HaltStrategy) => Z; <Z>(self: HaltStrategy, options: { readonly onLeft: () => Z; readonly onRight: () => Z; readonly onBoth: () => Z; readonly onEither: () => Z; }): Z; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "Both",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Both {\n  readonly _tag: \"Both\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "Either",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Either {\n  readonly _tag: \"Either\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "Left",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Left {\n  readonly _tag: \"Left\"\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "Right",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Right {\n  readonly _tag: \"Right\"\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "HaltStrategy",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type HaltStrategy = Left | Right | Both | Either"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "StreamHaltStrategy",
      "path": [
        "src",
        "StreamHaltStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "HaltStrategyInput",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type HaltStrategyInput = HaltStrategy | \"left\" | \"right\" | \"both\" | \"either\""
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "isString",
    "description": "Tests if a value is a `string`.",
    "deprecated": false,
    "examples": [
      "import { String } from \"effect\"\n\nassert.deepStrictEqual(String.isString(\"a\"), true)\nassert.deepStrictEqual(String.isString(1), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isString: Refinement<unknown, string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "Equivalence",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Equivalence: equivalence.Equivalence<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "Order",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Order: order.Order<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "The empty string `\"\"`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const empty: \"\""
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "concat",
    "description": "Concatenates two strings at runtime.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const concat: { <B extends string>(that: B): <A extends string>(self: A) => Concat<A, B>; <A extends string, B extends string>(self: A, that: B): Concat<A, B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "split",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe('abc', String.split('')), ['a', 'b', 'c'])\nassert.deepStrictEqual(pipe('', String.split('')), [''])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const split: { (separator: string | RegExp): (self: string) => NonEmptyArray<string>; (self: string, separator: string | RegExp): NonEmptyArray<string>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "charCodeAt",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"abc\", String.charCodeAt(1)), Option.some(98))\nassert.deepStrictEqual(pipe(\"abc\", String.charCodeAt(4)), Option.none())"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const charCodeAt: { (index: number): (self: string) => Option.Option<number>; (self: string, index: number): Option.Option<number>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "at",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"abc\", String.at(1)), Option.some(\"b\"))\nassert.deepStrictEqual(pipe(\"abc\", String.at(4)), Option.none())"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const at: { (index: number): (self: string) => Option.Option<string>; (self: string, index: number): Option.Option<string>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "charAt",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"abc\", String.charAt(1)), Option.some(\"b\"))\nassert.deepStrictEqual(pipe(\"abc\", String.charAt(4)), Option.none())"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const charAt: { (index: number): (self: string) => Option.Option<string>; (self: string, index: number): Option.Option<string>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "codePointAt",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"abc\", String.codePointAt(1)), Option.some(98))"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const codePointAt: { (index: number): (self: string) => Option.Option<number>; (self: string, index: number): Option.Option<number>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "search",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"ababb\", String.search(\"b\")), Option.some(1))\nassert.deepStrictEqual(pipe(\"ababb\", String.search(/abb/)), Option.some(2))\nassert.deepStrictEqual(pipe(\"ababb\", String.search(\"d\")), Option.none())"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const search: { (regexp: RegExp | string): (self: string) => Option.Option<number>; (self: string, regexp: RegExp | string): Option.Option<number>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "takeLeft",
    "description": "Keep the specified number of characters from the start of a string.\n\nIf `n` is larger than the available number of characters, the string will\nbe returned whole.\n\nIf `n` is not a positive number, an empty string will be returned.\n\nIf `n` is a float, it will be rounded down to the nearest integer.",
    "deprecated": false,
    "examples": [
      "import { String } from \"effect\"\n\nassert.deepStrictEqual(String.takeLeft(\"Hello World\", 5), \"Hello\")"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const takeLeft: { (n: number): (self: string) => string; (self: string, n: number): string; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "takeRight",
    "description": "Keep the specified number of characters from the end of a string.\n\nIf `n` is larger than the available number of characters, the string will\nbe returned whole.\n\nIf `n` is not a positive number, an empty string will be returned.\n\nIf `n` is a float, it will be rounded down to the nearest integer.",
    "deprecated": false,
    "examples": [
      "import { String } from \"effect\"\n\nassert.deepStrictEqual(String.takeRight(\"Hello World\", 5), \"World\")"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const takeRight: { (n: number): (self: string) => string; (self: string, n: number): string; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "stripMarginWith",
    "description": "For every line in this string, strip a leading prefix consisting of blanks\nor control characters followed by the character specified by `marginChar`\nfrom the line.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const stripMarginWith: { (marginChar: string): (self: string) => string; (self: string, marginChar: string): string; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "toUpperCase",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe('a', String.toUpperCase), 'A')"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "toLowerCase",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe('A', String.toLowerCase), 'a')"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "capitalize",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe('abc', String.capitalize), 'Abc')"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "uncapitalize",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe('ABC', String.uncapitalize), 'aBC')"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "replace",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe('abc', String.replace('b', 'd')), 'adc')"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "trim",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { String } from \"effect\"\n\nassert.deepStrictEqual(String.trim(' a '), 'a')"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "trimStart",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { String } from \"effect\"\n\nassert.deepStrictEqual(String.trimStart(' a '), 'a ')"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "trimEnd",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { String } from \"effect\"\n\nassert.deepStrictEqual(String.trimEnd(' a '), ' a')"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "slice",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe('abcd', String.slice(1, 3)), 'bc')"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Test whether a `string` is empty.",
    "deprecated": false,
    "examples": [
      "import { String } from \"effect\"\n\nassert.deepStrictEqual(String.isEmpty(''), true)\nassert.deepStrictEqual(String.isEmpty('a'), false)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "isNonEmpty",
    "description": "Test whether a `string` is non empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "length",
    "description": "Calculate the number of characters in a `string`.",
    "deprecated": false,
    "examples": [
      "import { String } from \"effect\"\n\nassert.deepStrictEqual(String.length('abc'), 3)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "includes",
    "description": "Returns `true` if `searchString` appears as a substring of `self`, at one or more positions that are\ngreater than or equal to `position`; otherwise, returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "startsWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "endsWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "substring",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"abcd\", String.substring(1)), \"bcd\")\nassert.deepStrictEqual(pipe(\"abcd\", String.substring(1, 3)), \"bc\")"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "indexOf",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"abbbc\", String.indexOf(\"b\")), Option.some(1))"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "lastIndexOf",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String, Option } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"abbbc\", String.lastIndexOf(\"b\")), Option.some(3))\nassert.deepStrictEqual(pipe(\"abbbc\", String.lastIndexOf(\"d\")), Option.none())"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "localeCompare",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"a\", String.localeCompare(\"b\")), -1)\nassert.deepStrictEqual(pipe(\"b\", String.localeCompare(\"a\")), 1)\nassert.deepStrictEqual(pipe(\"a\", String.localeCompare(\"a\")), 0)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "It is the `pipe`-able version of the native `match` method.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "matchAll",
    "description": "It is the `pipe`-able version of the native `matchAll` method.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "normalize",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nconst str = \"\\u1E9B\\u0323\";\nassert.deepStrictEqual(pipe(str, String.normalize()), \"\\u1E9B\\u0323\")\nassert.deepStrictEqual(pipe(str, String.normalize(\"NFC\")), \"\\u1E9B\\u0323\")\nassert.deepStrictEqual(pipe(str, String.normalize(\"NFD\")), \"\\u017F\\u0323\\u0307\")\nassert.deepStrictEqual(pipe(str, String.normalize(\"NFKC\")), \"\\u1E69\")\nassert.deepStrictEqual(pipe(str, String.normalize(\"NFKD\")), \"\\u0073\\u0323\\u0307\")"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "padEnd",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"a\", String.padEnd(5)), \"a    \")\nassert.deepStrictEqual(pipe(\"a\", String.padEnd(5, \"_\")), \"a____\")"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "padStart",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"a\", String.padStart(5)), \"    a\")\nassert.deepStrictEqual(pipe(\"a\", String.padStart(5, \"_\")), \"____a\")"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "repeat",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"a\", String.repeat(5)), \"aaaaa\")"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "replaceAll",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nassert.deepStrictEqual(pipe(\"ababb\", String.replaceAll(\"b\", \"c\")), \"acacc\")\nassert.deepStrictEqual(pipe(\"ababb\", String.replaceAll(/ba/g, \"cc\")), \"accbb\")"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "toLocaleLowerCase",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nconst str = \"\\u0130\"\nassert.deepStrictEqual(pipe(str, String.toLocaleLowerCase(\"tr\")), \"i\")"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "toLocaleUpperCase",
    "description": null,
    "deprecated": false,
    "examples": [
      "import { pipe, String } from \"effect\"\n\nconst str = \"i\\u0307\"\nassert.deepStrictEqual(pipe(str, String.toLocaleUpperCase(\"lt-LT\")), \"I\")"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "linesIterator",
    "description": "Returns an `IterableIterator` which yields each line contained within the\nstring, trimming off the trailing newline character.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "linesWithSeparators",
    "description": "Returns an `IterableIterator` which yields each line contained within the\nstring as well as the trailing newline character.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "stripMargin",
    "description": "For every line in this string, strip a leading prefix consisting of blanks\nor control characters followed by the `\"|\"` character from the line.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "snakeToCamel",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "snakeToPascal",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "snakeToKebab",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "camelToSnake",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "pascalToSnake",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "kebabToSnake",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "Concat",
    "description": "Concatenates two strings at the type level.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type Concat<A extends string, B extends string> = `${A}${B}`"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "Trim",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type Trim<A extends string> = TrimEnd<TrimStart<A>>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "TrimEnd",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type TrimEnd<A extends string> = A extends `${infer B}${\" \" | \"\\n\" | \"\\t\" | \"\\r\"}` ? TrimEnd<B> : A"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "String",
      "path": [
        "src",
        "String.ts"
      ]
    },
    "project": "effect",
    "name": "TrimStart",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type TrimStart<A extends string> = A extends `${\" \" | \"\\n\" | \"\\t\" | \"\\r\"}${infer B}` ? TrimStart<B> : A"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Struct",
      "path": [
        "src",
        "Struct.ts"
      ]
    },
    "project": "effect",
    "name": "pick",
    "description": "Create a new object by picking properties of an existing object.",
    "deprecated": false,
    "examples": [
      "import { pipe, Struct } from \"effect\"\n\nassert.deepStrictEqual(pipe({ a: \"a\", b: 1, c: true }, Struct.pick(\"a\", \"b\")), { a: \"a\", b: 1 })\nassert.deepStrictEqual(Struct.pick({ a: \"a\", b: 1, c: true }, \"a\", \"b\"), { a: \"a\", b: 1 })"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const pick: { <Keys extends Array<PropertyKey>>(...keys: Keys): <S extends { [K in Keys[number]]?: any; }>(s: S) => MatchRecord<S, { [K in Keys[number]]?: S[K]; }, Simplify<Pick<S, Keys[number]>>>; <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys): MatchRecord<S, { [K in Keys[number]]?: S[K]; }, Simplify<Pick<S, Keys[number]>>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Struct",
      "path": [
        "src",
        "Struct.ts"
      ]
    },
    "project": "effect",
    "name": "omit",
    "description": "Create a new object by omitting properties of an existing object.",
    "deprecated": false,
    "examples": [
      "import { pipe, Struct } from \"effect\"\n\nassert.deepStrictEqual(pipe({ a: \"a\", b: 1, c: true }, Struct.omit(\"c\")), { a: \"a\", b: 1 })\nassert.deepStrictEqual(Struct.omit({ a: \"a\", b: 1, c: true }, \"c\"), { a: \"a\", b: 1 })"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const omit: { <Keys extends Array<PropertyKey>>(...keys: Keys): <S extends { [K in Keys[number]]?: any; }>(s: S) => Simplify<Omit<S, Keys[number]>>; <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys): Simplify<Omit<S, Keys[number]>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Struct",
      "path": [
        "src",
        "Struct.ts"
      ]
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": "Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct\nby applying each `Equivalence` to the corresponding property of the struct.\n\nAlias of {@link Equivalence.struct}.",
    "deprecated": false,
    "examples": [
      "import { Struct, String, Number } from \"effect\"\n\nconst PersonEquivalence = Struct.getEquivalence({\n  name: String.Equivalence,\n  age: Number.Equivalence\n})\n\nassert.deepStrictEqual(\n  PersonEquivalence({ name: \"John\", age: 25 }, { name: \"John\", age: 25 }),\n  true\n)\nassert.deepStrictEqual(\n  PersonEquivalence({ name: \"John\", age: 25 }, { name: \"John\", age: 40 }),\n  false\n)"
    ],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const getEquivalence: <R extends Record<string, Equivalence.Equivalence<any>>>(isEquivalents: R) => Equivalence.Equivalence<{ readonly [K in keyof R]: [R[K]] extends [Equivalence.Equivalence<infer A>] ? A : never; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Struct",
      "path": [
        "src",
        "Struct.ts"
      ]
    },
    "project": "effect",
    "name": "getOrder",
    "description": "This function creates and returns a new `Order` for a struct of values based on the given `Order`s\nfor each property in the struct.\n\nAlias of {@link order.struct}.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const getOrder: <R extends { readonly [x: string]: order.Order<any>; }>(fields: R) => order.Order<{ [K in keyof R]: [R[K]] extends [order.Order<infer A>] ? A : never; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Struct",
      "path": [
        "src",
        "Struct.ts"
      ]
    },
    "project": "effect",
    "name": "evolve",
    "description": "Transforms the values of a Struct provided a transformation function for each key.\nIf no transformation function is provided for a key, it will return the origional value for that key.",
    "deprecated": false,
    "examples": [
      "import { pipe, Struct } from \"effect\"\n\nassert.deepStrictEqual(\n  pipe(\n    { a: 'a', b: 1, c: 3 },\n    Struct.evolve({\n      a: (a) => a.length,\n      b: (b) => b * 2\n    })\n  ),\n  { a: 1, b: 2, c: 3 }\n)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const evolve: { <O, T>(t: PartialTransform<O, T>): (obj: O) => Transformed<O, T>; <O, T>(obj: O, t: PartialTransform<O, T>): Transformed<O, T>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Struct",
      "path": [
        "src",
        "Struct.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves the value associated with the specified key from a struct.",
    "deprecated": false,
    "examples": [
      "import { pipe, Struct } from \"effect\"\n\nconst value = pipe({ a: 1, b: 2 }, Struct.get(\"a\"))\n\nassert.deepStrictEqual(value, 1)"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Struct",
      "path": [
        "src",
        "Struct.ts"
      ]
    },
    "project": "effect",
    "name": "keys",
    "description": "Retrieves the object keys that are strings in a typed manner",
    "deprecated": false,
    "examples": [
      "import { Struct } from \"effect\"\n\nconst symbol: unique symbol = Symbol()\n\nconst value = {\n  a: 1,\n  b: 2,\n  [symbol]: 3\n}\n\nconst keys: Array<\"a\" | \"b\"> = Struct.keys(value)\n\nassert.deepStrictEqual(keys, [\"a\", \"b\"])"
    ],
    "since": "3.6.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Subscribable",
      "path": [
        "src",
        "Subscribable.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "export declare const TypeId: typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Subscribable",
      "path": [
        "src",
        "Subscribable.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const map: { <A, B>(f: (a: NoInfer<A>) => B): <E, R>(fa: Subscribable<A, E, R>) => Subscribable<B, E, R>; <A, E, R, B>(self: Subscribable<A, E, R>, f: (a: NoInfer<A>) => B): Subscribable<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Subscribable",
      "path": [
        "src",
        "Subscribable.ts"
      ]
    },
    "project": "effect",
    "name": "mapEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const mapEffect: { <A, B, E2, R2>(f: (a: NoInfer<A>) => Effect.Effect<B, E2, R2>): <E, R>(fa: Subscribable<A, E, R>) => Subscribable<B, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Subscribable<A, E, R>, f: (a: NoInfer<A>) => Effect.Effect<B, E2, R2>): Subscribable<B, E | E2, R | R2>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Subscribable",
      "path": [
        "src",
        "Subscribable.ts"
      ]
    },
    "project": "effect",
    "name": "isSubscribable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Subscribable",
      "path": [
        "src",
        "Subscribable.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Subscribable",
      "path": [
        "src",
        "Subscribable.ts"
      ]
    },
    "project": "effect",
    "name": "unwrap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Subscribable",
      "path": [
        "src",
        "Subscribable.ts"
      ]
    },
    "project": "effect",
    "name": "Subscribable",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Subscribable<A, E = never, R = never> extends Readable.Readable<A, E, R> {\n  readonly [TypeId]: TypeId\n  readonly changes: Stream.Stream<A, E, R>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Subscribable",
      "path": [
        "src",
        "Subscribable.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type ids",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "SubscriptionRefTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const SubscriptionRefTypeId: typeof SubscriptionRefTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const get: <A>(self: SubscriptionRef<A>) => Effect.Effect<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndSet: { <A>(value: A): (self: SubscriptionRef<A>) => Effect.Effect<A>; <A>(self: SubscriptionRef<A>, value: A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndUpdate: { <A>(f: (a: A) => A): (self: SubscriptionRef<A>) => Effect.Effect<A>; <A>(self: SubscriptionRef<A>, f: (a: A) => A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdateEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndUpdateEffect: { <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SubscriptionRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdateSome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndUpdateSome: { <A>(pf: (a: A) => Option.Option<A>): (self: SubscriptionRef<A>) => Effect.Effect<A>; <A>(self: SubscriptionRef<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdateSomeEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndUpdateSomeEffect: { <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SubscriptionRef<A>, pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Creates a new `SubscriptionRef` with the specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <A>(value: A) => Effect.Effect<SubscriptionRef<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "modify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const modify: { <A, B>(f: (a: A) => readonly [B, A]): (self: SubscriptionRef<A>) => Effect.Effect<B>; <A, B>(self: SubscriptionRef<A>, f: (a: A) => readonly [B, A]): Effect.Effect<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "modifyEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const modifyEffect: { <B, A, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): (self: SubscriptionRef<A>) => Effect.Effect<B, E, R>; <A, B, E, R>(self: SubscriptionRef<A>, f: (a: A) => Effect.Effect<readonly [B, A], E, R>): Effect.Effect<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "modifySome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const modifySome: { <B, A>(fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): (self: SubscriptionRef<A>) => Effect.Effect<B>; <A, B>(self: SubscriptionRef<A>, fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): Effect.Effect<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "modifySomeEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const modifySomeEffect: { <A, B, R, E>(fallback: B, pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>): (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<B, E, R>; <A, B, R, E>(self: Synchronized.SynchronizedRef<A>, fallback: B, pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>): Effect.Effect<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const set: { <A>(value: A): (self: SubscriptionRef<A>) => Effect.Effect<void>; <A>(self: SubscriptionRef<A>, value: A): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "setAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const setAndGet: { <A>(value: A): (self: SubscriptionRef<A>) => Effect.Effect<A>; <A>(self: SubscriptionRef<A>, value: A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "update",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const update: { <A>(f: (a: A) => A): (self: SubscriptionRef<A>) => Effect.Effect<void>; <A>(self: SubscriptionRef<A>, f: (a: A) => A): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateEffect: { <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<void, E, R>; <A, R, E>(self: Synchronized.SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateAndGet: { <A>(f: (a: A) => A): (self: SubscriptionRef<A>) => Effect.Effect<A>; <A>(self: SubscriptionRef<A>, f: (a: A) => A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateAndGetEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateAndGetEffect: { <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SubscriptionRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateSome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateSome: { <A>(f: (a: A) => Option.Option<A>): (self: SubscriptionRef<A>) => Effect.Effect<void>; <A>(self: SubscriptionRef<A>, f: (a: A) => Option.Option<A>): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateSomeEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateSomeEffect: { <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<void, E, R>; <A, R, E>(self: Synchronized.SynchronizedRef<A>, pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): Effect.Effect<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateSomeAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateSomeAndGet: { <A>(pf: (a: A) => Option.Option<A>): (self: SubscriptionRef<A>) => Effect.Effect<A>; <A>(self: SubscriptionRef<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateSomeAndGetEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateSomeAndGetEffect: { <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SubscriptionRef<A>, pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "SubscriptionRef",
    "description": "A `SubscriptionRef<A>` is a `Ref` that can be subscribed to in order to\nreceive the current value as well as all changes to the value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SubscriptionRef<in out A>\n  extends SubscriptionRef.Variance<A>, Synchronized.SynchronizedRef<A>, Subscribable<A>\n{\n  /** @internal */\n  readonly ref: Ref.Ref<A>\n  /** @internal */\n  readonly pubsub: PubSub.PubSub<A>\n  /** @internal */\n  readonly semaphore: Effect.Semaphore\n  /**\n   * A stream containing the current value of the `Ref` as well as all changes\n   * to that value.\n   */\n  readonly changes: Stream.Stream<A>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: SubscriptionRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: SubscriptionRefUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "SubscriptionRefUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface SubscriptionRefUnify<A extends { [Unify.typeSymbol]?: any }>\n  extends Synchronized.SynchronizedRefUnify<A>\n{\n  SubscriptionRef?: () => Extract<A[Unify.typeSymbol], SubscriptionRef<any>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "SubscriptionRefUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface SubscriptionRefUnifyIgnore extends Synchronized.SynchronizedRefUnifyIgnore {\n  SynchronizedRef?: true\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SubscriptionRef",
      "path": [
        "src",
        "SubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "SubscriptionRefTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type SubscriptionRefTypeId = typeof SubscriptionRefTypeId"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Supervisor",
      "path": [
        "src",
        "Supervisor.ts"
      ]
    },
    "project": "effect",
    "name": "AbstractSupervisor",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare class AbstractSupervisor<T>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Supervisor",
      "path": [
        "src",
        "Supervisor.ts"
      ]
    },
    "project": "effect",
    "name": "SupervisorTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const SupervisorTypeId: typeof SupervisorTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Supervisor",
      "path": [
        "src",
        "Supervisor.ts"
      ]
    },
    "project": "effect",
    "name": "addSupervisor",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const addSupervisor: <A>(supervisor: Supervisor<A>) => Layer.Layer<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Supervisor",
      "path": [
        "src",
        "Supervisor.ts"
      ]
    },
    "project": "effect",
    "name": "fibersIn",
    "description": "Creates a new supervisor that tracks children in a set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fibersIn: (ref: MutableRef.MutableRef<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>) => Effect.Effect<Supervisor<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Supervisor",
      "path": [
        "src",
        "Supervisor.ts"
      ]
    },
    "project": "effect",
    "name": "fromEffect",
    "description": "Creates a new supervisor that constantly yields effect when polled",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromEffect: <A>(effect: Effect.Effect<A>) => Supervisor<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Supervisor",
      "path": [
        "src",
        "Supervisor.ts"
      ]
    },
    "project": "effect",
    "name": "none",
    "description": "A supervisor that doesn't do anything in response to supervision events.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const none: Supervisor<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Supervisor",
      "path": [
        "src",
        "Supervisor.ts"
      ]
    },
    "project": "effect",
    "name": "track",
    "description": "Creates a new supervisor that tracks children in a set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const track: Effect.Effect<Supervisor<Fiber.RuntimeFiber<any, any>[]>, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Supervisor",
      "path": [
        "src",
        "Supervisor.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeTrack",
    "description": "Unsafely creates a new supervisor that tracks children in a set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeTrack: () => Supervisor<Array<Fiber.RuntimeFiber<any, any>>>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Supervisor",
      "path": [
        "src",
        "Supervisor.ts"
      ]
    },
    "project": "effect",
    "name": "Supervisor",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Supervisor<out T> extends Supervisor.Variance<T> {\n  /**\n   * Returns an `Effect` that succeeds with the value produced by this\n   * supervisor. This value may change over time, reflecting what the supervisor\n   * produces as it supervises fibers.\n   */\n  readonly value: Effect.Effect<T>\n\n  /**\n   * Supervises the start of a `Fiber`.\n   */\n  onStart<A, E, R>(\n    context: Context.Context<R>,\n    effect: Effect.Effect<A, E, R>,\n    parent: Option.Option<Fiber.RuntimeFiber<any, any>>,\n    fiber: Fiber.RuntimeFiber<A, E>\n  ): void\n\n  /**\n   * Supervises the end of a `Fiber`.\n   */\n  onEnd<A, E>(value: Exit.Exit<A, E>, fiber: Fiber.RuntimeFiber<A, E>): void\n\n  /**\n   * Supervises the execution of an `Effect` by a `Fiber`.\n   */\n  onEffect<A, E>(fiber: Fiber.RuntimeFiber<A, E>, effect: Effect.Effect<any, any, any>): void\n\n  /**\n   * Supervises the suspension of a computation running within a `Fiber`.\n   */\n  onSuspend<A, E>(fiber: Fiber.RuntimeFiber<A, E>): void\n\n  /**\n   * Supervises the resumption of a computation running within a `Fiber`.\n   */\n  onResume<A, E>(fiber: Fiber.RuntimeFiber<A, E>): void\n\n  /**\n   * Maps this supervisor to another one, which has the same effect, but whose\n   * value has been transformed by the specified function.\n   */\n  map<B>(f: (a: T) => B): Supervisor<B>\n\n  /**\n   * Returns a new supervisor that performs the function of this supervisor, and\n   * the function of the specified supervisor, producing a tuple of the outputs\n   * produced by both supervisors.\n   */\n  zip<A>(right: Supervisor<A>): Supervisor<[T, A]>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Supervisor",
      "path": [
        "src",
        "Supervisor.ts"
      ]
    },
    "project": "effect",
    "name": "SupervisorTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type SupervisorTypeId = typeof SupervisorTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Symbol",
      "path": [
        "src",
        "Symbol.ts"
      ]
    },
    "project": "effect",
    "name": "isSymbol",
    "description": "Tests if a value is a `symbol`.",
    "deprecated": false,
    "examples": [
      "import { Predicate } from \"effect\"\n\nassert.deepStrictEqual(Predicate.isSymbol(Symbol.for(\"a\")), true)\nassert.deepStrictEqual(Predicate.isSymbol(\"a\"), false)"
    ],
    "since": "2.0.0",
    "category": "guards",
    "signature": "export declare const isSymbol: (u: unknown) => u is symbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Symbol",
      "path": [
        "src",
        "Symbol.ts"
      ]
    },
    "project": "effect",
    "name": "Equivalence",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "instances",
    "signature": "export declare const Equivalence: equivalence.Equivalence<symbol>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "SynchronizedRefTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const SynchronizedRefTypeId: typeof SynchronizedRefTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <A>(value: A) => Effect.Effect<SynchronizedRef<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const get: <A>(self: SynchronizedRef<A>) => Effect.Effect<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndSet: { <A>(value: A): (self: Ref.Ref<A>) => Effect.Effect<A>; <A>(self: Ref.Ref<A>, value: A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndUpdate: { <A>(f: (a: A) => A): (self: Ref.Ref<A>) => Effect.Effect<A>; <A>(self: Ref.Ref<A>, f: (a: A) => A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdateEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndUpdateEffect: { <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdateSome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndUpdateSome: { <A>(pf: (a: A) => Option.Option<A>): (self: Ref.Ref<A>) => Effect.Effect<A>; <A>(self: Ref.Ref<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdateSomeEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const getAndUpdateSomeEffect: { <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SynchronizedRef<A>, pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "modify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const modify: { <A, B>(f: (a: A) => readonly [B, A]): (self: SynchronizedRef<A>) => Effect.Effect<B>; <A, B>(self: SynchronizedRef<A>, f: (a: A) => readonly [B, A]): Effect.Effect<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "modifyEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const modifyEffect: { <A, B, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): (self: SynchronizedRef<A>) => Effect.Effect<B, E, R>; <A, B, E, R>(self: SynchronizedRef<A>, f: (a: A) => Effect.Effect<readonly [B, A], E, R>): Effect.Effect<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "modifySome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const modifySome: { <B, A>(fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): (self: Ref.Ref<A>) => Effect.Effect<B>; <A, B>(self: Ref.Ref<A>, fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): Effect.Effect<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "modifySomeEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const modifySomeEffect: { <A, B, R, E>(fallback: B, pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>): (self: SynchronizedRef<A>) => Effect.Effect<B, E, R>; <A, B, R, E>(self: SynchronizedRef<A>, fallback: B, pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>): Effect.Effect<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const set: { <A>(value: A): (self: Ref.Ref<A>) => Effect.Effect<void>; <A>(self: Ref.Ref<A>, value: A): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "setAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const setAndGet: { <A>(value: A): (self: Ref.Ref<A>) => Effect.Effect<A>; <A>(self: Ref.Ref<A>, value: A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "update",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const update: { <A>(f: (a: A) => A): (self: Ref.Ref<A>) => Effect.Effect<void>; <A>(self: Ref.Ref<A>, f: (a: A) => A): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateEffect: { <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SynchronizedRef<A>) => Effect.Effect<void, E, R>; <A, R, E>(self: SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateAndGet: { <A>(f: (a: A) => A): (self: Ref.Ref<A>) => Effect.Effect<A>; <A>(self: Ref.Ref<A>, f: (a: A) => A): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateAndGetEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateAndGetEffect: { <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateSome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateSome: { <A>(f: (a: A) => Option.Option<A>): (self: Ref.Ref<A>) => Effect.Effect<void>; <A>(self: Ref.Ref<A>, f: (a: A) => Option.Option<A>): Effect.Effect<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateSomeEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateSomeEffect: { <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SynchronizedRef<A>) => Effect.Effect<void, E, R>; <A, R, E>(self: SynchronizedRef<A>, pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): Effect.Effect<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateSomeAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateSomeAndGet: { <A>(pf: (a: A) => Option.Option<A>): (self: Ref.Ref<A>) => Effect.Effect<A>; <A>(self: Ref.Ref<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateSomeAndGetEffect",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const updateSomeAndGetEffect: { <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>; <A, R, E>(self: SynchronizedRef<A>, pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMake",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeMake: <A>(value: A) => SynchronizedRef<A>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "SynchronizedRef",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SynchronizedRef<in out A> extends SynchronizedRef.Variance<A>, Ref.Ref<A> {\n  modifyEffect<B, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): Effect.Effect<B, E, R>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: SynchronizedRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: SynchronizedRefUnifyIgnore\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "SynchronizedRefUnify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface SynchronizedRefUnify<A extends { [Unify.typeSymbol]?: any }> extends Ref.RefUnify<A> {\n  SynchronizedRef?: () => Extract<A[Unify.typeSymbol], SynchronizedRef<any>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "SynchronizedRefUnifyIgnore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.8.0",
    "category": "models",
    "signature": "export interface SynchronizedRefUnifyIgnore extends Ref.RefUnifyIgnore {\n  Ref?: true\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "SynchronizedRef",
      "path": [
        "src",
        "SynchronizedRef.ts"
      ]
    },
    "project": "effect",
    "name": "SynchronizedRefTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type SynchronizedRefTypeId = typeof SynchronizedRefTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "TakeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TakeTypeId: typeof TakeTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "chunk",
    "description": "Creates a `Take` with the specified chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const chunk: <A>(chunk: Chunk.Chunk<A>) => Take<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "die",
    "description": "Creates a failing `Take` with the specified defect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const die: (defect: unknown) => Take<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "dieMessage",
    "description": "Creates a failing `Take` with the specified error message.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dieMessage: (message: string) => Take<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "done",
    "description": "Transforms a `Take<A, E>` to an `Effect<A, E>`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const done: <A, E>(self: Take<A, E>) => Effect.Effect<Chunk.Chunk<A>, Option.Option<E>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "end",
    "description": "Represents the end-of-stream marker.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const end: Take<never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": "Creates a failing `Take` with the specified error.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fail: <E>(error: E) => Take<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "failCause",
    "description": "Creates a failing `Take` with the specified cause.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const failCause: <E>(cause: Cause.Cause<E>) => Take<never, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "fromEffect",
    "description": "Creates an effect from `Effect<A, E, R>` that does not fail, but succeeds with\nthe `Take<A, E>`. Error from stream when pulling is converted to\n`Take.failCause`. Creates a single value chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<Take<A, E>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "fromExit",
    "description": "Creates a `Take` from an `Exit`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromExit: <A, E>(exit: Exit.Exit<A, E>) => Take<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "fromPull",
    "description": "Creates effect from `Effect<Chunk<A>, Option<E>, R>` that does not fail, but\nsucceeds with the `Take<A, E>`. Errors from stream when pulling are converted\nto `Take.failCause`, and the end-of-stream is converted to `Take.end`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromPull: <A, E, R>(pull: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>) => Effect.Effect<Take<A, E>, never, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "isDone",
    "description": "Checks if this `take` is done (`Take.end`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isDone: <A, E>(self: Take<A, E>) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "isFailure",
    "description": "Checks if this `take` is a failure.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isFailure: <A, E>(self: Take<A, E>) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "isSuccess",
    "description": "Checks if this `take` is a success.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isSuccess: <A, E>(self: Take<A, E>) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a `Take`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <A, E>(exit: Exit.Exit<Chunk.Chunk<A>, Option.Option<E>>) => Take<A, E>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms `Take<A, E>` to `Take<B, A>` by applying function `f`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const map: { <A, B>(f: (a: A) => B): <E>(self: Take<A, E>) => Take<B, E>; <A, E, B>(self: Take<A, E>, f: (a: A) => B): Take<B, E>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Folds over the failure cause, success value and end-of-stream marker to\nyield a value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const match: { <Z, E, Z2, A, Z3>(options: { readonly onEnd: () => Z; readonly onFailure: (cause: Cause.Cause<E>) => Z2; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Z3; }): (self: Take<A, E>) => Z | Z2 | Z3; <A, E, Z, Z2, Z3>(self: Take<A, E>, options: { readonly onEnd: () => Z; readonly onFailure: (cause: Cause.Cause<E>) => Z2; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Z3; }): Z | Z2 | Z3; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "matchEffect",
    "description": "Effectful version of `Take.fold`.\n\nFolds over the failure cause, success value and end-of-stream marker to\nyield an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const matchEffect: { <Z, E2, R, E, Z2, R2, A, Z3, E3, R3>(options: { readonly onEnd: Effect.Effect<Z, E2, R>; readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<Z2, E2, R2>; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Effect.Effect<Z3, E3, R3>; }): (self: Take<A, E>) => Effect.Effect<Z | Z2 | Z3, E2 | E | E3, R | R2 | R3>; <A, E, Z, E2, R, Z2, R2, Z3, E3, R3>(self: Take<A, E>, options: { readonly onEnd: Effect.Effect<Z, E2, R>; readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<Z2, E2, R2>; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Effect.Effect<Z3, E3, R3>; }): Effect.Effect<Z | Z2 | Z3, E | E2 | E3, R | R2 | R3>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "of",
    "description": "Creates a `Take` with a single value chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const of: <A>(value: A) => Take<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "tap",
    "description": "Returns an effect that effectfully \"peeks\" at the success of this take.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "sequencing",
    "signature": "export declare const tap: { <A, X, E2, R>(f: (chunk: Chunk.Chunk<A>) => Effect.Effect<X, E2, R>): <E>(self: Take<A, E>) => Effect.Effect<void, E2 | E, R>; <A, E, X, E2, R>(self: Take<A, E>, f: (chunk: Chunk.Chunk<A>) => Effect.Effect<X, E2, R>): Effect.Effect<void, E | E2, R>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "Take",
    "description": "A `Take<A, E>` represents a single `take` from a queue modeling a stream of\nvalues. A `Take` may be a failure cause `Cause<E>`, a chunk value `Chunk<A>`,\nor an end-of-stream marker.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Take<out A, out E = never> extends Take.Variance<A, E>, Pipeable {\n  /** @internal */\n  readonly exit: Exit.Exit<Chunk.Chunk<A>, Option.Option<E>>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Take",
      "path": [
        "src",
        "Take.ts"
      ]
    },
    "project": "effect",
    "name": "TakeTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type TakeTypeId = typeof TakeTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "TArrayTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TArrayTypeId: typeof TArrayTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "collectFirst",
    "description": "Finds the result of applying a partial function to the first value in its\ndomain.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const collectFirst: { <A, B>(pf: (a: A) => Option.Option<B>): (self: TArray<A>) => STM.STM<Option.Option<B>>; <A, B>(self: TArray<A>, pf: (a: A) => Option.Option<B>): STM.STM<Option.Option<B>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "collectFirstSTM",
    "description": "Finds the result of applying an transactional partial function to the first\nvalue in its domain.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const collectFirstSTM: { <A, B, E, R>(pf: (a: A) => Option.Option<STM.STM<B, E, R>>): (self: TArray<A>) => STM.STM<Option.Option<B>, E, R>; <A, B, E, R>(self: TArray<A>, pf: (a: A) => Option.Option<STM.STM<B, E, R>>): STM.STM<Option.Option<B>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "contains",
    "description": "Determine if the array contains a specified value.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const contains: { <A>(value: A): (self: TArray<A>) => STM.STM<boolean>; <A>(self: TArray<A>, value: A): STM.STM<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "count",
    "description": "Count the values in the array matching a predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const count: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<number>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<number>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "countSTM",
    "description": "Count the values in the array matching a transactional predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const countSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<number, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<number, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "Makes an empty `TArray`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: <A>() => STM.STM<TArray<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "every",
    "description": "Atomically evaluate the conjunction of a predicate across the members of\nthe array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const every: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<boolean>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "everySTM",
    "description": "Atomically evaluate the conjunction of a transactional predicate across the\nmembers of the array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const everySTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<boolean, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<boolean, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "findFirst",
    "description": "Find the first element in the array matching the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirst: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "findFirstIndex",
    "description": "Get the first index of a specific value in the array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirstIndex: { <A>(value: A): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A): STM.STM<Option.Option<number>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "findFirstIndexFrom",
    "description": "Get the first index of a specific value in the array starting from the\nspecified index.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirstIndexFrom: { <A>(value: A, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A, from: number): STM.STM<Option.Option<number>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "findFirstIndexWhere",
    "description": "Get the index of the first entry in the array matching a predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirstIndexWhere: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<number>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "findFirstIndexWhereFrom",
    "description": "Get the index of the first entry in the array starting from the specified\nindex, matching a predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirstIndexWhereFrom: { <A>(predicate: Predicate<A>, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, predicate: Predicate<A>, from: number): STM.STM<Option.Option<number>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "findFirstIndexWhereSTM",
    "description": "Get the index of the next entry that matches a transactional predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirstIndexWhereSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<number>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<number>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "findFirstIndexWhereFromSTM",
    "description": "Starting at specified index, get the index of the next entry that matches a\ntransactional predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirstIndexWhereFromSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>, from: number): STM.STM<Option.Option<number>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "findFirstSTM",
    "description": "Find the first element in the array matching a transactional predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findFirstSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "findLast",
    "description": "Find the last element in the array matching a predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findLast: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "findLastIndex",
    "description": "Get the last index of a specific value in the array bounded above by a\nspecific index.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findLastIndex: { <A>(value: A): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A): STM.STM<Option.Option<number>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "findLastIndexFrom",
    "description": "Get the last index of a specific value in the array bounded above by a\nspecific index.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findLastIndexFrom: { <A>(value: A, end: number): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A, end: number): STM.STM<Option.Option<number>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "findLastSTM",
    "description": "Find the last element in the array matching a transactional predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findLastSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "Atomically performs transactional effect for each item in array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const forEach: { <A, R, E>(f: (value: A) => STM.STM<void, E, R>): (self: TArray<A>) => STM.STM<void, E, R>; <A, R, E>(self: TArray<A>, f: (value: A) => STM.STM<void, E, R>): STM.STM<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `TArray` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterable: <A>(iterable: Iterable<A>) => STM.STM<TArray<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Extracts value from ref in array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const get: { (index: number): <A>(self: TArray<A>) => STM.STM<A>; <A>(self: TArray<A>, index: number): STM.STM<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "headOption",
    "description": "The first entry of the array, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const headOption: <A>(self: TArray<A>) => STM.STM<Option.Option<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "lastOption",
    "description": "The last entry in the array, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const lastOption: <A>(self: TArray<A>) => STM.STM<Option.Option<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Makes a new `TArray` that is initialized with specified values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <Elements extends [any, ...Array<any>]>(...elements: Elements) => STM.STM<TArray<Elements[number]>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "maxOption",
    "description": "Atomically compute the greatest element in the array, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const maxOption: { <A>(order: Order.Order<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, order: Order.Order<A>): STM.STM<Option.Option<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "minOption",
    "description": "Atomically compute the least element in the array, if it exists.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const minOption: { <A>(order: Order.Order<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, order: Order.Order<A>): STM.STM<Option.Option<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": "Atomically folds using a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduce: { <Z, A>(zero: Z, f: (accumulator: Z, current: A) => Z): (self: TArray<A>) => STM.STM<Z>; <Z, A>(self: TArray<A>, zero: Z, f: (accumulator: Z, current: A) => Z): STM.STM<Z>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "reduceOption",
    "description": "Atomically reduce the array, if non-empty, by a binary operator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const reduceOption: { <A>(f: (x: A, y: A) => A): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, f: (x: A, y: A) => A): STM.STM<Option.Option<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "reduceOptionSTM",
    "description": "Atomically reduce the non-empty array using a transactional binary\noperator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const reduceOptionSTM: { <A, R, E>(f: (x: A, y: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>; <A, R, E>(self: TArray<A>, f: (x: A, y: A) => STM.STM<A, E, R>): STM.STM<Option.Option<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "reduceSTM",
    "description": "Atomically folds using a transactional function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduceSTM: { <Z, A, R, E>(zero: Z, f: (accumulator: Z, current: A) => STM.STM<Z, E, R>): (self: TArray<A>) => STM.STM<Z, E, R>; <Z, A, R, E>(self: TArray<A>, zero: Z, f: (accumulator: Z, current: A) => STM.STM<Z, E, R>): STM.STM<Z, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the size of the `TArray`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const size: <A>(self: TArray<A>) => number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "some",
    "description": "Determine if the array contains a value satisfying a predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const some: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<boolean>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "someSTM",
    "description": "Determine if the array contains a value satisfying a transactional\npredicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const someSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<boolean, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<boolean, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "toArray",
    "description": "Collects all elements into a chunk.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toArray: <A>(self: TArray<A>) => STM.STM<Array<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "transform",
    "description": "Atomically updates all elements using a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const transform: { <A>(f: (value: A) => A): (self: TArray<A>) => STM.STM<void>; <A>(self: TArray<A>, f: (value: A) => A): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "transformSTM",
    "description": "Atomically updates all elements using a transactional effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const transformSTM: { <A, R, E>(f: (value: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<void, E, R>; <A, R, E>(self: TArray<A>, f: (value: A) => STM.STM<A, E, R>): STM.STM<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "update",
    "description": "Updates element in the array with given function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const update: { <A>(index: number, f: (value: A) => A): (self: TArray<A>) => STM.STM<void>; <A>(self: TArray<A>, index: number, f: (value: A) => A): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "updateSTM",
    "description": "Atomically updates element in the array with given transactional effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const updateSTM: { <A, R, E>(index: number, f: (value: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<void, E, R>; <A, R, E>(self: TArray<A>, index: number, f: (value: A) => STM.STM<A, E, R>): STM.STM<void, E, R>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "TArray",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TArray<in out A> extends TArray.Variance<A> {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TArray",
      "path": [
        "src",
        "TArray.ts"
      ]
    },
    "project": "effect",
    "name": "TArrayTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type TArrayTypeId = typeof TArrayTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TDeferred",
      "path": [
        "src",
        "TDeferred.ts"
      ]
    },
    "project": "effect",
    "name": "TDeferredTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TDeferredTypeId: typeof TDeferredTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TDeferred",
      "path": [
        "src",
        "TDeferred.ts"
      ]
    },
    "project": "effect",
    "name": "done",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const done: { <A, E>(either: Either.Either<A, E>): (self: TDeferred<A, E>) => STM.STM<boolean>; <A, E>(self: TDeferred<A, E>, either: Either.Either<A, E>): STM.STM<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TDeferred",
      "path": [
        "src",
        "TDeferred.ts"
      ]
    },
    "project": "effect",
    "name": "fail",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const fail: { <E>(error: E): <A>(self: TDeferred<A, E>) => STM.STM<boolean>; <A, E>(self: TDeferred<A, E>, error: E): STM.STM<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TDeferred",
      "path": [
        "src",
        "TDeferred.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <A, E = never>() => STM.STM<TDeferred<A, E>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TDeferred",
      "path": [
        "src",
        "TDeferred.ts"
      ]
    },
    "project": "effect",
    "name": "poll",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const poll: <A, E>(self: TDeferred<A, E>) => STM.STM<Option.Option<Either.Either<A, E>>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TDeferred",
      "path": [
        "src",
        "TDeferred.ts"
      ]
    },
    "project": "effect",
    "name": "succeed",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const succeed: { <A>(value: A): <E>(self: TDeferred<A, E>) => STM.STM<boolean>; <A, E>(self: TDeferred<A, E>, value: A): STM.STM<boolean>; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "TDeferred",
      "path": [
        "src",
        "TDeferred.ts"
      ]
    },
    "project": "effect",
    "name": "await",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const await: <A, E>(self: TDeferred<A, E>) => STM.STM<A, E>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TDeferred",
      "path": [
        "src",
        "TDeferred.ts"
      ]
    },
    "project": "effect",
    "name": "TDeferred",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TDeferred<in out A, in out E = never> extends TDeferred.Variance<A, E> {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TDeferred",
      "path": [
        "src",
        "TDeferred.ts"
      ]
    },
    "project": "effect",
    "name": "TDeferredTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type TDeferredTypeId = typeof TDeferredTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotation",
      "path": [
        "src",
        "TestAnnotation.ts"
      ]
    },
    "project": "effect",
    "name": "TestAnnotationTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TestAnnotationTypeId: typeof TestAnnotationTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotation",
      "path": [
        "src",
        "TestAnnotation.ts"
      ]
    },
    "project": "effect",
    "name": "fibers",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const fibers: TestAnnotation<Either.Either<Chunk.Chunk<MutableRef.MutableRef<SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>>>, number>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotation",
      "path": [
        "src",
        "TestAnnotation.ts"
      ]
    },
    "project": "effect",
    "name": "ignored",
    "description": "An annotation which counts ignored tests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const ignored: TestAnnotation<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotation",
      "path": [
        "src",
        "TestAnnotation.ts"
      ]
    },
    "project": "effect",
    "name": "repeated",
    "description": "An annotation which counts repeated tests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const repeated: TestAnnotation<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotation",
      "path": [
        "src",
        "TestAnnotation.ts"
      ]
    },
    "project": "effect",
    "name": "retried",
    "description": "An annotation which counts retried tests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const retried: TestAnnotation<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotation",
      "path": [
        "src",
        "TestAnnotation.ts"
      ]
    },
    "project": "effect",
    "name": "tagged",
    "description": "An annotation which tags tests with strings.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const tagged: TestAnnotation<HashSet.HashSet<string>>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotation",
      "path": [
        "src",
        "TestAnnotation.ts"
      ]
    },
    "project": "effect",
    "name": "isTestAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotation",
      "path": [
        "src",
        "TestAnnotation.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotation",
      "path": [
        "src",
        "TestAnnotation.ts"
      ]
    },
    "project": "effect",
    "name": "compose",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestAnnotation",
      "path": [
        "src",
        "TestAnnotation.ts"
      ]
    },
    "project": "effect",
    "name": "TestAnnotation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TestAnnotation<in out A> extends Equal.Equal {\n  readonly [TestAnnotationTypeId]: {\n    readonly _A: Types.Invariant<A>\n  }\n  readonly identifier: string\n  readonly initial: A\n  combine(a: A, b: A): A\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TestAnnotation",
      "path": [
        "src",
        "TestAnnotation.ts"
      ]
    },
    "project": "effect",
    "name": "TestAnnotationTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type TestAnnotationTypeId = typeof TestAnnotationTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotationMap",
      "path": [
        "src",
        "TestAnnotationMap.ts"
      ]
    },
    "project": "effect",
    "name": "TestAnnotationMapTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TestAnnotationMapTypeId: typeof TestAnnotationMapTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotationMap",
      "path": [
        "src",
        "TestAnnotationMap.ts"
      ]
    },
    "project": "effect",
    "name": "overwrite",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const overwrite: (<A>(key: TestAnnotation.TestAnnotation<A>, value: A) => (self: TestAnnotationMap) => TestAnnotationMap) & (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>, value: A) => TestAnnotationMap)"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotationMap",
      "path": [
        "src",
        "TestAnnotationMap.ts"
      ]
    },
    "project": "effect",
    "name": "update",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const update: (<A>(key: TestAnnotation.TestAnnotation<A>, f: (value: A) => A) => (self: TestAnnotationMap) => TestAnnotationMap) & (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>, f: (value: A) => A) => TestAnnotationMap)"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotationMap",
      "path": [
        "src",
        "TestAnnotationMap.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves the annotation of the specified type, or its default value if\nthere is none.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const get: (<A>(key: TestAnnotation.TestAnnotation<A>) => (self: TestAnnotationMap) => A) & (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>) => A)"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotationMap",
      "path": [
        "src",
        "TestAnnotationMap.ts"
      ]
    },
    "project": "effect",
    "name": "annotate",
    "description": "Appends the specified annotation to the annotation map.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const annotate: (<A>(key: TestAnnotation.TestAnnotation<A>, value: A) => (self: TestAnnotationMap) => TestAnnotationMap) & (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>, value: A) => TestAnnotationMap)"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotationMap",
      "path": [
        "src",
        "TestAnnotationMap.ts"
      ]
    },
    "project": "effect",
    "name": "combine",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const combine: ((that: TestAnnotationMap) => (self: TestAnnotationMap) => TestAnnotationMap) & ((self: TestAnnotationMap, that: TestAnnotationMap) => TestAnnotationMap)"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotationMap",
      "path": [
        "src",
        "TestAnnotationMap.ts"
      ]
    },
    "project": "effect",
    "name": "isTestAnnotationMap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotationMap",
      "path": [
        "src",
        "TestAnnotationMap.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotationMap",
      "path": [
        "src",
        "TestAnnotationMap.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestAnnotationMap",
      "path": [
        "src",
        "TestAnnotationMap.ts"
      ]
    },
    "project": "effect",
    "name": "TestAnnotationMap",
    "description": "An annotation map keeps track of annotations of different types.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TestAnnotationMap {\n  readonly [TestAnnotationMapTypeId]: TestAnnotationMapTypeId\n  /** @internal */\n  readonly map: HashMap.HashMap<TestAnnotation.TestAnnotation<any>, any>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TestAnnotationMap",
      "path": [
        "src",
        "TestAnnotationMap.ts"
      ]
    },
    "project": "effect",
    "name": "TestAnnotationMapTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type TestAnnotationMapTypeId = typeof TestAnnotationMapTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotations",
      "path": [
        "src",
        "TestAnnotations.ts"
      ]
    },
    "project": "effect",
    "name": "TestAnnotationsTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TestAnnotationsTypeId: typeof TestAnnotationsTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestAnnotations",
      "path": [
        "src",
        "TestAnnotations.ts"
      ]
    },
    "project": "effect",
    "name": "TestAnnotations",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TestAnnotations: Context.Tag<TestAnnotations, TestAnnotations>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotations",
      "path": [
        "src",
        "TestAnnotations.ts"
      ]
    },
    "project": "effect",
    "name": "isTestAnnotations",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestAnnotations",
      "path": [
        "src",
        "TestAnnotations.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestAnnotations",
      "path": [
        "src",
        "TestAnnotations.ts"
      ]
    },
    "project": "effect",
    "name": "TestAnnotations",
    "description": "The `Annotations` trait provides access to an annotation map that tests can\nadd arbitrary annotations to. Each annotation consists of a string\nidentifier, an initial value, and a function for combining two values.\nAnnotations form monoids and you can think of `Annotations` as a more\nstructured logging service or as a super polymorphic version of the writer\nmonad effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TestAnnotations {\n  readonly [TestAnnotationsTypeId]: TestAnnotationsTypeId\n\n  /**\n   * A ref containing the bacnking map for all annotations\n   */\n  readonly ref: Ref.Ref<TestAnnotationMap.TestAnnotationMap>\n\n  /**\n   * Accesses an `Annotations` instance in the context and retrieves the\n   * annotation of the specified type, or its default value if there is none.\n   */\n  get<A>(key: TestAnnotation.TestAnnotation<A>): Effect.Effect<A>\n\n  /**\n   * Accesses an `Annotations` instance in the context and appends the\n   * specified annotation to the annotation map.\n   */\n  annotate<A>(key: TestAnnotation.TestAnnotation<A>, value: A): Effect.Effect<void>\n\n  /**\n   * Returns the set of all fibers in this test.\n   */\n  readonly supervisedFibers: Effect.Effect<\n    SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>\n  >\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TestAnnotations",
      "path": [
        "src",
        "TestAnnotations.ts"
      ]
    },
    "project": "effect",
    "name": "TestAnnotationsTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type TestAnnotationsTypeId = typeof TestAnnotationsTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "TestClock",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TestClock: Context.Tag<TestClock, TestClock>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "defaultTestClock",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const defaultTestClock: Layer.Layer<TestClock, never, Annotations.TestAnnotations | Live.TestLive>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "adjustWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const adjustWith: ((duration: Duration.DurationInput) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, duration: Duration.DurationInput) => Effect.Effect<A, E, R>)"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "currentTimeMillis",
    "description": "Accesses the current time of a `TestClock` instance in the context in\nmilliseconds.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const currentTimeMillis: Effect.Effect<number, never, never>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "makeData",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "live",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "adjust",
    "description": "Accesses a `TestClock` instance in the context and increments the time\nby the specified duration, running any actions scheduled for on or before\nthe new time in order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "save",
    "description": "Accesses a `TestClock` instance in the context and saves the clock\nstate in an effect which, when run, will restore the `TestClock` to the\nsaved state.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "setTime",
    "description": "Accesses a `TestClock` instance in the context and sets the clock time\nto the specified `Instant`, running any actions scheduled for on or before\nthe new time in order.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "sleep",
    "description": "Semantically blocks the current fiber until the clock time is equal to or\ngreater than the specified duration. Once the clock time is adjusted to\non or after the duration, the fiber will automatically be resumed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "sleeps",
    "description": "Accesses a `TestClock` instance in the context and returns a list of\ntimes that effects are scheduled to run.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "testClock",
    "description": "Retrieves the `TestClock` service for this test.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "testClockWith",
    "description": "Retrieves the `TestClock` service for this test and uses it to run the\nspecified workflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "Data",
    "description": "`Data` represents the state of the `TestClock`, including the clock time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.1",
    "category": null,
    "signature": "export interface Data {\n  readonly instant: number\n  readonly sleeps: Chunk.Chunk<readonly [number, Deferred.Deferred<void>]>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestClock",
      "path": [
        "src",
        "TestClock.ts"
      ]
    },
    "project": "effect",
    "name": "TestClock",
    "description": "A `TestClock` makes it easy to deterministically and efficiently test effects\ninvolving the passage of time.\n\nInstead of waiting for actual time to pass, `sleep` and methods implemented\nin terms of it schedule effects to take place at a given clock time. Users\ncan adjust the clock time using the `adjust` and `setTime` methods, and all\neffects scheduled to take place on or before that time will automatically be\nrun in order.\n\nFor example, here is how we can test `Effect.timeout` using `TestClock`:\n\n```ts\nimport { Duration, Effect, Fiber, TestClock, Option } from \"effect\"\n\nEffect.gen(function*() {\n  const fiber = yield* pipe(\n    Effect.sleep(Duration.minutes(5)),\n    Effect.timeout(Duration.minutes(1)),\n    Effect.fork\n  )\n  yield* TestClock.adjust(Duration.minutes(1))\n  const result = yield* Fiber.join(fiber)\n  assert.deepStrictEqual(result, Option.none())\n})\n```\n\nNote how we forked the fiber that `sleep` was invoked on. Calls to `sleep`\nand methods derived from it will semantically block until the time is set to\non or after the time they are scheduled to run. If we didn't fork the fiber\non which we called sleep we would never get to set the time on the line\nbelow. Thus, a useful pattern when using `TestClock` is to fork the effect\nbeing tested, then adjust the clock time, and finally verify that the\nexpected effects have been performed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TestClock extends Clock.Clock {\n  adjust(duration: Duration.DurationInput): Effect.Effect<void>\n  adjustWith(duration: Duration.DurationInput): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  readonly save: Effect.Effect<Effect.Effect<void>>\n  setTime(time: number): Effect.Effect<void>\n  readonly sleeps: Effect.Effect<Chunk.Chunk<number>>\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestConfig",
      "path": [
        "src",
        "TestConfig.ts"
      ]
    },
    "project": "effect",
    "name": "TestConfig",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TestConfig: Context.Tag<TestConfig, TestConfig>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestConfig",
      "path": [
        "src",
        "TestConfig.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestConfig",
      "path": [
        "src",
        "TestConfig.ts"
      ]
    },
    "project": "effect",
    "name": "TestConfig",
    "description": "The `TestConfig` service provides access to default configuration settings\nused by tests, including the number of times to repeat tests to ensure\nthey are stable, the number of times to retry flaky tests, the sufficient\nnumber of samples to check from a random variable, and the maximum number of\nshrinkings to minimize large failures.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TestConfig {\n  /**\n   * The number of times to repeat tests to ensure they are stable.\n   */\n  readonly repeats: number\n  /**\n   * The number of times to retry flaky tests.\n   */\n  readonly retries: number\n  /**\n   * The number of sufficient samples to check for a random variable.\n   */\n  readonly samples: number\n  /**\n   * The maximum number of shrinkings to minimize large failures\n   */\n  readonly shrinks: number\n}"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestContext",
      "path": [
        "src",
        "TestContext.ts"
      ]
    },
    "project": "effect",
    "name": "LiveContext",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const LiveContext: Layer.Layer<DefaultServices.DefaultServices, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestContext",
      "path": [
        "src",
        "TestContext.ts"
      ]
    },
    "project": "effect",
    "name": "TestContext",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TestContext: Layer.Layer<TestServices.TestServices, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestLive",
      "path": [
        "src",
        "TestLive.ts"
      ]
    },
    "project": "effect",
    "name": "TestLiveTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TestLiveTypeId: typeof TestLiveTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestLive",
      "path": [
        "src",
        "TestLive.ts"
      ]
    },
    "project": "effect",
    "name": "TestLive",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TestLive: Context.Tag<TestLive, TestLive>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestLive",
      "path": [
        "src",
        "TestLive.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestLive",
      "path": [
        "src",
        "TestLive.ts"
      ]
    },
    "project": "effect",
    "name": "TestLive",
    "description": "The `Live` trait provides access to the \"live\" default Effect services from\nwithin tests for workflows such as printing test results to the console or\ntiming out tests where it is necessary to access the real implementations of\nthese services.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TestLive {\n  readonly [TestLiveTypeId]: TestLiveTypeId\n  provide<A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TestLive",
      "path": [
        "src",
        "TestLive.ts"
      ]
    },
    "project": "effect",
    "name": "TestLiveTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type TestLiveTypeId = typeof TestLiveTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "liveServices",
    "description": "The default Effect test services.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const liveServices: Context.Context<TestServices>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "currentServices",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const currentServices: FiberRef.FiberRef<Context.Context<TestServices>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "withAnnotations",
    "description": "Executes the specified workflow with the specified implementation of the\nannotations service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const withAnnotations: ((annotations: Annotations.TestAnnotations) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, annotations: Annotations.TestAnnotations) => Effect.Effect<A, E, R>)"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "live",
    "description": "Retrieves the `Live` service for this test.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const live: Effect.Effect<Live.TestLive, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "withLive",
    "description": "Executes the specified workflow with the specified implementation of the\nlive service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const withLive: ((live: Live.TestLive) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, live: Live.TestLive) => Effect.Effect<A, E, R>)"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "provideWithLive",
    "description": "Runs a transformation function with the live default Effect services while\nensuring that the workflow itself is run with the test services.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const provideWithLive: (<A, E, R, A2, E2, R2>(f: (effect: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>) => (self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E | E2, R | R2>) & (<A, E, R, A2, E2, R2>(self: Effect.Effect<A, E, R>, f: (effect: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>) => Effect.Effect<A2, E | E2, R | R2>)"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "sized",
    "description": "Retrieves the `Sized` service for this test.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const sized: Effect.Effect<Sized.TestSized, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "withSized",
    "description": "Executes the specified workflow with the specified implementation of the\nsized service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const withSized: ((sized: Sized.TestSized) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, sized: Sized.TestSized) => Effect.Effect<A, E, R>)"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const size: Effect.Effect<number, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "withSize",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const withSize: ((size: number) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, size: number) => Effect.Effect<A, E, R>)"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "testConfig",
    "description": "Retrieves the `TestConfig` service for this test.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const testConfig: Effect.Effect<TestConfig.TestConfig, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "withTestConfig",
    "description": "Executes the specified workflow with the specified implementation of the\nconfig service.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const withTestConfig: ((config: TestConfig.TestConfig) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, config: TestConfig.TestConfig) => Effect.Effect<A, E, R>)"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "repeats",
    "description": "The number of times to repeat tests to ensure they are stable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const repeats: Effect.Effect<number, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "retries",
    "description": "The number of times to retry flaky tests.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const retries: Effect.Effect<number, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "samples",
    "description": "The number of sufficient samples to check for a random variable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const samples: Effect.Effect<number, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "shrinks",
    "description": "The maximum number of shrinkings to minimize large failures.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const shrinks: Effect.Effect<number, never, never>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "annotations",
    "description": "Retrieves the `Annotations` service for this test.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "annotationsWith",
    "description": "Retrieves the `Annotations` service for this test and uses it to run the\nspecified workflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "withAnnotationsScoped",
    "description": "Sets the implementation of the annotations service to the specified value\nand restores it to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "annotationsLayer",
    "description": "Constructs a new `Annotations` service wrapped in a layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Accesses an `Annotations` instance in the context and retrieves the\nannotation of the specified type, or its default value if there is none.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "annotate",
    "description": "Accesses an `Annotations` instance in the context and appends the\nspecified annotation to the annotation map.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "supervisedFibers",
    "description": "Returns the set of all fibers in this test.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "liveWith",
    "description": "Retrieves the `Live` service for this test and uses it to run the specified\nworkflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "withLiveScoped",
    "description": "Sets the implementation of the live service to the specified value and\nrestores it to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "liveLayer",
    "description": "Constructs a new `Live` service wrapped in a layer.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "provideLive",
    "description": "Provides a workflow with the \"live\" default Effect services.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "sizedWith",
    "description": "Retrieves the `Sized` service for this test and uses it to run the\nspecified workflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "withSizedScoped",
    "description": "Sets the implementation of the sized service to the specified value and\nrestores it to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "sizedLayer",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "testConfigWith",
    "description": "Retrieves the `TestConfig` service for this test and uses it to run the\nspecified workflow.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "withTestConfigScoped",
    "description": "Sets the implementation of the config service to the specified value and\nrestores it to its original value when the scope is closed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "testConfigLayer",
    "description": "Constructs a new `TestConfig` service with the specified settings.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TestServices",
      "path": [
        "src",
        "TestServices.ts"
      ]
    },
    "project": "effect",
    "name": "TestServices",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type TestServices =\n  | Annotations.TestAnnotations\n  | Live.TestLive\n  | Sized.TestSized\n  | TestConfig.TestConfig"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestSized",
      "path": [
        "src",
        "TestSized.ts"
      ]
    },
    "project": "effect",
    "name": "TestSizedTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TestSizedTypeId: typeof TestSizedTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TestSized",
      "path": [
        "src",
        "TestSized.ts"
      ]
    },
    "project": "effect",
    "name": "TestSized",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TestSized: Context.Tag<TestSized, TestSized>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestSized",
      "path": [
        "src",
        "TestSized.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TestSized",
      "path": [
        "src",
        "TestSized.ts"
      ]
    },
    "project": "effect",
    "name": "fromFiberRef",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TestSized",
      "path": [
        "src",
        "TestSized.ts"
      ]
    },
    "project": "effect",
    "name": "TestSized",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface TestSized {\n  readonly [TestSizedTypeId]: TestSizedTypeId\n  readonly fiberRef: FiberRef.FiberRef<number>\n  readonly size: Effect.Effect<number>\n  withSize(size: number): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TestSized",
      "path": [
        "src",
        "TestSized.ts"
      ]
    },
    "project": "effect",
    "name": "TestSizedTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type TestSizedTypeId = typeof TestSizedTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "TMapTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TMapTypeId: typeof TMapTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "Makes an empty `TMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: <K, V>() => STM.STM<TMap<K, V>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "find",
    "description": "Finds the key/value pair matching the specified predicate, and uses the\nprovided function to extract a value out of it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const find: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<Option.Option<A>>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<Option.Option<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "findSTM",
    "description": "Finds the key/value pair matching the specified predicate, and uses the\nprovided effectful function to extract a value out of it.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findSTM: { <K, V, A, E, R>(f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<Option.Option<A>, E, R>; <K, V, A, E, R>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<Option.Option<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "findAll",
    "description": "Finds all the key/value pairs matching the specified predicate, and uses\nthe provided function to extract values out them.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findAll: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<Array<A>>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<Array<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "findAllSTM",
    "description": "Finds all the key/value pairs matching the specified predicate, and uses\nthe provided effectful function to extract values out of them..",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const findAllSTM: { <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<Array<A>, E, R>; <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<Array<A>, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "Atomically performs transactional-effect for each binding present in map.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const forEach: { <K, V, X, E, R>(f: (key: K, value: V) => STM.STM<X, E, R>): (self: TMap<K, V>) => STM.STM<void, E, R>; <K, V, X, E, R>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<X, E, R>): STM.STM<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `TMap` from an iterable collection of key/value pairs.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterable: <K, V>(iterable: Iterable<readonly [K, V]>) => STM.STM<TMap<K, V>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Retrieves value associated with given key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const get: { <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<Option.Option<V>>; <K, V>(self: TMap<K, V>, key: K): STM.STM<Option.Option<V>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "getOrElse",
    "description": "Retrieves value associated with given key or default value, in case the key\nisn't present.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const getOrElse: { <K, V>(key: K, fallback: LazyArg<V>): (self: TMap<K, V>) => STM.STM<V>; <K, V>(self: TMap<K, V>, key: K, fallback: LazyArg<V>): STM.STM<V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "has",
    "description": "Tests whether or not map contains a key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const has: { <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<boolean>; <K, V>(self: TMap<K, V>, key: K): STM.STM<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Tests if the map is empty or not.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isEmpty: <K, V>(self: TMap<K, V>) => STM.STM<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "keys",
    "description": "Collects all keys stored in map.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const keys: <K, V>(self: TMap<K, V>) => STM.STM<Array<K>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Makes a new `TMap` that is initialized with specified values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <K, V>(...entries: Array<readonly [K, V]>) => STM.STM<TMap<K, V>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "merge",
    "description": "If the key is not already associated with a value, stores the provided value,\notherwise merge the existing value with the new one using function `f` and\nstore the result.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const merge: { <K, V>(key: K, value: V, f: (x: V, y: V) => V): (self: TMap<K, V>) => STM.STM<V>; <K, V>(self: TMap<K, V>, key: K, value: V, f: (x: V, y: V) => V): STM.STM<V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": "Atomically folds using a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduce: { <Z, K, V>(zero: Z, f: (acc: Z, value: V, key: K) => Z): (self: TMap<K, V>) => STM.STM<Z>; <K, V, Z>(self: TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => Z): STM.STM<Z>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "reduceSTM",
    "description": "Atomically folds using a transactional function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduceSTM: { <Z, V, K, R, E>(zero: Z, f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>): (self: TMap<K, V>) => STM.STM<Z, E, R>; <Z, V, K, R, E>(self: TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>): STM.STM<Z, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "remove",
    "description": "Removes binding for given key.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const remove: { <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "removeAll",
    "description": "Deletes all entries associated with the specified keys.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const removeAll: { <K>(keys: Iterable<K>): <V>(self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, keys: Iterable<K>): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "removeIf",
    "description": "Removes entries from a `TMap` that satisfy the specified predicate and returns the removed entries\n(or `void` if `discard = true`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const removeIf: { <K, V>(predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): (self: TMap<K, V>) => STM.STM<void>; <K, V>(predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): (self: TMap<K, V>) => STM.STM<Array<[K, V]>>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): STM.STM<void>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): STM.STM<Array<[K, V]>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "retainIf",
    "description": "Retains entries in a `TMap` that satisfy the specified predicate and returns the removed entries\n(or `void` if `discard = true`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const retainIf: { <K, V>(predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): (self: TMap<K, V>) => STM.STM<void>; <K, V>(predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): (self: TMap<K, V>) => STM.STM<Array<[K, V]>>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): STM.STM<void>; <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): STM.STM<Array<[K, V]>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": "Stores new binding into the map.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const set: { <K, V>(key: K, value: V): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K, value: V): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "setIfAbsent",
    "description": "Stores new binding in the map if it does not already exist.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const setIfAbsent: { <K, V>(key: K, value: V): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K, value: V): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the number of bindings.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const size: <K, V>(self: TMap<K, V>) => STM.STM<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "takeFirst",
    "description": "Takes the first matching value, or retries until there is one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeFirst: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<A>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "takeFirstSTM",
    "description": "Takes the first matching value, or retries until there is one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeFirstSTM: { <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<A, E, R>; <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "takeSome",
    "description": "Takes all matching values, or retries until there is at least one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeSome: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<[A, ...Array<A>]>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<[A, ...Array<A>]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "takeSomeSTM",
    "description": "Takes all matching values, or retries until there is at least one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeSomeSTM: { <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<[A, ...Array<A>], E, R>; <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<[A, ...Array<A>], E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "toChunk",
    "description": "Collects all bindings into a `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toChunk: <K, V>(self: TMap<K, V>) => STM.STM<Chunk.Chunk<[K, V]>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "toHashMap",
    "description": "Collects all bindings into a `HashMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toHashMap: <K, V>(self: TMap<K, V>) => STM.STM<HashMap.HashMap<K, V>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "toArray",
    "description": "Collects all bindings into an `Array`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toArray: <K, V>(self: TMap<K, V>) => STM.STM<Array<[K, V]>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "toMap",
    "description": "Collects all bindings into a `Map`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toMap: <K, V>(self: TMap<K, V>) => STM.STM<ReadonlyMap<K, V>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "transform",
    "description": "Atomically updates all bindings using a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const transform: { <K, V>(f: (key: K, value: V) => readonly [K, V]): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, f: (key: K, value: V) => readonly [K, V]): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "transformSTM",
    "description": "Atomically updates all bindings using a transactional function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const transformSTM: { <K, V, R, E>(f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>): (self: TMap<K, V>) => STM.STM<void, E, R>; <K, V, R, E>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>): STM.STM<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "transformValues",
    "description": "Atomically updates all values using a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const transformValues: { <V>(f: (value: V) => V): <K>(self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, f: (value: V) => V): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "transformValuesSTM",
    "description": "Atomically updates all values using a transactional function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const transformValuesSTM: { <V, R, E>(f: (value: V) => STM.STM<V, E, R>): <K>(self: TMap<K, V>) => STM.STM<void, E, R>; <K, V, R, E>(self: TMap<K, V>, f: (value: V) => STM.STM<V, E, R>): STM.STM<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "updateWith",
    "description": "Updates the mapping for the specified key with the specified function,\nwhich takes the current value of the key as an input, if it exists, and\neither returns `Some` with a new value to indicate to update the value in\nthe map or `None` to remove the value from the map. Returns `Some` with the\nupdated value or `None` if the value was removed from the map.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const updateWith: { <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>): (self: TMap<K, V>) => STM.STM<Option.Option<V>>; <K, V>(self: TMap<K, V>, key: K, f: (value: Option.Option<V>) => Option.Option<V>): STM.STM<Option.Option<V>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "values",
    "description": "Collects all values stored in map.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const values: <K, V>(self: TMap<K, V>) => STM.STM<Array<V>>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "TMap",
    "description": "Transactional map implemented on top of `TRef` and `TArray`. Resolves\nconflicts via chaining.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TMap<in out K, in out V> extends TMap.Variance<K, V> {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TMap",
      "path": [
        "src",
        "TMap.ts"
      ]
    },
    "project": "effect",
    "name": "TMapTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type TMapTypeId = typeof TMapTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "TPriorityQueueTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TPriorityQueueTypeId: typeof TPriorityQueueTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "Constructs a new empty `TPriorityQueue` with the specified `Order`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: <A>(order: Order.Order<A>) => STM.STM<TPriorityQueue<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `TPriorityQueue` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterable: <A>(order: Order.Order<A>) => (iterable: Iterable<A>) => STM.STM<TPriorityQueue<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Checks whether the queue is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isEmpty: <A>(self: TPriorityQueue<A>) => STM.STM<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "isNonEmpty",
    "description": "Checks whether the queue is not empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isNonEmpty: <A>(self: TPriorityQueue<A>) => STM.STM<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Makes a new `TPriorityQueue` that is initialized with specified values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <A>(order: Order.Order<A>) => (...elements: Array<A>) => STM.STM<TPriorityQueue<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "offer",
    "description": "Offers the specified value to the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const offer: { <A>(value: A): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, value: A): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "offerAll",
    "description": "Offers all of the elements in the specified collection to the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const offerAll: { <A>(values: Iterable<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, values: Iterable<A>): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "peek",
    "description": "Peeks at the first value in the queue without removing it, retrying until a\nvalue is in the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const peek: <A>(self: TPriorityQueue<A>) => STM.STM<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "peekOption",
    "description": "Peeks at the first value in the queue without removing it, returning `None`\nif there is not a value in the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const peekOption: <A>(self: TPriorityQueue<A>) => STM.STM<Option.Option<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "removeIf",
    "description": "Removes all elements from the queue matching the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const removeIf: { <A>(predicate: Predicate<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, predicate: Predicate<A>): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "retainIf",
    "description": "Retains only elements from the queue matching the specified predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const retainIf: { <A>(predicate: Predicate<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, predicate: Predicate<A>): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the size of the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const size: <A>(self: TPriorityQueue<A>) => STM.STM<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "take",
    "description": "Takes a value from the queue, retrying until a value is in the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const take: <A>(self: TPriorityQueue<A>) => STM.STM<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "takeAll",
    "description": "Takes all values from the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeAll: <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "takeOption",
    "description": "Takes a value from the queue, returning `None` if there is not a value in\nthe queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeOption: <A>(self: TPriorityQueue<A>) => STM.STM<Option.Option<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "takeUpTo",
    "description": "Takes up to the specified maximum number of elements from the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeUpTo: { (n: number): <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>; <A>(self: TPriorityQueue<A>, n: number): STM.STM<Array<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "toChunk",
    "description": "Collects all values into a `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toChunk: <A>(self: TPriorityQueue<A>) => STM.STM<Chunk.Chunk<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "toArray",
    "description": "Collects all values into an array.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toArray: <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "TPriorityQueue",
    "description": "A `TPriorityQueue` contains values of type `A` that an `Order` is defined\non. Unlike a `TQueue`, `take` returns the highest priority value (the value\nthat is first in the specified ordering) as opposed to the first value\noffered to the queue. The ordering that elements with the same priority will\nbe taken from the queue is not guaranteed.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TPriorityQueue<in out A> extends TPriorityQueue.Variance<A> {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TPriorityQueue",
      "path": [
        "src",
        "TPriorityQueue.ts"
      ]
    },
    "project": "effect",
    "name": "TPriorityQueueTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type TPriorityQueueTypeId = typeof TPriorityQueueTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "TPubSubTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TPubSubTypeId: typeof TPubSubTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "awaitShutdown",
    "description": "Waits until the `TPubSub` is shutdown. The `STM` returned by this method will\nnot resume until the queue has been shutdown. If the `TPubSub` is already\nshutdown, the `STM` will resume right away.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const awaitShutdown: <A>(self: TPubSub<A>) => STM.STM<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "bounded",
    "description": "Creates a bounded `TPubSub` with the back pressure strategy. The `TPubSub` will retain\nmessages until they have been taken by all subscribers, applying back\npressure to publishers if the `TPubSub` is at capacity.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const bounded: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "capacity",
    "description": "Returns the number of elements the `TPubSub` can hold.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const capacity: <A>(self: TPubSub<A>) => number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "dropping",
    "description": "Creates a bounded `TPubSub` with the dropping strategy. The `TPubSub` will drop new\nmessages if the `TPubSub` is at capacity.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dropping: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the `TPubSub` contains zero elements, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isEmpty: <A>(self: TPubSub<A>) => STM.STM<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "isFull",
    "description": "Returns `true` if the `TPubSub` contains at least one element, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isFull: <A>(self: TPubSub<A>) => STM.STM<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "shutdown",
    "description": "Interrupts any fibers that are suspended on `offer` or `take`. Future calls\nto `offer*` and `take*` will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "utils",
    "signature": "export declare const shutdown: <A>(self: TPubSub<A>) => STM.STM<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "isShutdown",
    "description": "Returns `true` if `shutdown` has been called, otherwise returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isShutdown: <A>(self: TPubSub<A>) => STM.STM<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "publish",
    "description": "Publishes a message to the `TPubSub`, returning whether the message was published\nto the `TPubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const publish: { <A>(value: A): (self: TPubSub<A>) => STM.STM<boolean>; <A>(self: TPubSub<A>, value: A): STM.STM<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "publishAll",
    "description": "Publishes all of the specified messages to the `TPubSub`, returning whether they\nwere published to the `TPubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const publishAll: { <A>(iterable: Iterable<A>): (self: TPubSub<A>) => STM.STM<boolean>; <A>(self: TPubSub<A>, iterable: Iterable<A>): STM.STM<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Retrieves the size of the `TPubSub`, which is equal to the number of elements\nin the `TPubSub`. This may be negative if fibers are suspended waiting for\nelements to be added to the `TPubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const size: <A>(self: TPubSub<A>) => STM.STM<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "sliding",
    "description": "Creates a bounded `TPubSub` with the sliding strategy. The `TPubSub` will add new\nmessages and drop old messages if the `TPubSub` is at capacity.\n\nFor best performance use capacities that are powers of two.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sliding: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "subscribe",
    "description": "Subscribes to receive messages from the `TPubSub`. The resulting subscription can\nbe evaluated multiple times to take a message from the `TPubSub` each time. The\ncaller is responsible for unsubscribing from the `TPubSub` by shutting down the\nqueue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const subscribe: <A>(self: TPubSub<A>) => STM.STM<TQueue.TDequeue<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "subscribeScoped",
    "description": "Subscribes to receive messages from the `TPubSub`. The resulting subscription can\nbe evaluated multiple times within the scope to take a message from the `TPubSub`\neach time.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const subscribeScoped: <A>(self: TPubSub<A>) => Effect.Effect<TQueue.TDequeue<A>, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "unbounded",
    "description": "Creates an unbounded `TPubSub`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unbounded: <A>() => STM.STM<TPubSub<A>>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "TPubSub",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TPubSub<in out A> extends TQueue.TEnqueue<A> {\n  readonly [TPubSubTypeId]: {\n    readonly _A: Types.Invariant<A>\n  }\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TPubSub",
      "path": [
        "src",
        "TPubSub.ts"
      ]
    },
    "project": "effect",
    "name": "TPubSubTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type TPubSubTypeId = typeof TPubSubTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "TDequeueTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TDequeueTypeId: typeof TDequeueTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "TEnqueueTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TEnqueueTypeId: typeof TEnqueueTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "isTQueue",
    "description": "Returns `true` if the specified value is a `TQueue`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isTQueue: (u: unknown) => u is TQueue<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "isTDequeue",
    "description": "Returns `true` if the specified value is a `TDequeue`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isTDequeue: (u: unknown) => u is TDequeue<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "isTEnqueue",
    "description": "Returns `true` if the specified value is a `TEnqueue`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isTEnqueue: (u: unknown) => u is TEnqueue<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "awaitShutdown",
    "description": "Waits until the queue is shutdown. The `STM` returned by this method will\nnot resume until the queue has been shutdown. If the queue is already\nshutdown, the `STM` will resume right away.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const awaitShutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "bounded",
    "description": "Creates a bounded queue with the back pressure strategy. The queue will\nretain values until they have been taken, applying back pressure to\nofferors if the queue is at capacity.\n\nFor best performance use capacities that are powers of two.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const bounded: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "capacity",
    "description": "Returns the number of elements the queue can hold.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const capacity: <A>(self: TDequeue<A> | TEnqueue<A>) => number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "dropping",
    "description": "Creates a bounded queue with the dropping strategy. The queue will drop new\nvalues if the queue is at capacity.\n\nFor best performance use capacities that are powers of two.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const dropping: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Returns `true` if the `TQueue` contains zero elements, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isEmpty: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "isFull",
    "description": "Returns `true` if the `TQueue` contains at least one element, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isFull: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "isShutdown",
    "description": "Returns `true` if `shutdown` has been called, otherwise returns `false`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isShutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "offer",
    "description": "Places one value in the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const offer: { <A>(value: A): (self: TEnqueue<A>) => STM.STM<void>; <A>(self: TEnqueue<A>, value: A): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "offerAll",
    "description": "For Bounded TQueue: uses the `BackPressure` Strategy, places the values in\nthe queue and always returns true. If the queue has reached capacity, then\nthe fiber performing the `offerAll` will be suspended until there is room\nin the queue.\n\nFor Unbounded TQueue: Places all values in the queue and returns true.\n\nFor Sliding TQueue: uses `Sliding` Strategy If there is room in the queue,\nit places the values otherwise it removes the old elements and enqueues the\nnew ones. Always returns true.\n\nFor Dropping TQueue: uses `Dropping` Strategy, It places the values in the\nqueue but if there is no room it will not enqueue them and return false.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const offerAll: { <A>(iterable: Iterable<A>): (self: TEnqueue<A>) => STM.STM<boolean>; <A>(self: TEnqueue<A>, iterable: Iterable<A>): STM.STM<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "peek",
    "description": "Views the next element in the queue without removing it, retrying if the\nqueue is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const peek: <A>(self: TDequeue<A>) => STM.STM<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "peekOption",
    "description": "Views the next element in the queue without removing it, returning `None`\nif the queue is empty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const peekOption: <A>(self: TDequeue<A>) => STM.STM<Option.Option<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "poll",
    "description": "Takes a single element from the queue, returning `None` if the queue is\nempty.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const poll: <A>(self: TDequeue<A>) => STM.STM<Option.Option<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "seek",
    "description": "Drops elements from the queue while they do not satisfy the predicate,\ntaking and returning the first element that does satisfy the predicate.\nRetries if no elements satisfy the predicate.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const seek: { <A>(predicate: Predicate<A>): (self: TDequeue<A>) => STM.STM<A>; <A>(self: TDequeue<A>, predicate: Predicate<A>): STM.STM<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "shutdown",
    "description": "Interrupts any fibers that are suspended on `offer` or `take`. Future calls\nto `offer*` and `take*` will be interrupted immediately.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const shutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Retrieves the size of the queue, which is equal to the number of elements\nin the queue. This may be negative if fibers are suspended waiting for\nelements to be added to the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const size: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "sliding",
    "description": "Creates a bounded queue with the sliding strategy. The queue will add new\nvalues and drop old values if the queue is at capacity.\n\nFor best performance use capacities that are powers of two.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const sliding: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "take",
    "description": "Takes the oldest value in the queue. If the queue is empty, this will return\na computation that resumes when an item has been added to the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const take: <A>(self: TDequeue<A>) => STM.STM<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "takeAll",
    "description": "Takes all the values in the queue and returns the values. If the queue is\nempty returns an empty collection.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeAll: <A>(self: TDequeue<A>) => STM.STM<Array<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "takeBetween",
    "description": "Takes a number of elements from the queue between the specified minimum and\nmaximum. If there are fewer than the minimum number of elements available,\nretries until at least the minimum number of elements have been collected.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeBetween: { (min: number, max: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, min: number, max: number): STM.STM<Array<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "takeN",
    "description": "Takes the specified number of elements from the queue. If there are fewer\nthan the specified number of elements available, it retries until they\nbecome available.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeN: { (n: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, n: number): STM.STM<Array<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "takeUpTo",
    "description": "Takes up to max number of values from the queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeUpTo: { (max: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, max: number): STM.STM<Array<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "unbounded",
    "description": "Creates an unbounded queue.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const unbounded: <A>() => STM.STM<TQueue<A>>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "BaseTQueue",
    "description": "The base interface that all `TQueue`s must implement.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface BaseTQueue {\n  /**\n   * Returns the number of elements the queue can hold.\n   */\n  capacity(): number\n\n  /**\n   * Retrieves the size of the queue, which is equal to the number of elements\n   * in the queue. This may be negative if fibers are suspended waiting for\n   * elements to be added to the queue.\n   */\n  readonly size: STM.STM<number>\n\n  /**\n   * Returns `true` if the `TQueue` contains at least one element, `false`\n   * otherwise.\n   */\n  readonly isFull: STM.STM<boolean>\n\n  /**\n   * Returns `true` if the `TQueue` contains zero elements, `false` otherwise.\n   */\n  readonly isEmpty: STM.STM<boolean>\n\n  /**\n   * Interrupts any fibers that are suspended on `offer` or `take`. Future calls\n   * to `offer*` and `take*` will be interrupted immediately.\n   */\n  readonly shutdown: STM.STM<void>\n\n  /**\n   * Returns `true` if `shutdown` has been called, otherwise returns `false`.\n   */\n  readonly isShutdown: STM.STM<boolean>\n\n  /**\n   * Waits until the queue is shutdown. The `STM` returned by this method will\n   * not resume until the queue has been shutdown. If the queue is already\n   * shutdown, the `STM` will resume right away.\n   */\n  readonly awaitShutdown: STM.STM<void>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "TDequeue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TDequeue<out A> extends TQueue.TDequeueVariance<A>, BaseTQueue {\n  /**\n   * Views the next element in the queue without removing it, retrying if the\n   * queue is empty.\n   */\n  readonly peek: STM.STM<A>\n\n  /**\n   * Views the next element in the queue without removing it, returning `None`\n   * if the queue is empty.\n   */\n  readonly peekOption: STM.STM<Option.Option<A>>\n\n  /**\n   * Takes the oldest value in the queue. If the queue is empty, this will return\n   * a computation that resumes when an item has been added to the queue.\n   */\n  readonly take: STM.STM<A>\n\n  /**\n   * Takes all the values in the queue and returns the values. If the queue is\n   * empty returns an empty collection.\n   */\n  readonly takeAll: STM.STM<Array<A>>\n\n  /**\n   * Takes up to max number of values from the queue.\n   */\n  takeUpTo(max: number): STM.STM<Array<A>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "TEnqueue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TEnqueue<in A> extends TQueue.TEnqueueVariance<A>, BaseTQueue {\n  /**\n   * Places one value in the queue.\n   */\n  offer(value: A): STM.STM<boolean>\n\n  /**\n   * For Bounded TQueue: uses the `BackPressure` Strategy, places the values in\n   * the queue and always returns true. If the queue has reached capacity, then\n   * the fiber performing the `offerAll` will be suspended until there is room\n   * in the queue.\n   *\n   * For Unbounded TQueue: Places all values in the queue and returns true.\n   *\n   * For Sliding TQueue: uses `Sliding` Strategy If there is room in the queue,\n   * it places the values otherwise it removes the old elements and enqueues the\n   * new ones. Always returns true.\n   *\n   * For Dropping TQueue: uses `Dropping` Strategy, It places the values in the\n   * queue but if there is no room it will not enqueue them and return false.\n   */\n  offerAll(iterable: Iterable<A>): STM.STM<boolean>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "TQueue",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TQueue<in out A> extends TEnqueue<A>, TDequeue<A> {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "TDequeueTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type TDequeueTypeId = typeof TDequeueTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TQueue",
      "path": [
        "src",
        "TQueue.ts"
      ]
    },
    "project": "effect",
    "name": "TEnqueueTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type TEnqueueTypeId = typeof TEnqueueTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "TracerTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const TracerTypeId: typeof TracerTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "ParentSpan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tags",
    "signature": "export declare const ParentSpan: Context.Tag<ParentSpan, AnySpan>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "Tracer",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tags",
    "signature": "export declare const Tracer: Context.Tag<Tracer, Tracer>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: (options: Omit<Tracer, typeof TracerTypeId>) => Tracer"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "externalSpan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const externalSpan: (options: { readonly spanId: string; readonly traceId: string; readonly sampled?: boolean | undefined; readonly context?: Context.Context<never> | undefined; }) => ExternalSpan"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "tracerWith",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const tracerWith: <A, E, R>(f: (tracer: Tracer) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "DisablePropagation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "annotations",
    "signature": "export declare const DisablePropagation: Context.Reference<DisablePropagation, boolean>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "DisablePropagation",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.12.0",
    "category": "annotations",
    "signature": "export interface DisablePropagation {\n  readonly _: unique symbol\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "ExternalSpan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface ExternalSpan {\n  readonly _tag: \"ExternalSpan\"\n  readonly spanId: string\n  readonly traceId: string\n  readonly sampled: boolean\n  readonly context: Context.Context<never>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "ParentSpan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "tags",
    "signature": "export interface ParentSpan {\n  readonly _: unique symbol\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "Span",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Span {\n  readonly _tag: \"Span\"\n  readonly name: string\n  readonly spanId: string\n  readonly traceId: string\n  readonly parent: Option.Option<AnySpan>\n  readonly context: Context.Context<never>\n  readonly status: SpanStatus\n  readonly attributes: ReadonlyMap<string, unknown>\n  readonly links: ReadonlyArray<SpanLink>\n  readonly sampled: boolean\n  readonly kind: SpanKind\n  end(endTime: bigint, exit: Exit.Exit<unknown, unknown>): void\n  attribute(key: string, value: unknown): void\n  event(name: string, startTime: bigint, attributes?: Record<string, unknown>): void\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "SpanLink",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface SpanLink {\n  readonly _tag: \"SpanLink\"\n  readonly span: AnySpan\n  readonly attributes: Readonly<Record<string, unknown>>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "SpanOptions",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.1.0",
    "category": "models",
    "signature": "export interface SpanOptions {\n  readonly attributes?: Record<string, unknown> | undefined\n  readonly links?: ReadonlyArray<SpanLink> | undefined\n  readonly parent?: AnySpan | undefined\n  readonly root?: boolean | undefined\n  readonly context?: Context.Context<never> | undefined\n  readonly kind?: SpanKind | undefined\n  readonly captureStackTrace?: boolean | LazyArg<string | undefined> | undefined\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "Tracer",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export interface Tracer {\n  readonly [TracerTypeId]: TracerTypeId\n  span(\n    name: string,\n    parent: Option.Option<AnySpan>,\n    context: Context.Context<never>,\n    links: ReadonlyArray<SpanLink>,\n    startTime: bigint,\n    kind: SpanKind\n  ): Span\n  context<X>(f: () => X, fiber: Fiber.RuntimeFiber<any, any>): X\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "AnySpan",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type AnySpan = Span | ExternalSpan"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "SpanKind",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.1.0",
    "category": "models",
    "signature": "export type SpanKind = \"internal\" | \"server\" | \"client\" | \"producer\" | \"consumer\""
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "SpanStatus",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type SpanStatus = {\n  _tag: \"Started\"\n  startTime: bigint\n} | {\n  _tag: \"Ended\"\n  startTime: bigint\n  endTime: bigint\n  exit: Exit.Exit<unknown, unknown>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Tracer",
      "path": [
        "src",
        "Tracer.ts"
      ]
    },
    "project": "effect",
    "name": "TracerTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type TracerTypeId = typeof TracerTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom",
      "path": [
        "src",
        "TRandom.ts"
      ]
    },
    "project": "effect",
    "name": "TRandomTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TRandomTypeId: typeof TRandomTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom",
      "path": [
        "src",
        "TRandom.ts"
      ]
    },
    "project": "effect",
    "name": "Tag",
    "description": "The service tag used to access `TRandom` in the environment of an effect.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const Tag: Context.Tag<TRandom, TRandom>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom",
      "path": [
        "src",
        "TRandom.ts"
      ]
    },
    "project": "effect",
    "name": "live",
    "description": "The \"live\" `TRandom` service wrapped into a `Layer`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "context",
    "signature": "export declare const live: Layer.Layer<TRandom, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom",
      "path": [
        "src",
        "TRandom.ts"
      ]
    },
    "project": "effect",
    "name": "next",
    "description": "Returns the next number from the pseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "random",
    "signature": "export declare const next: STM.STM<number, never, TRandom>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom",
      "path": [
        "src",
        "TRandom.ts"
      ]
    },
    "project": "effect",
    "name": "nextBoolean",
    "description": "Returns the next boolean value from the pseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "random",
    "signature": "export declare const nextBoolean: STM.STM<boolean, never, TRandom>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom",
      "path": [
        "src",
        "TRandom.ts"
      ]
    },
    "project": "effect",
    "name": "nextInt",
    "description": "Returns the next integer from the pseudo-random number generator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "random",
    "signature": "export declare const nextInt: STM.STM<number, never, TRandom>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom",
      "path": [
        "src",
        "TRandom.ts"
      ]
    },
    "project": "effect",
    "name": "nextIntBetween",
    "description": "Returns the next integer in the specified range from the pseudo-random number\ngenerator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "random",
    "signature": "export declare const nextIntBetween: (low: number, high: number) => STM.STM<number, never, TRandom>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom",
      "path": [
        "src",
        "TRandom.ts"
      ]
    },
    "project": "effect",
    "name": "nextRange",
    "description": "Returns the next number in the specified range from the pseudo-random number\ngenerator.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "random",
    "signature": "export declare const nextRange: (min: number, max: number) => STM.STM<number, never, TRandom>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRandom",
      "path": [
        "src",
        "TRandom.ts"
      ]
    },
    "project": "effect",
    "name": "shuffle",
    "description": "Uses the pseudo-random number generator to shuffle the specified iterable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "random",
    "signature": "export declare const shuffle: <A>(elements: Iterable<A>) => STM.STM<Array<A>, never, TRandom>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TRandom",
      "path": [
        "src",
        "TRandom.ts"
      ]
    },
    "project": "effect",
    "name": "TRandom",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TRandom {\n  readonly [TRandomTypeId]: TRandomTypeId\n  /**\n   * Returns the next numeric value from the pseudo-random number generator.\n   */\n  readonly next: STM.STM<number>\n  /**\n   * Returns the next boolean value from the pseudo-random number generator.\n   */\n  readonly nextBoolean: STM.STM<boolean>\n  /**\n   * Returns the next integer value from the pseudo-random number generator.\n   */\n  readonly nextInt: STM.STM<number>\n  /**\n   * Returns the next numeric value in the specified range from the\n   * pseudo-random number generator.\n   */\n  nextRange(min: number, max: number): STM.STM<number>\n  /**\n   * Returns the next integer value in the specified range from the\n   * pseudo-random number generator.\n   */\n  nextIntBetween(min: number, max: number): STM.STM<number>\n  /**\n   * Uses the pseudo-random number generator to shuffle the specified iterable.\n   */\n  shuffle<A>(elements: Iterable<A>): STM.STM<Array<A>>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TRandom",
      "path": [
        "src",
        "TRandom.ts"
      ]
    },
    "project": "effect",
    "name": "TRandomTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type TRandomTypeId = typeof TRandomTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "TReentrantLockTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TReentrantLockTypeId: typeof TReentrantLockTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "acquireRead",
    "description": "Acquires a read lock. The transaction will suspend until no other fiber is\nholding a write lock. Succeeds with the number of read locks held by this\nfiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const acquireRead: (self: TReentrantLock) => STM.STM<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "acquireWrite",
    "description": "Acquires a write lock. The transaction will suspend until no other fibers\nare holding read or write locks. Succeeds with the number of write locks\nheld by this fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const acquireWrite: (self: TReentrantLock) => STM.STM<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "fiberReadLocks",
    "description": "Retrieves the number of acquired read locks for this fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const fiberReadLocks: (self: TReentrantLock) => STM.STM<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "fiberWriteLocks",
    "description": "Retrieves the number of acquired write locks for this fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const fiberWriteLocks: (self: TReentrantLock) => STM.STM<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "lock",
    "description": "Just a convenience method for applications that only need reentrant locks,\nwithout needing a distinction between readers / writers.\n\nSee `TReentrantLock.writeLock`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const lock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "locked",
    "description": "Determines if any fiber has a read or write lock.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const locked: (self: TReentrantLock) => STM.STM<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Makes a new reentrant read/write lock.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: STM.STM<TReentrantLock, never, never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "readLock",
    "description": "Obtains a read lock in a scoped context.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const readLock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "readLocks",
    "description": "Retrieves the total number of acquired read locks.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const readLocks: (self: TReentrantLock) => STM.STM<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "readLocked",
    "description": "Determines if any fiber has a read lock.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const readLocked: (self: TReentrantLock) => STM.STM<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "releaseRead",
    "description": "Releases a read lock held by this fiber. Succeeds with the outstanding\nnumber of read locks held by this fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const releaseRead: (self: TReentrantLock) => STM.STM<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "releaseWrite",
    "description": "Releases a write lock held by this fiber. Succeeds with the outstanding\nnumber of write locks held by this fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const releaseWrite: (self: TReentrantLock) => STM.STM<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "withLock",
    "description": "Runs the specified workflow with a lock.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const withLock: { (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "withReadLock",
    "description": "Runs the specified workflow with a read lock.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const withReadLock: { (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "withWriteLock",
    "description": "Runs the specified workflow with a write lock.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const withWriteLock: { (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "writeLock",
    "description": "Obtains a write lock in a scoped context.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const writeLock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "writeLocked",
    "description": "Determines if a write lock is held by some fiber.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const writeLocked: (self: TReentrantLock) => STM.STM<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "writeLocks",
    "description": "Computes the number of write locks held by fibers.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const writeLocks: (self: TReentrantLock) => STM.STM<number>"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "TReentrantLock",
    "description": "A `TReentrantLock` is a reentrant read/write lock. Multiple readers may all\nconcurrently acquire read locks. Only one writer is allowed to acquire a\nwrite lock at any given time. Read locks may be upgraded into write locks. A\nfiber that has a write lock may acquire other write locks or read locks.\n\nThe two primary methods of this structure are `readLock`, which acquires a\nread lock in a scoped context, and `writeLock`, which acquires a write lock\nin a scoped context.\n\nAlthough located in the STM package, there is no need for locks within STM\ntransactions. However, this lock can be quite useful in effectful code, to\nprovide consistent read/write access to mutable state; and being in STM\nallows this structure to be composed into more complicated concurrent\nstructures that are consumed from effectful code.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TReentrantLock extends TReentrantLock.Proto {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TReentrantLock",
      "path": [
        "src",
        "TReentrantLock.ts"
      ]
    },
    "project": "effect",
    "name": "TReentrantLockTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type TReentrantLockTypeId = typeof TReentrantLockTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "TRefTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TRefTypeId: typeof TRefTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const get: <A>(self: TRef<A>) => STM.STM<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const getAndSet: { <A>(value: A): (self: TRef<A>) => STM.STM<A>; <A>(self: TRef<A>, value: A): STM.STM<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const getAndUpdate: { <A>(f: (a: A) => A): (self: TRef<A>) => STM.STM<A>; <A>(self: TRef<A>, f: (a: A) => A): STM.STM<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdateSome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const getAndUpdateSome: { <A>(f: (a: A) => Option.Option<A>): (self: TRef<A>) => STM.STM<A>; <A>(self: TRef<A>, f: (a: A) => Option.Option<A>): STM.STM<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <A>(value: A) => STM.STM<TRef<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "modify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const modify: { <A, B>(f: (a: A) => readonly [B, A]): (self: TRef<A>) => STM.STM<B>; <A, B>(self: TRef<A>, f: (a: A) => readonly [B, A]): STM.STM<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "modifySome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const modifySome: { <A, B>(fallback: B, f: (a: A) => Option.Option<readonly [B, A]>): (self: TRef<A>) => STM.STM<B>; <A, B>(self: TRef<A>, fallback: B, f: (a: A) => Option.Option<readonly [B, A]>): STM.STM<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const set: { <A>(value: A): (self: TRef<A>) => STM.STM<void>; <A>(self: TRef<A>, value: A): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "setAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const setAndGet: { <A>(value: A): (self: TRef<A>) => STM.STM<A>; <A>(self: TRef<A>, value: A): STM.STM<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "update",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const update: { <A>(f: (a: A) => A): (self: TRef<A>) => STM.STM<void>; <A>(self: TRef<A>, f: (a: A) => A): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const updateAndGet: { <A>(f: (a: A) => A): (self: TRef<A>) => STM.STM<A>; <A>(self: TRef<A>, f: (a: A) => A): STM.STM<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateSome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const updateSome: { <A>(f: (a: A) => Option.Option<A>): (self: TRef<A>) => STM.STM<void>; <A>(self: TRef<A>, f: (a: A) => Option.Option<A>): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateSomeAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const updateSomeAndGet: { <A>(f: (a: A) => Option.Option<A>): (self: TRef<A>) => STM.STM<A>; <A>(self: TRef<A>, f: (a: A) => Option.Option<A>): STM.STM<A>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "TRef",
    "description": "A `TRef<A>` is a purely functional description of a mutable reference that can\nbe modified as part of a transactional effect. The fundamental operations of\na `TRef` are `set` and `get`. `set` transactionally sets the reference to a\nnew value. `get` gets the current value of the reference.\n\nNOTE: While `TRef<A>` provides the transactional equivalent of a mutable\nreference, the value inside the `TRef` should be immutable.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TRef<in out A> extends TRef.Variance<A>, Pipeable {\n  /**\n   * Note: the method is unbound, exposed only for potential extensions.\n   */\n  modify<B>(f: (a: A) => readonly [B, A]): STM.STM<B>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TRef",
      "path": [
        "src",
        "TRef.ts"
      ]
    },
    "project": "effect",
    "name": "TRefTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type TRefTypeId = typeof TRefTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "Creates an empty `Trie`.",
    "deprecated": false,
    "examples": [
      "import { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<string>()\n\nassert.equal(Trie.size(trie), 0)\nassert.deepStrictEqual(Array.from(trie), [])"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: <V = never>() => Trie<V>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `Trie` from an iterable collection of key/value pairs (e.g. `Array<[string, V]>`).",
    "deprecated": false,
    "examples": [
      "import { Trie, Equal } from \"effect\"\n\nconst iterable: Array<readonly [string, number]> = [[\"call\", 0], [\"me\", 1], [\"mind\", 2], [\"mid\", 3]]\nconst trie = Trie.fromIterable(iterable)\n\n// The entries in the `Trie` are extracted in alphabetical order, regardless of the insertion order\nassert.deepStrictEqual(Array.from(trie), [[\"call\", 0], [\"me\", 1], [\"mid\", 3], [\"mind\", 2]])\nassert.equal(Equal.equals(Trie.make([\"call\", 0], [\"me\", 1], [\"mind\", 2], [\"mid\", 3]), trie), true)"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterable: <V>(entries: Iterable<readonly [string, V]>) => Trie<V>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new `Trie` from the specified entries (`[string, V]`).",
    "deprecated": false,
    "examples": [
      "import { Trie, Equal } from \"effect\"\n\nconst trie = Trie.make([\"ca\", 0], [\"me\", 1])\n\nassert.deepStrictEqual(Array.from(trie), [[\"ca\", 0], [\"me\", 1]])\nassert.equal(Equal.equals(Trie.fromIterable([[\"ca\", 0], [\"me\", 1]]), trie), true)"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <Entries extends Array<readonly [string, any]>>(...entries: Entries) => Trie<Entries[number] extends readonly [any, infer V] ? V : never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "insert",
    "description": "Insert a new entry in the `Trie`.",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nconst trie1 = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0)\n)\nconst trie2 = trie1.pipe(Trie.insert(\"me\", 1))\nconst trie3 = trie2.pipe(Trie.insert(\"mind\", 2))\nconst trie4 = trie3.pipe(Trie.insert(\"mid\", 3))\n\nassert.deepStrictEqual(Array.from(trie1), [[\"call\", 0]])\nassert.deepStrictEqual(Array.from(trie2), [[\"call\", 0], [\"me\", 1]])\nassert.deepStrictEqual(Array.from(trie3), [[\"call\", 0], [\"me\", 1], [\"mind\", 2]])\nassert.deepStrictEqual(Array.from(trie4), [[\"call\", 0], [\"me\", 1], [\"mid\", 3], [\"mind\", 2]])"
    ],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const insert: { <V1>(key: string, value: V1): <V>(self: Trie<V>) => Trie<V | V1>; <V1, V>(self: Trie<V>, key: string, value: V1): Trie<V | V1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "keys",
    "description": "Returns an `IterableIterator` of the keys within the `Trie`.\n\nThe keys are returned in alphabetical order, regardless of insertion order.",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"cab\", 0),\n  Trie.insert(\"abc\", 1),\n  Trie.insert(\"bca\", 2)\n)\n\nconst result = Array.from(Trie.keys(trie))\nassert.deepStrictEqual(result, [\"abc\", \"bca\", \"cab\"])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const keys: <V>(self: Trie<V>) => IterableIterator<string>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "values",
    "description": "Returns an `IterableIterator` of the values within the `Trie`.\n\nValues are ordered based on their key in alphabetical order, regardless of insertion order.",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1),\n  Trie.insert(\"and\", 2)\n)\n\nconst result = Array.from(Trie.values(trie))\nassert.deepStrictEqual(result, [2, 0, 1])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const values: <V>(self: Trie<V>) => IterableIterator<V>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "entries",
    "description": "Returns an `IterableIterator` of the entries within the `Trie`.\n\nThe entries are returned by keys in alphabetical order, regardless of insertion order.",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1)\n)\n\nconst result = Array.from(Trie.entries(trie))\nassert.deepStrictEqual(result, [[\"call\", 0], [\"me\", 1]])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const entries: <V>(self: Trie<V>) => IterableIterator<[string, V]>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "keysWithPrefix",
    "description": "Returns an `IterableIterator` of the keys within the `Trie`\nthat have `prefix` as prefix (`prefix` included if it exists).",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 0),\n  Trie.insert(\"shells\", 1),\n  Trie.insert(\"sea\", 2),\n  Trie.insert(\"shore\", 3)\n)\n\nconst result = Array.from(Trie.keysWithPrefix(trie, \"she\"))\nassert.deepStrictEqual(result, [\"she\", \"shells\"])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const keysWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<string>; <V>(self: Trie<V>, prefix: string): IterableIterator<string>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "valuesWithPrefix",
    "description": "Returns an `IterableIterator` of the values within the `Trie`\nthat have `prefix` as prefix (`prefix` included if it exists).",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 0),\n  Trie.insert(\"shells\", 1),\n  Trie.insert(\"sea\", 2),\n  Trie.insert(\"shore\", 3)\n)\n\nconst result = Array.from(Trie.valuesWithPrefix(trie, \"she\"))\n\n// 0: \"she\", 1: \"shells\"\nassert.deepStrictEqual(result, [0, 1])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const valuesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<V>; <V>(self: Trie<V>, prefix: string): IterableIterator<V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "entriesWithPrefix",
    "description": "Returns an `IterableIterator` of the entries within the `Trie`\nthat have `prefix` as prefix (`prefix` included if it exists).",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 0),\n  Trie.insert(\"shells\", 1),\n  Trie.insert(\"sea\", 2),\n  Trie.insert(\"shore\", 3)\n)\n\nconst result = Array.from(Trie.entriesWithPrefix(trie, \"she\"))\nassert.deepStrictEqual(result, [[\"she\", 0], [\"shells\", 1]])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const entriesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<[string, V]>; <V>(self: Trie<V>, prefix: string): IterableIterator<[string, V]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "toEntriesWithPrefix",
    "description": "Returns `Array<[K, V]>` of the entries within the `Trie`\nthat have `prefix` as prefix (`prefix` included if it exists).",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"sea\", 2),\n  Trie.insert(\"she\", 3)\n)\n\nconst result = Trie.toEntriesWithPrefix(trie, \"she\")\nassert.deepStrictEqual(result, [[\"she\", 3], [\"shells\", 0]])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const toEntriesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => Array<[string, V]>; <V>(self: Trie<V>, prefix: string): Array<[string, V]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "longestPrefixOf",
    "description": "Returns the longest key/value in the `Trie`\nthat is a prefix of that `key` if it exists, `None` otherwise.",
    "deprecated": false,
    "examples": [
      "import { Trie, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nassert.deepStrictEqual(Trie.longestPrefixOf(trie, \"sell\"), Option.none())\nassert.deepStrictEqual(Trie.longestPrefixOf(trie, \"sells\"), Option.some([\"sells\", 1]))\nassert.deepStrictEqual(Trie.longestPrefixOf(trie, \"shell\"), Option.some([\"she\", 2]))\nassert.deepStrictEqual(Trie.longestPrefixOf(trie, \"shellsort\"), Option.some([\"shells\", 0]))"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const longestPrefixOf: { (key: string): <V>(self: Trie<V>) => Option<[string, V]>; <V>(self: Trie<V>, key: string): Option<[string, V]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the size of the `Trie` (number of entries in the `Trie`).",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"a\", 0),\n  Trie.insert(\"b\", 1)\n)\n\nassert.equal(Trie.size(trie), 2)"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const size: <V>(self: Trie<V>) => number"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": "Safely lookup the value for the specified key in the `Trie`.",
    "deprecated": false,
    "examples": [
      "import { Trie, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1),\n  Trie.insert(\"mind\", 2),\n  Trie.insert(\"mid\", 3)\n)\n\nassert.deepStrictEqual(Trie.get(trie, \"call\"), Option.some(0))\nassert.deepStrictEqual(Trie.get(trie, \"me\"), Option.some(1))\nassert.deepStrictEqual(Trie.get(trie, \"mind\"), Option.some(2))\nassert.deepStrictEqual(Trie.get(trie, \"mid\"), Option.some(3))\nassert.deepStrictEqual(Trie.get(trie, \"cale\"), Option.none())\nassert.deepStrictEqual(Trie.get(trie, \"ma\"), Option.none())\nassert.deepStrictEqual(Trie.get(trie, \"midn\"), Option.none())\nassert.deepStrictEqual(Trie.get(trie, \"mea\"), Option.none())"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const get: { (key: string): <V>(self: Trie<V>) => Option<V>; <V>(self: Trie<V>, key: string): Option<V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "has",
    "description": "Check if the given key exists in the `Trie`.",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1),\n  Trie.insert(\"mind\", 2),\n  Trie.insert(\"mid\", 3)\n)\n\nassert.equal(Trie.has(trie, \"call\"), true)\nassert.equal(Trie.has(trie, \"me\"), true)\nassert.equal(Trie.has(trie, \"mind\"), true)\nassert.equal(Trie.has(trie, \"mid\"), true)\nassert.equal(Trie.has(trie, \"cale\"), false)\nassert.equal(Trie.has(trie, \"ma\"), false)\nassert.equal(Trie.has(trie, \"midn\"), false)\nassert.equal(Trie.has(trie, \"mea\"), false)"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const has: { (key: string): <V>(self: Trie<V>) => boolean; <V>(self: Trie<V>, key: string): boolean; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Checks if the `Trie` contains any entries.",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>()\nconst trie1 = trie.pipe(Trie.insert(\"ma\", 0))\n\nassert.equal(Trie.isEmpty(trie), true)\nassert.equal(Trie.isEmpty(trie1), false)"
    ],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const isEmpty: <V>(self: Trie<V>) => boolean"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeGet",
    "description": "Unsafely lookup the value for the specified key in the `Trie`.\n\n`unsafeGet` will throw if the key is not found. Use `get` instead to safely\nget a value from the `Trie`.",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1)\n)\n\nassert.throws(() => Trie.unsafeGet(trie, \"mae\"))"
    ],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeGet: { (key: string): <V>(self: Trie<V>) => V; <V>(self: Trie<V>, key: string): V; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "remove",
    "description": "Remove the entry for the specified key in the `Trie`.",
    "deprecated": false,
    "examples": [
      "import { Trie, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1),\n  Trie.insert(\"mind\", 2),\n  Trie.insert(\"mid\", 3)\n)\n\nconst trie1 = trie.pipe(Trie.remove(\"call\"))\nconst trie2 = trie1.pipe(Trie.remove(\"mea\"))\n\nassert.deepStrictEqual(Trie.get(trie, \"call\"), Option.some(0))\nassert.deepStrictEqual(Trie.get(trie1, \"call\"), Option.none())\nassert.deepStrictEqual(Trie.get(trie2, \"call\"), Option.none())"
    ],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const remove: { (key: string): <V>(self: Trie<V>) => Trie<V>; <V>(self: Trie<V>, key: string): Trie<V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": "Reduce a state over the entries of the `Trie`.",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nassert.equal(\n  trie.pipe(\n    Trie.reduce(0, (acc, n) => acc + n)\n  ),\n  3\n)\nassert.equal(\n  trie.pipe(\n    Trie.reduce(10, (acc, n) => acc + n)\n  ),\n  13\n)\nassert.equal(\n  trie.pipe(\n    Trie.reduce(\"\", (acc, _, key) => acc + key)\n  ),\n  \"sellssheshells\"\n)"
    ],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduce: { <Z, V>(zero: Z, f: (accumulator: Z, value: V, key: string) => Z): (self: Trie<V>) => Z; <Z, V>(self: Trie<V>, zero: Z, f: (accumulator: Z, value: V, key: string) => Z): Z; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Maps over the entries of the `Trie` using the specified function.",
    "deprecated": false,
    "examples": [
      "import { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapV = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 1),\n  Trie.insert(\"sells\", 2),\n  Trie.insert(\"she\", 3)\n)\n\nconst trieMapK = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 6),\n  Trie.insert(\"sells\", 5),\n  Trie.insert(\"she\", 3)\n)\n\nassert.equal(Equal.equals(Trie.map(trie, (v) => v + 1), trieMapV), true)\nassert.equal(Equal.equals(Trie.map(trie, (_, k) => k.length), trieMapK), true)"
    ],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const map: { <A, V>(f: (value: V, key: string) => A): (self: Trie<V>) => Trie<A>; <V, A>(self: Trie<V>, f: (value: V, key: string) => A): Trie<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "filter",
    "description": "Filters entries out of a `Trie` using the specified predicate.",
    "deprecated": false,
    "examples": [
      "import { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapV = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapK = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1)\n)\n\nassert.equal(Equal.equals(Trie.filter(trie, (v) => v > 1), trieMapV), true)\nassert.equal(Equal.equals(Trie.filter(trie, (_, k) => k.length > 3), trieMapK), true)"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filter: { <A, B extends A>(f: (a: NoInfer<A>, k: string) => a is B): (self: Trie<A>) => Trie<B>; <A>(f: (a: NoInfer<A>, k: string) => boolean): (self: Trie<A>) => Trie<A>; <A, B extends A>(self: Trie<A>, f: (a: A, k: string) => a is B): Trie<B>; <A>(self: Trie<A>, f: (a: A, k: string) => boolean): Trie<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "filterMap",
    "description": "Maps over the entries of the `Trie` using the specified partial function\nand filters out `None` values.",
    "deprecated": false,
    "examples": [
      "import { Trie, Equal, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapV = Trie.empty<number>().pipe(\n  Trie.insert(\"she\", 2)\n)\n\nconst trieMapK = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1)\n)\n\nassert.equal(Equal.equals(Trie.filterMap(trie, (v) => v > 1 ? Option.some(v) : Option.none()), trieMapV), true)\nassert.equal(\n  Equal.equals(Trie.filterMap(trie, (v, k) => k.length > 3 ? Option.some(v) : Option.none()), trieMapK),\n  true\n)"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const filterMap: { <A, B>(f: (value: A, key: string) => Option<B>): (self: Trie<A>) => Trie<B>; <A, B>(self: Trie<A>, f: (value: A, key: string) => Option<B>): Trie<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "compact",
    "description": "Filters out `None` values from a `Trie` of `Options`s.",
    "deprecated": false,
    "examples": [
      "import { Trie, Equal, Option } from \"effect\"\n\nconst trie = Trie.empty<Option.Option<number>>().pipe(\n  Trie.insert(\"shells\", Option.some(0)),\n  Trie.insert(\"sells\", Option.none()),\n  Trie.insert(\"she\", Option.some(2))\n)\n\nconst trieMapV = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"she\", 2)\n)\n\nassert.equal(Equal.equals(Trie.compact(trie), trieMapV), true)"
    ],
    "since": "2.0.0",
    "category": "filtering",
    "signature": "export declare const compact: <A>(self: Trie<Option<A>>) => Trie<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "Applies the specified function to the entries of the `Trie`.",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nlet value = 0\n\nTrie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2),\n  Trie.forEach((n, key) => {\n    value += n + key.length\n  })\n)\n\nassert.equal(value, 17)"
    ],
    "since": "2.0.0",
    "category": "traversing",
    "signature": "export declare const forEach: { <V>(f: (value: V, key: string) => void): (self: Trie<V>) => void; <V>(self: Trie<V>, f: (value: V, key: string) => void): void; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "modify",
    "description": "Updates the value of the specified key within the `Trie` if it exists.",
    "deprecated": false,
    "examples": [
      "import { Trie, Equal, Option } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nassert.deepStrictEqual(trie.pipe(Trie.modify(\"she\", (v) => v + 10), Trie.get(\"she\")), Option.some(12))\n\nassert.equal(Equal.equals(trie.pipe(Trie.modify(\"me\", (v) => v)), trie), true)"
    ],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const modify: { <V1, V>(key: string, f: (v: V) => V1): (self: Trie<V>) => Trie<V1 | V>; <V1, V>(self: Trie<V>, key: string, f: (v: V) => V1): Trie<V | V1>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "removeMany",
    "description": "Removes all entries in the `Trie` which have the specified keys.",
    "deprecated": false,
    "examples": [
      "import { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nassert.equal(\n  Equal.equals(trie.pipe(Trie.removeMany([\"she\", \"sells\"])), Trie.empty<number>().pipe(Trie.insert(\"shells\", 0))),\n  true\n)"
    ],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const removeMany: { (keys: Iterable<string>): <V>(self: Trie<V>) => Trie<V>; <V>(self: Trie<V>, keys: Iterable<string>): Trie<V>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "insertMany",
    "description": "Insert multiple entries in the `Trie` at once.",
    "deprecated": false,
    "examples": [
      "import { Trie, Equal } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insert(\"sells\", 1),\n  Trie.insert(\"she\", 2)\n)\n\nconst trieInsert = Trie.empty<number>().pipe(\n  Trie.insert(\"shells\", 0),\n  Trie.insertMany(\n    [[\"sells\", 1], [\"she\", 2]]\n  )\n)\n\nassert.equal(\n  Equal.equals(trie, trieInsert),\n  true\n)"
    ],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const insertMany: { <V1>(iter: Iterable<[string, V1]>): <V>(self: Trie<V>) => Trie<V | V1>; <V1, V>(self: Trie<V>, iter: Iterable<[string, V1]>): Trie<V | V1>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "toEntries",
    "description": "Returns an `Array<[K, V]>` of the entries within the `Trie`.\n\nEquivalent to `Array.from(Trie.entries(trie))`.",
    "deprecated": false,
    "examples": [
      "import { Trie } from \"effect\"\n\nconst trie = Trie.empty<number>().pipe(\n  Trie.insert(\"call\", 0),\n  Trie.insert(\"me\", 1)\n)\nconst result = Trie.toEntries(trie)\n\nassert.deepStrictEqual(result, [[\"call\", 0], [\"me\", 1]])"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "Trie",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Trie<out Value> extends Iterable<[string, Value]>, Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _Value: Covariant<Value>\n  }\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Trie",
      "path": [
        "src",
        "Trie.ts"
      ]
    },
    "project": "effect",
    "name": "TypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbol",
    "signature": "export type TypeId = typeof TypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore",
      "path": [
        "src",
        "TSemaphore.ts"
      ]
    },
    "project": "effect",
    "name": "TSemaphoreTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TSemaphoreTypeId: typeof TSemaphoreTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore",
      "path": [
        "src",
        "TSemaphore.ts"
      ]
    },
    "project": "effect",
    "name": "acquire",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const acquire: (self: TSemaphore) => STM.STM<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore",
      "path": [
        "src",
        "TSemaphore.ts"
      ]
    },
    "project": "effect",
    "name": "acquireN",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const acquireN: { (n: number): (self: TSemaphore) => STM.STM<void>; (self: TSemaphore, n: number): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore",
      "path": [
        "src",
        "TSemaphore.ts"
      ]
    },
    "project": "effect",
    "name": "available",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const available: (self: TSemaphore) => STM.STM<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore",
      "path": [
        "src",
        "TSemaphore.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: (permits: number) => STM.STM<TSemaphore>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore",
      "path": [
        "src",
        "TSemaphore.ts"
      ]
    },
    "project": "effect",
    "name": "release",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const release: (self: TSemaphore) => STM.STM<void>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore",
      "path": [
        "src",
        "TSemaphore.ts"
      ]
    },
    "project": "effect",
    "name": "releaseN",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const releaseN: { (n: number): (self: TSemaphore) => STM.STM<void>; (self: TSemaphore, n: number): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore",
      "path": [
        "src",
        "TSemaphore.ts"
      ]
    },
    "project": "effect",
    "name": "withPermit",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const withPermit: { (semaphore: TSemaphore): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(self: Effect.Effect<A, E, R>, semaphore: TSemaphore): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore",
      "path": [
        "src",
        "TSemaphore.ts"
      ]
    },
    "project": "effect",
    "name": "withPermits",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const withPermits: { (semaphore: TSemaphore, permits: number): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(self: Effect.Effect<A, E, R>, semaphore: TSemaphore, permits: number): Effect.Effect<A, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore",
      "path": [
        "src",
        "TSemaphore.ts"
      ]
    },
    "project": "effect",
    "name": "withPermitScoped",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const withPermitScoped: (self: TSemaphore) => Effect.Effect<void, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore",
      "path": [
        "src",
        "TSemaphore.ts"
      ]
    },
    "project": "effect",
    "name": "withPermitsScoped",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const withPermitsScoped: { (permits: number): (self: TSemaphore) => Effect.Effect<void, never, Scope.Scope>; (self: TSemaphore, permits: number): Effect.Effect<void, never, Scope.Scope>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSemaphore",
      "path": [
        "src",
        "TSemaphore.ts"
      ]
    },
    "project": "effect",
    "name": "unsafeMake",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "unsafe",
    "signature": "export declare const unsafeMake: (permits: number) => TSemaphore"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TSemaphore",
      "path": [
        "src",
        "TSemaphore.ts"
      ]
    },
    "project": "effect",
    "name": "TSemaphore",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TSemaphore extends TSemaphore.Proto {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TSemaphore",
      "path": [
        "src",
        "TSemaphore.ts"
      ]
    },
    "project": "effect",
    "name": "TSemaphoreTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type TSemaphoreTypeId = typeof TSemaphoreTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "TSetTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const TSetTypeId: typeof TSetTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "add",
    "description": "Stores new element in the set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const add: { <A>(value: A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, value: A): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "difference",
    "description": "Atomically transforms the set into the difference of itself and the\nprovided set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const difference: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "empty",
    "description": "Makes an empty `TSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const empty: <A>() => STM.STM<TSet<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "forEach",
    "description": "Atomically performs transactional-effect for each element in set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const forEach: { <A, R, E>(f: (value: A) => STM.STM<void, E, R>): (self: TSet<A>) => STM.STM<void, E, R>; <A, R, E>(self: TSet<A>, f: (value: A) => STM.STM<void, E, R>): STM.STM<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "fromIterable",
    "description": "Creates a new `TSet` from an iterable collection of values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const fromIterable: <A>(iterable: Iterable<A>) => STM.STM<TSet<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "has",
    "description": "Tests whether or not set contains an element.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "elements",
    "signature": "export declare const has: { <A>(value: A): (self: TSet<A>) => STM.STM<boolean>; <A>(self: TSet<A>, value: A): STM.STM<boolean>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "intersection",
    "description": "Atomically transforms the set into the intersection of itself and the\nprovided set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const intersection: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "isEmpty",
    "description": "Tests if the set is empty or not",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const isEmpty: <A>(self: TSet<A>) => STM.STM<boolean>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Makes a new `TSet` that is initialized with specified values.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const make: <Elements extends Array<any>>(...elements: Elements) => STM.STM<TSet<Elements[number]>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "reduce",
    "description": "Atomically folds using a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduce: { <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: TSet<A>) => STM.STM<Z>; <Z, A>(self: TSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): STM.STM<Z>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "reduceSTM",
    "description": "Atomically folds using a transactional function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const reduceSTM: { <Z, A, R, E>(zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>): (self: TSet<A>) => STM.STM<Z, E, R>; <Z, A, R, E>(self: TSet<A>, zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>): STM.STM<Z, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "remove",
    "description": "Removes a single element from the set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const remove: { <A>(value: A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, value: A): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "removeAll",
    "description": "Removes elements from the set.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const removeAll: { <A>(iterable: Iterable<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, iterable: Iterable<A>): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "removeIf",
    "description": "Removes entries from a `TSet` that satisfy the specified predicate and returns the removed entries\n(or `void` if `discard = true`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const removeIf: { <A>(predicate: Predicate<A>, options: { readonly discard: true; }): (self: TSet<A>) => STM.STM<void>; <A>(predicate: Predicate<A>, options?: { readonly discard: false; }): (self: TSet<A>) => STM.STM<Array<A>>; <A>(self: TSet<A>, predicate: Predicate<A>, options: { readonly discard: true; }): STM.STM<void>; <A>(self: TSet<A>, predicate: Predicate<A>, options?: { readonly discard: false; }): STM.STM<Array<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "retainIf",
    "description": "Retains entries in a `TSet` that satisfy the specified predicate and returns the removed entries\n(or `void` if `discard = true`).",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const retainIf: { <A>(predicate: Predicate<A>, options: { readonly discard: true; }): (self: TSet<A>) => STM.STM<void>; <A>(predicate: Predicate<A>, options?: { readonly discard: false; }): (self: TSet<A>) => STM.STM<Array<A>>; <A>(self: TSet<A>, predicate: Predicate<A>, options: { readonly discard: true; }): STM.STM<void>; <A>(self: TSet<A>, predicate: Predicate<A>, options?: { readonly discard: false; }): STM.STM<Array<A>>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "size",
    "description": "Returns the set's cardinality.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "getters",
    "signature": "export declare const size: <A>(self: TSet<A>) => STM.STM<number>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "takeFirst",
    "description": "Takes the first matching value, or retries until there is one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeFirst: { <A, B>(pf: (a: A) => Option.Option<B>): (self: TSet<A>) => STM.STM<B>; <A, B>(self: TSet<A>, pf: (a: A) => Option.Option<B>): STM.STM<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "takeFirstSTM",
    "description": "Takes the first matching value, or retries until there is one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeFirstSTM: { <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>): (self: TSet<A>) => STM.STM<B, E, R>; <A, B, E, R>(self: TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>): STM.STM<B, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "takeSome",
    "description": "Takes all matching values, or retries until there is at least one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeSome: { <A, B>(pf: (a: A) => Option.Option<B>): (self: TSet<A>) => STM.STM<[B, ...Array<B>]>; <A, B>(self: TSet<A>, pf: (a: A) => Option.Option<B>): STM.STM<[B, ...Array<B>]>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "takeSomeSTM",
    "description": "Takes all matching values, or retries until there is at least one.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const takeSomeSTM: { <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>): (self: TSet<A>) => STM.STM<[B, ...Array<B>], E, R>; <A, B, E, R>(self: TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>): STM.STM<[B, ...Array<B>], E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "toChunk",
    "description": "Collects all elements into a `Chunk`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toChunk: <A>(self: TSet<A>) => STM.STM<Chunk.Chunk<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "toHashSet",
    "description": "Collects all elements into a `HashSet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toHashSet: <A>(self: TSet<A>) => STM.STM<HashSet.HashSet<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "toArray",
    "description": "Collects all elements into a `Array`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toArray: <A>(self: TSet<A>) => STM.STM<Array<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "toReadonlySet",
    "description": "Collects all elements into a `ReadonlySet`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "destructors",
    "signature": "export declare const toReadonlySet: <A>(self: TSet<A>) => STM.STM<ReadonlySet<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "transform",
    "description": "Atomically updates all elements using a pure function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const transform: { <A>(f: (a: A) => A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, f: (a: A) => A): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "transformSTM",
    "description": "Atomically updates all elements using a transactional function.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const transformSTM: { <A, R, E>(f: (a: A) => STM.STM<A, E, R>): (self: TSet<A>) => STM.STM<void, E, R>; <A, R, E>(self: TSet<A>, f: (a: A) => STM.STM<A, E, R>): STM.STM<void, E, R>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "union",
    "description": "Atomically transforms the set into the union of itself and the provided\nset.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "mutations",
    "signature": "export declare const union: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "TSet",
    "description": "Transactional set implemented on top of `TMap`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface TSet<in out A> extends TSet.Variance<A> {}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TSet",
      "path": [
        "src",
        "TSet.ts"
      ]
    },
    "project": "effect",
    "name": "TSetTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type TSetTypeId = typeof TSetTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "TSubscriptionRefTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbols",
    "signature": "export declare const TSubscriptionRefTypeId: typeof TSubscriptionRefTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "get",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "export declare const get: <A>(self: TSubscriptionRef<A>) => STM.STM<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndSet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "export declare const getAndSet: { <A>(value: A): (self: TSubscriptionRef<A>) => STM.STM<A>; <A>(self: TSubscriptionRef<A>, value: A): STM.STM<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdate",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "export declare const getAndUpdate: { <A>(f: (a: A) => A): (self: TSubscriptionRef<A>) => STM.STM<A>; <A>(self: TSubscriptionRef<A>, f: (a: A) => A): STM.STM<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "getAndUpdateSome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "export declare const getAndUpdateSome: { <A>(f: (a: A) => Option.Option<A>): (self: TSubscriptionRef<A>) => STM.STM<A>; <A>(self: TSubscriptionRef<A>, f: (a: A) => Option.Option<A>): STM.STM<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "constructors",
    "signature": "export declare const make: <A>(value: A) => STM.STM<TSubscriptionRef<A>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "modify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "export declare const modify: { <A, B>(f: (a: A) => readonly [B, A]): (self: TSubscriptionRef<A>) => STM.STM<B>; <A, B>(self: TSubscriptionRef<A>, f: (a: A) => readonly [B, A]): STM.STM<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "modifySome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "export declare const modifySome: { <A, B>(fallback: B, f: (a: A) => Option.Option<readonly [B, A]>): (self: TSubscriptionRef<A>) => STM.STM<B>; <A, B>(self: TSubscriptionRef<A>, fallback: B, f: (a: A) => Option.Option<readonly [B, A]>): STM.STM<B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "set",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "export declare const set: { <A>(value: A): (self: TSubscriptionRef<A>) => STM.STM<void>; <A>(self: TSubscriptionRef<A>, value: A): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "setAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "export declare const setAndGet: { <A>(value: A): (self: TSubscriptionRef<A>) => STM.STM<A>; <A>(self: TSubscriptionRef<A>, value: A): STM.STM<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "update",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "export declare const update: { <A>(f: (a: A) => A): (self: TSubscriptionRef<A>) => STM.STM<void>; <A>(self: TSubscriptionRef<A>, f: (a: A) => A): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "export declare const updateAndGet: { <A>(f: (a: A) => A): (self: TSubscriptionRef<A>) => STM.STM<A>; <A>(self: TSubscriptionRef<A>, f: (a: A) => A): STM.STM<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateSome",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "export declare const updateSome: { <A>(f: (a: A) => Option.Option<A>): (self: TSubscriptionRef<A>) => STM.STM<void>; <A>(self: TSubscriptionRef<A>, f: (a: A) => Option.Option<A>): STM.STM<void>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "updateSomeAndGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "export declare const updateSomeAndGet: { <A>(f: (a: A) => Option.Option<A>): (self: TSubscriptionRef<A>) => STM.STM<A>; <A>(self: TSubscriptionRef<A>, f: (a: A) => Option.Option<A>): STM.STM<A>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "changesScoped",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "export declare const changesScoped: <A>(self: TSubscriptionRef<A>) => Effect.Effect<TQueue.TDequeue<A>, never, Scope.Scope>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "changesStream",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": "export declare const changesStream: <A>(self: TSubscriptionRef<A>) => Stream.Stream<A>"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "changes",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "mutations",
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "TSubscriptionRef",
    "description": "A `TSubscriptionRef<A>` is a `TRef` that can be subscribed to in order to\nreceive a `TDequeue<A>` of the current value and all committed changes to the value.",
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "models",
    "signature": "export interface TSubscriptionRef<in out A> extends TSubscriptionRef.Variance<A>, TRef.TRef<A> {\n  /** @internal */\n  readonly ref: TRef.TRef<A>\n  /** @internal */\n  readonly pubsub: TPubSub.TPubSub<A>\n  /** @internal */\n  modify<B>(f: (a: A) => readonly [B, A]): STM.STM<B>\n\n  /**\n   * A TDequeue containing the current value of the `Ref` as well as all changes\n   * to that value.\n   */\n  readonly changes: STM.STM<TQueue.TDequeue<A>>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "TSubscriptionRef",
      "path": [
        "src",
        "TSubscriptionRef.ts"
      ]
    },
    "project": "effect",
    "name": "TSubscriptionRefTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.10.0",
    "category": "symbols",
    "signature": "export type TSubscriptionRefTypeId = typeof TSubscriptionRefTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "map",
    "description": "Transforms each element of tuple using the given function, treating tuple homomorphically",
    "deprecated": false,
    "examples": [
      "import { pipe, Tuple } from \"effect\"\n\nconst result = pipe(\n  [\"a\", 1, false] as const,\n  Tuple.map((el) => el.toString().toUpperCase())\n)\nassert.deepStrictEqual(result, ['A', '1', 'FALSE'])"
    ],
    "since": "3.9.0",
    "category": "mapping",
    "signature": "export declare const map: { <T extends ReadonlyArray<any> | [], B>(fn: (element: T[number]) => B): (self: T) => TupleOf<T[\"length\"], B>; <B, T extends ReadonlyArray<any> | []>(self: T, fn: (element: T[number]) => B): TupleOf<T[\"length\"], B>; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "mapBoth",
    "description": "Transforms both elements of a tuple using the given functions.",
    "deprecated": false,
    "examples": [
      "import { mapBoth } from \"effect/Tuple\"\n\nassert.deepStrictEqual(\n  mapBoth([\"hello\", 42], { onFirst: s => s.toUpperCase(), onSecond: n => n.toString() }),\n  [\"HELLO\", \"42\"]\n)"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapBoth: { <L1, L2, R1, R2>(options: { readonly onFirst: (e: L1) => L2; readonly onSecond: (a: R1) => R2; }): (self: readonly [L1, R1]) => [L2, R2]; <L1, R1, L2, R2>(self: readonly [L1, R1], options: { readonly onFirst: (e: L1) => L2; readonly onSecond: (a: R1) => R2; }): [L2, R2]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "mapFirst",
    "description": "Transforms the first component of a tuple using a given function.",
    "deprecated": false,
    "examples": [
      "import { mapFirst } from \"effect/Tuple\"\n\nassert.deepStrictEqual(\n  mapFirst([\"hello\", 42], s => s.toUpperCase()),\n  [\"HELLO\", 42]\n)"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapFirst: { <L1, L2>(f: (left: L1) => L2): <R>(self: readonly [L1, R]) => [L2, R]; <L1, R, L2>(self: readonly [L1, R], f: (left: L1) => L2): [L2, R]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "mapSecond",
    "description": "Transforms the second component of a tuple using a given function.",
    "deprecated": false,
    "examples": [
      "import { mapSecond } from \"effect/Tuple\"\n\nassert.deepStrictEqual(\n  mapSecond([\"hello\", 42], n => n.toString()),\n  [\"hello\", \"42\"]\n)"
    ],
    "since": "2.0.0",
    "category": "mapping",
    "signature": "export declare const mapSecond: { <R1, R2>(f: (right: R1) => R2): <L>(self: readonly [L, R1]) => [L, R2]; <L, R1, R2>(self: readonly [L, R1], f: (right: R1) => R2): [L, R2]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "getEquivalence",
    "description": "Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\nby applying each `Equivalence` to the corresponding element of the tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const getEquivalence: <T extends ReadonlyArray<Equivalence.Equivalence<any>>>(...isEquivalents: T) => Equivalence.Equivalence<Readonly<{ [I in keyof T]: [T[I]] extends [Equivalence.Equivalence<infer A>] ? A : never; }>>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "getOrder",
    "description": "This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\nThe returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\nIt is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\nof the tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "combinators",
    "signature": "export declare const getOrder: <T extends ReadonlyArray<order.Order<any>>>(...elements: T) => order.Order<{ [I in keyof T]: [T[I]] extends [order.Order<infer A>] ? A : never; }>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "appendElement",
    "description": "Appends an element to the end of a tuple.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "concatenating",
    "signature": "export declare const appendElement: { <B>(that: B): <A extends ReadonlyArray<unknown>>(self: A) => [...A, B]; <A extends ReadonlyArray<unknown>, B>(self: A, that: B): [...A, B]; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "at",
    "description": "Retrieves the element at a specified index from a tuple.",
    "deprecated": false,
    "examples": [
      "import { Tuple } from \"effect\"\n\nassert.deepStrictEqual(Tuple.at([1, 'hello', true], 1), 'hello')"
    ],
    "since": "3.4.0",
    "category": "getters",
    "signature": "export declare const at: { <N extends number>(index: N): <A extends ReadonlyArray<unknown>>(self: A) => A[N]; <A extends ReadonlyArray<unknown>, N extends number>(self: A, index: N): A[N]; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "isTupleOf",
    "description": "Determine if an `Array` is a tuple with exactly `N` elements, narrowing down the type to `TupleOf`.\n\nAn `Array` is considered to be a `TupleOf` if its length is exactly `N`.",
    "deprecated": false,
    "examples": [
      "import { isTupleOf } from \"effect/Tuple\"\n\nassert.deepStrictEqual(isTupleOf([1, 2, 3], 3), true);\nassert.deepStrictEqual(isTupleOf([1, 2, 3], 2), false);\nassert.deepStrictEqual(isTupleOf([1, 2, 3], 4), false);\n\nconst arr: number[] = [1, 2, 3];\nif (isTupleOf(arr, 3)) {\n  console.log(arr);\n  // ^? [number, number, number]\n}\n"
    ],
    "since": "3.3.0",
    "category": "guards",
    "signature": "export declare const isTupleOf: { <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOf<N, T>; <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOf<N, T>; }"
  },
  {
    "_tag": "Export",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "isTupleOfAtLeast",
    "description": "Determine if an `Array` is a tuple with at least `N` elements, narrowing down the type to `TupleOfAtLeast`.\n\nAn `Array` is considered to be a `TupleOfAtLeast` if its length is at least `N`.",
    "deprecated": false,
    "examples": [
      "import { isTupleOfAtLeast } from \"effect/Tuple\"\n\nassert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 3), true);\nassert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 2), true);\nassert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 4), false);\n\nconst arr: number[] = [1, 2, 3, 4];\nif (isTupleOfAtLeast(arr, 3)) {\n  console.log(arr);\n  // ^? [number, number, number, ...number[]]\n}\n"
    ],
    "since": "3.3.0",
    "category": "guards",
    "signature": "export declare const isTupleOfAtLeast: { <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOfAtLeast<N, T>; <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOfAtLeast<N, T>; }"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "make",
    "description": "Constructs a new tuple from the provided values.",
    "deprecated": false,
    "examples": [
      "import { make } from \"effect/Tuple\"\n\nassert.deepStrictEqual(make(1, 'hello', true), [1, 'hello', true])"
    ],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "getFirst",
    "description": "Return the first element of a tuple.",
    "deprecated": false,
    "examples": [
      "import { getFirst } from \"effect/Tuple\"\n\nassert.deepStrictEqual(getFirst([\"hello\", 42]), \"hello\")"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "getSecond",
    "description": "Return the second element of a tuple.",
    "deprecated": false,
    "examples": [
      "import { getSecond } from \"effect/Tuple\"\n\nassert.deepStrictEqual(getSecond([\"hello\", 42]), 42)"
    ],
    "since": "2.0.0",
    "category": "getters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "swap",
    "description": "Swaps the two elements of a tuple.",
    "deprecated": false,
    "examples": [
      "import { swap } from \"effect/Tuple\"\n\nassert.deepStrictEqual(swap([\"hello\", 42]), [42, \"hello\"])"
    ],
    "since": "2.0.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Tuple",
      "path": [
        "src",
        "Tuple.ts"
      ]
    },
    "project": "effect",
    "name": "TupleTypeLambda",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "type lambdas",
    "signature": "export interface TupleTypeLambda extends TypeLambda {\n  readonly type: [this[\"Out1\"], this[\"Target\"]]\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "Concurrency",
    "description": "Describes the concurrency to use when executing multiple Effect's.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type Concurrency = number | \"unbounded\" | \"inherit\""
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "Contravariant",
    "description": "Contravariant helper.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type Contravariant<A> = (_: A) => void"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "Covariant",
    "description": "Covariant helper.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type Covariant<A> = (_: never) => A"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "DeepMutable",
    "description": "Like `Types.Mutable`, but works recursively.",
    "deprecated": false,
    "examples": [
      "import type { Types } from \"effect\"\n\ntype DeepMutableStruct = Types.DeepMutable<{\n  readonly a: string;\n  readonly b: readonly string[]\n}>\n// { a: string; b: string[] }"
    ],
    "since": "3.1.0",
    "category": "types",
    "signature": "export type DeepMutable<T> = T extends ReadonlyMap<infer K, infer V> ? Map<DeepMutable<K>, DeepMutable<V>>\n  : T extends ReadonlySet<infer V> ? Set<DeepMutable<V>>\n  : [keyof T] extends [never] ? T\n  : { -readonly [K in keyof T]: DeepMutable<T[K]> }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "Equals",
    "description": "Determines if two types are equal.",
    "deprecated": false,
    "examples": [
      "import type { Types } from \"effect\"\n\ntype Res1 = Types.Equals<{ a: number }, { a: number }> // true\ntype Res2 = Types.Equals<{ a: number }, { b: number }> // false"
    ],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends <\n  T\n>() => T extends Y ? 1 : 2 ? true\n  : false"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "ExcludeTag",
    "description": "Excludes the tagged object from the type.",
    "deprecated": false,
    "examples": [
      "import type { Types } from \"effect\"\n\ntype Res = Types.ExcludeTag<string | { _tag: \"a\" } | { _tag: \"b\" }, \"a\"> // string | { _tag: \"b\" }"
    ],
    "since": "2.0.0",
    "category": "types",
    "signature": "export type ExcludeTag<E, K extends Tags<E>> = Exclude<E, { _tag: K }>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "ExtractTag",
    "description": "Extracts the type of the given tag.",
    "deprecated": false,
    "examples": [
      "import type { Types } from \"effect\"\n\ntype Res = Types.ExtractTag<{ _tag: \"a\", a: number } | { _tag: \"b\", b: number }, \"b\"> // { _tag: \"b\", b: number }"
    ],
    "since": "2.0.0",
    "category": "types",
    "signature": "export type ExtractTag<E, K extends Tags<E>> = Extract<E, { _tag: K }>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "Has",
    "description": "Determines if a record contains any of the given keys.",
    "deprecated": false,
    "examples": [
      "import type { Types } from \"effect\"\n\ntype Res1 = Types.Has<{ a: number }, \"a\" | \"b\"> // true\ntype Res2 = Types.Has<{ c: number }, \"a\" | \"b\"> // false"
    ],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type Has<A, Key extends string> = (Key extends infer K ? K extends keyof A ? true : never : never) extends never\n  ? false\n  : true"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "Invariant",
    "description": "Invariant helper.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type Invariant<A> = (_: A) => A"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "MatchRecord",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type MatchRecord<S, onTrue, onFalse> = {} extends S ? onTrue : onFalse"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "MergeLeft",
    "description": "Merges two object where the keys of the left object take precedence in the case of a conflict.",
    "deprecated": false,
    "examples": [
      "import type { Types } from \"effect\"\ntype MergeLeft = Types.MergeLeft<{ a: number, b: number; }, { a: string }> // { a: number; b: number; }"
    ],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type MergeLeft<Source, Target> = MergeRight<Target, Source>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "MergeRecord",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type MergeRecord<Source, Target> = MergeLeft<Source, Target>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "MergeRight",
    "description": "Merges two object where the keys of the right object take precedence in the case of a conflict.",
    "deprecated": false,
    "examples": [
      "import type { Types } from \"effect\"\ntype MergeRight = Types.MergeRight<{ a: number, b: number; }, { a: string }> // { a: string; b: number; }"
    ],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type MergeRight<Target, Source> = Simplify<\n  & Source\n  & {\n    [Key in keyof Target as Key extends keyof Source ? never : Key]: Target[Key]\n  }\n>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "Mutable",
    "description": "Make all properties in `T` mutable. Supports arrays, tuples, and records as well.",
    "deprecated": false,
    "examples": [
      "import type { Types } from \"effect\"\n\ntype MutableStruct = Types.Mutable<{ readonly a: string; readonly b: number }> // { a: string; b: number; }\n\ntype MutableArray = Types.Mutable<ReadonlyArray<string>> // string[]\n\ntype MutableTuple = Types.Mutable<readonly [string, number]> // [string, number]\n\ntype MutableRecord = Types.Mutable<{ readonly [_: string]: number }> // { [x: string]: number; }"
    ],
    "since": "2.0.0",
    "category": "types",
    "signature": "export type Mutable<T> = {\n  -readonly [P in keyof T]: T[P]\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "NoExcessProperties",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.9.0",
    "category": null,
    "signature": "export type NoExcessProperties<T, U> = T & { readonly [K in Exclude<keyof U, keyof T>]: never }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "NoInfer",
    "description": "Avoid inference on a specific parameter",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type NoInfer<A> = [A][A extends any ? 0 : never]"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "NotFunction",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type NotFunction<T> = T extends Function ? never : T"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "Simplify",
    "description": "Simplifies the type signature of a type.",
    "deprecated": false,
    "examples": [
      "import type { Types } from \"effect\"\n\ntype Res = Types.Simplify<{ a: number } & { b: number }> // { a: number; b: number; }"
    ],
    "since": "2.0.0",
    "category": "types",
    "signature": "export type Simplify<A> = {\n  [K in keyof A]: A[K]\n} extends infer B ? B : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "Tags",
    "description": "Returns the tags in a type.",
    "deprecated": false,
    "examples": [
      "import type { Types } from \"effect\"\n\ntype Res = Types.Tags<string | { _tag: \"a\" } | { _tag: \"b\" } > // \"a\" | \"b\""
    ],
    "since": "2.0.0",
    "category": "types",
    "signature": "export type Tags<E> = E extends { _tag: string } ? E[\"_tag\"] : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "TupleOf",
    "description": "Represents a tuple with a fixed number of elements of type `T`.\n\nThis type constructs a tuple that has exactly `N` elements of type `T`.",
    "deprecated": false,
    "examples": [
      "import { TupleOf } from \"effect/Types\"\n\n// A tuple with exactly 3 numbers\nconst example1: TupleOf<3, number> = [1, 2, 3]; // valid\n// @ts-expect-error\nconst example2: TupleOf<3, number> = [1, 2]; // invalid\n// @ts-expect-error\nconst example3: TupleOf<3, number> = [1, 2, 3, 4]; // invalid"
    ],
    "since": "3.3.0",
    "category": "tuples",
    "signature": "export type TupleOf<N extends number, T> = N extends N ? number extends N ? Array<T> : _TupleOf<T, N, []> : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "TupleOfAtLeast",
    "description": "Represents a tuple with at least `N` elements of type `T`.\n\nThis type constructs a tuple that has a fixed number of elements `N` of type `T` at the start,\nfollowed by any number (including zero) of additional elements of the same type `T`.",
    "deprecated": false,
    "examples": [
      "import { TupleOfAtLeast } from \"effect/Types\"\n\n// A tuple with at least 3 numbers\nconst example1: TupleOfAtLeast<3, number> = [1, 2, 3]; // valid\nconst example2: TupleOfAtLeast<3, number> = [1, 2, 3, 4, 5]; // valid\n// @ts-expect-error\nconst example3: TupleOfAtLeast<3, number> = [1, 2]; // invalid"
    ],
    "since": "3.3.0",
    "category": "tuples",
    "signature": "export type TupleOfAtLeast<N extends number, T> = [...TupleOf<N, T>, ...Array<T>]"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Types",
      "path": [
        "src",
        "Types.ts"
      ]
    },
    "project": "effect",
    "name": "UnionToIntersection",
    "description": "A utility type that transforms a union type `T` into an intersection type.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "types",
    "signature": "export type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R\n  : never"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Unify",
      "path": [
        "src",
        "Unify.ts"
      ]
    },
    "project": "effect",
    "name": "unify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export declare const unify: { <Args extends Array<any>, Args2 extends Array<any>, Args3 extends Array<any>, Args4 extends Array<any>, Args5 extends Array<any>, T>(x: (...args: Args) => (...args: Args2) => (...args: Args3) => (...args: Args4) => (...args: Args5) => T): (...args: Args) => (...args: Args2) => (...args: Args3) => (...args: Args4) => (...args: Args5) => Unify<T>; <Args extends Array<any>, Args2 extends Array<any>, Args3 extends Array<any>, Args4 extends Array<any>, T>(x: (...args: Args) => (...args: Args2) => (...args: Args3) => (...args: Args4) => T): (...args: Args) => (...args: Args2) => (...args: Args3) => (...args: Args4) => Unify<T>; <Args extends Array<any>, Args2 extends Array<any>, Args3 extends Array<any>, T>(x: (...args: Args) => (...args: Args2) => (...args: Args3) => T): (...args: Args) => (...args: Args2) => (...args: Args3) => Unify<T>; <Args extends Array<any>, Args2 extends Array<any>, T>(x: (...args: Args) => (...args: Args2) => T): (...args: Args) => (...args: Args2) => Unify<T>; <Args extends Array<any>, T>(x: (...args: Args) => T): (...args: Args) => Unify<T>; <T>(x: T): Unify<T>; }"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Unify",
      "path": [
        "src",
        "Unify.ts"
      ]
    },
    "project": "effect",
    "name": "Unify",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type Unify<A> = Values<\n  ExtractTypes<\n    (\n      & FilterIn<A>\n      & { [typeSymbol]: A }\n    )\n  >\n> extends infer Z ? Z | Exclude<A, Z> | FilterOut<A> : never"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Unify",
      "path": [
        "src",
        "Unify.ts"
      ]
    },
    "project": "effect",
    "name": "ignoreSymbol",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type ignoreSymbol = typeof ignoreSymbol"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Unify",
      "path": [
        "src",
        "Unify.ts"
      ]
    },
    "project": "effect",
    "name": "typeSymbol",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type typeSymbol = typeof typeSymbol"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Unify",
      "path": [
        "src",
        "Unify.ts"
      ]
    },
    "project": "effect",
    "name": "unifySymbol",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": null,
    "signature": "export type unifySymbol = typeof unifySymbol"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullRequest",
      "path": [
        "src",
        "UpstreamPullRequest.ts"
      ]
    },
    "project": "effect",
    "name": "UpstreamPullRequestTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const UpstreamPullRequestTypeId: typeof UpstreamPullRequestTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullRequest",
      "path": [
        "src",
        "UpstreamPullRequest.ts"
      ]
    },
    "project": "effect",
    "name": "Pulled",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const Pulled: <A>(value: A) => UpstreamPullRequest<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullRequest",
      "path": [
        "src",
        "UpstreamPullRequest.ts"
      ]
    },
    "project": "effect",
    "name": "NoUpstream",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const NoUpstream: (activeDownstreamCount: number) => UpstreamPullRequest<never>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullRequest",
      "path": [
        "src",
        "UpstreamPullRequest.ts"
      ]
    },
    "project": "effect",
    "name": "isUpstreamPullRequest",
    "description": "Returns `true` if the specified value is an `UpstreamPullRequest`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isUpstreamPullRequest: (u: unknown) => u is UpstreamPullRequest<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullRequest",
      "path": [
        "src",
        "UpstreamPullRequest.ts"
      ]
    },
    "project": "effect",
    "name": "isPulled",
    "description": "Returns `true` if the specified `UpstreamPullRequest` is a `Pulled`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isPulled: <A>(self: UpstreamPullRequest<A>) => self is Pulled<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullRequest",
      "path": [
        "src",
        "UpstreamPullRequest.ts"
      ]
    },
    "project": "effect",
    "name": "isNoUpstream",
    "description": "Returns `true` if the specified `UpstreamPullRequest` is a `NoUpstream`,\n`false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isNoUpstream: <A>(self: UpstreamPullRequest<A>) => self is NoUpstream"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullRequest",
      "path": [
        "src",
        "UpstreamPullRequest.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Folds an `UpstreamPullRequest<A>` into a value of type `Z`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const match: { <A, Z>(options: { readonly onPulled: (value: A) => Z; readonly onNoUpstream: (activeDownstreamCount: number) => Z; }): (self: UpstreamPullRequest<A>) => Z; <A, Z>(self: UpstreamPullRequest<A>, options: { readonly onPulled: (value: A) => Z; readonly onNoUpstream: (activeDownstreamCount: number) => Z; }): Z; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "UpstreamPullRequest",
      "path": [
        "src",
        "UpstreamPullRequest.ts"
      ]
    },
    "project": "effect",
    "name": "NoUpstream",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface NoUpstream extends UpstreamPullRequest.Variance<never> {\n  readonly _tag: \"NoUpstream\"\n  readonly activeDownstreamCount: number\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "UpstreamPullRequest",
      "path": [
        "src",
        "UpstreamPullRequest.ts"
      ]
    },
    "project": "effect",
    "name": "Pulled",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Pulled<out A> extends UpstreamPullRequest.Variance<A> {\n  readonly _tag: \"Pulled\"\n  readonly value: A\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "UpstreamPullRequest",
      "path": [
        "src",
        "UpstreamPullRequest.ts"
      ]
    },
    "project": "effect",
    "name": "UpstreamPullRequest",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type UpstreamPullRequest<A> = Pulled<A> | NoUpstream"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "UpstreamPullRequest",
      "path": [
        "src",
        "UpstreamPullRequest.ts"
      ]
    },
    "project": "effect",
    "name": "UpstreamPullRequestTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type UpstreamPullRequestTypeId = typeof UpstreamPullRequestTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullStrategy",
      "path": [
        "src",
        "UpstreamPullStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "UpstreamPullStrategyTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const UpstreamPullStrategyTypeId: typeof UpstreamPullStrategyTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullStrategy",
      "path": [
        "src",
        "UpstreamPullStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "PullAfterNext",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const PullAfterNext: <A>(emitSeparator: Option.Option<A>) => UpstreamPullStrategy<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullStrategy",
      "path": [
        "src",
        "UpstreamPullStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "PullAfterAllEnqueued",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare const PullAfterAllEnqueued: <A>(emitSeparator: Option.Option<A>) => UpstreamPullStrategy<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullStrategy",
      "path": [
        "src",
        "UpstreamPullStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "isUpstreamPullStrategy",
    "description": "Returns `true` if the specified value is an `UpstreamPullStrategy`, `false`\notherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isUpstreamPullStrategy: (u: unknown) => u is UpstreamPullStrategy<unknown>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullStrategy",
      "path": [
        "src",
        "UpstreamPullStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "isPullAfterNext",
    "description": "Returns `true` if the specified `UpstreamPullStrategy` is a `PullAfterNext`,\n`false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isPullAfterNext: <A>(self: UpstreamPullStrategy<A>) => self is PullAfterNext<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullStrategy",
      "path": [
        "src",
        "UpstreamPullStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "isPullAfterAllEnqueued",
    "description": "Returns `true` if the specified `UpstreamPullStrategy` is a\n`PullAfterAllEnqueued`, `false` otherwise.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "refinements",
    "signature": "export declare const isPullAfterAllEnqueued: <A>(self: UpstreamPullStrategy<A>) => self is PullAfterAllEnqueued<A>"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "UpstreamPullStrategy",
      "path": [
        "src",
        "UpstreamPullStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "match",
    "description": "Folds an `UpstreamPullStrategy<A>` into a value of type `Z`.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "folding",
    "signature": "export declare const match: { <A, Z>(options: { readonly onNext: (emitSeparator: Option.Option<A>) => Z; readonly onAllEnqueued: (emitSeparator: Option.Option<A>) => Z; }): (self: UpstreamPullStrategy<A>) => Z; <A, Z>(self: UpstreamPullStrategy<A>, options: { readonly onNext: (emitSeparator: Option.Option<A>) => Z; readonly onAllEnqueued: (emitSeparator: Option.Option<A>) => Z; }): Z; }"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "UpstreamPullStrategy",
      "path": [
        "src",
        "UpstreamPullStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "PullAfterAllEnqueued",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface PullAfterAllEnqueued<out A> extends UpstreamPullStrategy.Variance<A> {\n  readonly _tag: \"PullAfterAllEnqueued\"\n  readonly emitSeparator: Option.Option<A>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "UpstreamPullStrategy",
      "path": [
        "src",
        "UpstreamPullStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "PullAfterNext",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface PullAfterNext<out A> extends UpstreamPullStrategy.Variance<A> {\n  readonly _tag: \"PullAfterNext\"\n  readonly emitSeparator: Option.Option<A>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "UpstreamPullStrategy",
      "path": [
        "src",
        "UpstreamPullStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "UpstreamPullStrategy",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export type UpstreamPullStrategy<A> = PullAfterNext<A> | PullAfterAllEnqueued<A>"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "UpstreamPullStrategy",
      "path": [
        "src",
        "UpstreamPullStrategy.ts"
      ]
    },
    "project": "effect",
    "name": "UpstreamPullStrategyTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type UpstreamPullStrategyTypeId = typeof UpstreamPullStrategyTypeId"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "GenKindImpl",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare class GenKindImpl<F, R, O, E, A> { constructor(\n    /**\n     * @since 2.0.0\n     */\n    readonly value: Kind<F, R, O, E, A>\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "PCGRandom",
    "description": "PCG is a family of simple fast space-efficient statistically good algorithms\nfor random number generation. Unlike many general-purpose RNGs, they are also\nhard to predict.",
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export declare class PCGRandom { constructor(\n    seedHi?: OptionalNumber,\n    seedLo?: OptionalNumber,\n    incHi?: OptionalNumber,\n    incLo?: OptionalNumber\n  ) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "SingleShotGen",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": "export declare class SingleShotGen<T, A> { constructor(readonly self: T) }"
  },
  {
    "_tag": "Class",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "YieldWrap",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.0.6",
    "category": null,
    "signature": "export declare class YieldWrap<T> { constructor(value: T) }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "GenKindTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export declare const GenKindTypeId: typeof GenKindTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "YieldWrapTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.0.6",
    "category": null,
    "signature": "export declare const YieldWrapTypeId: typeof YieldWrapTypeId"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "structuralRegionState",
    "description": "Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code",
    "deprecated": false,
    "examples": [],
    "since": "3.1.1",
    "category": "modifiers",
    "signature": "export declare const structuralRegionState: { enabled: boolean; tester: ((a: unknown, b: unknown) => boolean) | undefined; }"
  },
  {
    "_tag": "Constant",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "internalCall",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.2.2",
    "category": "tracing",
    "signature": "export declare const internalCall: <A>(fn: () => A) => A"
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "yieldWrapGet",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.0.6",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "isGenKind",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.0.6",
    "category": "predicates",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "makeGenKind",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "constructors",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "adapter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "adapters",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "structuralRegion",
    "description": "Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code",
    "deprecated": false,
    "examples": [],
    "since": "3.1.1",
    "category": "modifiers",
    "signature": null
  },
  {
    "_tag": "Function",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "isGeneratorFunction",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "3.11.0",
    "category": null,
    "signature": null
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "Adapter",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Adapter<Z extends TypeLambda> {\n  <_R, _O, _E, _A>(\n    self: Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, _R, _O, _E, _A>(a: A, ab: (a: A) => Kind<Z, _R, _O, _E, _A>): GenKind<Z, _R, _O, _E, _A>\n  <A, B, _R, _O, _E, _A>(a: A, ab: (a: A) => B, bc: (b: B) => Kind<Z, _R, _O, _E, _A>): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: F) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (g: H) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, _R, _O, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => T,\n    tu: (s: T) => Kind<Z, _R, _O, _E, _A>\n  ): GenKind<Z, _R, _O, _E, _A>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "Gen",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Gen<F extends TypeLambda, Z> {\n  <Self, K extends Variance<F, any, any, any> | YieldWrap<Kind<F, any, any, any, any>>, A>(\n    ...args:\n      | [\n        self: Self,\n        body: (this: Self, resume: Z) => Generator<K, A, never>\n      ]\n      | [\n        body: (resume: Z) => Generator<K, A, never>\n      ]\n  ): Kind<\n    F,\n    [K] extends [Variance<F, infer R, any, any>] ? R\n      : [K] extends [YieldWrap<Kind<F, infer R, any, any, any>>] ? R\n      : never,\n    [K] extends [Variance<F, any, infer O, any>] ? O\n      : [K] extends [YieldWrap<Kind<F, any, infer O, any, any>>] ? O\n      : never,\n    [K] extends [Variance<F, any, any, infer E>] ? E\n      : [K] extends [YieldWrap<Kind<F, any, any, infer E, any>>] ? E\n      : never,\n    A\n  >\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "GenKind",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface GenKind<F extends TypeLambda, R, O, E, A> extends Variance<F, R, O, E> {\n  readonly value: Kind<F, R, O, E, A>\n\n  [Symbol.iterator](): IterableIterator<GenKind<F, R, O, E, A>, A>\n}"
  },
  {
    "_tag": "Interface",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "Variance",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "models",
    "signature": "export interface Variance<in out F extends TypeLambda, in R, out O, out E> {\n  readonly [GenKindTypeId]: GenKindTypeId\n  readonly _F: Types.Invariant<F>\n  readonly _R: Types.Contravariant<R>\n  readonly _O: Types.Covariant<O>\n  readonly _E: Types.Covariant<E>\n}"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "GenKindTypeId",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "symbols",
    "signature": "export type GenKindTypeId = typeof GenKindTypeId"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "OptionalNumber",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export type OptionalNumber = number | null | undefined"
  },
  {
    "_tag": "TypeAlias",
    "module": {
      "name": "Utils",
      "path": [
        "src",
        "Utils.ts"
      ]
    },
    "project": "effect",
    "name": "PCGRandomState",
    "description": null,
    "deprecated": false,
    "examples": [],
    "since": "2.0.0",
    "category": "model",
    "signature": "export type PCGRandomState = [number, number, number, number]"
  }
]